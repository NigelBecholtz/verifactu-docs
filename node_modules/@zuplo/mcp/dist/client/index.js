import { newJSONRPCRequest } from "../jsonrpc2/types.js";
import { isJSONRPCError, isJSONRPCResponse } from "../jsonrpc2/validation.js";
import { createDefaultLogger } from "../logger/index.js";
import { LATEST_PROTOCOL_VERSION } from "../mcp/versions.js";
export const DEFAULT_MCP_CLIENT_NAME = "MCP Client";
export const DEFAULT_MCP_CLIENT_VERSION = "0.0.0";
export class MCPClient {
    name;
    version;
    capabilities;
    transport;
    isInitialized = false;
    protocolVersion;
    logger;
    requestId = 1;
    transportOptions;
    constructor(options = {}) {
        this.name = options.name || DEFAULT_MCP_CLIENT_NAME;
        this.version = options.version || DEFAULT_MCP_CLIENT_VERSION;
        this.logger = options.logger || createDefaultLogger();
        this.transportOptions = options.transportOptions || {};
        this.capabilities = {
            experimental: {},
            sampling: {},
            ...options.capabilities,
        };
    }
    /**
     * Connect to an MCP server using the provided transport
     */
    async connect(transport) {
        if (this.transportOptions.headers) {
            transport.setHeaders(this.transportOptions.headers);
        }
        this.transport = transport;
        await transport.connect();
    }
    /**
     * Initialize the connection with the server
     */
    async initialize(protocolVersion = LATEST_PROTOCOL_VERSION) {
        if (!this.transport) {
            throw new Error("No transport connected. Call connect() first.");
        }
        const request = newJSONRPCRequest({
            id: this.requestId,
            method: "initialize",
            params: {
                protocolVersion,
                capabilities: this.capabilities,
                clientInfo: {
                    name: this.name,
                    version: this.version,
                },
            },
        });
        const response = await this.sendRequest(request);
        if (isJSONRPCError(response)) {
            throw new Error(`Initialization failed: ${response.error.message}`);
        }
        const result = response.result;
        this.isInitialized = true;
        this.protocolVersion = result.protocolVersion;
        this.logger.info("Successfully initialized MCP client", {
            serverInfo: result,
            protocolVersion: this.protocolVersion,
        });
        return result;
    }
    /**
     * Send a ping request to the server
     */
    async ping() {
        if (!this.isInitialized) {
            throw new Error("Client not initialized. Call initialize() first.");
        }
        const request = newJSONRPCRequest({
            id: this.requestId,
            method: "ping",
        });
        const response = await this.sendRequest(request);
        if (isJSONRPCError(response)) {
            throw new Error(`Ping failed: ${response.error.message}`);
        }
    }
    /**
     * List all available tools from the server
     */
    async listTools() {
        if (!this.isInitialized) {
            throw new Error("Client not initialized. Call initialize() first.");
        }
        const request = newJSONRPCRequest({
            id: this.requestId,
            method: "tools/list",
            params: {},
        });
        const response = await this.sendRequest(request);
        if (isJSONRPCError(response)) {
            throw new Error(`Failed to list tools: ${response.error.message}`);
        }
        const result = response.result;
        return result.tools;
    }
    /**
     * Call a specific tool with provided arguments
     */
    async callTool(name, args = {}) {
        if (!this.isInitialized) {
            throw new Error("Client not initialized. Call initialize() first.");
        }
        const request = newJSONRPCRequest({
            id: this.requestId,
            method: "tools/call",
            params: {
                name,
                arguments: args,
            },
        });
        const response = await this.sendRequest(request);
        if (isJSONRPCError(response)) {
            throw new Error(`Failed to call tool '${name}': ${response.error.message}`);
        }
        return response.result;
    }
    /**
     * List all available prompts from the server
     */
    async listPrompts() {
        if (!this.isInitialized) {
            throw new Error("Client not initialized. Call initialize() first.");
        }
        const request = newJSONRPCRequest({
            id: this.requestId,
            method: "prompts/list",
            params: {},
        });
        const response = await this.sendRequest(request);
        if (isJSONRPCError(response)) {
            throw new Error(`Failed to list prompts: ${response.error.message}`);
        }
        const result = response.result;
        return result.prompts;
    }
    /**
     * Get a prompt with provided arguments
     */
    async getPrompt(name, args = {}) {
        if (!this.isInitialized) {
            throw new Error("Client not initialized. Call initialize() first.");
        }
        const request = newJSONRPCRequest({
            id: this.requestId,
            method: "prompts/get",
            params: {
                name,
                arguments: args,
            },
        });
        const response = await this.sendRequest(request);
        if (isJSONRPCError(response)) {
            throw new Error(`Failed to get prompt '${name}': ${response.error.message}`);
        }
        return response.result;
    }
    /**
     * Disconnect from the server
     */
    async disconnect() {
        if (this.transport) {
            await this.transport.close();
            this.transport = undefined;
        }
        this.isInitialized = false;
        this.protocolVersion = undefined;
    }
    async sendRequest(request) {
        return new Promise((resolve, reject) => {
            const requestId = request.id;
            // Set up a temporary message handler to capture the response
            this.transport?.onMessage(async (message) => {
                // Check if this is the response we're waiting for
                if ((isJSONRPCResponse(message) || isJSONRPCError(message)) &&
                    message.id === requestId) {
                    resolve(message);
                    return null;
                }
                return null;
            });
            // Send the request
            this.transport?.send(request).catch(reject);
        });
    }
}
//# sourceMappingURL=index.js.map