import { z } from "zod/v4";
import { ErrorCode } from "../jsonrpc2/consts.js";
import { newJSONRPCError, newJSONRPCReponse, } from "../jsonrpc2/types.js";
import { isJSONRPCNotification, isJSONRPCRequest, isJSONRPCResponse, } from "../jsonrpc2/validation.js";
import { createDefaultLogger } from "../logger/index.js";
import { InitializeRequestSchema } from "../mcp/20250618/schemas/initialize.schema.js";
import { GetPromptRequestSchema, ListPromptsRequestSchema, } from "../mcp/20250618/schemas/prompt.schema.js";
import { CallToolRequestSchema } from "../mcp/20250618/schemas/tools.schema.js";
import { LATEST_PROTOCOL_VERSION, PROTOCOL_VERSION_2024_10_07, PROTOCOL_VERSION_2024_11_05, PROTOCOL_VERSION_2025_03_26, SUPPORTED_PROTOCOL_VERSIONS, } from "../mcp/versions.js";
export const DEFAULT_MCP_SERVER_NAME = "MCP Server";
export const DEFAULT_MCP_SERVER_VERSION = "0.0.0";
export class MCPServer {
    capabilities;
    tools = new Map();
    prompts = new Map();
    name;
    version;
    instructions;
    logger;
    constructor(options) {
        this.name = options.name || DEFAULT_MCP_SERVER_NAME;
        this.version = options.version || DEFAULT_MCP_SERVER_VERSION;
        this.instructions = options.instructions || undefined;
        this.logger = options.logger || createDefaultLogger();
        // Set default capabilities
        this.capabilities = {
            tools: {
                supported: true,
                available: [],
            },
            prompts: {},
            ...options.capabilities,
        };
    }
    withTransport(transport) {
        transport.onMessage(async (message) => {
            try {
                if (isJSONRPCRequest(message)) {
                    const response = await this.handleRequest(message);
                    if (response) {
                        await transport.send(response);
                        return response;
                    }
                }
                else if (isJSONRPCNotification(message)) {
                    await this.handleNotification(message);
                    return null;
                }
                else if (isJSONRPCResponse(message)) {
                    this.logger.debug("Received response:", message);
                    return null;
                }
            }
            catch (error) {
                this.logger.error("Error processing message:", error);
                // Send error response for requests
                if (isJSONRPCRequest(message)) {
                    const errorResponse = newJSONRPCError({
                        id: message.id,
                        code: ErrorCode.InternalError,
                        message: error instanceof Error ? error.message : "Internal error",
                    });
                    await transport.send(errorResponse);
                    return errorResponse;
                }
            }
            return null;
        });
    }
    getTool(name) {
        const registeredTool = this.tools.get(name);
        return registeredTool?.tool;
    }
    getTools() {
        const toolsMap = new Map();
        for (const [name, registeredTool] of this.tools.entries()) {
            toolsMap.set(name, registeredTool.tool);
        }
        return toolsMap;
    }
    /**
     * Get the server capabilities
     */
    getCapabilities() {
        return { ...this.capabilities };
    }
    /**
     * Register a tool
     */
    addTool(config) {
        const { name, validator, handler, description = `Execute the ${name} tool`, outputSchema, } = config;
        const toolSchema = {
            name,
            description,
            inputSchema: validator.jsonSchema,
            ...(outputSchema && { outputSchema }),
        };
        const registered = {
            tool: toolSchema,
            validator,
            handler,
        };
        this.tools.set(name, registered);
        this.updateAvailableTools();
    }
    /**
     * Remove a tool from the server
     */
    removeTool(name) {
        const result = this.tools.delete(name);
        if (result) {
            this.updateAvailableTools();
        }
        return result;
    }
    /**
     * Get all registered tools
     */
    getToolDefinitions() {
        return Array.from(this.tools.values()).map((tool) => tool.tool);
    }
    /**
     * Register a prompt
     */
    addPrompt(config) {
        const { name, validator, generator, description } = config;
        // Extract "arguments" from the validator's JSON schema
        // be be used as the broadcasted arguments
        const jsonSchema = validator.jsonSchema;
        let promptArguments;
        if (jsonSchema.properties && typeof jsonSchema.properties === "object") {
            const requiredFields = new Set(jsonSchema.required || []);
            promptArguments = Object.entries(jsonSchema.properties).map(([propName, propSchema]) => ({
                name: propName,
                description: propSchema.description ?? `Prompt for ${propName}`,
                required: requiredFields.has(propName),
            }));
        }
        const promptSchema = {
            name,
            description,
            ...(promptArguments && { arguments: promptArguments }),
        };
        const registered = {
            prompt: promptSchema,
            validator,
            generator,
        };
        this.prompts.set(name, registered);
    }
    /**
     * Remove a prompt from the server
     */
    removePrompt(name) {
        return this.prompts.delete(name);
    }
    /**
     * Get a specific prompt by name
     */
    getPrompt(name) {
        const registeredPrompt = this.prompts.get(name);
        return registeredPrompt?.prompt;
    }
    /**
     * Get all registered prompts
     */
    getPromptDefinitions() {
        return Array.from(this.prompts.values()).map((prompt) => prompt.prompt);
    }
    /**
     * Handle a JSON-RPC request
     */
    async handleRequest(request) {
        try {
            switch (request.method) {
                case "ping":
                    return this.handlePing(request);
                case "initialize":
                    return this.handleInitialize(request);
                case "tools/list":
                    return this.handleToolListRequest(request);
                case "tools/call":
                    return this.handleToolCallRequest(request);
                case "prompts/list":
                    return this.handlePromptListRequest(request);
                case "prompts/get":
                    return this.handlePromptGetRequest(request);
                default:
                    // Method not found
                    return newJSONRPCError({
                        id: request.id,
                        code: ErrorCode.MethodNotFound,
                        message: `Method "${request.method}" not found`,
                    });
            }
        }
        catch (error) {
            this.logger.error("Error handling request:", error);
            // Internal error
            return newJSONRPCError({
                id: request.id,
                code: ErrorCode.InternalError,
                message: error instanceof Error ? error.message : "Internal error",
            });
        }
    }
    /**
     * Handle a JSON-RPC notification
     */
    async handleNotification(notification) {
        this.logger.debug("Received notification:", notification.method);
    }
    /**
     * Handle ping request - the server MUST respond with an empty request.
     */
    handlePing(request) {
        return newJSONRPCReponse({ id: request.id, result: {} });
    }
    /**
     * Handle initialize request
     */
    handleInitialize(request) {
        const parseResult = InitializeRequestSchema.safeParse(request);
        if (!parseResult.success) {
            const treeErrors = z.treeifyError(parseResult.error);
            const prettyErrors = z.prettifyError(parseResult.error);
            return newJSONRPCError({
                id: request.id,
                code: ErrorCode.InvalidParams,
                message: `Invalid request parameters: ${prettyErrors}`,
                data: treeErrors,
            });
        }
        const protocolVersion = parseResult.data.params.protocolVersion;
        switch (protocolVersion) {
            case LATEST_PROTOCOL_VERSION:
            case PROTOCOL_VERSION_2025_03_26:
            case PROTOCOL_VERSION_2024_11_05:
            case PROTOCOL_VERSION_2024_10_07: {
                const initResponse = {
                    protocolVersion: protocolVersion,
                    capabilities: this.getCapabilities(),
                    serverInfo: {
                        name: this.name,
                        version: this.version,
                    },
                    ...(this.instructions ? { instructions: this.instructions } : {}),
                };
                return newJSONRPCReponse({ id: request.id, result: initResponse });
            }
            default: {
                return newJSONRPCError({
                    id: request.id,
                    code: ErrorCode.InvalidParams,
                    message: `Unsupported protocol version: ${protocolVersion} - supported versions: ${SUPPORTED_PROTOCOL_VERSIONS}`,
                    data: {
                        supportedVersions: SUPPORTED_PROTOCOL_VERSIONS,
                    },
                });
            }
        }
    }
    async handleToolListRequest(request) {
        // Map over the tools Map to create an array of Tool objects
        const toolsArray = Array.from(this.tools.entries()).map(([name, registeredTool]) => {
            // Extract the toolSchema which already has the correct structure
            return registeredTool.tool;
        });
        const toolList = {
            tools: toolsArray,
        };
        return newJSONRPCReponse({
            id: request.id,
            result: toolList,
        });
    }
    /**
     * Handle tool request
     */
    async handleToolCallRequest(request) {
        const validatedToolCall = CallToolRequestSchema.safeParse(request);
        if (!validatedToolCall.success) {
            this.logger.warn("Could not validate tool call:", validatedToolCall.error);
            return newJSONRPCError({
                id: request.id,
                code: ErrorCode.InvalidRequest,
                message: `Invalid request ${validatedToolCall.error}`,
            });
        }
        const toolCallReq = validatedToolCall.data;
        const toolName = toolCallReq.params.name;
        const tool = this.tools.get(toolName);
        if (!tool) {
            return newJSONRPCError({
                id: request.id,
                code: ErrorCode.InvalidParams,
                message: `Tool "${toolName}" not found`,
            });
        }
        const rawArgs = toolCallReq.params.arguments ?? {};
        const validation = tool.validator.parse(rawArgs);
        if (!validation.success) {
            return newJSONRPCError({
                id: request.id,
                code: ErrorCode.InvalidParams,
                message: validation.errorMessage
                    ? `Invalid arguments for tool '${toolName}': ${validation.errorMessage}`
                    : `Invalid arguments for tool '${toolName}'`,
                data: validation.errorData,
            });
        }
        // Execute the tool
        try {
            // upcast here since we are sure that the json schema object has been
            // validated and "data" should be some sort of object.
            const data = validation.data;
            const result = await tool.handler(data);
            return newJSONRPCReponse({
                id: request.id,
                result: result,
            });
        }
        catch (error) {
            this.logger.error(`Error executing tool "${toolName}":`, error);
            return newJSONRPCError({
                id: request.id,
                code: ErrorCode.InternalError,
                message: error instanceof Error ? error.message : "Tool execution error",
            });
        }
    }
    /**
     * Handle prompts/list request
     */
    async handlePromptListRequest(request) {
        const parseResult = ListPromptsRequestSchema.safeParse(request);
        if (!parseResult.success) {
            const treeErrors = z.treeifyError(parseResult.error);
            const prettyErrors = z.prettifyError(parseResult.error);
            return newJSONRPCError({
                id: request.id,
                code: ErrorCode.InvalidParams,
                message: `Invalid request parameters: ${prettyErrors}`,
                data: treeErrors,
            });
        }
        const promptsArray = Array.from(this.prompts.values()).map((registeredPrompt) => registeredPrompt.prompt);
        const result = {
            prompts: promptsArray,
        };
        return newJSONRPCReponse({
            id: request.id,
            result,
        });
    }
    /**
     * Handle prompts/get request
     */
    async handlePromptGetRequest(request) {
        const parseResult = GetPromptRequestSchema.safeParse(request);
        if (!parseResult.success) {
            const treeErrors = z.treeifyError(parseResult.error);
            const prettyErrors = z.prettifyError(parseResult.error);
            return newJSONRPCError({
                id: request.id,
                code: ErrorCode.InvalidParams,
                message: `Invalid request parameters: ${prettyErrors}`,
                data: treeErrors,
            });
        }
        const promptName = parseResult.data.params.name;
        const prompt = this.prompts.get(promptName);
        if (!prompt) {
            return newJSONRPCError({
                id: request.id,
                code: ErrorCode.InvalidParams,
                message: `Prompt "${promptName}" not found`,
            });
        }
        const rawArgs = parseResult.data.params.arguments ?? {};
        const validation = prompt.validator.parse(rawArgs);
        if (!validation.success) {
            return newJSONRPCError({
                id: request.id,
                code: ErrorCode.InvalidParams,
                message: validation.errorMessage
                    ? `Invalid arguments for prompt '${promptName}': ${validation.errorMessage}`
                    : `Invalid arguments for prompt '${promptName}'`,
                data: validation.errorData,
            });
        }
        try {
            const data = validation.data;
            const messages = await prompt.generator(data);
            const result = {
                ...(prompt.prompt.description && {
                    description: prompt.prompt.description,
                }),
                messages,
            };
            return newJSONRPCReponse({
                id: request.id,
                result,
            });
        }
        catch (error) {
            this.logger.error(`Error generating prompt "${promptName}":`, error);
            return newJSONRPCError({
                id: request.id,
                code: ErrorCode.InternalError,
                message: error instanceof Error ? error.message : "Prompt generation error",
            });
        }
    }
    /**
     * Update the available tools in capabilities
     */
    updateAvailableTools() {
        if (this.capabilities.tools) {
            this.capabilities.tools.available = Array.from(this.tools.keys());
        }
    }
}
//# sourceMappingURL=index.js.map