import type { JSONRPCMessage } from "../jsonrpc2/types.js";
import type { MessageHandler, Transport, TransportOptions } from "./types.js";
/**
 * Handler for streaming responses
 */
export interface StreamProvider {
    getStream(): AsyncIterable<JSONRPCMessage>;
    cancel?(): void;
}
/**
 * HTTP Streamable Transport implementation for Model Context Protocol
 * following the Streamable HTTP transport specification
 */
export declare class HTTPStreamableTransport implements Transport {
    messageHandler: MessageHandler | null;
    closeCallback: (() => void) | null;
    private headers;
    private options;
    private connected;
    private enableStreaming;
    private sessions;
    private streams;
    private logger;
    setHeaders(headers: Record<string, string>): void;
    constructor(options?: TransportOptions, streamable?: boolean);
    onError(callback: (error: Error) => void): void;
    getSessionId(): string | undefined;
    setSessionId(sessionId: string | undefined): void;
    /**
     * Initialize the transport with the server
     */
    connect(): Promise<void>;
    /**
     * Send a JSON RPC Message on the connected transport
     * This sends messages to connected SSE streams
     */
    send(message: JSONRPCMessage): Promise<void>;
    /**
     * Set message handler callback
     */
    onMessage(handler: MessageHandler): void;
    /**
     * Sets a callback for when the transport is closed
     */
    onClose(callback: () => void): void;
    /**
     * Close the transport
     */
    close(): Promise<void>;
    /**
     * Handle HTTP request (follows the WinterTC standard)
     */
    handleRequest(request: Request): Promise<Response>;
    /**
     * Handle POST requests (sending messages to server)
     */
    private handlePostRequest;
    /**
     * Handle GET requests (listening for server messages)
     */
    private handleGetRequest;
    /**
     * Handle DELETE requests (explicit session termination)
     */
    private handleDeleteRequest;
    /**
     * Send message to a specific stream
     */
    private sendToStream;
    /**
     * Close a specific stream
     */
    private closeStream;
    /**
     * Create a new session
     */
    private createSession;
    /**
     * Create a new stream for SSE communication
     */
    private createStream;
    /**
     * Replay messages on a stream from a given event ID
     */
    private replayMessages;
    /**
     * Start periodic cleanup of expired sessions
     */
    private startSessionCleanup;
    /**
     * Extract JSON-RPC message(s) from HTTP request
     */
    private extractJSONRPC;
    /**
     * Validate origin header to prevent DNS rebinding attacks
     */
    private validateOrigin;
    /**
     * Check if an origin is valid
     */
    private isValidOrigin;
    /**
     * Check if a message is a JSON-RPC request
     */
    private isRequest;
    /**
     * Generate a fallback UUID if crypto.randomUUID is not available
     */
    private generateFallbackUUID;
}
