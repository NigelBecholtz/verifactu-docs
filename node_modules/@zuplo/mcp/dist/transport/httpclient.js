import { EventSourceParserStream } from "eventsource-parser/stream";
import { createDefaultLogger } from "../logger/index.js";
/**
 * HTTP Client Transport for MCP clients to communicate with MCP servers
 *
 * Makes HTTP POST requests to send JSON-RPC messages and handles responses.
 * Designed specifically for client-side usage.
 */
export class HTTPClientTransport {
    url;
    timeout;
    headers;
    fetch;
    logger;
    sessionId;
    messageHandler;
    errorCallback;
    closeCallback;
    isConnected = false;
    constructor(options) {
        this.url = options.url;
        this.timeout = options.timeout || 30000;
        this.headers = {
            "Content-Type": "application/json",
            Accept: "application/json, text/event-stream",
            ...options.headers,
        };
        this.fetch = options.fetch || globalThis.fetch;
        this.logger = options.logger || createDefaultLogger();
        if (options.enableSessions) {
            this.logger.debug("Session support not yet implemented for HTTP client transport");
        }
    }
    setHeaders(headers) {
        this.headers = { ...this.headers, ...headers };
    }
    async connect() {
        try {
            new URL(this.url);
            this.isConnected = true;
            this.logger.info("HTTP Client Transport connected to:", this.url);
        }
        catch (error) {
            const err = new Error(`Invalid URL: ${this.url}`);
            if (this.errorCallback) {
                this.errorCallback(err);
            }
            throw err;
        }
    }
    async send(message) {
        if (!this.isConnected) {
            throw new Error("Transport not connected. Call connect() first.");
        }
        let timeoutId;
        try {
            const requestHeaders = { ...this.headers };
            // Add session ID header if available per MCP spec
            if (this.sessionId) {
                requestHeaders["Mcp-Session-Id"] = this.sessionId;
            }
            const controller = new AbortController();
            timeoutId = setTimeout(() => controller.abort(), this.timeout);
            const response = await this.fetch(this.url, {
                method: "POST",
                headers: {
                    ...this.headers,
                    ...(this.sessionId && { "Mcp-Session-Id": this.sessionId }),
                },
                body: JSON.stringify(message),
                signal: controller.signal,
            });
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            // Check content type to determine response format
            const contentType = response.headers.get("Content-Type") || "";
            if (contentType.includes("text/event-stream")) {
                // Handle SSE response
                await this.handleSSEResponse(response);
            }
            else {
                // Handle JSON response
                await this.handleJSONResponse(response);
            }
        }
        catch (error) {
            if (error instanceof Error && error.name === "AbortError") {
                if (this.errorCallback) {
                    this.errorCallback(error);
                }
                throw new Error(`Request timeout after ${this.timeout}ms`);
            }
            const unknownError = new Error(`A client error occurred: ${error}`);
            if (this.errorCallback) {
                this.errorCallback(unknownError);
            }
            throw unknownError;
        }
        finally {
            if (timeoutId) {
                clearTimeout(timeoutId);
            }
        }
    }
    onMessage(handler) {
        this.messageHandler = handler;
    }
    async close() {
        this.logger.debug("Closing HTTP Client Transport");
        this.isConnected = false;
        this.messageHandler = undefined;
        if (this.closeCallback) {
            this.closeCallback();
        }
        this.logger.info("HTTP Client Transport closed");
    }
    onClose(callback) {
        this.closeCallback = callback;
    }
    onError(callback) {
        this.errorCallback = callback;
    }
    getSessionId() {
        return this.sessionId;
    }
    setSessionId(sessionId) {
        this.sessionId = sessionId;
        this.logger.debug("Session ID set:", sessionId ? "***" : "undefined");
    }
    /**
     * Handle JSON response from server
     */
    async handleJSONResponse(response) {
        const responseText = await response.text();
        if (!responseText.trim()) {
            this.logger.debug("Received empty response");
            return;
        }
        let responseMessage;
        try {
            responseMessage = JSON.parse(responseText);
        }
        catch (parseError) {
            throw new Error(`Invalid JSON response: ${responseText}`);
        }
        this.logger.debug("Received JSON-RPC response:", responseMessage);
        // Call the message handler with the response
        if (this.messageHandler) {
            await this.messageHandler(responseMessage);
        }
    }
    /**
     * Handle SSE response from server
     */
    async handleSSEResponse(response) {
        if (!response.body) {
            throw new Error("SSE response has no body");
        }
        this.logger.debug("Handling SSE response");
        const onEvent = (event) => {
            // Only process "message" events, ignore others like "ping" or comments
            if (!event.event || event.event === "message") {
                try {
                    const message = JSON.parse(event.data);
                    this.logger.debug("Received SSE message:", message);
                    if (this.messageHandler) {
                        this.messageHandler(message);
                    }
                }
                catch (parseError) {
                    this.logger.warn("Failed to parse SSE message data:", event.data, parseError);
                }
            }
        };
        const eventStream = response.body
            .pipeThrough(new TextDecoderStream())
            .pipeThrough(new EventSourceParserStream())
            .getReader();
        try {
            while (true) {
                const { done, value } = await eventStream.read();
                if (done) {
                    return;
                }
                onEvent(value);
            }
        }
        catch (streamError) {
            this.logger.error("Error processing SSE stream:", streamError);
            throw new Error(`SSE stream error: ${streamError}`);
        }
    }
}
//# sourceMappingURL=httpclient.js.map