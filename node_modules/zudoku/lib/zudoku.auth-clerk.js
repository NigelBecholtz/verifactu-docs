import { j as l } from "./jsx-runtime-DywqP_6a.js";
import { LogOutIcon as f } from "lucide-react";
import { S as w, a as p, b as v } from "./SignUp-C-YP_Rxi.js";
import { u as n } from "./hook-BkLXq8pm.js";
const b = ({
  clerkPubKey: d,
  jwtTemplateName: m,
  redirectToAfterSignOut: c = "/",
  redirectToAfterSignUp: a,
  redirectToAfterSignIn: r
}) => {
  let s;
  const t = (async () => {
    if (typeof window > "u") return;
    const { Clerk: e } = await import("@clerk/clerk-js");
    if (s = new e(d), await s.load(), s.user) {
      const i = s.user.emailAddresses.find(
        (o) => o.verification.status === "verified"
      );
      n.getState().setLoggedIn({
        profile: {
          sub: s.user.id,
          name: s.user.fullName ?? void 0,
          email: i?.emailAddress ?? s.user.emailAddresses[0]?.emailAddress,
          emailVerified: i !== void 0,
          pictureUrl: s.user.imageUrl
        },
        providerData: {
          user: {
            publicMetadata: s.user.publicMetadata,
            id: s.user.id,
            emailAddresses: s.user.emailAddresses,
            imageUrl: s.user.imageUrl,
            fullName: s.user.fullName
          }
        }
      });
    }
    return s;
  })();
  async function u() {
    if (await t, !s?.session)
      throw new Error("No session available");
    const e = await s.session.getToken({
      template: m
    });
    if (!e)
      throw new Error("Could not get access token from Clerk");
    return e;
  }
  async function g(e) {
    const i = await u();
    return e.headers.set("Authorization", `Bearer ${i}`), e;
  }
  return {
    getRoutes: () => [
      {
        path: "/signout",
        element: /* @__PURE__ */ l.jsx(w, {})
      },
      {
        path: "/signin",
        element: /* @__PURE__ */ l.jsx(p, {})
      },
      {
        path: "/signup",
        element: /* @__PURE__ */ l.jsx(v, {})
      }
    ],
    getProfileMenuItems() {
      return [
        {
          label: "Logout",
          path: "/signout",
          category: "bottom",
          icon: f
        }
      ];
    },
    initialize: async () => {
      const e = await t;
      if (e)
        if (e.session) {
          const i = e.session.user.emailAddresses.find(
            (o) => o.verification.status === "verified"
          );
          n.getState().setLoggedIn({
            profile: {
              sub: e.session.user.id,
              name: e.session.user.fullName ?? void 0,
              email: i?.emailAddress ?? e.session.user.emailAddresses[0]?.emailAddress,
              emailVerified: i !== void 0,
              pictureUrl: e.session.user.imageUrl
            },
            providerData: {
              user: e.session.user
            }
          });
        } else
          n.setState({
            isAuthenticated: !1,
            isPending: !1,
            profile: void 0
          });
    },
    getAccessToken: u,
    signRequest: g,
    signOut: async () => {
      await t, await s?.signOut({
        redirectUrl: window.location.origin + c
      }), n.getState().setLoggedOut();
    },
    signIn: async ({ redirectTo: e } = {}) => {
      await t, await s?.redirectToSignIn({
        signInForceRedirectUrl: r ? window.location.origin + r : e,
        signUpForceRedirectUrl: a ? window.location.origin + a : e
      });
    },
    signUp: async ({ redirectTo: e } = {}) => {
      await t, await s?.redirectToSignUp({
        signInForceRedirectUrl: r ? window.location.origin + r : e,
        signUpForceRedirectUrl: a ? window.location.origin + a : e
      });
    }
  };
};
export {
  b as default
};
//# sourceMappingURL=zudoku.auth-clerk.js.map
