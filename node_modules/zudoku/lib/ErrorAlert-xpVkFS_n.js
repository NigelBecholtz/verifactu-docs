import * as Es from "react";
import { useRef as qe, createContext as si, use as oi, useEffect as et, useCallback as li, useState as sn, useMemo as Ft, memo as cr, Fragment as Ts, useId as gs, useLayoutEffect as bs } from "react";
import { j as O } from "./jsx-runtime-DywqP_6a.js";
import { a as As } from "./useExposedProps-B8NHdNRq.js";
import { a as _s, d as Cs, e as Is } from "./hook-BkLXq8pm.js";
import { J as xs, K as en, j as Xn, d as fr, m as Ss } from "./ZudokuContext-BcqSiygJ.js";
import { s as tn, p as je, a as hr, v as Tn, b as Ns, V as ks, u as Os, t as ys, c as jr, d as Vr, o as Me, z as ci, e as Ls, f as Rs, g as Ds, i as fi, j as Ps, k as Wr, E as ws, S as Ms, l as Bs, h as Fs } from "./SyntaxHighlight-CPF64UHi.js";
import { g as Hs, i as Us, Z as Qr } from "./invariant-Bm-FVUQE.js";
import { L as vs, C as zs } from "./CodeBlock-i0BM_QFf.js";
import { EmbeddedCodeBlock as Ys } from "./ui/EmbeddedCodeBlock.js";
import { Callout as Ue } from "./ui/Callout.js";
import { CheckIcon as qs, CopyIcon as js, ChevronRightIcon as Vs, ExternalLinkIcon as Ws, LinkIcon as Qs } from "lucide-react";
import { c as ae } from "./cn-dYga0KKN.js";
import { u as Gs } from "./useCopyToClipboard-B_085nfO.js";
import { c as gn, d as Xs, ac as dr, aZ as Ks } from "./chunk-PVWAREVJ-BO6B-RAk.js";
import * as pt from "@radix-ui/react-tooltip";
import * as yn from "@radix-ui/react-collapsible";
import { B as $s } from "./Button-DTDRi4CT.js";
import { c as hi } from "./index-DI5SPFK9.js";
import { Slot as Js } from "@radix-ui/react-slot";
import { Button as Zs } from "./ui/Button.js";
import { Stepper as eo } from "./ui/Stepper.js";
const Ln = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
}, to = {};
function mr(e, t) {
  const n = to, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, u = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return di(e, r, u);
}
function di(e, t, n) {
  if (no(e)) {
    if ("value" in e)
      return e.type === "html" && !n ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return Gr(e.children, t, n);
  }
  return Array.isArray(e) ? Gr(e, t, n) : "";
}
function Gr(e, t, n) {
  const r = [];
  let u = -1;
  for (; ++u < e.length; )
    r[u] = di(e[u], t, n);
  return r.join("");
}
function no(e) {
  return !!(e && typeof e == "object");
}
const Xr = typeof document < "u" && document.createElement("i");
function pr(e) {
  const t = "&" + e + ";";
  Xr.innerHTML = t;
  const n = Xr.textContent;
  return n.charCodeAt(n.length - 1) === 59 && e !== "semi" || n === t ? !1 : n;
}
function Oe(e, t, n, r) {
  const u = e.length;
  let a = 0, i;
  if (t < 0 ? t = -t > u ? 0 : u + t : t = t > u ? u : t, n = n > 0 ? n : 0, r.length < 1e4)
    i = Array.from(r), i.unshift(t, n), e.splice(...i);
  else
    for (n && e.splice(t, n); a < r.length; )
      i = r.slice(a, a + 1e4), i.unshift(t, 0), e.splice(...i), a += 1e4, t += 1e4;
}
function ge(e, t) {
  return e.length > 0 ? (Oe(e, e.length, 0, t), e) : t;
}
const Kr = {}.hasOwnProperty;
function ro(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; )
    uo(t, e[n]);
  return t;
}
function uo(e, t) {
  let n;
  for (n in t) {
    const u = (Kr.call(e, n) ? e[n] : void 0) || (e[n] = {}), a = t[n];
    let i;
    if (a)
      for (i in a) {
        Kr.call(u, i) || (u[i] = []);
        const o = a[i];
        io(
          // @ts-expect-error Looks like a list.
          u[i],
          Array.isArray(o) ? o : o ? [o] : []
        );
      }
  }
}
function io(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; )
    (t[n].add === "after" ? e : r).push(t[n]);
  Oe(e, 0, 0, r);
}
function mi(e, t) {
  const n = Number.parseInt(e, t);
  return (
    // C0 except for HT, LF, FF, CR, space.
    n < 9 || n === 11 || n > 13 && n < 32 || // Control character (DEL) of C0, and C1 controls.
    n > 126 && n < 160 || // Lone high surrogates and low surrogates.
    n > 55295 && n < 57344 || // Noncharacters.
    n > 64975 && n < 65008 || /* eslint-disable no-bitwise */
    (n & 65535) === 65535 || (n & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    n > 1114111 ? "�" : String.fromCodePoint(n)
  );
}
function ft(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const de = Ve(/[A-Za-z]/), fe = Ve(/[\dA-Za-z]/), ao = Ve(/[#-'*+\--9=?A-Z^-~]/);
function on(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
const Kn = Ve(/\d/), so = Ve(/[\dA-Fa-f]/), oo = Ve(/[!-/:-@[-`{-~]/);
function H(e) {
  return e !== null && e < -2;
}
function J(e) {
  return e !== null && (e < 0 || e === 32);
}
function j(e) {
  return e === -2 || e === -1 || e === 32;
}
const bn = Ve(/\p{P}|\p{S}/u), tt = Ve(/\s/);
function Ve(e) {
  return t;
  function t(n) {
    return n !== null && n > -1 && e.test(String.fromCharCode(n));
  }
}
function W(e, t, n, r) {
  const u = r ? r - 1 : Number.POSITIVE_INFINITY;
  let a = 0;
  return i;
  function i(l) {
    return j(l) ? (e.enter(n), o(l)) : t(l);
  }
  function o(l) {
    return j(l) && a++ < u ? (e.consume(l), o) : (e.exit(n), t(l));
  }
}
const lo = {
  tokenize: co
};
function co(e) {
  const t = e.attempt(
    this.parser.constructs.contentInitial,
    r,
    u
  );
  let n;
  return t;
  function r(o) {
    if (o === null) {
      e.consume(o);
      return;
    }
    return e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), W(e, t, "linePrefix");
  }
  function u(o) {
    return e.enter("paragraph"), a(o);
  }
  function a(o) {
    const l = e.enter("chunkText", {
      contentType: "text",
      previous: n
    });
    return n && (n.next = l), n = l, i(o);
  }
  function i(o) {
    if (o === null) {
      e.exit("chunkText"), e.exit("paragraph"), e.consume(o);
      return;
    }
    return H(o) ? (e.consume(o), e.exit("chunkText"), a) : (e.consume(o), i);
  }
}
const fo = {
  tokenize: ho
}, $r = {
  tokenize: mo
};
function ho(e) {
  const t = this, n = [];
  let r = 0, u, a, i;
  return o;
  function o(D) {
    if (r < n.length) {
      const z = n[r];
      return t.containerState = z[1], e.attempt(
        z[0].continuation,
        l,
        c
      )(D);
    }
    return c(D);
  }
  function l(D) {
    if (r++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, u && w();
      const z = t.events.length;
      let Y = z, k;
      for (; Y--; )
        if (t.events[Y][0] === "exit" && t.events[Y][1].type === "chunkFlow") {
          k = t.events[Y][1].end;
          break;
        }
      x(r);
      let Q = z;
      for (; Q < t.events.length; )
        t.events[Q][1].end = Object.assign({}, k), Q++;
      return Oe(
        t.events,
        Y + 1,
        0,
        t.events.slice(z)
      ), t.events.length = Q, c(D);
    }
    return o(D);
  }
  function c(D) {
    if (r === n.length) {
      if (!u)
        return p(D);
      if (u.currentConstruct && u.currentConstruct.concrete)
        return A(D);
      t.interrupt = !!(u.currentConstruct && !u._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, e.check(
      $r,
      h,
      f
    )(D);
  }
  function h(D) {
    return u && w(), x(r), p(D);
  }
  function f(D) {
    return t.parser.lazy[t.now().line] = r !== n.length, i = t.now().offset, A(D);
  }
  function p(D) {
    return t.containerState = {}, e.attempt(
      $r,
      d,
      A
    )(D);
  }
  function d(D) {
    return r++, n.push([t.currentConstruct, t.containerState]), p(D);
  }
  function A(D) {
    if (D === null) {
      u && w(), x(0), e.consume(D);
      return;
    }
    return u = u || t.parser.flow(t.now()), e.enter("chunkFlow", {
      contentType: "flow",
      previous: a,
      _tokenizer: u
    }), C(D);
  }
  function C(D) {
    if (D === null) {
      L(e.exit("chunkFlow"), !0), x(0), e.consume(D);
      return;
    }
    return H(D) ? (e.consume(D), L(e.exit("chunkFlow")), r = 0, t.interrupt = void 0, o) : (e.consume(D), C);
  }
  function L(D, z) {
    const Y = t.sliceStream(D);
    if (z && Y.push(null), D.previous = a, a && (a.next = D), a = D, u.defineSkip(D.start), u.write(Y), t.parser.lazy[D.start.line]) {
      let k = u.events.length;
      for (; k--; )
        if (
          // The token starts before the line ending…
          u.events[k][1].start.offset < i && // …and either is not ended yet…
          (!u.events[k][1].end || // …or ends after it.
          u.events[k][1].end.offset > i)
        )
          return;
      const Q = t.events.length;
      let ee = Q, X, S;
      for (; ee--; )
        if (t.events[ee][0] === "exit" && t.events[ee][1].type === "chunkFlow") {
          if (X) {
            S = t.events[ee][1].end;
            break;
          }
          X = !0;
        }
      for (x(r), k = Q; k < t.events.length; )
        t.events[k][1].end = Object.assign({}, S), k++;
      Oe(
        t.events,
        ee + 1,
        0,
        t.events.slice(Q)
      ), t.events.length = k;
    }
  }
  function x(D) {
    let z = n.length;
    for (; z-- > D; ) {
      const Y = n[z];
      t.containerState = Y[1], Y[0].exit.call(t, e);
    }
    n.length = D;
  }
  function w() {
    u.write([null]), a = void 0, u = void 0, t.containerState._closeFlow = void 0;
  }
}
function mo(e, t, n) {
  return W(
    e,
    e.attempt(this.parser.constructs.document, t, n),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
function dt(e) {
  if (e === null || J(e) || tt(e))
    return 1;
  if (bn(e))
    return 2;
}
function Er(e, t, n) {
  const r = [];
  let u = -1;
  for (; ++u < e.length; ) {
    const a = e[u].resolveAll;
    a && !r.includes(a) && (t = a(t, n), r.push(a));
  }
  return t;
}
const $n = {
  name: "attention",
  tokenize: Eo,
  resolveAll: po
};
function po(e, t) {
  let n = -1, r, u, a, i, o, l, c, h;
  for (; ++n < e.length; )
    if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) {
      for (r = n; r--; )
        if (e[r][0] === "exit" && e[r][1].type === "attentionSequence" && e[r][1]._open && // If the markers are the same:
        t.sliceSerialize(e[r][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)) {
          if ((e[r][1]._close || e[n][1]._open) && (e[n][1].end.offset - e[n][1].start.offset) % 3 && !((e[r][1].end.offset - e[r][1].start.offset + e[n][1].end.offset - e[n][1].start.offset) % 3))
            continue;
          l = e[r][1].end.offset - e[r][1].start.offset > 1 && e[n][1].end.offset - e[n][1].start.offset > 1 ? 2 : 1;
          const f = Object.assign({}, e[r][1].end), p = Object.assign({}, e[n][1].start);
          Jr(f, -l), Jr(p, l), i = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: f,
            end: Object.assign({}, e[r][1].end)
          }, o = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, e[n][1].start),
            end: p
          }, a = {
            type: l > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, e[r][1].end),
            end: Object.assign({}, e[n][1].start)
          }, u = {
            type: l > 1 ? "strong" : "emphasis",
            start: Object.assign({}, i.start),
            end: Object.assign({}, o.end)
          }, e[r][1].end = Object.assign({}, i.start), e[n][1].start = Object.assign({}, o.end), c = [], e[r][1].end.offset - e[r][1].start.offset && (c = ge(c, [
            ["enter", e[r][1], t],
            ["exit", e[r][1], t]
          ])), c = ge(c, [
            ["enter", u, t],
            ["enter", i, t],
            ["exit", i, t],
            ["enter", a, t]
          ]), c = ge(
            c,
            Er(
              t.parser.constructs.insideSpan.null,
              e.slice(r + 1, n),
              t
            )
          ), c = ge(c, [
            ["exit", a, t],
            ["enter", o, t],
            ["exit", o, t],
            ["exit", u, t]
          ]), e[n][1].end.offset - e[n][1].start.offset ? (h = 2, c = ge(c, [
            ["enter", e[n][1], t],
            ["exit", e[n][1], t]
          ])) : h = 0, Oe(e, r - 1, n - r + 3, c), n = r + c.length - h - 2;
          break;
        }
    }
  for (n = -1; ++n < e.length; )
    e[n][1].type === "attentionSequence" && (e[n][1].type = "data");
  return e;
}
function Eo(e, t) {
  const n = this.parser.constructs.attentionMarkers.null, r = this.previous, u = dt(r);
  let a;
  return i;
  function i(l) {
    return a = l, e.enter("attentionSequence"), o(l);
  }
  function o(l) {
    if (l === a)
      return e.consume(l), o;
    const c = e.exit("attentionSequence"), h = dt(l), f = !h || h === 2 && u || n.includes(l), p = !u || u === 2 && h || n.includes(r);
    return c._open = !!(a === 42 ? f : f && (u || !p)), c._close = !!(a === 42 ? p : p && (h || !f)), t(l);
  }
}
function Jr(e, t) {
  e.column += t, e.offset += t, e._bufferIndex += t;
}
const To = {
  name: "autolink",
  tokenize: go
};
function go(e, t, n) {
  let r = 0;
  return u;
  function u(d) {
    return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(d), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), a;
  }
  function a(d) {
    return de(d) ? (e.consume(d), i) : c(d);
  }
  function i(d) {
    return d === 43 || d === 45 || d === 46 || fe(d) ? (r = 1, o(d)) : c(d);
  }
  function o(d) {
    return d === 58 ? (e.consume(d), r = 0, l) : (d === 43 || d === 45 || d === 46 || fe(d)) && r++ < 32 ? (e.consume(d), o) : (r = 0, c(d));
  }
  function l(d) {
    return d === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(d), e.exit("autolinkMarker"), e.exit("autolink"), t) : d === null || d === 32 || d === 60 || on(d) ? n(d) : (e.consume(d), l);
  }
  function c(d) {
    return d === 64 ? (e.consume(d), h) : ao(d) ? (e.consume(d), c) : n(d);
  }
  function h(d) {
    return fe(d) ? f(d) : n(d);
  }
  function f(d) {
    return d === 46 ? (e.consume(d), r = 0, h) : d === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(d), e.exit("autolinkMarker"), e.exit("autolink"), t) : p(d);
  }
  function p(d) {
    if ((d === 45 || fe(d)) && r++ < 63) {
      const A = d === 45 ? p : f;
      return e.consume(d), A;
    }
    return n(d);
  }
}
const An = {
  tokenize: bo,
  partial: !0
};
function bo(e, t, n) {
  return r;
  function r(a) {
    return j(a) ? W(e, u, "linePrefix")(a) : u(a);
  }
  function u(a) {
    return a === null || H(a) ? t(a) : n(a);
  }
}
const pi = {
  name: "blockQuote",
  tokenize: Ao,
  continuation: {
    tokenize: _o
  },
  exit: Co
};
function Ao(e, t, n) {
  const r = this;
  return u;
  function u(i) {
    if (i === 62) {
      const o = r.containerState;
      return o.open || (e.enter("blockQuote", {
        _container: !0
      }), o.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(i), e.exit("blockQuoteMarker"), a;
    }
    return n(i);
  }
  function a(i) {
    return j(i) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(i), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(i));
  }
}
function _o(e, t, n) {
  const r = this;
  return u;
  function u(i) {
    return j(i) ? W(
      e,
      a,
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(i) : a(i);
  }
  function a(i) {
    return e.attempt(pi, t, n)(i);
  }
}
function Co(e) {
  e.exit("blockQuote");
}
const Ei = {
  name: "characterEscape",
  tokenize: Io
};
function Io(e, t, n) {
  return r;
  function r(a) {
    return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(a), e.exit("escapeMarker"), u;
  }
  function u(a) {
    return oo(a) ? (e.enter("characterEscapeValue"), e.consume(a), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(a);
  }
}
const Ti = {
  name: "characterReference",
  tokenize: xo
};
function xo(e, t, n) {
  const r = this;
  let u = 0, a, i;
  return o;
  function o(f) {
    return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(f), e.exit("characterReferenceMarker"), l;
  }
  function l(f) {
    return f === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(f), e.exit("characterReferenceMarkerNumeric"), c) : (e.enter("characterReferenceValue"), a = 31, i = fe, h(f));
  }
  function c(f) {
    return f === 88 || f === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(f), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), a = 6, i = so, h) : (e.enter("characterReferenceValue"), a = 7, i = Kn, h(f));
  }
  function h(f) {
    if (f === 59 && u) {
      const p = e.exit("characterReferenceValue");
      return i === fe && !pr(r.sliceSerialize(p)) ? n(f) : (e.enter("characterReferenceMarker"), e.consume(f), e.exit("characterReferenceMarker"), e.exit("characterReference"), t);
    }
    return i(f) && u++ < a ? (e.consume(f), h) : n(f);
  }
}
const Zr = {
  tokenize: No,
  partial: !0
}, eu = {
  name: "codeFenced",
  tokenize: So,
  concrete: !0
};
function So(e, t, n) {
  const r = this, u = {
    tokenize: Y,
    partial: !0
  };
  let a = 0, i = 0, o;
  return l;
  function l(k) {
    return c(k);
  }
  function c(k) {
    const Q = r.events[r.events.length - 1];
    return a = Q && Q[1].type === "linePrefix" ? Q[2].sliceSerialize(Q[1], !0).length : 0, o = k, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), h(k);
  }
  function h(k) {
    return k === o ? (i++, e.consume(k), h) : i < 3 ? n(k) : (e.exit("codeFencedFenceSequence"), j(k) ? W(e, f, "whitespace")(k) : f(k));
  }
  function f(k) {
    return k === null || H(k) ? (e.exit("codeFencedFence"), r.interrupt ? t(k) : e.check(Zr, C, z)(k)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
      contentType: "string"
    }), p(k));
  }
  function p(k) {
    return k === null || H(k) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), f(k)) : j(k) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), W(e, d, "whitespace")(k)) : k === 96 && k === o ? n(k) : (e.consume(k), p);
  }
  function d(k) {
    return k === null || H(k) ? f(k) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), A(k));
  }
  function A(k) {
    return k === null || H(k) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), f(k)) : k === 96 && k === o ? n(k) : (e.consume(k), A);
  }
  function C(k) {
    return e.attempt(u, z, L)(k);
  }
  function L(k) {
    return e.enter("lineEnding"), e.consume(k), e.exit("lineEnding"), x;
  }
  function x(k) {
    return a > 0 && j(k) ? W(
      e,
      w,
      "linePrefix",
      a + 1
    )(k) : w(k);
  }
  function w(k) {
    return k === null || H(k) ? e.check(Zr, C, z)(k) : (e.enter("codeFlowValue"), D(k));
  }
  function D(k) {
    return k === null || H(k) ? (e.exit("codeFlowValue"), w(k)) : (e.consume(k), D);
  }
  function z(k) {
    return e.exit("codeFenced"), t(k);
  }
  function Y(k, Q, ee) {
    let X = 0;
    return S;
    function S(G) {
      return k.enter("lineEnding"), k.consume(G), k.exit("lineEnding"), B;
    }
    function B(G) {
      return k.enter("codeFencedFence"), j(G) ? W(
        k,
        F,
        "linePrefix",
        r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
      )(G) : F(G);
    }
    function F(G) {
      return G === o ? (k.enter("codeFencedFenceSequence"), $(G)) : ee(G);
    }
    function $(G) {
      return G === o ? (X++, k.consume(G), $) : X >= i ? (k.exit("codeFencedFenceSequence"), j(G) ? W(k, ne, "whitespace")(G) : ne(G)) : ee(G);
    }
    function ne(G) {
      return G === null || H(G) ? (k.exit("codeFencedFence"), Q(G)) : ee(G);
    }
  }
}
function No(e, t, n) {
  const r = this;
  return u;
  function u(i) {
    return i === null ? n(i) : (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), a);
  }
  function a(i) {
    return r.parser.lazy[r.now().line] ? n(i) : t(i);
  }
}
const Rn = {
  name: "codeIndented",
  tokenize: Oo
}, ko = {
  tokenize: yo,
  partial: !0
};
function Oo(e, t, n) {
  const r = this;
  return u;
  function u(c) {
    return e.enter("codeIndented"), W(e, a, "linePrefix", 5)(c);
  }
  function a(c) {
    const h = r.events[r.events.length - 1];
    return h && h[1].type === "linePrefix" && h[2].sliceSerialize(h[1], !0).length >= 4 ? i(c) : n(c);
  }
  function i(c) {
    return c === null ? l(c) : H(c) ? e.attempt(ko, i, l)(c) : (e.enter("codeFlowValue"), o(c));
  }
  function o(c) {
    return c === null || H(c) ? (e.exit("codeFlowValue"), i(c)) : (e.consume(c), o);
  }
  function l(c) {
    return e.exit("codeIndented"), t(c);
  }
}
function yo(e, t, n) {
  const r = this;
  return u;
  function u(i) {
    return r.parser.lazy[r.now().line] ? n(i) : H(i) ? (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), u) : W(e, a, "linePrefix", 5)(i);
  }
  function a(i) {
    const o = r.events[r.events.length - 1];
    return o && o[1].type === "linePrefix" && o[2].sliceSerialize(o[1], !0).length >= 4 ? t(i) : H(i) ? u(i) : n(i);
  }
}
const Lo = {
  name: "codeText",
  tokenize: Po,
  resolve: Ro,
  previous: Do
};
function Ro(e) {
  let t = e.length - 4, n = 3, r, u;
  if ((e[n][1].type === "lineEnding" || e[n][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (r = n; ++r < t; )
      if (e[r][1].type === "codeTextData") {
        e[n][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", n += 2, t -= 2;
        break;
      }
  }
  for (r = n - 1, t++; ++r <= t; )
    u === void 0 ? r !== t && e[r][1].type !== "lineEnding" && (u = r) : (r === t || e[r][1].type === "lineEnding") && (e[u][1].type = "codeTextData", r !== u + 2 && (e[u][1].end = e[r - 1][1].end, e.splice(u + 2, r - u - 2), t -= r - u - 2, r = u + 2), u = void 0);
  return e;
}
function Do(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function Po(e, t, n) {
  let r = 0, u, a;
  return i;
  function i(f) {
    return e.enter("codeText"), e.enter("codeTextSequence"), o(f);
  }
  function o(f) {
    return f === 96 ? (e.consume(f), r++, o) : (e.exit("codeTextSequence"), l(f));
  }
  function l(f) {
    return f === null ? n(f) : f === 32 ? (e.enter("space"), e.consume(f), e.exit("space"), l) : f === 96 ? (a = e.enter("codeTextSequence"), u = 0, h(f)) : H(f) ? (e.enter("lineEnding"), e.consume(f), e.exit("lineEnding"), l) : (e.enter("codeTextData"), c(f));
  }
  function c(f) {
    return f === null || f === 32 || f === 96 || H(f) ? (e.exit("codeTextData"), l(f)) : (e.consume(f), c);
  }
  function h(f) {
    return f === 96 ? (e.consume(f), u++, h) : u === r ? (e.exit("codeTextSequence"), e.exit("codeText"), t(f)) : (a.type = "codeTextData", c(f));
  }
}
function gi(e) {
  const t = {};
  let n = -1, r, u, a, i, o, l, c;
  for (; ++n < e.length; ) {
    for (; n in t; )
      n = t[n];
    if (r = e[n], n && r[1].type === "chunkFlow" && e[n - 1][1].type === "listItemPrefix" && (l = r[1]._tokenizer.events, a = 0, a < l.length && l[a][1].type === "lineEndingBlank" && (a += 2), a < l.length && l[a][1].type === "content"))
      for (; ++a < l.length && l[a][1].type !== "content"; )
        l[a][1].type === "chunkText" && (l[a][1]._isInFirstContentOfListItem = !0, a++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(t, wo(e, n)), n = t[n], c = !0);
    else if (r[1]._container) {
      for (a = n, u = void 0; a-- && (i = e[a], i[1].type === "lineEnding" || i[1].type === "lineEndingBlank"); )
        i[0] === "enter" && (u && (e[u][1].type = "lineEndingBlank"), i[1].type = "lineEnding", u = a);
      u && (r[1].end = Object.assign({}, e[u][1].start), o = e.slice(u, n), o.unshift(r), Oe(e, u, n - u + 1, o));
    }
  }
  return !c;
}
function wo(e, t) {
  const n = e[t][1], r = e[t][2];
  let u = t - 1;
  const a = [], i = n._tokenizer || r.parser[n.contentType](n.start), o = i.events, l = [], c = {};
  let h, f, p = -1, d = n, A = 0, C = 0;
  const L = [C];
  for (; d; ) {
    for (; e[++u][1] !== d; )
      ;
    a.push(u), d._tokenizer || (h = r.sliceStream(d), d.next || h.push(null), f && i.defineSkip(d.start), d._isInFirstContentOfListItem && (i._gfmTasklistFirstContentOfListItem = !0), i.write(h), d._isInFirstContentOfListItem && (i._gfmTasklistFirstContentOfListItem = void 0)), f = d, d = d.next;
  }
  for (d = n; ++p < o.length; )
    // Find a void token that includes a break.
    o[p][0] === "exit" && o[p - 1][0] === "enter" && o[p][1].type === o[p - 1][1].type && o[p][1].start.line !== o[p][1].end.line && (C = p + 1, L.push(C), d._tokenizer = void 0, d.previous = void 0, d = d.next);
  for (i.events = [], d ? (d._tokenizer = void 0, d.previous = void 0) : L.pop(), p = L.length; p--; ) {
    const x = o.slice(L[p], L[p + 1]), w = a.pop();
    l.unshift([w, w + x.length - 1]), Oe(e, w, 2, x);
  }
  for (p = -1; ++p < l.length; )
    c[A + l[p][0]] = A + l[p][1], A += l[p][1] - l[p][0] - 1;
  return c;
}
const Mo = {
  tokenize: Ho,
  resolve: Fo
}, Bo = {
  tokenize: Uo,
  partial: !0
};
function Fo(e) {
  return gi(e), e;
}
function Ho(e, t) {
  let n;
  return r;
  function r(o) {
    return e.enter("content"), n = e.enter("chunkContent", {
      contentType: "content"
    }), u(o);
  }
  function u(o) {
    return o === null ? a(o) : H(o) ? e.check(
      Bo,
      i,
      a
    )(o) : (e.consume(o), u);
  }
  function a(o) {
    return e.exit("chunkContent"), e.exit("content"), t(o);
  }
  function i(o) {
    return e.consume(o), e.exit("chunkContent"), n.next = e.enter("chunkContent", {
      contentType: "content",
      previous: n
    }), n = n.next, u;
  }
}
function Uo(e, t, n) {
  const r = this;
  return u;
  function u(i) {
    return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), W(e, a, "linePrefix");
  }
  function a(i) {
    if (i === null || H(i))
      return n(i);
    const o = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && o && o[1].type === "linePrefix" && o[2].sliceSerialize(o[1], !0).length >= 4 ? t(i) : e.interrupt(r.parser.constructs.flow, n, t)(i);
  }
}
function bi(e, t, n, r, u, a, i, o, l) {
  const c = l || Number.POSITIVE_INFINITY;
  let h = 0;
  return f;
  function f(x) {
    return x === 60 ? (e.enter(r), e.enter(u), e.enter(a), e.consume(x), e.exit(a), p) : x === null || x === 32 || x === 41 || on(x) ? n(x) : (e.enter(r), e.enter(i), e.enter(o), e.enter("chunkString", {
      contentType: "string"
    }), C(x));
  }
  function p(x) {
    return x === 62 ? (e.enter(a), e.consume(x), e.exit(a), e.exit(u), e.exit(r), t) : (e.enter(o), e.enter("chunkString", {
      contentType: "string"
    }), d(x));
  }
  function d(x) {
    return x === 62 ? (e.exit("chunkString"), e.exit(o), p(x)) : x === null || x === 60 || H(x) ? n(x) : (e.consume(x), x === 92 ? A : d);
  }
  function A(x) {
    return x === 60 || x === 62 || x === 92 ? (e.consume(x), d) : d(x);
  }
  function C(x) {
    return !h && (x === null || x === 41 || J(x)) ? (e.exit("chunkString"), e.exit(o), e.exit(i), e.exit(r), t(x)) : h < c && x === 40 ? (e.consume(x), h++, C) : x === 41 ? (e.consume(x), h--, C) : x === null || x === 32 || x === 40 || on(x) ? n(x) : (e.consume(x), x === 92 ? L : C);
  }
  function L(x) {
    return x === 40 || x === 41 || x === 92 ? (e.consume(x), C) : C(x);
  }
}
function Ai(e, t, n, r, u, a) {
  const i = this;
  let o = 0, l;
  return c;
  function c(d) {
    return e.enter(r), e.enter(u), e.consume(d), e.exit(u), e.enter(a), h;
  }
  function h(d) {
    return o > 999 || d === null || d === 91 || d === 93 && !l || // To do: remove in the future once we’ve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesn’t need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    d === 94 && !o && "_hiddenFootnoteSupport" in i.parser.constructs ? n(d) : d === 93 ? (e.exit(a), e.enter(u), e.consume(d), e.exit(u), e.exit(r), t) : H(d) ? (e.enter("lineEnding"), e.consume(d), e.exit("lineEnding"), h) : (e.enter("chunkString", {
      contentType: "string"
    }), f(d));
  }
  function f(d) {
    return d === null || d === 91 || d === 93 || H(d) || o++ > 999 ? (e.exit("chunkString"), h(d)) : (e.consume(d), l || (l = !j(d)), d === 92 ? p : f);
  }
  function p(d) {
    return d === 91 || d === 92 || d === 93 ? (e.consume(d), o++, f) : f(d);
  }
}
function _i(e, t, n, r, u, a) {
  let i;
  return o;
  function o(p) {
    return p === 34 || p === 39 || p === 40 ? (e.enter(r), e.enter(u), e.consume(p), e.exit(u), i = p === 40 ? 41 : p, l) : n(p);
  }
  function l(p) {
    return p === i ? (e.enter(u), e.consume(p), e.exit(u), e.exit(r), t) : (e.enter(a), c(p));
  }
  function c(p) {
    return p === i ? (e.exit(a), l(i)) : p === null ? n(p) : H(p) ? (e.enter("lineEnding"), e.consume(p), e.exit("lineEnding"), W(e, c, "linePrefix")) : (e.enter("chunkString", {
      contentType: "string"
    }), h(p));
  }
  function h(p) {
    return p === i || p === null || H(p) ? (e.exit("chunkString"), c(p)) : (e.consume(p), p === 92 ? f : h);
  }
  function f(p) {
    return p === i || p === 92 ? (e.consume(p), h) : h(p);
  }
}
function Lt(e, t) {
  let n;
  return r;
  function r(u) {
    return H(u) ? (e.enter("lineEnding"), e.consume(u), e.exit("lineEnding"), n = !0, r) : j(u) ? W(e, r, n ? "linePrefix" : "lineSuffix")(u) : t(u);
  }
}
const vo = {
  name: "definition",
  tokenize: Yo
}, zo = {
  tokenize: qo,
  partial: !0
};
function Yo(e, t, n) {
  const r = this;
  let u;
  return a;
  function a(d) {
    return e.enter("definition"), i(d);
  }
  function i(d) {
    return Ai.call(
      r,
      e,
      o,
      // Note: we don’t need to reset the way `markdown-rs` does.
      n,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(d);
  }
  function o(d) {
    return u = ft(
      r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)
    ), d === 58 ? (e.enter("definitionMarker"), e.consume(d), e.exit("definitionMarker"), l) : n(d);
  }
  function l(d) {
    return J(d) ? Lt(e, c)(d) : c(d);
  }
  function c(d) {
    return bi(
      e,
      h,
      // Note: we don’t need to reset the way `markdown-rs` does.
      n,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(d);
  }
  function h(d) {
    return e.attempt(zo, f, f)(d);
  }
  function f(d) {
    return j(d) ? W(e, p, "whitespace")(d) : p(d);
  }
  function p(d) {
    return d === null || H(d) ? (e.exit("definition"), r.parser.defined.push(u), t(d)) : n(d);
  }
}
function qo(e, t, n) {
  return r;
  function r(o) {
    return J(o) ? Lt(e, u)(o) : n(o);
  }
  function u(o) {
    return _i(
      e,
      a,
      n,
      "definitionTitle",
      "definitionTitleMarker",
      "definitionTitleString"
    )(o);
  }
  function a(o) {
    return j(o) ? W(e, i, "whitespace")(o) : i(o);
  }
  function i(o) {
    return o === null || H(o) ? t(o) : n(o);
  }
}
const jo = {
  name: "hardBreakEscape",
  tokenize: Vo
};
function Vo(e, t, n) {
  return r;
  function r(a) {
    return e.enter("hardBreakEscape"), e.consume(a), u;
  }
  function u(a) {
    return H(a) ? (e.exit("hardBreakEscape"), t(a)) : n(a);
  }
}
const Wo = {
  name: "headingAtx",
  tokenize: Go,
  resolve: Qo
};
function Qo(e, t) {
  let n = e.length - 2, r = 3, u, a;
  return e[r][1].type === "whitespace" && (r += 2), n - 2 > r && e[n][1].type === "whitespace" && (n -= 2), e[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && e[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (u = {
    type: "atxHeadingText",
    start: e[r][1].start,
    end: e[n][1].end
  }, a = {
    type: "chunkText",
    start: e[r][1].start,
    end: e[n][1].end,
    contentType: "text"
  }, Oe(e, r, n - r + 1, [
    ["enter", u, t],
    ["enter", a, t],
    ["exit", a, t],
    ["exit", u, t]
  ])), e;
}
function Go(e, t, n) {
  let r = 0;
  return u;
  function u(h) {
    return e.enter("atxHeading"), a(h);
  }
  function a(h) {
    return e.enter("atxHeadingSequence"), i(h);
  }
  function i(h) {
    return h === 35 && r++ < 6 ? (e.consume(h), i) : h === null || J(h) ? (e.exit("atxHeadingSequence"), o(h)) : n(h);
  }
  function o(h) {
    return h === 35 ? (e.enter("atxHeadingSequence"), l(h)) : h === null || H(h) ? (e.exit("atxHeading"), t(h)) : j(h) ? W(e, o, "whitespace")(h) : (e.enter("atxHeadingText"), c(h));
  }
  function l(h) {
    return h === 35 ? (e.consume(h), l) : (e.exit("atxHeadingSequence"), o(h));
  }
  function c(h) {
    return h === null || h === 35 || J(h) ? (e.exit("atxHeadingText"), o(h)) : (e.consume(h), c);
  }
}
const Xo = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], tu = ["pre", "script", "style", "textarea"], Ko = {
  name: "htmlFlow",
  tokenize: el,
  resolveTo: Zo,
  concrete: !0
}, $o = {
  tokenize: nl,
  partial: !0
}, Jo = {
  tokenize: tl,
  partial: !0
};
function Zo(e) {
  let t = e.length;
  for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e;
}
function el(e, t, n) {
  const r = this;
  let u, a, i, o, l;
  return c;
  function c(b) {
    return h(b);
  }
  function h(b) {
    return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(b), f;
  }
  function f(b) {
    return b === 33 ? (e.consume(b), p) : b === 47 ? (e.consume(b), a = !0, C) : b === 63 ? (e.consume(b), u = 3, r.interrupt ? t : g) : de(b) ? (e.consume(b), i = String.fromCharCode(b), L) : n(b);
  }
  function p(b) {
    return b === 45 ? (e.consume(b), u = 2, d) : b === 91 ? (e.consume(b), u = 5, o = 0, A) : de(b) ? (e.consume(b), u = 4, r.interrupt ? t : g) : n(b);
  }
  function d(b) {
    return b === 45 ? (e.consume(b), r.interrupt ? t : g) : n(b);
  }
  function A(b) {
    const Ie = "CDATA[";
    return b === Ie.charCodeAt(o++) ? (e.consume(b), o === Ie.length ? r.interrupt ? t : F : A) : n(b);
  }
  function C(b) {
    return de(b) ? (e.consume(b), i = String.fromCharCode(b), L) : n(b);
  }
  function L(b) {
    if (b === null || b === 47 || b === 62 || J(b)) {
      const Ie = b === 47, Qe = i.toLowerCase();
      return !Ie && !a && tu.includes(Qe) ? (u = 1, r.interrupt ? t(b) : F(b)) : Xo.includes(i.toLowerCase()) ? (u = 6, Ie ? (e.consume(b), x) : r.interrupt ? t(b) : F(b)) : (u = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(b) : a ? w(b) : D(b));
    }
    return b === 45 || fe(b) ? (e.consume(b), i += String.fromCharCode(b), L) : n(b);
  }
  function x(b) {
    return b === 62 ? (e.consume(b), r.interrupt ? t : F) : n(b);
  }
  function w(b) {
    return j(b) ? (e.consume(b), w) : S(b);
  }
  function D(b) {
    return b === 47 ? (e.consume(b), S) : b === 58 || b === 95 || de(b) ? (e.consume(b), z) : j(b) ? (e.consume(b), D) : S(b);
  }
  function z(b) {
    return b === 45 || b === 46 || b === 58 || b === 95 || fe(b) ? (e.consume(b), z) : Y(b);
  }
  function Y(b) {
    return b === 61 ? (e.consume(b), k) : j(b) ? (e.consume(b), Y) : D(b);
  }
  function k(b) {
    return b === null || b === 60 || b === 61 || b === 62 || b === 96 ? n(b) : b === 34 || b === 39 ? (e.consume(b), l = b, Q) : j(b) ? (e.consume(b), k) : ee(b);
  }
  function Q(b) {
    return b === l ? (e.consume(b), l = null, X) : b === null || H(b) ? n(b) : (e.consume(b), Q);
  }
  function ee(b) {
    return b === null || b === 34 || b === 39 || b === 47 || b === 60 || b === 61 || b === 62 || b === 96 || J(b) ? Y(b) : (e.consume(b), ee);
  }
  function X(b) {
    return b === 47 || b === 62 || j(b) ? D(b) : n(b);
  }
  function S(b) {
    return b === 62 ? (e.consume(b), B) : n(b);
  }
  function B(b) {
    return b === null || H(b) ? F(b) : j(b) ? (e.consume(b), B) : n(b);
  }
  function F(b) {
    return b === 45 && u === 2 ? (e.consume(b), ce) : b === 60 && u === 1 ? (e.consume(b), oe) : b === 62 && u === 4 ? (e.consume(b), Ce) : b === 63 && u === 3 ? (e.consume(b), g) : b === 93 && u === 5 ? (e.consume(b), Le) : H(b) && (u === 6 || u === 7) ? (e.exit("htmlFlowData"), e.check(
      $o,
      Re,
      $
    )(b)) : b === null || H(b) ? (e.exit("htmlFlowData"), $(b)) : (e.consume(b), F);
  }
  function $(b) {
    return e.check(
      Jo,
      ne,
      Re
    )(b);
  }
  function ne(b) {
    return e.enter("lineEnding"), e.consume(b), e.exit("lineEnding"), G;
  }
  function G(b) {
    return b === null || H(b) ? $(b) : (e.enter("htmlFlowData"), F(b));
  }
  function ce(b) {
    return b === 45 ? (e.consume(b), g) : F(b);
  }
  function oe(b) {
    return b === 47 ? (e.consume(b), i = "", _e) : F(b);
  }
  function _e(b) {
    if (b === 62) {
      const Ie = i.toLowerCase();
      return tu.includes(Ie) ? (e.consume(b), Ce) : F(b);
    }
    return de(b) && i.length < 8 ? (e.consume(b), i += String.fromCharCode(b), _e) : F(b);
  }
  function Le(b) {
    return b === 93 ? (e.consume(b), g) : F(b);
  }
  function g(b) {
    return b === 62 ? (e.consume(b), Ce) : b === 45 && u === 2 ? (e.consume(b), g) : F(b);
  }
  function Ce(b) {
    return b === null || H(b) ? (e.exit("htmlFlowData"), Re(b)) : (e.consume(b), Ce);
  }
  function Re(b) {
    return e.exit("htmlFlow"), t(b);
  }
}
function tl(e, t, n) {
  const r = this;
  return u;
  function u(i) {
    return H(i) ? (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), a) : n(i);
  }
  function a(i) {
    return r.parser.lazy[r.now().line] ? n(i) : t(i);
  }
}
function nl(e, t, n) {
  return r;
  function r(u) {
    return e.enter("lineEnding"), e.consume(u), e.exit("lineEnding"), e.attempt(An, t, n);
  }
}
const rl = {
  name: "htmlText",
  tokenize: ul
};
function ul(e, t, n) {
  const r = this;
  let u, a, i;
  return o;
  function o(g) {
    return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(g), l;
  }
  function l(g) {
    return g === 33 ? (e.consume(g), c) : g === 47 ? (e.consume(g), Y) : g === 63 ? (e.consume(g), D) : de(g) ? (e.consume(g), ee) : n(g);
  }
  function c(g) {
    return g === 45 ? (e.consume(g), h) : g === 91 ? (e.consume(g), a = 0, A) : de(g) ? (e.consume(g), w) : n(g);
  }
  function h(g) {
    return g === 45 ? (e.consume(g), d) : n(g);
  }
  function f(g) {
    return g === null ? n(g) : g === 45 ? (e.consume(g), p) : H(g) ? (i = f, oe(g)) : (e.consume(g), f);
  }
  function p(g) {
    return g === 45 ? (e.consume(g), d) : f(g);
  }
  function d(g) {
    return g === 62 ? ce(g) : g === 45 ? p(g) : f(g);
  }
  function A(g) {
    const Ce = "CDATA[";
    return g === Ce.charCodeAt(a++) ? (e.consume(g), a === Ce.length ? C : A) : n(g);
  }
  function C(g) {
    return g === null ? n(g) : g === 93 ? (e.consume(g), L) : H(g) ? (i = C, oe(g)) : (e.consume(g), C);
  }
  function L(g) {
    return g === 93 ? (e.consume(g), x) : C(g);
  }
  function x(g) {
    return g === 62 ? ce(g) : g === 93 ? (e.consume(g), x) : C(g);
  }
  function w(g) {
    return g === null || g === 62 ? ce(g) : H(g) ? (i = w, oe(g)) : (e.consume(g), w);
  }
  function D(g) {
    return g === null ? n(g) : g === 63 ? (e.consume(g), z) : H(g) ? (i = D, oe(g)) : (e.consume(g), D);
  }
  function z(g) {
    return g === 62 ? ce(g) : D(g);
  }
  function Y(g) {
    return de(g) ? (e.consume(g), k) : n(g);
  }
  function k(g) {
    return g === 45 || fe(g) ? (e.consume(g), k) : Q(g);
  }
  function Q(g) {
    return H(g) ? (i = Q, oe(g)) : j(g) ? (e.consume(g), Q) : ce(g);
  }
  function ee(g) {
    return g === 45 || fe(g) ? (e.consume(g), ee) : g === 47 || g === 62 || J(g) ? X(g) : n(g);
  }
  function X(g) {
    return g === 47 ? (e.consume(g), ce) : g === 58 || g === 95 || de(g) ? (e.consume(g), S) : H(g) ? (i = X, oe(g)) : j(g) ? (e.consume(g), X) : ce(g);
  }
  function S(g) {
    return g === 45 || g === 46 || g === 58 || g === 95 || fe(g) ? (e.consume(g), S) : B(g);
  }
  function B(g) {
    return g === 61 ? (e.consume(g), F) : H(g) ? (i = B, oe(g)) : j(g) ? (e.consume(g), B) : X(g);
  }
  function F(g) {
    return g === null || g === 60 || g === 61 || g === 62 || g === 96 ? n(g) : g === 34 || g === 39 ? (e.consume(g), u = g, $) : H(g) ? (i = F, oe(g)) : j(g) ? (e.consume(g), F) : (e.consume(g), ne);
  }
  function $(g) {
    return g === u ? (e.consume(g), u = void 0, G) : g === null ? n(g) : H(g) ? (i = $, oe(g)) : (e.consume(g), $);
  }
  function ne(g) {
    return g === null || g === 34 || g === 39 || g === 60 || g === 61 || g === 96 ? n(g) : g === 47 || g === 62 || J(g) ? X(g) : (e.consume(g), ne);
  }
  function G(g) {
    return g === 47 || g === 62 || J(g) ? X(g) : n(g);
  }
  function ce(g) {
    return g === 62 ? (e.consume(g), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(g);
  }
  function oe(g) {
    return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(g), e.exit("lineEnding"), _e;
  }
  function _e(g) {
    return j(g) ? W(
      e,
      Le,
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(g) : Le(g);
  }
  function Le(g) {
    return e.enter("htmlTextData"), i(g);
  }
}
const Tr = {
  name: "labelEnd",
  tokenize: cl,
  resolveTo: ll,
  resolveAll: ol
}, il = {
  tokenize: fl
}, al = {
  tokenize: hl
}, sl = {
  tokenize: dl
};
function ol(e) {
  let t = -1;
  for (; ++t < e.length; ) {
    const n = e[t][1];
    (n.type === "labelImage" || n.type === "labelLink" || n.type === "labelEnd") && (e.splice(t + 1, n.type === "labelImage" ? 4 : 2), n.type = "data", t++);
  }
  return e;
}
function ll(e, t) {
  let n = e.length, r = 0, u, a, i, o;
  for (; n--; )
    if (u = e[n][1], a) {
      if (u.type === "link" || u.type === "labelLink" && u._inactive)
        break;
      e[n][0] === "enter" && u.type === "labelLink" && (u._inactive = !0);
    } else if (i) {
      if (e[n][0] === "enter" && (u.type === "labelImage" || u.type === "labelLink") && !u._balanced && (a = n, u.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else u.type === "labelEnd" && (i = n);
  const l = {
    type: e[a][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, e[a][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, c = {
    type: "label",
    start: Object.assign({}, e[a][1].start),
    end: Object.assign({}, e[i][1].end)
  }, h = {
    type: "labelText",
    start: Object.assign({}, e[a + r + 2][1].end),
    end: Object.assign({}, e[i - 2][1].start)
  };
  return o = [
    ["enter", l, t],
    ["enter", c, t]
  ], o = ge(o, e.slice(a + 1, a + r + 3)), o = ge(o, [["enter", h, t]]), o = ge(
    o,
    Er(
      t.parser.constructs.insideSpan.null,
      e.slice(a + r + 4, i - 3),
      t
    )
  ), o = ge(o, [
    ["exit", h, t],
    e[i - 2],
    e[i - 1],
    ["exit", c, t]
  ]), o = ge(o, e.slice(i + 1)), o = ge(o, [["exit", l, t]]), Oe(e, a, e.length, o), e;
}
function cl(e, t, n) {
  const r = this;
  let u = r.events.length, a, i;
  for (; u--; )
    if ((r.events[u][1].type === "labelImage" || r.events[u][1].type === "labelLink") && !r.events[u][1]._balanced) {
      a = r.events[u][1];
      break;
    }
  return o;
  function o(p) {
    return a ? a._inactive ? f(p) : (i = r.parser.defined.includes(
      ft(
        r.sliceSerialize({
          start: a.end,
          end: r.now()
        })
      )
    ), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(p), e.exit("labelMarker"), e.exit("labelEnd"), l) : n(p);
  }
  function l(p) {
    return p === 40 ? e.attempt(
      il,
      h,
      i ? h : f
    )(p) : p === 91 ? e.attempt(
      al,
      h,
      i ? c : f
    )(p) : i ? h(p) : f(p);
  }
  function c(p) {
    return e.attempt(
      sl,
      h,
      f
    )(p);
  }
  function h(p) {
    return t(p);
  }
  function f(p) {
    return a._balanced = !0, n(p);
  }
}
function fl(e, t, n) {
  return r;
  function r(f) {
    return e.enter("resource"), e.enter("resourceMarker"), e.consume(f), e.exit("resourceMarker"), u;
  }
  function u(f) {
    return J(f) ? Lt(e, a)(f) : a(f);
  }
  function a(f) {
    return f === 41 ? h(f) : bi(
      e,
      i,
      o,
      "resourceDestination",
      "resourceDestinationLiteral",
      "resourceDestinationLiteralMarker",
      "resourceDestinationRaw",
      "resourceDestinationString",
      32
    )(f);
  }
  function i(f) {
    return J(f) ? Lt(e, l)(f) : h(f);
  }
  function o(f) {
    return n(f);
  }
  function l(f) {
    return f === 34 || f === 39 || f === 40 ? _i(
      e,
      c,
      n,
      "resourceTitle",
      "resourceTitleMarker",
      "resourceTitleString"
    )(f) : h(f);
  }
  function c(f) {
    return J(f) ? Lt(e, h)(f) : h(f);
  }
  function h(f) {
    return f === 41 ? (e.enter("resourceMarker"), e.consume(f), e.exit("resourceMarker"), e.exit("resource"), t) : n(f);
  }
}
function hl(e, t, n) {
  const r = this;
  return u;
  function u(o) {
    return Ai.call(
      r,
      e,
      a,
      i,
      "reference",
      "referenceMarker",
      "referenceString"
    )(o);
  }
  function a(o) {
    return r.parser.defined.includes(
      ft(
        r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)
      )
    ) ? t(o) : n(o);
  }
  function i(o) {
    return n(o);
  }
}
function dl(e, t, n) {
  return r;
  function r(a) {
    return e.enter("reference"), e.enter("referenceMarker"), e.consume(a), e.exit("referenceMarker"), u;
  }
  function u(a) {
    return a === 93 ? (e.enter("referenceMarker"), e.consume(a), e.exit("referenceMarker"), e.exit("reference"), t) : n(a);
  }
}
const ml = {
  name: "labelStartImage",
  tokenize: pl,
  resolveAll: Tr.resolveAll
};
function pl(e, t, n) {
  const r = this;
  return u;
  function u(o) {
    return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(o), e.exit("labelImageMarker"), a;
  }
  function a(o) {
    return o === 91 ? (e.enter("labelMarker"), e.consume(o), e.exit("labelMarker"), e.exit("labelImage"), i) : n(o);
  }
  function i(o) {
    return o === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(o) : t(o);
  }
}
const El = {
  name: "labelStartLink",
  tokenize: Tl,
  resolveAll: Tr.resolveAll
};
function Tl(e, t, n) {
  const r = this;
  return u;
  function u(i) {
    return e.enter("labelLink"), e.enter("labelMarker"), e.consume(i), e.exit("labelMarker"), e.exit("labelLink"), a;
  }
  function a(i) {
    return i === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(i) : t(i);
  }
}
const Dn = {
  name: "lineEnding",
  tokenize: gl
};
function gl(e, t) {
  return n;
  function n(r) {
    return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), W(e, t, "linePrefix");
  }
}
const nn = {
  name: "thematicBreak",
  tokenize: bl
};
function bl(e, t, n) {
  let r = 0, u;
  return a;
  function a(c) {
    return e.enter("thematicBreak"), i(c);
  }
  function i(c) {
    return u = c, o(c);
  }
  function o(c) {
    return c === u ? (e.enter("thematicBreakSequence"), l(c)) : r >= 3 && (c === null || H(c)) ? (e.exit("thematicBreak"), t(c)) : n(c);
  }
  function l(c) {
    return c === u ? (e.consume(c), r++, l) : (e.exit("thematicBreakSequence"), j(c) ? W(e, o, "whitespace")(c) : o(c));
  }
}
const pe = {
  name: "list",
  tokenize: Cl,
  continuation: {
    tokenize: Il
  },
  exit: Sl
}, Al = {
  tokenize: Nl,
  partial: !0
}, _l = {
  tokenize: xl,
  partial: !0
};
function Cl(e, t, n) {
  const r = this, u = r.events[r.events.length - 1];
  let a = u && u[1].type === "linePrefix" ? u[2].sliceSerialize(u[1], !0).length : 0, i = 0;
  return o;
  function o(d) {
    const A = r.containerState.type || (d === 42 || d === 43 || d === 45 ? "listUnordered" : "listOrdered");
    if (A === "listUnordered" ? !r.containerState.marker || d === r.containerState.marker : Kn(d)) {
      if (r.containerState.type || (r.containerState.type = A, e.enter(A, {
        _container: !0
      })), A === "listUnordered")
        return e.enter("listItemPrefix"), d === 42 || d === 45 ? e.check(nn, n, c)(d) : c(d);
      if (!r.interrupt || d === 49)
        return e.enter("listItemPrefix"), e.enter("listItemValue"), l(d);
    }
    return n(d);
  }
  function l(d) {
    return Kn(d) && ++i < 10 ? (e.consume(d), l) : (!r.interrupt || i < 2) && (r.containerState.marker ? d === r.containerState.marker : d === 41 || d === 46) ? (e.exit("listItemValue"), c(d)) : n(d);
  }
  function c(d) {
    return e.enter("listItemMarker"), e.consume(d), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || d, e.check(
      An,
      // Can’t be empty when interrupting.
      r.interrupt ? n : h,
      e.attempt(
        Al,
        p,
        f
      )
    );
  }
  function h(d) {
    return r.containerState.initialBlankLine = !0, a++, p(d);
  }
  function f(d) {
    return j(d) ? (e.enter("listItemPrefixWhitespace"), e.consume(d), e.exit("listItemPrefixWhitespace"), p) : n(d);
  }
  function p(d) {
    return r.containerState.size = a + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(d);
  }
}
function Il(e, t, n) {
  const r = this;
  return r.containerState._closeFlow = void 0, e.check(An, u, a);
  function u(o) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, W(
      e,
      t,
      "listItemIndent",
      r.containerState.size + 1
    )(o);
  }
  function a(o) {
    return r.containerState.furtherBlankLines || !j(o) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, i(o)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt(_l, t, i)(o));
  }
  function i(o) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, W(
      e,
      e.attempt(pe, t, n),
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(o);
  }
}
function xl(e, t, n) {
  const r = this;
  return W(
    e,
    u,
    "listItemIndent",
    r.containerState.size + 1
  );
  function u(a) {
    const i = r.events[r.events.length - 1];
    return i && i[1].type === "listItemIndent" && i[2].sliceSerialize(i[1], !0).length === r.containerState.size ? t(a) : n(a);
  }
}
function Sl(e) {
  e.exit(this.containerState.type);
}
function Nl(e, t, n) {
  const r = this;
  return W(
    e,
    u,
    "listItemPrefixWhitespace",
    r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5
  );
  function u(a) {
    const i = r.events[r.events.length - 1];
    return !j(a) && i && i[1].type === "listItemPrefixWhitespace" ? t(a) : n(a);
  }
}
const nu = {
  name: "setextUnderline",
  tokenize: Ol,
  resolveTo: kl
};
function kl(e, t) {
  let n = e.length, r, u, a;
  for (; n--; )
    if (e[n][0] === "enter") {
      if (e[n][1].type === "content") {
        r = n;
        break;
      }
      e[n][1].type === "paragraph" && (u = n);
    } else
      e[n][1].type === "content" && e.splice(n, 1), !a && e[n][1].type === "definition" && (a = n);
  const i = {
    type: "setextHeading",
    start: Object.assign({}, e[u][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  };
  return e[u][1].type = "setextHeadingText", a ? (e.splice(u, 0, ["enter", i, t]), e.splice(a + 1, 0, ["exit", e[r][1], t]), e[r][1].end = Object.assign({}, e[a][1].end)) : e[r][1] = i, e.push(["exit", i, t]), e;
}
function Ol(e, t, n) {
  const r = this;
  let u;
  return a;
  function a(c) {
    let h = r.events.length, f;
    for (; h--; )
      if (r.events[h][1].type !== "lineEnding" && r.events[h][1].type !== "linePrefix" && r.events[h][1].type !== "content") {
        f = r.events[h][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || f) ? (e.enter("setextHeadingLine"), u = c, i(c)) : n(c);
  }
  function i(c) {
    return e.enter("setextHeadingLineSequence"), o(c);
  }
  function o(c) {
    return c === u ? (e.consume(c), o) : (e.exit("setextHeadingLineSequence"), j(c) ? W(e, l, "lineSuffix")(c) : l(c));
  }
  function l(c) {
    return c === null || H(c) ? (e.exit("setextHeadingLine"), t(c)) : n(c);
  }
}
const yl = {
  tokenize: Ll
};
function Ll(e) {
  const t = this, n = e.attempt(
    // Try to parse a blank line.
    An,
    r,
    // Try to parse initial flow (essentially, only code).
    e.attempt(
      this.parser.constructs.flowInitial,
      u,
      W(
        e,
        e.attempt(
          this.parser.constructs.flow,
          u,
          e.attempt(Mo, u)
        ),
        "linePrefix"
      )
    )
  );
  return n;
  function r(a) {
    if (a === null) {
      e.consume(a);
      return;
    }
    return e.enter("lineEndingBlank"), e.consume(a), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n;
  }
  function u(a) {
    if (a === null) {
      e.consume(a);
      return;
    }
    return e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), t.currentConstruct = void 0, n;
  }
}
const Rl = {
  resolveAll: Ii()
}, Dl = Ci("string"), Pl = Ci("text");
function Ci(e) {
  return {
    tokenize: t,
    resolveAll: Ii(
      e === "text" ? wl : void 0
    )
  };
  function t(n) {
    const r = this, u = this.parser.constructs[e], a = n.attempt(u, i, o);
    return i;
    function i(h) {
      return c(h) ? a(h) : o(h);
    }
    function o(h) {
      if (h === null) {
        n.consume(h);
        return;
      }
      return n.enter("data"), n.consume(h), l;
    }
    function l(h) {
      return c(h) ? (n.exit("data"), a(h)) : (n.consume(h), l);
    }
    function c(h) {
      if (h === null)
        return !0;
      const f = u[h];
      let p = -1;
      if (f)
        for (; ++p < f.length; ) {
          const d = f[p];
          if (!d.previous || d.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function Ii(e) {
  return t;
  function t(n, r) {
    let u = -1, a;
    for (; ++u <= n.length; )
      a === void 0 ? n[u] && n[u][1].type === "data" && (a = u, u++) : (!n[u] || n[u][1].type !== "data") && (u !== a + 2 && (n[a][1].end = n[u - 1][1].end, n.splice(a + 2, u - a - 2), u = a + 2), a = void 0);
    return e ? e(n, r) : n;
  }
}
function wl(e, t) {
  let n = 0;
  for (; ++n <= e.length; )
    if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") {
      const r = e[n - 1][1], u = t.sliceStream(r);
      let a = u.length, i = -1, o = 0, l;
      for (; a--; ) {
        const c = u[a];
        if (typeof c == "string") {
          for (i = c.length; c.charCodeAt(i - 1) === 32; )
            o++, i--;
          if (i) break;
          i = -1;
        } else if (c === -2)
          l = !0, o++;
        else if (c !== -1) {
          a++;
          break;
        }
      }
      if (o) {
        const c = {
          type: n === e.length || l || o < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: r.end.line,
            column: r.end.column - o,
            offset: r.end.offset - o,
            _index: r.start._index + a,
            _bufferIndex: a ? i : r.start._bufferIndex + i
          },
          end: Object.assign({}, r.end)
        };
        r.end = Object.assign({}, c.start), r.start.offset === r.end.offset ? Object.assign(r, c) : (e.splice(
          n,
          0,
          ["enter", c, t],
          ["exit", c, t]
        ), n += 2);
      }
      n++;
    }
  return e;
}
function Ml(e, t, n) {
  let r = Object.assign(
    n ? Object.assign({}, n) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  const u = {}, a = [];
  let i = [], o = [];
  const l = {
    consume: w,
    enter: D,
    exit: z,
    attempt: Q(Y),
    check: Q(k),
    interrupt: Q(k, {
      interrupt: !0
    })
  }, c = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser: e,
    sliceStream: d,
    sliceSerialize: p,
    now: A,
    defineSkip: C,
    write: f
  };
  let h = t.tokenize.call(c, l);
  return t.resolveAll && a.push(t), c;
  function f(B) {
    return i = ge(i, B), L(), i[i.length - 1] !== null ? [] : (ee(t, 0), c.events = Er(a, c.events, c), c.events);
  }
  function p(B, F) {
    return Fl(d(B), F);
  }
  function d(B) {
    return Bl(i, B);
  }
  function A() {
    const { line: B, column: F, offset: $, _index: ne, _bufferIndex: G } = r;
    return {
      line: B,
      column: F,
      offset: $,
      _index: ne,
      _bufferIndex: G
    };
  }
  function C(B) {
    u[B.line] = B.column, S();
  }
  function L() {
    let B;
    for (; r._index < i.length; ) {
      const F = i[r._index];
      if (typeof F == "string")
        for (B = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === B && r._bufferIndex < F.length; )
          x(F.charCodeAt(r._bufferIndex));
      else
        x(F);
    }
  }
  function x(B) {
    h = h(B);
  }
  function w(B) {
    H(B) ? (r.line++, r.column = 1, r.offset += B === -3 ? 2 : 1, S()) : B !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === i[r._index].length && (r._bufferIndex = -1, r._index++)), c.previous = B;
  }
  function D(B, F) {
    const $ = F || {};
    return $.type = B, $.start = A(), c.events.push(["enter", $, c]), o.push($), $;
  }
  function z(B) {
    const F = o.pop();
    return F.end = A(), c.events.push(["exit", F, c]), F;
  }
  function Y(B, F) {
    ee(B, F.from);
  }
  function k(B, F) {
    F.restore();
  }
  function Q(B, F) {
    return $;
    function $(ne, G, ce) {
      let oe, _e, Le, g;
      return Array.isArray(ne) ? Re(ne) : "tokenize" in ne ? (
        // @ts-expect-error Looks like a construct.
        Re([ne])
      ) : Ce(ne);
      function Ce(le) {
        return _t;
        function _t(Fe) {
          const it = Fe !== null && le[Fe], Ge = Fe !== null && le.null, On = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(it) ? it : it ? [it] : [],
            ...Array.isArray(Ge) ? Ge : Ge ? [Ge] : []
          ];
          return Re(On)(Fe);
        }
      }
      function Re(le) {
        return oe = le, _e = 0, le.length === 0 ? ce : b(le[_e]);
      }
      function b(le) {
        return _t;
        function _t(Fe) {
          return g = X(), Le = le, le.partial || (c.currentConstruct = le), le.name && c.parser.constructs.disable.null.includes(le.name) ? Qe() : le.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a “live binding”, which is needed for `interrupt`.
            F ? Object.assign(Object.create(c), F) : c,
            l,
            Ie,
            Qe
          )(Fe);
        }
      }
      function Ie(le) {
        return B(Le, g), G;
      }
      function Qe(le) {
        return g.restore(), ++_e < oe.length ? b(oe[_e]) : ce;
      }
    }
  }
  function ee(B, F) {
    B.resolveAll && !a.includes(B) && a.push(B), B.resolve && Oe(
      c.events,
      F,
      c.events.length - F,
      B.resolve(c.events.slice(F), c)
    ), B.resolveTo && (c.events = B.resolveTo(c.events, c));
  }
  function X() {
    const B = A(), F = c.previous, $ = c.currentConstruct, ne = c.events.length, G = Array.from(o);
    return {
      restore: ce,
      from: ne
    };
    function ce() {
      r = B, c.previous = F, c.currentConstruct = $, c.events.length = ne, o = G, S();
    }
  }
  function S() {
    r.line in u && r.column < 2 && (r.column = u[r.line], r.offset += u[r.line] - 1);
  }
}
function Bl(e, t) {
  const n = t.start._index, r = t.start._bufferIndex, u = t.end._index, a = t.end._bufferIndex;
  let i;
  if (n === u)
    i = [e[n].slice(r, a)];
  else {
    if (i = e.slice(n, u), r > -1) {
      const o = i[0];
      typeof o == "string" ? i[0] = o.slice(r) : i.shift();
    }
    a > 0 && i.push(e[u].slice(0, a));
  }
  return i;
}
function Fl(e, t) {
  let n = -1;
  const r = [];
  let u;
  for (; ++n < e.length; ) {
    const a = e[n];
    let i;
    if (typeof a == "string")
      i = a;
    else
      switch (a) {
        case -5: {
          i = "\r";
          break;
        }
        case -4: {
          i = `
`;
          break;
        }
        case -3: {
          i = `\r
`;
          break;
        }
        case -2: {
          i = t ? " " : "	";
          break;
        }
        case -1: {
          if (!t && u) continue;
          i = " ";
          break;
        }
        default:
          i = String.fromCharCode(a);
      }
    u = a === -2, r.push(i);
  }
  return r.join("");
}
const Hl = {
  42: pe,
  43: pe,
  45: pe,
  48: pe,
  49: pe,
  50: pe,
  51: pe,
  52: pe,
  53: pe,
  54: pe,
  55: pe,
  56: pe,
  57: pe,
  62: pi
}, Ul = {
  91: vo
}, vl = {
  [-2]: Rn,
  [-1]: Rn,
  32: Rn
}, zl = {
  35: Wo,
  42: nn,
  45: [nu, nn],
  60: Ko,
  61: nu,
  95: nn,
  96: eu,
  126: eu
}, Yl = {
  38: Ti,
  92: Ei
}, ql = {
  [-5]: Dn,
  [-4]: Dn,
  [-3]: Dn,
  33: ml,
  38: Ti,
  42: $n,
  60: [To, rl],
  91: El,
  92: [jo, Ei],
  93: Tr,
  95: $n,
  96: Lo
}, jl = {
  null: [$n, Rl]
}, Vl = {
  null: [42, 95]
}, Wl = {
  null: []
}, Ql = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: Vl,
  contentInitial: Ul,
  disable: Wl,
  document: Hl,
  flow: zl,
  flowInitial: vl,
  insideSpan: jl,
  string: Yl,
  text: ql
}, Symbol.toStringTag, { value: "Module" }));
function Gl(e) {
  const n = (
    /** @type {FullNormalizedExtension} */
    ro([Ql, ...(e || {}).extensions || []])
  ), r = {
    defined: [],
    lazy: {},
    constructs: n,
    content: u(lo),
    document: u(fo),
    flow: u(yl),
    string: u(Dl),
    text: u(Pl)
  };
  return r;
  function u(a) {
    return i;
    function i(o) {
      return Ml(r, a, o);
    }
  }
}
function Xl(e) {
  for (; !gi(e); )
    ;
  return e;
}
const ru = /[\0\t\n\r]/g;
function Kl() {
  let e = 1, t = "", n = !0, r;
  return u;
  function u(a, i, o) {
    const l = [];
    let c, h, f, p, d;
    for (a = t + (typeof a == "string" ? a.toString() : new TextDecoder(i || void 0).decode(a)), f = 0, t = "", n && (a.charCodeAt(0) === 65279 && f++, n = void 0); f < a.length; ) {
      if (ru.lastIndex = f, c = ru.exec(a), p = c && c.index !== void 0 ? c.index : a.length, d = a.charCodeAt(p), !c) {
        t = a.slice(f);
        break;
      }
      if (d === 10 && f === p && r)
        l.push(-3), r = void 0;
      else
        switch (r && (l.push(-5), r = void 0), f < p && (l.push(a.slice(f, p)), e += p - f), d) {
          case 0: {
            l.push(65533), e++;
            break;
          }
          case 9: {
            for (h = Math.ceil(e / 4) * 4, l.push(-2); e++ < h; ) l.push(-1);
            break;
          }
          case 10: {
            l.push(-4), e = 1;
            break;
          }
          default:
            r = !0, e = 1;
        }
      f = p + 1;
    }
    return o && (r && l.push(-5), t && l.push(t), l.push(null)), l;
  }
}
const $l = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function Jl(e) {
  return e.replace($l, Zl);
}
function Zl(e, t, n) {
  if (t)
    return t;
  if (n.charCodeAt(0) === 35) {
    const u = n.charCodeAt(1), a = u === 120 || u === 88;
    return mi(n.slice(a ? 2 : 1), a ? 16 : 10);
  }
  return pr(n) || e;
}
const xi = {}.hasOwnProperty;
function ec(e, t, n) {
  return typeof t != "string" && (n = t, t = void 0), tc(n)(
    Xl(
      Gl(n).document().write(Kl()(e, t, !0))
    )
  );
}
function tc(e) {
  const t = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: a(Yr),
      autolinkProtocol: X,
      autolinkEmail: X,
      atxHeading: a(Ur),
      blockQuote: a(it),
      characterEscape: X,
      characterReference: X,
      codeFenced: a(Ge),
      codeFencedFenceInfo: i,
      codeFencedFenceMeta: i,
      codeIndented: a(Ge, i),
      codeText: a(On, i),
      codeTextData: X,
      data: X,
      codeFlowValue: X,
      definition: a(os),
      definitionDestinationString: i,
      definitionLabelString: i,
      definitionTitleString: i,
      emphasis: a(ls),
      hardBreakEscape: a(vr),
      hardBreakTrailing: a(vr),
      htmlFlow: a(zr, i),
      htmlFlowData: X,
      htmlText: a(zr, i),
      htmlTextData: X,
      image: a(cs),
      label: i,
      link: a(Yr),
      listItem: a(fs),
      listItemValue: p,
      listOrdered: a(qr, f),
      listUnordered: a(qr),
      paragraph: a(hs),
      reference: b,
      referenceString: i,
      resourceDestinationString: i,
      resourceTitleString: i,
      setextHeading: a(Ur),
      strong: a(ds),
      thematicBreak: a(ps)
    },
    exit: {
      atxHeading: l(),
      atxHeadingSequence: Y,
      autolink: l(),
      autolinkEmail: Fe,
      autolinkProtocol: _t,
      blockQuote: l(),
      characterEscapeValue: S,
      characterReferenceMarkerHexadecimal: Qe,
      characterReferenceMarkerNumeric: Qe,
      characterReferenceValue: le,
      codeFenced: l(L),
      codeFencedFence: C,
      codeFencedFenceInfo: d,
      codeFencedFenceMeta: A,
      codeFlowValue: S,
      codeIndented: l(x),
      codeText: l(G),
      codeTextData: S,
      data: S,
      definition: l(),
      definitionDestinationString: z,
      definitionLabelString: w,
      definitionTitleString: D,
      emphasis: l(),
      hardBreakEscape: l(F),
      hardBreakTrailing: l(F),
      htmlFlow: l($),
      htmlFlowData: S,
      htmlText: l(ne),
      htmlTextData: S,
      image: l(oe),
      label: Le,
      labelText: _e,
      lineEnding: B,
      link: l(ce),
      listItem: l(),
      listOrdered: l(),
      listUnordered: l(),
      paragraph: l(),
      referenceString: Ie,
      resourceDestinationString: g,
      resourceTitleString: Ce,
      resource: Re,
      setextHeading: l(ee),
      setextHeadingLineSequence: Q,
      setextHeadingText: k,
      strong: l(),
      thematicBreak: l()
    }
  };
  Si(t, (e || {}).mdastExtensions || []);
  const n = {};
  return r;
  function r(N) {
    let M = {
      type: "root",
      children: []
    };
    const U = {
      stack: [M],
      tokenStack: [],
      config: t,
      enter: o,
      exit: c,
      buffer: i,
      resume: h,
      data: n
    }, V = [];
    let K = -1;
    for (; ++K < N.length; )
      if (N[K][1].type === "listOrdered" || N[K][1].type === "listUnordered")
        if (N[K][0] === "enter")
          V.push(K);
        else {
          const xe = V.pop();
          K = u(N, xe, K);
        }
    for (K = -1; ++K < N.length; ) {
      const xe = t[N[K][0]];
      xi.call(xe, N[K][1].type) && xe[N[K][1].type].call(
        Object.assign(
          {
            sliceSerialize: N[K][2].sliceSerialize
          },
          U
        ),
        N[K][1]
      );
    }
    if (U.tokenStack.length > 0) {
      const xe = U.tokenStack[U.tokenStack.length - 1];
      (xe[1] || uu).call(U, void 0, xe[0]);
    }
    for (M.position = {
      start: He(
        N.length > 0 ? N[0][1].start : {
          line: 1,
          column: 1,
          offset: 0
        }
      ),
      end: He(
        N.length > 0 ? N[N.length - 2][1].end : {
          line: 1,
          column: 1,
          offset: 0
        }
      )
    }, K = -1; ++K < t.transforms.length; )
      M = t.transforms[K](M) || M;
    return M;
  }
  function u(N, M, U) {
    let V = M - 1, K = -1, xe = !1, Xe, De, Ct, It;
    for (; ++V <= U; ) {
      const Ee = N[V];
      switch (Ee[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          Ee[0] === "enter" ? K++ : K--, It = void 0;
          break;
        }
        case "lineEndingBlank": {
          Ee[0] === "enter" && (Xe && !It && !K && !Ct && (Ct = V), It = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          It = void 0;
      }
      if (!K && Ee[0] === "enter" && Ee[1].type === "listItemPrefix" || K === -1 && Ee[0] === "exit" && (Ee[1].type === "listUnordered" || Ee[1].type === "listOrdered")) {
        if (Xe) {
          let at = V;
          for (De = void 0; at--; ) {
            const Pe = N[at];
            if (Pe[1].type === "lineEnding" || Pe[1].type === "lineEndingBlank") {
              if (Pe[0] === "exit") continue;
              De && (N[De][1].type = "lineEndingBlank", xe = !0), Pe[1].type = "lineEnding", De = at;
            } else if (!(Pe[1].type === "linePrefix" || Pe[1].type === "blockQuotePrefix" || Pe[1].type === "blockQuotePrefixWhitespace" || Pe[1].type === "blockQuoteMarker" || Pe[1].type === "listItemIndent")) break;
          }
          Ct && (!De || Ct < De) && (Xe._spread = !0), Xe.end = Object.assign(
            {},
            De ? N[De][1].start : Ee[1].end
          ), N.splice(De || V, 0, ["exit", Xe, Ee[2]]), V++, U++;
        }
        if (Ee[1].type === "listItemPrefix") {
          const at = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, Ee[1].start),
            // @ts-expect-error: we’ll add `end` in a second.
            end: void 0
          };
          Xe = at, N.splice(V, 0, ["enter", at, Ee[2]]), V++, U++, Ct = void 0, It = !0;
        }
      }
    }
    return N[M][1]._spread = xe, U;
  }
  function a(N, M) {
    return U;
    function U(V) {
      o.call(this, N(V), V), M && M.call(this, V);
    }
  }
  function i() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function o(N, M, U) {
    this.stack[this.stack.length - 1].children.push(N), this.stack.push(N), this.tokenStack.push([M, U]), N.position = {
      start: He(M.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function l(N) {
    return M;
    function M(U) {
      N && N.call(this, U), c.call(this, U);
    }
  }
  function c(N, M) {
    const U = this.stack.pop(), V = this.tokenStack.pop();
    if (V)
      V[0].type !== N.type && (M ? M.call(this, N, V[0]) : (V[1] || uu).call(this, N, V[0]));
    else throw new Error(
      "Cannot close `" + N.type + "` (" + tn({
        start: N.start,
        end: N.end
      }) + "): it’s not open"
    );
    U.position.end = He(N.end);
  }
  function h() {
    return mr(this.stack.pop());
  }
  function f() {
    this.data.expectingFirstListItemValue = !0;
  }
  function p(N) {
    if (this.data.expectingFirstListItemValue) {
      const M = this.stack[this.stack.length - 2];
      M.start = Number.parseInt(this.sliceSerialize(N), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function d() {
    const N = this.resume(), M = this.stack[this.stack.length - 1];
    M.lang = N;
  }
  function A() {
    const N = this.resume(), M = this.stack[this.stack.length - 1];
    M.meta = N;
  }
  function C() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function L() {
    const N = this.resume(), M = this.stack[this.stack.length - 1];
    M.value = N.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function x() {
    const N = this.resume(), M = this.stack[this.stack.length - 1];
    M.value = N.replace(/(\r?\n|\r)$/g, "");
  }
  function w(N) {
    const M = this.resume(), U = this.stack[this.stack.length - 1];
    U.label = M, U.identifier = ft(
      this.sliceSerialize(N)
    ).toLowerCase();
  }
  function D() {
    const N = this.resume(), M = this.stack[this.stack.length - 1];
    M.title = N;
  }
  function z() {
    const N = this.resume(), M = this.stack[this.stack.length - 1];
    M.url = N;
  }
  function Y(N) {
    const M = this.stack[this.stack.length - 1];
    if (!M.depth) {
      const U = this.sliceSerialize(N).length;
      M.depth = U;
    }
  }
  function k() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function Q(N) {
    const M = this.stack[this.stack.length - 1];
    M.depth = this.sliceSerialize(N).codePointAt(0) === 61 ? 1 : 2;
  }
  function ee() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function X(N) {
    const U = this.stack[this.stack.length - 1].children;
    let V = U[U.length - 1];
    (!V || V.type !== "text") && (V = ms(), V.position = {
      start: He(N.start),
      // @ts-expect-error: we’ll add `end` later.
      end: void 0
    }, U.push(V)), this.stack.push(V);
  }
  function S(N) {
    const M = this.stack.pop();
    M.value += this.sliceSerialize(N), M.position.end = He(N.end);
  }
  function B(N) {
    const M = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const U = M.children[M.children.length - 1];
      U.position.end = He(N.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(M.type) && (X.call(this, N), S.call(this, N));
  }
  function F() {
    this.data.atHardBreak = !0;
  }
  function $() {
    const N = this.resume(), M = this.stack[this.stack.length - 1];
    M.value = N;
  }
  function ne() {
    const N = this.resume(), M = this.stack[this.stack.length - 1];
    M.value = N;
  }
  function G() {
    const N = this.resume(), M = this.stack[this.stack.length - 1];
    M.value = N;
  }
  function ce() {
    const N = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const M = this.data.referenceType || "shortcut";
      N.type += "Reference", N.referenceType = M, delete N.url, delete N.title;
    } else
      delete N.identifier, delete N.label;
    this.data.referenceType = void 0;
  }
  function oe() {
    const N = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const M = this.data.referenceType || "shortcut";
      N.type += "Reference", N.referenceType = M, delete N.url, delete N.title;
    } else
      delete N.identifier, delete N.label;
    this.data.referenceType = void 0;
  }
  function _e(N) {
    const M = this.sliceSerialize(N), U = this.stack[this.stack.length - 2];
    U.label = Jl(M), U.identifier = ft(M).toLowerCase();
  }
  function Le() {
    const N = this.stack[this.stack.length - 1], M = this.resume(), U = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, U.type === "link") {
      const V = N.children;
      U.children = V;
    } else
      U.alt = M;
  }
  function g() {
    const N = this.resume(), M = this.stack[this.stack.length - 1];
    M.url = N;
  }
  function Ce() {
    const N = this.resume(), M = this.stack[this.stack.length - 1];
    M.title = N;
  }
  function Re() {
    this.data.inReference = void 0;
  }
  function b() {
    this.data.referenceType = "collapsed";
  }
  function Ie(N) {
    const M = this.resume(), U = this.stack[this.stack.length - 1];
    U.label = M, U.identifier = ft(
      this.sliceSerialize(N)
    ).toLowerCase(), this.data.referenceType = "full";
  }
  function Qe(N) {
    this.data.characterReferenceType = N.type;
  }
  function le(N) {
    const M = this.sliceSerialize(N), U = this.data.characterReferenceType;
    let V;
    U ? (V = mi(
      M,
      U === "characterReferenceMarkerNumeric" ? 10 : 16
    ), this.data.characterReferenceType = void 0) : V = pr(M);
    const K = this.stack.pop();
    K.value += V, K.position.end = He(N.end);
  }
  function _t(N) {
    S.call(this, N);
    const M = this.stack[this.stack.length - 1];
    M.url = this.sliceSerialize(N);
  }
  function Fe(N) {
    S.call(this, N);
    const M = this.stack[this.stack.length - 1];
    M.url = "mailto:" + this.sliceSerialize(N);
  }
  function it() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function Ge() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function On() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function os() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function ls() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function Ur() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function vr() {
    return {
      type: "break"
    };
  }
  function zr() {
    return {
      type: "html",
      value: ""
    };
  }
  function cs() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function Yr() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function qr(N) {
    return {
      type: "list",
      ordered: N.type === "listOrdered",
      start: null,
      spread: N._spread,
      children: []
    };
  }
  function fs(N) {
    return {
      type: "listItem",
      spread: N._spread,
      checked: null,
      children: []
    };
  }
  function hs() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function ds() {
    return {
      type: "strong",
      children: []
    };
  }
  function ms() {
    return {
      type: "text",
      value: ""
    };
  }
  function ps() {
    return {
      type: "thematicBreak"
    };
  }
}
function He(e) {
  return {
    line: e.line,
    column: e.column,
    offset: e.offset
  };
}
function Si(e, t) {
  let n = -1;
  for (; ++n < t.length; ) {
    const r = t[n];
    Array.isArray(r) ? Si(e, r) : nc(e, r);
  }
}
function nc(e, t) {
  let n;
  for (n in t)
    if (xi.call(t, n))
      switch (n) {
        case "canContainEols": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "transforms": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = t[n];
          r && Object.assign(e[n], r);
          break;
        }
      }
}
function uu(e, t) {
  throw e ? new Error(
    "Cannot close `" + e.type + "` (" + tn({
      start: e.start,
      end: e.end
    }) + "): a different token (`" + t.type + "`, " + tn({
      start: t.start,
      end: t.end
    }) + ") is open"
  ) : new Error(
    "Cannot close document, a token (`" + t.type + "`, " + tn({
      start: t.start,
      end: t.end
    }) + ") is still open"
  );
}
function rc(e) {
  const t = this;
  t.parser = n;
  function n(r) {
    return ec(r, {
      ...t.data("settings"),
      ...e,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: t.data("micromarkExtensions") || [],
      mdastExtensions: t.data("fromMarkdownExtensions") || []
    });
  }
}
function uc(e, t) {
  const n = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(t), !0)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function ic(e, t) {
  const n = { type: "element", tagName: "br", properties: {}, children: [] };
  return e.patch(t, n), [e.applyData(t, n), { type: "text", value: `
` }];
}
function ac(e, t) {
  const n = t.value ? t.value + `
` : "", r = {};
  t.lang && (r.className = ["language-" + t.lang]);
  let u = {
    type: "element",
    tagName: "code",
    properties: r,
    children: [{ type: "text", value: n }]
  };
  return t.meta && (u.data = { meta: t.meta }), e.patch(t, u), u = e.applyData(t, u), u = { type: "element", tagName: "pre", properties: {}, children: [u] }, e.patch(t, u), u;
}
function sc(e, t) {
  const n = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function oc(e, t) {
  const n = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Et(e) {
  const t = [];
  let n = -1, r = 0, u = 0;
  for (; ++n < e.length; ) {
    const a = e.charCodeAt(n);
    let i = "";
    if (a === 37 && fe(e.charCodeAt(n + 1)) && fe(e.charCodeAt(n + 2)))
      u = 2;
    else if (a < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(a)) || (i = String.fromCharCode(a));
    else if (a > 55295 && a < 57344) {
      const o = e.charCodeAt(n + 1);
      a < 56320 && o > 56319 && o < 57344 ? (i = String.fromCharCode(a, o), u = 1) : i = "�";
    } else
      i = String.fromCharCode(a);
    i && (t.push(e.slice(r, n), encodeURIComponent(i)), r = n + u + 1, i = ""), u && (n += u, u = 0);
  }
  return t.join("") + e.slice(r);
}
function lc(e, t) {
  const n = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", r = String(t.identifier).toUpperCase(), u = Et(r.toLowerCase()), a = e.footnoteOrder.indexOf(r);
  let i, o = e.footnoteCounts.get(r);
  o === void 0 ? (o = 0, e.footnoteOrder.push(r), i = e.footnoteOrder.length) : i = a + 1, o += 1, e.footnoteCounts.set(r, o);
  const l = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + n + "fn-" + u,
      id: n + "fnref-" + u + (o > 1 ? "-" + o : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(i) }]
  };
  e.patch(t, l);
  const c = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [l]
  };
  return e.patch(t, c), e.applyData(t, c);
}
function cc(e, t) {
  const n = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function fc(e, t) {
  if (e.options.allowDangerousHtml) {
    const n = { type: "raw", value: t.value };
    return e.patch(t, n), e.applyData(t, n);
  }
}
function Ni(e, t) {
  const n = t.referenceType;
  let r = "]";
  if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return [{ type: "text", value: "![" + t.alt + r }];
  const u = e.all(t), a = u[0];
  a && a.type === "text" ? a.value = "[" + a.value : u.unshift({ type: "text", value: "[" });
  const i = u[u.length - 1];
  return i && i.type === "text" ? i.value += r : u.push({ type: "text", value: r }), u;
}
function hc(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return Ni(e, t);
  const u = { src: Et(r.url || ""), alt: t.alt };
  r.title !== null && r.title !== void 0 && (u.title = r.title);
  const a = { type: "element", tagName: "img", properties: u, children: [] };
  return e.patch(t, a), e.applyData(t, a);
}
function dc(e, t) {
  const n = { src: Et(t.url) };
  t.alt !== null && t.alt !== void 0 && (n.alt = t.alt), t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = { type: "element", tagName: "img", properties: n, children: [] };
  return e.patch(t, r), e.applyData(t, r);
}
function mc(e, t) {
  const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
  e.patch(t, n);
  const r = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [n]
  };
  return e.patch(t, r), e.applyData(t, r);
}
function pc(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return Ni(e, t);
  const u = { href: Et(r.url || "") };
  r.title !== null && r.title !== void 0 && (u.title = r.title);
  const a = {
    type: "element",
    tagName: "a",
    properties: u,
    children: e.all(t)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function Ec(e, t) {
  const n = { href: Et(t.url) };
  t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = {
    type: "element",
    tagName: "a",
    properties: n,
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function Tc(e, t, n) {
  const r = e.all(t), u = n ? gc(n) : ki(t), a = {}, i = [];
  if (typeof t.checked == "boolean") {
    const h = r[0];
    let f;
    h && h.type === "element" && h.tagName === "p" ? f = h : (f = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(f)), f.children.length > 0 && f.children.unshift({ type: "text", value: " " }), f.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t.checked, disabled: !0 },
      children: []
    }), a.className = ["task-list-item"];
  }
  let o = -1;
  for (; ++o < r.length; ) {
    const h = r[o];
    (u || o !== 0 || h.type !== "element" || h.tagName !== "p") && i.push({ type: "text", value: `
` }), h.type === "element" && h.tagName === "p" && !u ? i.push(...h.children) : i.push(h);
  }
  const l = r[r.length - 1];
  l && (u || l.type !== "element" || l.tagName !== "p") && i.push({ type: "text", value: `
` });
  const c = { type: "element", tagName: "li", properties: a, children: i };
  return e.patch(t, c), e.applyData(t, c);
}
function gc(e) {
  let t = !1;
  if (e.type === "list") {
    t = e.spread || !1;
    const n = e.children;
    let r = -1;
    for (; !t && ++r < n.length; )
      t = ki(n[r]);
  }
  return t;
}
function ki(e) {
  const t = e.spread;
  return t ?? e.children.length > 1;
}
function bc(e, t) {
  const n = {}, r = e.all(t);
  let u = -1;
  for (typeof t.start == "number" && t.start !== 1 && (n.start = t.start); ++u < r.length; ) {
    const i = r[u];
    if (i.type === "element" && i.tagName === "li" && i.properties && Array.isArray(i.properties.className) && i.properties.className.includes("task-list-item")) {
      n.className = ["contains-task-list"];
      break;
    }
  }
  const a = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: n,
    children: e.wrap(r, !0)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function Ac(e, t) {
  const n = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function _c(e, t) {
  const n = { type: "root", children: e.wrap(e.all(t)) };
  return e.patch(t, n), e.applyData(t, n);
}
function Cc(e, t) {
  const n = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Ic(e, t) {
  const n = e.all(t), r = n.shift(), u = [];
  if (r) {
    const i = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([r], !0)
    };
    e.patch(t.children[0], i), u.push(i);
  }
  if (n.length > 0) {
    const i = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(n, !0)
    }, o = je(t.children[1]), l = hr(t.children[t.children.length - 1]);
    o && l && (i.position = { start: o, end: l }), u.push(i);
  }
  const a = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(u, !0)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function xc(e, t, n) {
  const r = n ? n.children : void 0, a = (r ? r.indexOf(t) : 1) === 0 ? "th" : "td", i = n && n.type === "table" ? n.align : void 0, o = i ? i.length : t.children.length;
  let l = -1;
  const c = [];
  for (; ++l < o; ) {
    const f = t.children[l], p = {}, d = i ? i[l] : void 0;
    d && (p.align = d);
    let A = { type: "element", tagName: a, properties: p, children: [] };
    f && (A.children = e.all(f), e.patch(f, A), A = e.applyData(f, A)), c.push(A);
  }
  const h = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(c, !0)
  };
  return e.patch(t, h), e.applyData(t, h);
}
function Sc(e, t) {
  const n = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
const iu = 9, au = 32;
function Nc(e) {
  const t = String(e), n = /\r?\n|\r/g;
  let r = n.exec(t), u = 0;
  const a = [];
  for (; r; )
    a.push(
      su(t.slice(u, r.index), u > 0, !0),
      r[0]
    ), u = r.index + r[0].length, r = n.exec(t);
  return a.push(su(t.slice(u), u > 0, !1)), a.join("");
}
function su(e, t, n) {
  let r = 0, u = e.length;
  if (t) {
    let a = e.codePointAt(r);
    for (; a === iu || a === au; )
      r++, a = e.codePointAt(r);
  }
  if (n) {
    let a = e.codePointAt(u - 1);
    for (; a === iu || a === au; )
      u--, a = e.codePointAt(u - 1);
  }
  return u > r ? e.slice(r, u) : "";
}
function kc(e, t) {
  const n = { type: "text", value: Nc(String(t.value)) };
  return e.patch(t, n), e.applyData(t, n);
}
function Oc(e, t) {
  const n = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(t, n), e.applyData(t, n);
}
const yc = {
  blockquote: uc,
  break: ic,
  code: ac,
  delete: sc,
  emphasis: oc,
  footnoteReference: lc,
  heading: cc,
  html: fc,
  imageReference: hc,
  image: dc,
  inlineCode: mc,
  linkReference: pc,
  link: Ec,
  listItem: Tc,
  list: bc,
  paragraph: Ac,
  // @ts-expect-error: root is different, but hard to type.
  root: _c,
  strong: Cc,
  table: Ic,
  tableCell: Sc,
  tableRow: xc,
  text: kc,
  thematicBreak: Oc,
  toml: Qt,
  yaml: Qt,
  definition: Qt,
  footnoteDefinition: Qt
};
function Qt() {
}
const Oi = -1, _n = 0, Rt = 1, ln = 2, gr = 3, br = 4, Ar = 5, _r = 6, yi = 7, Li = 8, ou = typeof self == "object" ? self : globalThis, Lc = (e, t) => {
  const n = (u, a) => (e.set(a, u), u), r = (u) => {
    if (e.has(u))
      return e.get(u);
    const [a, i] = t[u];
    switch (a) {
      case _n:
      case Oi:
        return n(i, u);
      case Rt: {
        const o = n([], u);
        for (const l of i)
          o.push(r(l));
        return o;
      }
      case ln: {
        const o = n({}, u);
        for (const [l, c] of i)
          o[r(l)] = r(c);
        return o;
      }
      case gr:
        return n(new Date(i), u);
      case br: {
        const { source: o, flags: l } = i;
        return n(new RegExp(o, l), u);
      }
      case Ar: {
        const o = n(/* @__PURE__ */ new Map(), u);
        for (const [l, c] of i)
          o.set(r(l), r(c));
        return o;
      }
      case _r: {
        const o = n(/* @__PURE__ */ new Set(), u);
        for (const l of i)
          o.add(r(l));
        return o;
      }
      case yi: {
        const { name: o, message: l } = i;
        return n(new ou[o](l), u);
      }
      case Li:
        return n(BigInt(i), u);
      case "BigInt":
        return n(Object(BigInt(i)), u);
      case "ArrayBuffer":
        return n(new Uint8Array(i).buffer, i);
      case "DataView": {
        const { buffer: o } = new Uint8Array(i);
        return n(new DataView(o), i);
      }
    }
    return n(new ou[a](i), u);
  };
  return r;
}, lu = (e) => Lc(/* @__PURE__ */ new Map(), e)(0), st = "", { toString: Rc } = {}, { keys: Dc } = Object, xt = (e) => {
  const t = typeof e;
  if (t !== "object" || !e)
    return [_n, t];
  const n = Rc.call(e).slice(8, -1);
  switch (n) {
    case "Array":
      return [Rt, st];
    case "Object":
      return [ln, st];
    case "Date":
      return [gr, st];
    case "RegExp":
      return [br, st];
    case "Map":
      return [Ar, st];
    case "Set":
      return [_r, st];
    case "DataView":
      return [Rt, n];
  }
  return n.includes("Array") ? [Rt, n] : n.includes("Error") ? [yi, n] : [ln, n];
}, Gt = ([e, t]) => e === _n && (t === "function" || t === "symbol"), Pc = (e, t, n, r) => {
  const u = (i, o) => {
    const l = r.push(i) - 1;
    return n.set(o, l), l;
  }, a = (i) => {
    if (n.has(i))
      return n.get(i);
    let [o, l] = xt(i);
    switch (o) {
      case _n: {
        let h = i;
        switch (l) {
          case "bigint":
            o = Li, h = i.toString();
            break;
          case "function":
          case "symbol":
            if (e)
              throw new TypeError("unable to serialize " + l);
            h = null;
            break;
          case "undefined":
            return u([Oi], i);
        }
        return u([o, h], i);
      }
      case Rt: {
        if (l) {
          let p = i;
          return l === "DataView" ? p = new Uint8Array(i.buffer) : l === "ArrayBuffer" && (p = new Uint8Array(i)), u([l, [...p]], i);
        }
        const h = [], f = u([o, h], i);
        for (const p of i)
          h.push(a(p));
        return f;
      }
      case ln: {
        if (l)
          switch (l) {
            case "BigInt":
              return u([l, i.toString()], i);
            case "Boolean":
            case "Number":
            case "String":
              return u([l, i.valueOf()], i);
          }
        if (t && "toJSON" in i)
          return a(i.toJSON());
        const h = [], f = u([o, h], i);
        for (const p of Dc(i))
          (e || !Gt(xt(i[p]))) && h.push([a(p), a(i[p])]);
        return f;
      }
      case gr:
        return u([o, i.toISOString()], i);
      case br: {
        const { source: h, flags: f } = i;
        return u([o, { source: h, flags: f }], i);
      }
      case Ar: {
        const h = [], f = u([o, h], i);
        for (const [p, d] of i)
          (e || !(Gt(xt(p)) || Gt(xt(d)))) && h.push([a(p), a(d)]);
        return f;
      }
      case _r: {
        const h = [], f = u([o, h], i);
        for (const p of i)
          (e || !Gt(xt(p))) && h.push(a(p));
        return f;
      }
    }
    const { message: c } = i;
    return u([o, { name: l, message: c }], i);
  };
  return a;
}, cu = (e, { json: t, lossy: n } = {}) => {
  const r = [];
  return Pc(!(t || n), !!t, /* @__PURE__ */ new Map(), r)(e), r;
}, cn = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (e, t) => t && ("json" in t || "lossy" in t) ? lu(cu(e, t)) : structuredClone(e)
) : (e, t) => lu(cu(e, t));
function wc(e, t) {
  const n = [{ type: "text", value: "↩" }];
  return t > 1 && n.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(t) }]
  }), n;
}
function Mc(e, t) {
  return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "");
}
function Bc(e) {
  const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", n = e.options.footnoteBackContent || wc, r = e.options.footnoteBackLabel || Mc, u = e.options.footnoteLabel || "Footnotes", a = e.options.footnoteLabelTagName || "h2", i = e.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, o = [];
  let l = -1;
  for (; ++l < e.footnoteOrder.length; ) {
    const c = e.footnoteById.get(
      e.footnoteOrder[l]
    );
    if (!c)
      continue;
    const h = e.all(c), f = String(c.identifier).toUpperCase(), p = Et(f.toLowerCase());
    let d = 0;
    const A = [], C = e.footnoteCounts.get(f);
    for (; C !== void 0 && ++d <= C; ) {
      A.length > 0 && A.push({ type: "text", value: " " });
      let w = typeof n == "string" ? n : n(l, d);
      typeof w == "string" && (w = { type: "text", value: w }), A.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t + "fnref-" + p + (d > 1 ? "-" + d : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof r == "string" ? r : r(l, d),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(w) ? w : [w]
      });
    }
    const L = h[h.length - 1];
    if (L && L.type === "element" && L.tagName === "p") {
      const w = L.children[L.children.length - 1];
      w && w.type === "text" ? w.value += " " : L.children.push({ type: "text", value: " " }), L.children.push(...A);
    } else
      h.push(...A);
    const x = {
      type: "element",
      tagName: "li",
      properties: { id: t + "fn-" + p },
      children: e.wrap(h, !0)
    };
    e.patch(c, x), o.push(x);
  }
  if (o.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: a,
          properties: {
            ...cn(i),
            id: "footnote-label"
          },
          children: [{ type: "text", value: u }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: e.wrap(o, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
const Jn = {}.hasOwnProperty, Fc = {};
function Hc(e, t) {
  const n = t || Fc, r = /* @__PURE__ */ new Map(), u = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), i = { ...yc, ...n.handlers }, o = {
    all: c,
    applyData: vc,
    definitionById: r,
    footnoteById: u,
    footnoteCounts: a,
    footnoteOrder: [],
    handlers: i,
    one: l,
    options: n,
    patch: Uc,
    wrap: Yc
  };
  return Tn(e, function(h) {
    if (h.type === "definition" || h.type === "footnoteDefinition") {
      const f = h.type === "definition" ? r : u, p = String(h.identifier).toUpperCase();
      f.has(p) || f.set(p, h);
    }
  }), o;
  function l(h, f) {
    const p = h.type, d = o.handlers[p];
    if (Jn.call(o.handlers, p) && d)
      return d(o, h, f);
    if (o.options.passThrough && o.options.passThrough.includes(p)) {
      if ("children" in h) {
        const { children: C, ...L } = h, x = cn(L);
        return x.children = o.all(h), x;
      }
      return cn(h);
    }
    return (o.options.unknownHandler || zc)(o, h, f);
  }
  function c(h) {
    const f = [];
    if ("children" in h) {
      const p = h.children;
      let d = -1;
      for (; ++d < p.length; ) {
        const A = o.one(p[d], h);
        if (A) {
          if (d && p[d - 1].type === "break" && (!Array.isArray(A) && A.type === "text" && (A.value = fu(A.value)), !Array.isArray(A) && A.type === "element")) {
            const C = A.children[0];
            C && C.type === "text" && (C.value = fu(C.value));
          }
          Array.isArray(A) ? f.push(...A) : f.push(A);
        }
      }
    }
    return f;
  }
}
function Uc(e, t) {
  e.position && (t.position = Ns(e));
}
function vc(e, t) {
  let n = t;
  if (e && e.data) {
    const r = e.data.hName, u = e.data.hChildren, a = e.data.hProperties;
    if (typeof r == "string")
      if (n.type === "element")
        n.tagName = r;
      else {
        const i = "children" in n ? n.children : [n];
        n = { type: "element", tagName: r, properties: {}, children: i };
      }
    n.type === "element" && a && Object.assign(n.properties, cn(a)), "children" in n && n.children && u !== null && u !== void 0 && (n.children = u);
  }
  return n;
}
function zc(e, t) {
  const n = t.data || {}, r = "value" in t && !(Jn.call(n, "hProperties") || Jn.call(n, "hChildren")) ? { type: "text", value: t.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function Yc(e, t) {
  const n = [];
  let r = -1;
  for (t && n.push({ type: "text", value: `
` }); ++r < e.length; )
    r && n.push({ type: "text", value: `
` }), n.push(e[r]);
  return t && e.length > 0 && n.push({ type: "text", value: `
` }), n;
}
function fu(e) {
  let t = 0, n = e.charCodeAt(t);
  for (; n === 9 || n === 32; )
    t++, n = e.charCodeAt(t);
  return e.slice(t);
}
function hu(e, t) {
  const n = Hc(e, t), r = n.one(e, void 0), u = Bc(n), a = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] };
  return u && a.children.push({ type: "text", value: `
` }, u), a;
}
function qc(e, t) {
  return e && "run" in e ? async function(n, r) {
    const u = (
      /** @type {HastRoot} */
      hu(n, { file: r, ...t })
    );
    await e.run(u, r);
  } : function(n, r) {
    return (
      /** @type {HastRoot} */
      hu(n, { file: r, ...e || t })
    );
  };
}
function du(e) {
  if (e)
    throw e;
}
var Pn, mu;
function jc() {
  if (mu) return Pn;
  mu = 1;
  var e = Object.prototype.hasOwnProperty, t = Object.prototype.toString, n = Object.defineProperty, r = Object.getOwnPropertyDescriptor, u = function(c) {
    return typeof Array.isArray == "function" ? Array.isArray(c) : t.call(c) === "[object Array]";
  }, a = function(c) {
    if (!c || t.call(c) !== "[object Object]")
      return !1;
    var h = e.call(c, "constructor"), f = c.constructor && c.constructor.prototype && e.call(c.constructor.prototype, "isPrototypeOf");
    if (c.constructor && !h && !f)
      return !1;
    var p;
    for (p in c)
      ;
    return typeof p > "u" || e.call(c, p);
  }, i = function(c, h) {
    n && h.name === "__proto__" ? n(c, h.name, {
      enumerable: !0,
      configurable: !0,
      value: h.newValue,
      writable: !0
    }) : c[h.name] = h.newValue;
  }, o = function(c, h) {
    if (h === "__proto__")
      if (e.call(c, h)) {
        if (r)
          return r(c, h).value;
      } else return;
    return c[h];
  };
  return Pn = function l() {
    var c, h, f, p, d, A, C = arguments[0], L = 1, x = arguments.length, w = !1;
    for (typeof C == "boolean" && (w = C, C = arguments[1] || {}, L = 2), (C == null || typeof C != "object" && typeof C != "function") && (C = {}); L < x; ++L)
      if (c = arguments[L], c != null)
        for (h in c)
          f = o(C, h), p = o(c, h), C !== p && (w && p && (a(p) || (d = u(p))) ? (d ? (d = !1, A = f && u(f) ? f : []) : A = f && a(f) ? f : {}, i(C, { name: h, newValue: l(w, A, p) })) : typeof p < "u" && i(C, { name: h, newValue: p }));
    return C;
  }, Pn;
}
var Vc = jc();
const wn = /* @__PURE__ */ Hs(Vc);
function Zn(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function Wc() {
  const e = [], t = { run: n, use: r };
  return t;
  function n(...u) {
    let a = -1;
    const i = u.pop();
    if (typeof i != "function")
      throw new TypeError("Expected function as last argument, not " + i);
    o(null, ...u);
    function o(l, ...c) {
      const h = e[++a];
      let f = -1;
      if (l) {
        i(l);
        return;
      }
      for (; ++f < u.length; )
        (c[f] === null || c[f] === void 0) && (c[f] = u[f]);
      u = c, h ? Qc(h, o)(...c) : i(null, ...c);
    }
  }
  function r(u) {
    if (typeof u != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + u
      );
    return e.push(u), t;
  }
}
function Qc(e, t) {
  let n;
  return r;
  function r(...i) {
    const o = e.length > i.length;
    let l;
    o && i.push(u);
    try {
      l = e.apply(this, i);
    } catch (c) {
      const h = (
        /** @type {Error} */
        c
      );
      if (o && n)
        throw h;
      return u(h);
    }
    o || (l && l.then && typeof l.then == "function" ? l.then(a, u) : l instanceof Error ? u(l) : a(l));
  }
  function u(i, ...o) {
    n || (n = !0, t(i, ...o));
  }
  function a(i) {
    u(null, i);
  }
}
const Ne = { basename: Gc, dirname: Xc, extname: Kc, join: $c, sep: "/" };
function Gc(e, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  zt(e);
  let n = 0, r = -1, u = e.length, a;
  if (t === void 0 || t.length === 0 || t.length > e.length) {
    for (; u--; )
      if (e.codePointAt(u) === 47) {
        if (a) {
          n = u + 1;
          break;
        }
      } else r < 0 && (a = !0, r = u + 1);
    return r < 0 ? "" : e.slice(n, r);
  }
  if (t === e)
    return "";
  let i = -1, o = t.length - 1;
  for (; u--; )
    if (e.codePointAt(u) === 47) {
      if (a) {
        n = u + 1;
        break;
      }
    } else
      i < 0 && (a = !0, i = u + 1), o > -1 && (e.codePointAt(u) === t.codePointAt(o--) ? o < 0 && (r = u) : (o = -1, r = i));
  return n === r ? r = i : r < 0 && (r = e.length), e.slice(n, r);
}
function Xc(e) {
  if (zt(e), e.length === 0)
    return ".";
  let t = -1, n = e.length, r;
  for (; --n; )
    if (e.codePointAt(n) === 47) {
      if (r) {
        t = n;
        break;
      }
    } else r || (r = !0);
  return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t);
}
function Kc(e) {
  zt(e);
  let t = e.length, n = -1, r = 0, u = -1, a = 0, i;
  for (; t--; ) {
    const o = e.codePointAt(t);
    if (o === 47) {
      if (i) {
        r = t + 1;
        break;
      }
      continue;
    }
    n < 0 && (i = !0, n = t + 1), o === 46 ? u < 0 ? u = t : a !== 1 && (a = 1) : u > -1 && (a = -1);
  }
  return u < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
  a === 0 || // The (right-most) trimmed path component is exactly `..`.
  a === 1 && u === n - 1 && u === r + 1 ? "" : e.slice(u, n);
}
function $c(...e) {
  let t = -1, n;
  for (; ++t < e.length; )
    zt(e[t]), e[t] && (n = n === void 0 ? e[t] : n + "/" + e[t]);
  return n === void 0 ? "." : Jc(n);
}
function Jc(e) {
  zt(e);
  const t = e.codePointAt(0) === 47;
  let n = Zc(e, !t);
  return n.length === 0 && !t && (n = "."), n.length > 0 && e.codePointAt(e.length - 1) === 47 && (n += "/"), t ? "/" + n : n;
}
function Zc(e, t) {
  let n = "", r = 0, u = -1, a = 0, i = -1, o, l;
  for (; ++i <= e.length; ) {
    if (i < e.length)
      o = e.codePointAt(i);
    else {
      if (o === 47)
        break;
      o = 47;
    }
    if (o === 47) {
      if (!(u === i - 1 || a === 1)) if (u !== i - 1 && a === 2) {
        if (n.length < 2 || r !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) {
          if (n.length > 2) {
            if (l = n.lastIndexOf("/"), l !== n.length - 1) {
              l < 0 ? (n = "", r = 0) : (n = n.slice(0, l), r = n.length - 1 - n.lastIndexOf("/")), u = i, a = 0;
              continue;
            }
          } else if (n.length > 0) {
            n = "", r = 0, u = i, a = 0;
            continue;
          }
        }
        t && (n = n.length > 0 ? n + "/.." : "..", r = 2);
      } else
        n.length > 0 ? n += "/" + e.slice(u + 1, i) : n = e.slice(u + 1, i), r = i - u - 1;
      u = i, a = 0;
    } else o === 46 && a > -1 ? a++ : a = -1;
  }
  return n;
}
function zt(e) {
  if (typeof e != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(e)
    );
}
const e0 = { cwd: t0 };
function t0() {
  return "/";
}
function er(e) {
  return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && // @ts-expect-error: indexing is fine.
  e.auth === void 0);
}
function n0(e) {
  if (typeof e == "string")
    e = new URL(e);
  else if (!er(e)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
    );
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (e.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return r0(e);
}
function r0(e) {
  if (e.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const t = e.pathname;
  let n = -1;
  for (; ++n < t.length; )
    if (t.codePointAt(n) === 37 && t.codePointAt(n + 1) === 50) {
      const r = t.codePointAt(n + 2);
      if (r === 70 || r === 102) {
        const u = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw u.code = "ERR_INVALID_FILE_URL_PATH", u;
      }
    }
  return decodeURIComponent(t);
}
const Mn = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class Ri {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array` — `{value: options}`
   * *   `URL` — `{path: options}`
   * *   `VFile` — shallow copies its data over to the new file
   * *   `object` — all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let n;
    t ? er(t) ? n = { path: t } : typeof t == "string" || u0(t) ? n = { value: t } : n = t : n = {}, this.cwd = "cwd" in n ? "" : e0.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r = -1;
    for (; ++r < Mn.length; ) {
      const a = Mn[r];
      a in n && n[a] !== void 0 && n[a] !== null && (this[a] = a === "history" ? [...n[a]] : n[a]);
    }
    let u;
    for (u in n)
      Mn.includes(u) || (this[u] = n[u]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? Ne.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(t) {
    Fn(t, "basename"), Bn(t, "basename"), this.path = Ne.join(this.dirname || "", t);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? Ne.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(t) {
    pu(this.basename, "dirname"), this.path = Ne.join(t || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? Ne.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(t) {
    if (Bn(t, "extname"), pu(this.dirname, "extname"), t) {
      if (t.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = Ne.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(t) {
    er(t) && (t = n0(t)), Fn(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? Ne.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(t) {
    Fn(t, "stem"), Bn(t, "stem"), this.path = Ne.join(this.dirname || "", t + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, n, r) {
    const u = this.message(t, n, r);
    throw u.fatal = !0, u;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, n, r) {
    const u = this.message(t, n, r);
    return u.fatal = void 0, u;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, n, r) {
    const u = new ks(
      // @ts-expect-error: the overloads are fine.
      t,
      n,
      r
    );
    return this.path && (u.name = this.path + ":" + u.name, u.file = this.path), u.fatal = !1, this.messages.push(u), u;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when it’s a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value);
  }
}
function Bn(e, t) {
  if (e && e.includes(Ne.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + Ne.sep + "`"
    );
}
function Fn(e, t) {
  if (!e)
    throw new Error("`" + t + "` cannot be empty");
}
function pu(e, t) {
  if (!e)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function u0(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const i0 = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(e) {
    const r = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), u = r[e], a = function() {
      return u.apply(a, arguments);
    };
    return Object.setPrototypeOf(a, r), a;
  }
), a0 = {}.hasOwnProperty;
class Cr extends i0 {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = Wc();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const t = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new Cr()
    );
    let n = -1;
    for (; ++n < this.attachers.length; ) {
      const r = this.attachers[n];
      t.use(...r);
    }
    return t.data(wn(!0, {}, this.namespace)), t;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(t, n) {
    return typeof t == "string" ? arguments.length === 2 ? (vn("data", this.frozen), this.namespace[t] = n, this) : a0.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (vn("data", this.frozen), this.namespace = t, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * It’s possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const t = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [n, ...r] = this.attachers[this.freezeIndex];
      if (r[0] === !1)
        continue;
      r[0] === !0 && (r[0] = void 0);
      const u = n.call(t, ...r);
      typeof u == "function" && this.transformers.use(u);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(t) {
    this.freeze();
    const n = Xt(t), r = this.parser || this.Parser;
    return Hn("parse", r), r(String(n), n);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(t, n) {
    const r = this;
    return this.freeze(), Hn("process", this.parser || this.Parser), Un("process", this.compiler || this.Compiler), n ? u(void 0, n) : new Promise(u);
    function u(a, i) {
      const o = Xt(t), l = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        r.parse(o)
      );
      r.run(l, o, function(h, f, p) {
        if (h || !f || !p)
          return c(h);
        const d = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          f
        ), A = r.stringify(d, p);
        l0(A) ? p.value = A : p.result = A, c(
          h,
          /** @type {VFileWithOutput<CompileResult>} */
          p
        );
      });
      function c(h, f) {
        h || !f ? i(h) : a ? a(f) : n(void 0, f);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(t) {
    let n = !1, r;
    return this.freeze(), Hn("processSync", this.parser || this.Parser), Un("processSync", this.compiler || this.Compiler), this.process(t, u), Tu("processSync", "process", n), r;
    function u(a, i) {
      n = !0, du(a), r = i;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(t, n, r) {
    Eu(t), this.freeze();
    const u = this.transformers;
    return !r && typeof n == "function" && (r = n, n = void 0), r ? a(void 0, r) : new Promise(a);
    function a(i, o) {
      const l = Xt(n);
      u.run(t, l, c);
      function c(h, f, p) {
        const d = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          f || t
        );
        h ? o(h) : i ? i(d) : r(void 0, d, p);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(t, n) {
    let r = !1, u;
    return this.run(t, n, a), Tu("runSync", "run", r), u;
    function a(i, o) {
      du(i), u = o, r = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(t, n) {
    this.freeze();
    const r = Xt(n), u = this.compiler || this.Compiler;
    return Un("stringify", u), Eu(t), u(t, r);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(t, ...n) {
    const r = this.attachers, u = this.namespace;
    if (vn("use", this.frozen), t != null) if (typeof t == "function")
      l(t, n);
    else if (typeof t == "object")
      Array.isArray(t) ? o(t) : i(t);
    else
      throw new TypeError("Expected usable value, not `" + t + "`");
    return this;
    function a(c) {
      if (typeof c == "function")
        l(c, []);
      else if (typeof c == "object")
        if (Array.isArray(c)) {
          const [h, ...f] = (
            /** @type {PluginTuple<Array<unknown>>} */
            c
          );
          l(h, f);
        } else
          i(c);
      else
        throw new TypeError("Expected usable value, not `" + c + "`");
    }
    function i(c) {
      if (!("plugins" in c) && !("settings" in c))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      o(c.plugins), c.settings && (u.settings = wn(!0, u.settings, c.settings));
    }
    function o(c) {
      let h = -1;
      if (c != null) if (Array.isArray(c))
        for (; ++h < c.length; ) {
          const f = c[h];
          a(f);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + c + "`");
    }
    function l(c, h) {
      let f = -1, p = -1;
      for (; ++f < r.length; )
        if (r[f][0] === c) {
          p = f;
          break;
        }
      if (p === -1)
        r.push([c, ...h]);
      else if (h.length > 0) {
        let [d, ...A] = h;
        const C = r[p][1];
        Zn(C) && Zn(d) && (d = wn(!0, C, d)), r[p] = [c, d, ...A];
      }
    }
  }
}
const s0 = new Cr().freeze();
function Hn(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `parser`");
}
function Un(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `compiler`");
}
function vn(e, t) {
  if (t)
    throw new Error(
      "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function Eu(e) {
  if (!Zn(e) || typeof e.type != "string")
    throw new TypeError("Expected node, got `" + e + "`");
}
function Tu(e, t, n) {
  if (!n)
    throw new Error(
      "`" + e + "` finished async. Use `" + t + "` instead"
    );
}
function Xt(e) {
  return o0(e) ? e : new Ri(e);
}
function o0(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function l0(e) {
  return typeof e == "string" || c0(e);
}
function c0(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const f0 = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", gu = [], bu = { allowDangerousHtml: !0 }, h0 = /^(https?|ircs?|mailto|xmpp)$/i, d0 = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  { from: "className", id: "remove-classname" },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function m0(e) {
  const t = p0(e), n = E0(e);
  return T0(t.runSync(t.parse(n), n), e);
}
function p0(e) {
  const t = e.rehypePlugins || gu, n = e.remarkPlugins || gu, r = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ...bu } : bu;
  return s0().use(rc).use(n).use(qc, r).use(t);
}
function E0(e) {
  const t = e.children || "", n = new Ri();
  return typeof t == "string" && (n.value = t), n;
}
function T0(e, t) {
  const n = t.allowedElements, r = t.allowElement, u = t.components, a = t.disallowedElements, i = t.skipHtml, o = t.unwrapDisallowed, l = t.urlTransform || g0;
  for (const h of d0)
    Object.hasOwn(t, h.from) && Os(
      "Unexpected `" + h.from + "` prop, " + (h.to ? "use `" + h.to + "` instead" : "remove it") + " (see <" + f0 + "#" + h.id + "> for more info)"
    );
  return Tn(e, c), ys(e, {
    Fragment: O.Fragment,
    components: u,
    ignoreInvalidStyle: !0,
    jsx: O.jsx,
    jsxs: O.jsxs,
    passKeys: !0,
    passNode: !0
  });
  function c(h, f, p) {
    if (h.type === "raw" && p && typeof f == "number")
      return i ? p.children.splice(f, 1) : p.children[f] = { type: "text", value: h.value }, f;
    if (h.type === "element") {
      let d;
      for (d in Ln)
        if (Object.hasOwn(Ln, d) && Object.hasOwn(h.properties, d)) {
          const A = h.properties[d], C = Ln[d];
          (C === null || C.includes(h.tagName)) && (h.properties[d] = l(String(A || ""), d, h));
        }
    }
    if (h.type === "element") {
      let d = n ? !n.includes(h.tagName) : a ? a.includes(h.tagName) : !1;
      if (!d && r && typeof f == "number" && (d = !r(h, f, p)), d && p && typeof f == "number")
        return o && h.children ? p.children.splice(f, 1, ...h.children) : p.children.splice(f, 1), f;
    }
  }
}
function g0(e) {
  const t = e.indexOf(":"), n = e.indexOf("?"), r = e.indexOf("#"), u = e.indexOf("/");
  return (
    // If there is no protocol, it’s relative.
    t === -1 || // If the first colon is after a `?`, `#`, or `/`, it’s not a protocol.
    u !== -1 && t > u || n !== -1 && t > n || r !== -1 && t > r || // It is a protocol, it should be allowed.
    h0.test(e.slice(0, t)) ? e : ""
  );
}
const Di = -1, Cn = 0, fn = 1, hn = 2, Ir = 3, xr = 4, Sr = 5, Nr = 6, Pi = 7, wi = 8, Au = typeof self == "object" ? self : globalThis, b0 = (e, t) => {
  const n = (u, a) => (e.set(a, u), u), r = (u) => {
    if (e.has(u))
      return e.get(u);
    const [a, i] = t[u];
    switch (a) {
      case Cn:
      case Di:
        return n(i, u);
      case fn: {
        const o = n([], u);
        for (const l of i)
          o.push(r(l));
        return o;
      }
      case hn: {
        const o = n({}, u);
        for (const [l, c] of i)
          o[r(l)] = r(c);
        return o;
      }
      case Ir:
        return n(new Date(i), u);
      case xr: {
        const { source: o, flags: l } = i;
        return n(new RegExp(o, l), u);
      }
      case Sr: {
        const o = n(/* @__PURE__ */ new Map(), u);
        for (const [l, c] of i)
          o.set(r(l), r(c));
        return o;
      }
      case Nr: {
        const o = n(/* @__PURE__ */ new Set(), u);
        for (const l of i)
          o.add(r(l));
        return o;
      }
      case Pi: {
        const { name: o, message: l } = i;
        return n(new Au[o](l), u);
      }
      case wi:
        return n(BigInt(i), u);
      case "BigInt":
        return n(Object(BigInt(i)), u);
    }
    return n(new Au[a](i), u);
  };
  return r;
}, _u = (e) => b0(/* @__PURE__ */ new Map(), e)(0), ot = "", { toString: A0 } = {}, { keys: _0 } = Object, St = (e) => {
  const t = typeof e;
  if (t !== "object" || !e)
    return [Cn, t];
  const n = A0.call(e).slice(8, -1);
  switch (n) {
    case "Array":
      return [fn, ot];
    case "Object":
      return [hn, ot];
    case "Date":
      return [Ir, ot];
    case "RegExp":
      return [xr, ot];
    case "Map":
      return [Sr, ot];
    case "Set":
      return [Nr, ot];
  }
  return n.includes("Array") ? [fn, n] : n.includes("Error") ? [Pi, n] : [hn, n];
}, Kt = ([e, t]) => e === Cn && (t === "function" || t === "symbol"), C0 = (e, t, n, r) => {
  const u = (i, o) => {
    const l = r.push(i) - 1;
    return n.set(o, l), l;
  }, a = (i) => {
    if (n.has(i))
      return n.get(i);
    let [o, l] = St(i);
    switch (o) {
      case Cn: {
        let h = i;
        switch (l) {
          case "bigint":
            o = wi, h = i.toString();
            break;
          case "function":
          case "symbol":
            if (e)
              throw new TypeError("unable to serialize " + l);
            h = null;
            break;
          case "undefined":
            return u([Di], i);
        }
        return u([o, h], i);
      }
      case fn: {
        if (l)
          return u([l, [...i]], i);
        const h = [], f = u([o, h], i);
        for (const p of i)
          h.push(a(p));
        return f;
      }
      case hn: {
        if (l)
          switch (l) {
            case "BigInt":
              return u([l, i.toString()], i);
            case "Boolean":
            case "Number":
            case "String":
              return u([l, i.valueOf()], i);
          }
        if (t && "toJSON" in i)
          return a(i.toJSON());
        const h = [], f = u([o, h], i);
        for (const p of _0(i))
          (e || !Kt(St(i[p]))) && h.push([a(p), a(i[p])]);
        return f;
      }
      case Ir:
        return u([o, i.toISOString()], i);
      case xr: {
        const { source: h, flags: f } = i;
        return u([o, { source: h, flags: f }], i);
      }
      case Sr: {
        const h = [], f = u([o, h], i);
        for (const [p, d] of i)
          (e || !(Kt(St(p)) || Kt(St(d)))) && h.push([a(p), a(d)]);
        return f;
      }
      case Nr: {
        const h = [], f = u([o, h], i);
        for (const p of i)
          (e || !Kt(St(p))) && h.push(a(p));
        return f;
      }
    }
    const { message: c } = i;
    return u([o, { name: l, message: c }], i);
  };
  return a;
}, Cu = (e, { json: t, lossy: n } = {}) => {
  const r = [];
  return C0(!(t || n), !!t, /* @__PURE__ */ new Map(), r)(e), r;
}, Iu = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (e, t) => t && ("json" in t || "lossy" in t) ? _u(Cu(e, t)) : structuredClone(e)
) : (e, t) => _u(Cu(e, t));
class Yt {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(t, n, r) {
    this.property = t, this.normal = n, r && (this.space = r);
  }
}
Yt.prototype.property = {};
Yt.prototype.normal = {};
Yt.prototype.space = null;
function Mi(e, t) {
  const n = {}, r = {};
  let u = -1;
  for (; ++u < e.length; )
    Object.assign(n, e[u].property), Object.assign(r, e[u].normal);
  return new Yt(n, r, t);
}
function Ht(e) {
  return e.toLowerCase();
}
class Ae {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(t, n) {
    this.property = t, this.attribute = n;
  }
}
Ae.prototype.space = null;
Ae.prototype.boolean = !1;
Ae.prototype.booleanish = !1;
Ae.prototype.overloadedBoolean = !1;
Ae.prototype.number = !1;
Ae.prototype.commaSeparated = !1;
Ae.prototype.spaceSeparated = !1;
Ae.prototype.commaOrSpaceSeparated = !1;
Ae.prototype.mustUseProperty = !1;
Ae.prototype.defined = !1;
let I0 = 0;
const v = nt(), ue = nt(), Bi = nt(), P = nt(), Z = nt(), ht = nt(), Te = nt();
function nt() {
  return 2 ** ++I0;
}
const tr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: v,
  booleanish: ue,
  commaOrSpaceSeparated: Te,
  commaSeparated: ht,
  number: P,
  overloadedBoolean: Bi,
  spaceSeparated: Z
}, Symbol.toStringTag, { value: "Module" })), zn = Object.keys(tr);
class kr extends Ae {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(t, n, r, u) {
    let a = -1;
    if (super(t, n), xu(this, "space", u), typeof r == "number")
      for (; ++a < zn.length; ) {
        const i = zn[a];
        xu(this, zn[a], (r & tr[i]) === tr[i]);
      }
  }
}
kr.prototype.defined = !0;
function xu(e, t, n) {
  n && (e[t] = n);
}
const x0 = {}.hasOwnProperty;
function Tt(e) {
  const t = {}, n = {};
  let r;
  for (r in e.properties)
    if (x0.call(e.properties, r)) {
      const u = e.properties[r], a = new kr(
        r,
        e.transform(e.attributes || {}, r),
        u,
        e.space
      );
      e.mustUseProperty && e.mustUseProperty.includes(r) && (a.mustUseProperty = !0), t[r] = a, n[Ht(r)] = r, n[Ht(a.attribute)] = r;
    }
  return new Yt(t, n, e.space);
}
const Fi = Tt({
  space: "xlink",
  transform(e, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
}), Hi = Tt({
  space: "xml",
  transform(e, t) {
    return "xml:" + t.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function Ui(e, t) {
  return t in e ? e[t] : t;
}
function vi(e, t) {
  return Ui(e, t.toLowerCase());
}
const zi = Tt({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: vi,
  properties: { xmlns: null, xmlnsXLink: null }
}), Yi = Tt({
  transform(e, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: ue,
    ariaAutoComplete: null,
    ariaBusy: ue,
    ariaChecked: ue,
    ariaColCount: P,
    ariaColIndex: P,
    ariaColSpan: P,
    ariaControls: Z,
    ariaCurrent: null,
    ariaDescribedBy: Z,
    ariaDetails: null,
    ariaDisabled: ue,
    ariaDropEffect: Z,
    ariaErrorMessage: null,
    ariaExpanded: ue,
    ariaFlowTo: Z,
    ariaGrabbed: ue,
    ariaHasPopup: null,
    ariaHidden: ue,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: Z,
    ariaLevel: P,
    ariaLive: null,
    ariaModal: ue,
    ariaMultiLine: ue,
    ariaMultiSelectable: ue,
    ariaOrientation: null,
    ariaOwns: Z,
    ariaPlaceholder: null,
    ariaPosInSet: P,
    ariaPressed: ue,
    ariaReadOnly: ue,
    ariaRelevant: null,
    ariaRequired: ue,
    ariaRoleDescription: Z,
    ariaRowCount: P,
    ariaRowIndex: P,
    ariaRowSpan: P,
    ariaSelected: ue,
    ariaSetSize: P,
    ariaSort: null,
    ariaValueMax: P,
    ariaValueMin: P,
    ariaValueNow: P,
    ariaValueText: null,
    role: null
  }
}), S0 = Tt({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: vi,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: ht,
    acceptCharset: Z,
    accessKey: Z,
    action: null,
    allow: null,
    allowFullScreen: v,
    allowPaymentRequest: v,
    allowUserMedia: v,
    alt: null,
    as: null,
    async: v,
    autoCapitalize: null,
    autoComplete: Z,
    autoFocus: v,
    autoPlay: v,
    blocking: Z,
    capture: null,
    charSet: null,
    checked: v,
    cite: null,
    className: Z,
    cols: P,
    colSpan: null,
    content: null,
    contentEditable: ue,
    controls: v,
    controlsList: Z,
    coords: P | ht,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: v,
    defer: v,
    dir: null,
    dirName: null,
    disabled: v,
    download: Bi,
    draggable: ue,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: v,
    formTarget: null,
    headers: Z,
    height: P,
    hidden: v,
    high: P,
    href: null,
    hrefLang: null,
    htmlFor: Z,
    httpEquiv: Z,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: v,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: v,
    itemId: null,
    itemProp: Z,
    itemRef: Z,
    itemScope: v,
    itemType: Z,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: v,
    low: P,
    manifest: null,
    max: null,
    maxLength: P,
    media: null,
    method: null,
    min: null,
    minLength: P,
    multiple: v,
    muted: v,
    name: null,
    nonce: null,
    noModule: v,
    noValidate: v,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: v,
    optimum: P,
    pattern: null,
    ping: Z,
    placeholder: null,
    playsInline: v,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: v,
    referrerPolicy: null,
    rel: Z,
    required: v,
    reversed: v,
    rows: P,
    rowSpan: P,
    sandbox: Z,
    scope: null,
    scoped: v,
    seamless: v,
    selected: v,
    shadowRootClonable: v,
    shadowRootDelegatesFocus: v,
    shadowRootMode: null,
    shape: null,
    size: P,
    sizes: null,
    slot: null,
    span: P,
    spellCheck: ue,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: P,
    step: null,
    style: null,
    tabIndex: P,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: v,
    useMap: null,
    value: ue,
    width: P,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: Z,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: P,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: P,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: v,
    // Lists. Use CSS to reduce space between items instead
    declare: v,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: P,
    // `<img>` and `<object>`
    leftMargin: P,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: P,
    // `<body>`
    marginWidth: P,
    // `<body>`
    noResize: v,
    // `<frame>`
    noHref: v,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: v,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: v,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: P,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: ue,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: P,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: P,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: v,
    disableRemotePlayback: v,
    prefix: null,
    property: null,
    results: P,
    security: null,
    unselectable: null
  }
}), N0 = Tt({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: Ui,
  properties: {
    about: Te,
    accentHeight: P,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: P,
    amplitude: P,
    arabicForm: null,
    ascent: P,
    attributeName: null,
    attributeType: null,
    azimuth: P,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: P,
    by: null,
    calcMode: null,
    capHeight: P,
    className: Z,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: P,
    diffuseConstant: P,
    direction: null,
    display: null,
    dur: null,
    divisor: P,
    dominantBaseline: null,
    download: v,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: P,
    enableBackground: null,
    end: null,
    event: null,
    exponent: P,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: P,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: ht,
    g2: ht,
    glyphName: ht,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: P,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: P,
    horizOriginX: P,
    horizOriginY: P,
    id: null,
    ideographic: P,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: P,
    k: P,
    k1: P,
    k2: P,
    k3: P,
    k4: P,
    kernelMatrix: Te,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: P,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: P,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: P,
    overlineThickness: P,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: P,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: Z,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: P,
    pointsAtY: P,
    pointsAtZ: P,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: Te,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: Te,
    rev: Te,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: Te,
    requiredFeatures: Te,
    requiredFonts: Te,
    requiredFormats: Te,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: P,
    specularExponent: P,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: P,
    strikethroughThickness: P,
    string: null,
    stroke: null,
    strokeDashArray: Te,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: P,
    strokeOpacity: P,
    strokeWidth: null,
    style: null,
    surfaceScale: P,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: Te,
    tabIndex: P,
    tableValues: null,
    target: null,
    targetX: P,
    targetY: P,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: Te,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: P,
    underlineThickness: P,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: P,
    values: null,
    vAlphabetic: P,
    vMathematical: P,
    vectorEffect: null,
    vHanging: P,
    vIdeographic: P,
    version: null,
    vertAdvY: P,
    vertOriginX: P,
    vertOriginY: P,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: P,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
}), k0 = /^data[-\w.:]+$/i, Su = /-[a-z]/g, O0 = /[A-Z]/g;
function Or(e, t) {
  const n = Ht(t);
  let r = t, u = Ae;
  if (n in e.normal)
    return e.property[e.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && k0.test(t)) {
    if (t.charAt(4) === "-") {
      const a = t.slice(5).replace(Su, L0);
      r = "data" + a.charAt(0).toUpperCase() + a.slice(1);
    } else {
      const a = t.slice(4);
      if (!Su.test(a)) {
        let i = a.replace(O0, y0);
        i.charAt(0) !== "-" && (i = "-" + i), t = "data" + i;
      }
    }
    u = kr;
  }
  return new u(r, t);
}
function y0(e) {
  return "-" + e.toLowerCase();
}
function L0(e) {
  return e.charAt(1).toUpperCase();
}
const In = Mi([Hi, Fi, zi, Yi, S0], "html"), qt = Mi([Hi, Fi, zi, Yi, N0], "svg"), Nu = /[#.]/g;
function R0(e, t) {
  const n = e || "", r = {};
  let u = 0, a, i;
  for (; u < n.length; ) {
    Nu.lastIndex = u;
    const o = Nu.exec(n), l = n.slice(u, o ? o.index : n.length);
    l && (a ? a === "#" ? r.id = l : Array.isArray(r.className) ? r.className.push(l) : r.className = [l] : i = l, u += l.length), o && (a = o[0], u++);
  }
  return {
    type: "element",
    // @ts-expect-error: tag name is parsed.
    tagName: i || t || "div",
    properties: r,
    children: []
  };
}
const nr = {}.hasOwnProperty;
function qi(e, t, n) {
  const r = n && M0(n);
  function u(a, i, ...o) {
    let l = -1, c;
    if (a == null) {
      c = { type: "root", children: [] };
      const h = (
        /** @type {Child} */
        i
      );
      o.unshift(h);
    } else if (c = R0(a, t), c.tagName = c.tagName.toLowerCase(), r && nr.call(r, c.tagName) && (c.tagName = r[c.tagName]), D0(i))
      o.unshift(i);
    else {
      let h;
      for (h in i)
        nr.call(i, h) && P0(e, c.properties, h, i[h]);
    }
    for (; ++l < o.length; )
      rr(c.children, o[l]);
    return c.type === "element" && c.tagName === "template" && (c.content = { type: "root", children: c.children }, c.children = []), c;
  }
  return u;
}
function D0(e) {
  if (e === null || typeof e != "object" || Array.isArray(e))
    return !0;
  if (typeof e.type != "string") return !1;
  const t = (
    /** @type {Record<string, unknown>} */
    e
  ), n = Object.keys(e);
  for (const r of n) {
    const u = t[r];
    if (u && typeof u == "object") {
      if (!Array.isArray(u)) return !0;
      const a = (
        /** @type {Array<unknown>} */
        u
      );
      for (const i of a)
        if (typeof i != "number" && typeof i != "string")
          return !0;
    }
  }
  return !!("children" in e && Array.isArray(e.children));
}
function P0(e, t, n, r) {
  const u = Or(e, n);
  let a = -1, i;
  if (r != null) {
    if (typeof r == "number") {
      if (Number.isNaN(r)) return;
      i = r;
    } else typeof r == "boolean" ? i = r : typeof r == "string" ? u.spaceSeparated ? i = jr(r) : u.commaSeparated ? i = Vr(r) : u.commaOrSpaceSeparated ? i = jr(Vr(r).join(" ")) : i = ku(u, u.property, r) : Array.isArray(r) ? i = r.concat() : i = u.property === "style" ? w0(r) : String(r);
    if (Array.isArray(i)) {
      const o = [];
      for (; ++a < i.length; ) {
        const l = (
          /** @type {number | string} */
          ku(u, u.property, i[a])
        );
        o[a] = l;
      }
      i = o;
    }
    if (u.property === "className" && Array.isArray(t.className)) {
      const o = (
        /** @type {number | string} */
        i
      );
      i = t.className.concat(o);
    }
    t[u.property] = i;
  }
}
function rr(e, t) {
  let n = -1;
  if (t != null) if (typeof t == "string" || typeof t == "number")
    e.push({ type: "text", value: String(t) });
  else if (Array.isArray(t))
    for (; ++n < t.length; )
      rr(e, t[n]);
  else if (typeof t == "object" && "type" in t)
    t.type === "root" ? rr(e, t.children) : e.push(t);
  else
    throw new Error("Expected node, nodes, or string, got `" + t + "`");
}
function ku(e, t, n) {
  if (typeof n == "string") {
    if (e.number && n && !Number.isNaN(Number(n)))
      return Number(n);
    if ((e.boolean || e.overloadedBoolean) && (n === "" || Ht(n) === Ht(t)))
      return !0;
  }
  return n;
}
function w0(e) {
  const t = [];
  let n;
  for (n in e)
    nr.call(e, n) && t.push([n, e[n]].join(": "));
  return t.join("; ");
}
function M0(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; )
    t[e[n].toLowerCase()] = e[n];
  return t;
}
const B0 = [
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "solidColor",
  "textArea",
  "textPath"
], F0 = qi(In, "div"), H0 = qi(qt, "g", B0);
function U0(e) {
  const t = String(e), n = [];
  return { toOffset: u, toPoint: r };
  function r(a) {
    if (typeof a == "number" && a > -1 && a <= t.length) {
      let i = 0;
      for (; ; ) {
        let o = n[i];
        if (o === void 0) {
          const l = Ou(t, n[i - 1]);
          o = l === -1 ? t.length + 1 : l + 1, n[i] = o;
        }
        if (o > a)
          return {
            line: i + 1,
            column: a - (i > 0 ? n[i - 1] : 0) + 1,
            offset: a
          };
        i++;
      }
    }
  }
  function u(a) {
    if (a && typeof a.line == "number" && typeof a.column == "number" && !Number.isNaN(a.line) && !Number.isNaN(a.column)) {
      for (; n.length < a.line; ) {
        const o = n[n.length - 1], l = Ou(t, o), c = l === -1 ? t.length + 1 : l + 1;
        if (o === c) break;
        n.push(c);
      }
      const i = (a.line > 1 ? n[a.line - 2] : 0) + a.column - 1;
      if (i < n[a.line - 1]) return i;
    }
  }
}
function Ou(e, t) {
  const n = e.indexOf("\r", t), r = e.indexOf(`
`, t);
  return r === -1 ? n : n === -1 || n + 1 === r ? r : n < r ? n : r;
}
const Je = {
  html: "http://www.w3.org/1999/xhtml",
  mathml: "http://www.w3.org/1998/Math/MathML",
  svg: "http://www.w3.org/2000/svg",
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
}, ji = {}.hasOwnProperty, v0 = Object.prototype;
function z0(e, t) {
  const n = t || {};
  return yr(
    {
      file: n.file || void 0,
      location: !1,
      schema: n.space === "svg" ? qt : In,
      verbose: n.verbose || !1
    },
    e
  );
}
function yr(e, t) {
  let n;
  switch (t.nodeName) {
    case "#comment": {
      const r = (
        /** @type {DefaultTreeAdapterMap['commentNode']} */
        t
      );
      return n = { type: "comment", value: r.data }, rn(e, r, n), n;
    }
    case "#document":
    case "#document-fragment": {
      const r = (
        /** @type {DefaultTreeAdapterMap['document'] | DefaultTreeAdapterMap['documentFragment']} */
        t
      ), u = "mode" in r ? r.mode === "quirks" || r.mode === "limited-quirks" : !1;
      if (n = {
        type: "root",
        children: Vi(e, t.childNodes),
        data: { quirksMode: u }
      }, e.file && e.location) {
        const a = String(e.file), i = U0(a), o = i.toPoint(0), l = i.toPoint(a.length);
        n.position = { start: o, end: l };
      }
      return n;
    }
    case "#documentType": {
      const r = (
        /** @type {DefaultTreeAdapterMap['documentType']} */
        t
      );
      return n = { type: "doctype" }, rn(e, r, n), n;
    }
    case "#text": {
      const r = (
        /** @type {DefaultTreeAdapterMap['textNode']} */
        t
      );
      return n = { type: "text", value: r.value }, rn(e, r, n), n;
    }
    // Element.
    default:
      return n = Y0(
        e,
        /** @type {DefaultTreeAdapterMap['element']} */
        t
      ), n;
  }
}
function Vi(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; ) {
    const u = (
      /** @type {RootContent} */
      yr(e, t[n])
    );
    r.push(u);
  }
  return r;
}
function Y0(e, t) {
  const n = e.schema;
  e.schema = t.namespaceURI === Je.svg ? qt : In;
  let r = -1;
  const u = {};
  for (; ++r < t.attrs.length; ) {
    const o = t.attrs[r], l = (o.prefix ? o.prefix + ":" : "") + o.name;
    ji.call(v0, l) || (u[l] = o.value);
  }
  const i = (e.schema.space === "svg" ? H0 : F0)(t.tagName, u, Vi(e, t.childNodes));
  if (rn(e, t, i), i.tagName === "template") {
    const o = (
      /** @type {DefaultTreeAdapterMap['template']} */
      t
    ), l = o.sourceCodeLocation, c = l && l.startTag && ct(l.startTag), h = l && l.endTag && ct(l.endTag), f = (
      /** @type {Root} */
      yr(e, o.content)
    );
    c && h && e.file && (f.position = { start: c.end, end: h.start }), i.content = f;
  }
  return e.schema = n, i;
}
function rn(e, t, n) {
  if ("sourceCodeLocation" in t && t.sourceCodeLocation && e.file) {
    const r = q0(e, n, t.sourceCodeLocation);
    r && (e.location = !0, n.position = r);
  }
}
function q0(e, t, n) {
  const r = ct(n);
  if (t.type === "element") {
    const u = t.children[t.children.length - 1];
    if (r && !n.endTag && u && u.position && u.position.end && (r.end = Object.assign({}, u.position.end)), e.verbose) {
      const a = {};
      let i;
      if (n.attrs)
        for (i in n.attrs)
          ji.call(n.attrs, i) && (a[Or(e.schema, i).property] = ct(
            n.attrs[i]
          ));
      Me(n.startTag);
      const o = ct(n.startTag), l = n.endTag ? ct(n.endTag) : void 0, c = { opening: o };
      l && (c.closing = l), c.properties = a, t.data = { position: c };
    }
  }
  return r;
}
function ct(e) {
  const t = yu({
    line: e.startLine,
    column: e.startCol,
    offset: e.startOffset
  }), n = yu({
    line: e.endLine,
    column: e.endCol,
    offset: e.endOffset
  });
  return t || n ? { start: t, end: n } : void 0;
}
function yu(e) {
  return e.line && e.column ? e : void 0;
}
const j0 = {}, V0 = {}.hasOwnProperty, Wi = ci("type", { handlers: { root: Q0, element: J0, text: K0, comment: $0, doctype: X0 } });
function W0(e, t) {
  const r = (t || j0).space;
  return Wi(e, r === "svg" ? qt : In);
}
function Q0(e, t) {
  const n = {
    nodeName: "#document",
    // @ts-expect-error: `parse5` uses enums, which are actually strings.
    mode: (e.data || {}).quirksMode ? "quirks" : "no-quirks",
    childNodes: []
  };
  return n.childNodes = Lr(e.children, n, t), gt(e, n), n;
}
function G0(e, t) {
  const n = { nodeName: "#document-fragment", childNodes: [] };
  return n.childNodes = Lr(e.children, n, t), gt(e, n), n;
}
function X0(e) {
  const t = {
    nodeName: "#documentType",
    name: "html",
    publicId: "",
    systemId: "",
    parentNode: null
  };
  return gt(e, t), t;
}
function K0(e) {
  const t = {
    nodeName: "#text",
    value: e.value,
    parentNode: null
  };
  return gt(e, t), t;
}
function $0(e) {
  const t = {
    nodeName: "#comment",
    data: e.value,
    parentNode: null
  };
  return gt(e, t), t;
}
function J0(e, t) {
  const n = t;
  let r = n;
  e.type === "element" && e.tagName.toLowerCase() === "svg" && n.space === "html" && (r = qt);
  const u = [];
  let a;
  if (e.properties) {
    for (a in e.properties)
      if (a !== "children" && V0.call(e.properties, a)) {
        const l = Z0(
          r,
          a,
          e.properties[a]
        );
        l && u.push(l);
      }
  }
  const i = r.space, o = {
    nodeName: e.tagName,
    tagName: e.tagName,
    attrs: u,
    // @ts-expect-error: `parse5` types are wrong.
    namespaceURI: Je[i],
    childNodes: [],
    parentNode: null
  };
  return o.childNodes = Lr(e.children, o, r), gt(e, o), e.tagName === "template" && e.content && (o.content = G0(e.content, r)), o;
}
function Z0(e, t, n) {
  const r = Or(e, t);
  if (n === !1 || n === null || n === void 0 || typeof n == "number" && Number.isNaN(n) || !n && r.boolean)
    return;
  Array.isArray(n) && (n = r.commaSeparated ? Ls(n) : Rs(n));
  const u = {
    name: r.attribute,
    value: n === !0 ? "" : String(n)
  };
  if (r.space && r.space !== "html" && r.space !== "svg") {
    const a = u.name.indexOf(":");
    a < 0 ? u.prefix = "" : (u.name = u.name.slice(a + 1), u.prefix = r.attribute.slice(0, a)), u.namespace = Je[r.space];
  }
  return u;
}
function Lr(e, t, n) {
  let r = -1;
  const u = [];
  if (e)
    for (; ++r < e.length; ) {
      const a = Wi(e[r], n);
      a.parentNode = t, u.push(a);
    }
  return u;
}
function gt(e, t) {
  const n = e.position;
  n && n.start && n.end && (Me(typeof n.start.offset == "number"), Me(typeof n.end.offset == "number"), t.sourceCodeLocation = {
    startLine: n.start.line,
    startCol: n.start.column,
    startOffset: n.start.offset,
    endLine: n.end.line,
    endCol: n.end.column,
    endOffset: n.end.offset
  });
}
const ef = /* @__PURE__ */ new Set([
  65534,
  65535,
  131070,
  131071,
  196606,
  196607,
  262142,
  262143,
  327678,
  327679,
  393214,
  393215,
  458750,
  458751,
  524286,
  524287,
  589822,
  589823,
  655358,
  655359,
  720894,
  720895,
  786430,
  786431,
  851966,
  851967,
  917502,
  917503,
  983038,
  983039,
  1048574,
  1048575,
  1114110,
  1114111
]), te = "�";
var m;
(function(e) {
  e[e.EOF = -1] = "EOF", e[e.NULL = 0] = "NULL", e[e.TABULATION = 9] = "TABULATION", e[e.CARRIAGE_RETURN = 13] = "CARRIAGE_RETURN", e[e.LINE_FEED = 10] = "LINE_FEED", e[e.FORM_FEED = 12] = "FORM_FEED", e[e.SPACE = 32] = "SPACE", e[e.EXCLAMATION_MARK = 33] = "EXCLAMATION_MARK", e[e.QUOTATION_MARK = 34] = "QUOTATION_MARK", e[e.AMPERSAND = 38] = "AMPERSAND", e[e.APOSTROPHE = 39] = "APOSTROPHE", e[e.HYPHEN_MINUS = 45] = "HYPHEN_MINUS", e[e.SOLIDUS = 47] = "SOLIDUS", e[e.DIGIT_0 = 48] = "DIGIT_0", e[e.DIGIT_9 = 57] = "DIGIT_9", e[e.SEMICOLON = 59] = "SEMICOLON", e[e.LESS_THAN_SIGN = 60] = "LESS_THAN_SIGN", e[e.EQUALS_SIGN = 61] = "EQUALS_SIGN", e[e.GREATER_THAN_SIGN = 62] = "GREATER_THAN_SIGN", e[e.QUESTION_MARK = 63] = "QUESTION_MARK", e[e.LATIN_CAPITAL_A = 65] = "LATIN_CAPITAL_A", e[e.LATIN_CAPITAL_Z = 90] = "LATIN_CAPITAL_Z", e[e.RIGHT_SQUARE_BRACKET = 93] = "RIGHT_SQUARE_BRACKET", e[e.GRAVE_ACCENT = 96] = "GRAVE_ACCENT", e[e.LATIN_SMALL_A = 97] = "LATIN_SMALL_A", e[e.LATIN_SMALL_Z = 122] = "LATIN_SMALL_Z";
})(m || (m = {}));
const me = {
  DASH_DASH: "--",
  CDATA_START: "[CDATA[",
  DOCTYPE: "doctype",
  SCRIPT: "script",
  PUBLIC: "public",
  SYSTEM: "system"
};
function Qi(e) {
  return e >= 55296 && e <= 57343;
}
function tf(e) {
  return e >= 56320 && e <= 57343;
}
function nf(e, t) {
  return (e - 55296) * 1024 + 9216 + t;
}
function Gi(e) {
  return e !== 32 && e !== 10 && e !== 13 && e !== 9 && e !== 12 && e >= 1 && e <= 31 || e >= 127 && e <= 159;
}
function Xi(e) {
  return e >= 64976 && e <= 65007 || ef.has(e);
}
var I;
(function(e) {
  e.controlCharacterInInputStream = "control-character-in-input-stream", e.noncharacterInInputStream = "noncharacter-in-input-stream", e.surrogateInInputStream = "surrogate-in-input-stream", e.nonVoidHtmlElementStartTagWithTrailingSolidus = "non-void-html-element-start-tag-with-trailing-solidus", e.endTagWithAttributes = "end-tag-with-attributes", e.endTagWithTrailingSolidus = "end-tag-with-trailing-solidus", e.unexpectedSolidusInTag = "unexpected-solidus-in-tag", e.unexpectedNullCharacter = "unexpected-null-character", e.unexpectedQuestionMarkInsteadOfTagName = "unexpected-question-mark-instead-of-tag-name", e.invalidFirstCharacterOfTagName = "invalid-first-character-of-tag-name", e.unexpectedEqualsSignBeforeAttributeName = "unexpected-equals-sign-before-attribute-name", e.missingEndTagName = "missing-end-tag-name", e.unexpectedCharacterInAttributeName = "unexpected-character-in-attribute-name", e.unknownNamedCharacterReference = "unknown-named-character-reference", e.missingSemicolonAfterCharacterReference = "missing-semicolon-after-character-reference", e.unexpectedCharacterAfterDoctypeSystemIdentifier = "unexpected-character-after-doctype-system-identifier", e.unexpectedCharacterInUnquotedAttributeValue = "unexpected-character-in-unquoted-attribute-value", e.eofBeforeTagName = "eof-before-tag-name", e.eofInTag = "eof-in-tag", e.missingAttributeValue = "missing-attribute-value", e.missingWhitespaceBetweenAttributes = "missing-whitespace-between-attributes", e.missingWhitespaceAfterDoctypePublicKeyword = "missing-whitespace-after-doctype-public-keyword", e.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers = "missing-whitespace-between-doctype-public-and-system-identifiers", e.missingWhitespaceAfterDoctypeSystemKeyword = "missing-whitespace-after-doctype-system-keyword", e.missingQuoteBeforeDoctypePublicIdentifier = "missing-quote-before-doctype-public-identifier", e.missingQuoteBeforeDoctypeSystemIdentifier = "missing-quote-before-doctype-system-identifier", e.missingDoctypePublicIdentifier = "missing-doctype-public-identifier", e.missingDoctypeSystemIdentifier = "missing-doctype-system-identifier", e.abruptDoctypePublicIdentifier = "abrupt-doctype-public-identifier", e.abruptDoctypeSystemIdentifier = "abrupt-doctype-system-identifier", e.cdataInHtmlContent = "cdata-in-html-content", e.incorrectlyOpenedComment = "incorrectly-opened-comment", e.eofInScriptHtmlCommentLikeText = "eof-in-script-html-comment-like-text", e.eofInDoctype = "eof-in-doctype", e.nestedComment = "nested-comment", e.abruptClosingOfEmptyComment = "abrupt-closing-of-empty-comment", e.eofInComment = "eof-in-comment", e.incorrectlyClosedComment = "incorrectly-closed-comment", e.eofInCdata = "eof-in-cdata", e.absenceOfDigitsInNumericCharacterReference = "absence-of-digits-in-numeric-character-reference", e.nullCharacterReference = "null-character-reference", e.surrogateCharacterReference = "surrogate-character-reference", e.characterReferenceOutsideUnicodeRange = "character-reference-outside-unicode-range", e.controlCharacterReference = "control-character-reference", e.noncharacterCharacterReference = "noncharacter-character-reference", e.missingWhitespaceBeforeDoctypeName = "missing-whitespace-before-doctype-name", e.missingDoctypeName = "missing-doctype-name", e.invalidCharacterSequenceAfterDoctypeName = "invalid-character-sequence-after-doctype-name", e.duplicateAttribute = "duplicate-attribute", e.nonConformingDoctype = "non-conforming-doctype", e.missingDoctype = "missing-doctype", e.misplacedDoctype = "misplaced-doctype", e.endTagWithoutMatchingOpenElement = "end-tag-without-matching-open-element", e.closingOfElementWithOpenChildElements = "closing-of-element-with-open-child-elements", e.disallowedContentInNoscriptInHead = "disallowed-content-in-noscript-in-head", e.openElementsLeftAfterEof = "open-elements-left-after-eof", e.abandonedHeadElementChild = "abandoned-head-element-child", e.misplacedStartTagForHeadElement = "misplaced-start-tag-for-head-element", e.nestedNoscriptInHead = "nested-noscript-in-head", e.eofInElementThatCanContainOnlyText = "eof-in-element-that-can-contain-only-text";
})(I || (I = {}));
const rf = 65536;
class uf {
  constructor(t) {
    this.handler = t, this.html = "", this.pos = -1, this.lastGapPos = -2, this.gapStack = [], this.skipNextNewLine = !1, this.lastChunkWritten = !1, this.endOfChunkHit = !1, this.bufferWaterline = rf, this.isEol = !1, this.lineStartPos = 0, this.droppedBufferSize = 0, this.line = 1, this.lastErrOffset = -1;
  }
  /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */
  get col() {
    return this.pos - this.lineStartPos + +(this.lastGapPos !== this.pos);
  }
  get offset() {
    return this.droppedBufferSize + this.pos;
  }
  getError(t, n) {
    const { line: r, col: u, offset: a } = this, i = u + n, o = a + n;
    return {
      code: t,
      startLine: r,
      endLine: r,
      startCol: i,
      endCol: i,
      startOffset: o,
      endOffset: o
    };
  }
  _err(t) {
    this.handler.onParseError && this.lastErrOffset !== this.offset && (this.lastErrOffset = this.offset, this.handler.onParseError(this.getError(t, 0)));
  }
  _addGap() {
    this.gapStack.push(this.lastGapPos), this.lastGapPos = this.pos;
  }
  _processSurrogate(t) {
    if (this.pos !== this.html.length - 1) {
      const n = this.html.charCodeAt(this.pos + 1);
      if (tf(n))
        return this.pos++, this._addGap(), nf(t, n);
    } else if (!this.lastChunkWritten)
      return this.endOfChunkHit = !0, m.EOF;
    return this._err(I.surrogateInInputStream), t;
  }
  willDropParsedChunk() {
    return this.pos > this.bufferWaterline;
  }
  dropParsedChunk() {
    this.willDropParsedChunk() && (this.html = this.html.substring(this.pos), this.lineStartPos -= this.pos, this.droppedBufferSize += this.pos, this.pos = 0, this.lastGapPos = -2, this.gapStack.length = 0);
  }
  write(t, n) {
    this.html.length > 0 ? this.html += t : this.html = t, this.endOfChunkHit = !1, this.lastChunkWritten = n;
  }
  insertHtmlAtCurrentPos(t) {
    this.html = this.html.substring(0, this.pos + 1) + t + this.html.substring(this.pos + 1), this.endOfChunkHit = !1;
  }
  startsWith(t, n) {
    if (this.pos + t.length > this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, !1;
    if (n)
      return this.html.startsWith(t, this.pos);
    for (let r = 0; r < t.length; r++)
      if ((this.html.charCodeAt(this.pos + r) | 32) !== t.charCodeAt(r))
        return !1;
    return !0;
  }
  peek(t) {
    const n = this.pos + t;
    if (n >= this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, m.EOF;
    const r = this.html.charCodeAt(n);
    return r === m.CARRIAGE_RETURN ? m.LINE_FEED : r;
  }
  advance() {
    if (this.pos++, this.isEol && (this.isEol = !1, this.line++, this.lineStartPos = this.pos), this.pos >= this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, m.EOF;
    let t = this.html.charCodeAt(this.pos);
    return t === m.CARRIAGE_RETURN ? (this.isEol = !0, this.skipNextNewLine = !0, m.LINE_FEED) : t === m.LINE_FEED && (this.isEol = !0, this.skipNextNewLine) ? (this.line--, this.skipNextNewLine = !1, this._addGap(), this.advance()) : (this.skipNextNewLine = !1, Qi(t) && (t = this._processSurrogate(t)), this.handler.onParseError === null || t > 31 && t < 127 || t === m.LINE_FEED || t === m.CARRIAGE_RETURN || t > 159 && t < 64976 || this._checkForProblematicCharacters(t), t);
  }
  _checkForProblematicCharacters(t) {
    Gi(t) ? this._err(I.controlCharacterInInputStream) : Xi(t) && this._err(I.noncharacterInInputStream);
  }
  retreat(t) {
    for (this.pos -= t; this.pos < this.lastGapPos; )
      this.lastGapPos = this.gapStack.pop(), this.pos--;
    this.isEol = !1;
  }
}
var q;
(function(e) {
  e[e.CHARACTER = 0] = "CHARACTER", e[e.NULL_CHARACTER = 1] = "NULL_CHARACTER", e[e.WHITESPACE_CHARACTER = 2] = "WHITESPACE_CHARACTER", e[e.START_TAG = 3] = "START_TAG", e[e.END_TAG = 4] = "END_TAG", e[e.COMMENT = 5] = "COMMENT", e[e.DOCTYPE = 6] = "DOCTYPE", e[e.EOF = 7] = "EOF", e[e.HIBERNATION = 8] = "HIBERNATION";
})(q || (q = {}));
function Ki(e, t) {
  for (let n = e.attrs.length - 1; n >= 0; n--)
    if (e.attrs[n].name === t)
      return e.attrs[n].value;
  return null;
}
const $i = new Uint16Array(
  // prettier-ignore
  'ᵁ<Õıʊҝջאٵ۞ޢߖࠏ੊ઑඡ๭༉༦჊ረዡᐕᒝᓃᓟᔥ\0\0\0\0\0\0ᕫᛍᦍᰒᷝ὾⁠↰⊍⏀⏻⑂⠤⤒ⴈ⹈⿎〖㊺㘹㞬㣾㨨㩱㫠㬮ࠀEMabcfglmnoprstu\\bfms¦³¹ÈÏlig耻Æ䃆P耻&䀦cute耻Á䃁reve;䄂Āiyx}rc耻Â䃂;䐐r;쀀𝔄rave耻À䃀pha;䎑acr;䄀d;橓Āgp¡on;䄄f;쀀𝔸plyFunction;恡ing耻Å䃅Ācs¾Ãr;쀀𝒜ign;扔ilde耻Ã䃃ml耻Ä䃄ЀaceforsuåûþėĜĢħĪĀcrêòkslash;或Ŷöø;櫧ed;挆y;䐑ƀcrtąċĔause;戵noullis;愬a;䎒r;쀀𝔅pf;쀀𝔹eve;䋘còēmpeq;扎܀HOacdefhilorsuōőŖƀƞƢƵƷƺǜȕɳɸɾcy;䐧PY耻©䂩ƀcpyŝŢźute;䄆Ā;iŧŨ拒talDifferentialD;慅leys;愭ȀaeioƉƎƔƘron;䄌dil耻Ç䃇rc;䄈nint;戰ot;䄊ĀdnƧƭilla;䂸terDot;䂷òſi;䎧rcleȀDMPTǇǋǑǖot;抙inus;抖lus;投imes;抗oĀcsǢǸkwiseContourIntegral;戲eCurlyĀDQȃȏoubleQuote;思uote;怙ȀlnpuȞȨɇɕonĀ;eȥȦ户;橴ƀgitȯȶȺruent;扡nt;戯ourIntegral;戮ĀfrɌɎ;愂oduct;成nterClockwiseContourIntegral;戳oss;樯cr;쀀𝒞pĀ;Cʄʅ拓ap;才րDJSZacefiosʠʬʰʴʸˋ˗ˡ˦̳ҍĀ;oŹʥtrahd;椑cy;䐂cy;䐅cy;䐏ƀgrsʿ˄ˇger;怡r;憡hv;櫤Āayː˕ron;䄎;䐔lĀ;t˝˞戇a;䎔r;쀀𝔇Āaf˫̧Ācm˰̢riticalȀADGT̖̜̀̆cute;䂴oŴ̋̍;䋙bleAcute;䋝rave;䁠ilde;䋜ond;拄ferentialD;慆Ѱ̽\0\0\0͔͂\0Ѕf;쀀𝔻ƀ;DE͈͉͍䂨ot;惜qual;扐blèCDLRUVͣͲ΂ϏϢϸontourIntegraìȹoɴ͹\0\0ͻ»͉nArrow;懓Āeo·ΤftƀARTΐΖΡrrow;懐ightArrow;懔eåˊngĀLRΫτeftĀARγιrrow;柸ightArrow;柺ightArrow;柹ightĀATϘϞrrow;懒ee;抨pɁϩ\0\0ϯrrow;懑ownArrow;懕erticalBar;戥ǹABLRTaВЪаўѿͼrrowƀ;BUНОТ憓ar;椓pArrow;懵reve;䌑eft˒к\0ц\0ѐightVector;楐eeVector;楞ectorĀ;Bљњ憽ar;楖ightǔѧ\0ѱeeVector;楟ectorĀ;BѺѻ懁ar;楗eeĀ;A҆҇护rrow;憧ĀctҒҗr;쀀𝒟rok;䄐ࠀNTacdfglmopqstuxҽӀӄӋӞӢӧӮӵԡԯԶՒ՝ՠեG;䅊H耻Ð䃐cute耻É䃉ƀaiyӒӗӜron;䄚rc耻Ê䃊;䐭ot;䄖r;쀀𝔈rave耻È䃈ement;戈ĀapӺӾcr;䄒tyɓԆ\0\0ԒmallSquare;旻erySmallSquare;斫ĀgpԦԪon;䄘f;쀀𝔼silon;䎕uĀaiԼՉlĀ;TՂՃ橵ilde;扂librium;懌Āci՗՚r;愰m;橳a;䎗ml耻Ë䃋Āipժկsts;戃onentialE;慇ʀcfiosօֈ֍ֲ׌y;䐤r;쀀𝔉lledɓ֗\0\0֣mallSquare;旼erySmallSquare;斪Ͱֺ\0ֿ\0\0ׄf;쀀𝔽All;戀riertrf;愱cò׋؀JTabcdfgorstר׬ׯ׺؀ؒؖ؛؝أ٬ٲcy;䐃耻>䀾mmaĀ;d׷׸䎓;䏜reve;䄞ƀeiy؇،ؐdil;䄢rc;䄜;䐓ot;䄠r;쀀𝔊;拙pf;쀀𝔾eater̀EFGLSTصلَٖٛ٦qualĀ;Lؾؿ扥ess;招ullEqual;执reater;檢ess;扷lantEqual;橾ilde;扳cr;쀀𝒢;扫ЀAacfiosuڅڋږڛڞڪھۊRDcy;䐪Āctڐڔek;䋇;䁞irc;䄤r;愌lbertSpace;愋ǰگ\0ڲf;愍izontalLine;攀Āctۃۅòکrok;䄦mpńېۘownHumðįqual;扏܀EJOacdfgmnostuۺ۾܃܇܎ܚܞܡܨ݄ݸދޏޕcy;䐕lig;䄲cy;䐁cute耻Í䃍Āiyܓܘrc耻Î䃎;䐘ot;䄰r;愑rave耻Ì䃌ƀ;apܠܯܿĀcgܴܷr;䄪inaryI;慈lieóϝǴ݉\0ݢĀ;eݍݎ戬Āgrݓݘral;戫section;拂isibleĀCTݬݲomma;恣imes;恢ƀgptݿރވon;䄮f;쀀𝕀a;䎙cr;愐ilde;䄨ǫޚ\0ޞcy;䐆l耻Ï䃏ʀcfosuެ޷޼߂ߐĀiyޱ޵rc;䄴;䐙r;쀀𝔍pf;쀀𝕁ǣ߇\0ߌr;쀀𝒥rcy;䐈kcy;䐄΀HJacfosߤߨ߽߬߱ࠂࠈcy;䐥cy;䐌ppa;䎚Āey߶߻dil;䄶;䐚r;쀀𝔎pf;쀀𝕂cr;쀀𝒦րJTaceflmostࠥࠩࠬࡐࡣ঳সে্਷ੇcy;䐉耻<䀼ʀcmnpr࠷࠼ࡁࡄࡍute;䄹bda;䎛g;柪lacetrf;愒r;憞ƀaeyࡗ࡜ࡡron;䄽dil;䄻;䐛Āfsࡨ॰tԀACDFRTUVarࡾࢩࢱࣦ࣠ࣼयज़ΐ४Ānrࢃ࢏gleBracket;柨rowƀ;BR࢙࢚࢞憐ar;懤ightArrow;懆eiling;挈oǵࢷ\0ࣃbleBracket;柦nǔࣈ\0࣒eeVector;楡ectorĀ;Bࣛࣜ懃ar;楙loor;挊ightĀAV࣯ࣵrrow;憔ector;楎Āerँगeƀ;AVउऊऐ抣rrow;憤ector;楚iangleƀ;BEतथऩ抲ar;槏qual;抴pƀDTVषूौownVector;楑eeVector;楠ectorĀ;Bॖॗ憿ar;楘ectorĀ;B॥०憼ar;楒ightáΜs̀EFGLSTॾঋকঝঢভqualGreater;拚ullEqual;扦reater;扶ess;檡lantEqual;橽ilde;扲r;쀀𝔏Ā;eঽা拘ftarrow;懚idot;䄿ƀnpw৔ਖਛgȀLRlr৞৷ਂਐeftĀAR০৬rrow;柵ightArrow;柷ightArrow;柶eftĀarγਊightáοightáϊf;쀀𝕃erĀLRਢਬeftArrow;憙ightArrow;憘ƀchtਾੀੂòࡌ;憰rok;䅁;扪Ѐacefiosuਗ਼੝੠੷੼અઋ઎p;椅y;䐜Ādl੥੯iumSpace;恟lintrf;愳r;쀀𝔐nusPlus;戓pf;쀀𝕄cò੶;䎜ҀJacefostuણધભીଔଙඑ඗ඞcy;䐊cute;䅃ƀaey઴હાron;䅇dil;䅅;䐝ƀgswે૰଎ativeƀMTV૓૟૨ediumSpace;怋hiĀcn૦૘ë૙eryThiî૙tedĀGL૸ଆreaterGreateòٳessLesóੈLine;䀊r;쀀𝔑ȀBnptଢନଷ଺reak;恠BreakingSpace;䂠f;愕ڀ;CDEGHLNPRSTV୕ୖ୪୼஡௫ఄ౞಄ದ೘ൡඅ櫬Āou୛୤ngruent;扢pCap;扭oubleVerticalBar;戦ƀlqxஃஊ஛ement;戉ualĀ;Tஒஓ扠ilde;쀀≂̸ists;戄reater΀;EFGLSTஶஷ஽௉௓௘௥扯qual;扱ullEqual;쀀≧̸reater;쀀≫̸ess;批lantEqual;쀀⩾̸ilde;扵umpń௲௽ownHump;쀀≎̸qual;쀀≏̸eĀfsఊధtTriangleƀ;BEచఛడ拪ar;쀀⧏̸qual;括s̀;EGLSTవశ఼ౄోౘ扮qual;扰reater;扸ess;쀀≪̸lantEqual;쀀⩽̸ilde;扴estedĀGL౨౹reaterGreater;쀀⪢̸essLess;쀀⪡̸recedesƀ;ESಒಓಛ技qual;쀀⪯̸lantEqual;拠ĀeiಫಹverseElement;戌ghtTriangleƀ;BEೋೌ೒拫ar;쀀⧐̸qual;拭ĀquೝഌuareSuĀbp೨೹setĀ;E೰ೳ쀀⊏̸qual;拢ersetĀ;Eഃആ쀀⊐̸qual;拣ƀbcpഓതൎsetĀ;Eഛഞ쀀⊂⃒qual;抈ceedsȀ;ESTലള഻െ抁qual;쀀⪰̸lantEqual;拡ilde;쀀≿̸ersetĀ;E൘൛쀀⊃⃒qual;抉ildeȀ;EFT൮൯൵ൿ扁qual;扄ullEqual;扇ilde;扉erticalBar;戤cr;쀀𝒩ilde耻Ñ䃑;䎝܀Eacdfgmoprstuvලෂ෉෕ෛ෠෧෼ขภยา฿ไlig;䅒cute耻Ó䃓Āiy෎ීrc耻Ô䃔;䐞blac;䅐r;쀀𝔒rave耻Ò䃒ƀaei෮ෲ෶cr;䅌ga;䎩cron;䎟pf;쀀𝕆enCurlyĀDQฎบoubleQuote;怜uote;怘;橔Āclวฬr;쀀𝒪ash耻Ø䃘iŬื฼de耻Õ䃕es;樷ml耻Ö䃖erĀBP๋๠Āar๐๓r;怾acĀek๚๜;揞et;掴arenthesis;揜Ҁacfhilors๿ງຊຏຒດຝະ໼rtialD;戂y;䐟r;쀀𝔓i;䎦;䎠usMinus;䂱Āipຢອncareplanåڝf;愙Ȁ;eio຺ູ໠໤檻cedesȀ;EST່້໏໚扺qual;檯lantEqual;扼ilde;找me;怳Ādp໩໮uct;戏ortionĀ;aȥ໹l;戝Āci༁༆r;쀀𝒫;䎨ȀUfos༑༖༛༟OT耻"䀢r;쀀𝔔pf;愚cr;쀀𝒬؀BEacefhiorsu༾གྷཇའཱིྦྷྪྭ႖ႩႴႾarr;椐G耻®䂮ƀcnrཎནབute;䅔g;柫rĀ;tཛྷཝ憠l;椖ƀaeyཧཬཱron;䅘dil;䅖;䐠Ā;vླྀཹ愜erseĀEUྂྙĀlq྇ྎement;戋uilibrium;懋pEquilibrium;楯r»ཹo;䎡ghtЀACDFTUVa࿁࿫࿳ဢဨၛႇϘĀnr࿆࿒gleBracket;柩rowƀ;BL࿜࿝࿡憒ar;懥eftArrow;懄eiling;按oǵ࿹\0စbleBracket;柧nǔည\0နeeVector;楝ectorĀ;Bဝသ懂ar;楕loor;挋Āerိ၃eƀ;AVဵံြ抢rrow;憦ector;楛iangleƀ;BEၐၑၕ抳ar;槐qual;抵pƀDTVၣၮၸownVector;楏eeVector;楜ectorĀ;Bႂႃ憾ar;楔ectorĀ;B႑႒懀ar;楓Āpuႛ႞f;愝ndImplies;楰ightarrow;懛ĀchႹႼr;愛;憱leDelayed;槴ڀHOacfhimoqstuფჱჷჽᄙᄞᅑᅖᅡᅧᆵᆻᆿĀCcჩხHcy;䐩y;䐨FTcy;䐬cute;䅚ʀ;aeiyᄈᄉᄎᄓᄗ檼ron;䅠dil;䅞rc;䅜;䐡r;쀀𝔖ortȀDLRUᄪᄴᄾᅉownArrow»ОeftArrow»࢚ightArrow»࿝pArrow;憑gma;䎣allCircle;战pf;쀀𝕊ɲᅭ\0\0ᅰt;戚areȀ;ISUᅻᅼᆉᆯ斡ntersection;抓uĀbpᆏᆞsetĀ;Eᆗᆘ抏qual;抑ersetĀ;Eᆨᆩ抐qual;抒nion;抔cr;쀀𝒮ar;拆ȀbcmpᇈᇛሉላĀ;sᇍᇎ拐etĀ;Eᇍᇕqual;抆ĀchᇠህeedsȀ;ESTᇭᇮᇴᇿ扻qual;檰lantEqual;扽ilde;承Tháྌ;我ƀ;esሒሓሣ拑rsetĀ;Eሜም抃qual;抇et»ሓրHRSacfhiorsሾቄ቉ቕ቞ቱቶኟዂወዑORN耻Þ䃞ADE;愢ĀHc቎ቒcy;䐋y;䐦Ābuቚቜ;䀉;䎤ƀaeyብቪቯron;䅤dil;䅢;䐢r;쀀𝔗Āeiቻ኉ǲኀ\0ኇefore;戴a;䎘Ācn኎ኘkSpace;쀀  Space;怉ldeȀ;EFTካኬኲኼ戼qual;扃ullEqual;扅ilde;扈pf;쀀𝕋ipleDot;惛Āctዖዛr;쀀𝒯rok;䅦ૡዷጎጚጦ\0ጬጱ\0\0\0\0\0ጸጽ፷ᎅ\0᏿ᐄᐊᐐĀcrዻጁute耻Ú䃚rĀ;oጇገ憟cir;楉rǣጓ\0጖y;䐎ve;䅬Āiyጞጣrc耻Û䃛;䐣blac;䅰r;쀀𝔘rave耻Ù䃙acr;䅪Ādiፁ፩erĀBPፈ፝Āarፍፐr;䁟acĀekፗፙ;揟et;掵arenthesis;揝onĀ;P፰፱拃lus;抎Āgp፻፿on;䅲f;쀀𝕌ЀADETadps᎕ᎮᎸᏄϨᏒᏗᏳrrowƀ;BDᅐᎠᎤar;椒ownArrow;懅ownArrow;憕quilibrium;楮eeĀ;AᏋᏌ报rrow;憥ownáϳerĀLRᏞᏨeftArrow;憖ightArrow;憗iĀ;lᏹᏺ䏒on;䎥ing;䅮cr;쀀𝒰ilde;䅨ml耻Ü䃜ҀDbcdefosvᐧᐬᐰᐳᐾᒅᒊᒐᒖash;披ar;櫫y;䐒ashĀ;lᐻᐼ抩;櫦Āerᑃᑅ;拁ƀbtyᑌᑐᑺar;怖Ā;iᑏᑕcalȀBLSTᑡᑥᑪᑴar;戣ine;䁼eparator;杘ilde;所ThinSpace;怊r;쀀𝔙pf;쀀𝕍cr;쀀𝒱dash;抪ʀcefosᒧᒬᒱᒶᒼirc;䅴dge;拀r;쀀𝔚pf;쀀𝕎cr;쀀𝒲Ȁfiosᓋᓐᓒᓘr;쀀𝔛;䎞pf;쀀𝕏cr;쀀𝒳ҀAIUacfosuᓱᓵᓹᓽᔄᔏᔔᔚᔠcy;䐯cy;䐇cy;䐮cute耻Ý䃝Āiyᔉᔍrc;䅶;䐫r;쀀𝔜pf;쀀𝕐cr;쀀𝒴ml;䅸ЀHacdefosᔵᔹᔿᕋᕏᕝᕠᕤcy;䐖cute;䅹Āayᕄᕉron;䅽;䐗ot;䅻ǲᕔ\0ᕛoWidtè૙a;䎖r;愨pf;愤cr;쀀𝒵௡ᖃᖊᖐ\0ᖰᖶᖿ\0\0\0\0ᗆᗛᗫᙟ᙭\0ᚕ᚛ᚲᚹ\0ᚾcute耻á䃡reve;䄃̀;Ediuyᖜᖝᖡᖣᖨᖭ戾;쀀∾̳;房rc耻â䃢te肻´̆;䐰lig耻æ䃦Ā;r²ᖺ;쀀𝔞rave耻à䃠ĀepᗊᗖĀfpᗏᗔsym;愵èᗓha;䎱ĀapᗟcĀclᗤᗧr;䄁g;樿ɤᗰ\0\0ᘊʀ;adsvᗺᗻᗿᘁᘇ戧nd;橕;橜lope;橘;橚΀;elmrszᘘᘙᘛᘞᘿᙏᙙ戠;榤e»ᘙsdĀ;aᘥᘦ戡ѡᘰᘲᘴᘶᘸᘺᘼᘾ;榨;榩;榪;榫;榬;榭;榮;榯tĀ;vᙅᙆ戟bĀ;dᙌᙍ抾;榝Āptᙔᙗh;戢»¹arr;捼Āgpᙣᙧon;䄅f;쀀𝕒΀;Eaeiop዁ᙻᙽᚂᚄᚇᚊ;橰cir;橯;扊d;手s;䀧roxĀ;e዁ᚒñᚃing耻å䃥ƀctyᚡᚦᚨr;쀀𝒶;䀪mpĀ;e዁ᚯñʈilde耻ã䃣ml耻ä䃤Āciᛂᛈoninôɲnt;樑ࠀNabcdefiklnoprsu᛭ᛱᜰ᜼ᝃᝈ᝸᝽០៦ᠹᡐᜍ᤽᥈ᥰot;櫭Ācrᛶ᜞kȀcepsᜀᜅᜍᜓong;扌psilon;䏶rime;怵imĀ;e᜚᜛戽q;拍Ŷᜢᜦee;抽edĀ;gᜬᜭ挅e»ᜭrkĀ;t፜᜷brk;掶Āoyᜁᝁ;䐱quo;怞ʀcmprtᝓ᝛ᝡᝤᝨausĀ;eĊĉptyv;榰séᜌnoõēƀahwᝯ᝱ᝳ;䎲;愶een;扬r;쀀𝔟g΀costuvwឍឝឳេ៕៛៞ƀaiuបពរðݠrc;旯p»፱ƀdptឤឨឭot;樀lus;樁imes;樂ɱឹ\0\0ើcup;樆ar;昅riangleĀdu៍្own;施p;斳plus;樄eåᑄåᒭarow;植ƀako៭ᠦᠵĀcn៲ᠣkƀlst៺֫᠂ozenge;槫riangleȀ;dlr᠒᠓᠘᠝斴own;斾eft;旂ight;斸k;搣Ʊᠫ\0ᠳƲᠯ\0ᠱ;斒;斑4;斓ck;斈ĀeoᠾᡍĀ;qᡃᡆ쀀=⃥uiv;쀀≡⃥t;挐Ȁptwxᡙᡞᡧᡬf;쀀𝕓Ā;tᏋᡣom»Ꮜtie;拈؀DHUVbdhmptuvᢅᢖᢪᢻᣗᣛᣬ᣿ᤅᤊᤐᤡȀLRlrᢎᢐᢒᢔ;敗;敔;敖;敓ʀ;DUduᢡᢢᢤᢦᢨ敐;敦;敩;敤;敧ȀLRlrᢳᢵᢷᢹ;敝;敚;敜;教΀;HLRhlrᣊᣋᣍᣏᣑᣓᣕ救;敬;散;敠;敫;敢;敟ox;槉ȀLRlrᣤᣦᣨᣪ;敕;敒;攐;攌ʀ;DUduڽ᣷᣹᣻᣽;敥;敨;攬;攴inus;抟lus;択imes;抠ȀLRlrᤙᤛᤝ᤟;敛;敘;攘;攔΀;HLRhlrᤰᤱᤳᤵᤷ᤻᤹攂;敪;敡;敞;攼;攤;攜Āevģ᥂bar耻¦䂦Ȁceioᥑᥖᥚᥠr;쀀𝒷mi;恏mĀ;e᜚᜜lƀ;bhᥨᥩᥫ䁜;槅sub;柈Ŭᥴ᥾lĀ;e᥹᥺怢t»᥺pƀ;Eeįᦅᦇ;檮Ā;qۜۛೡᦧ\0᧨ᨑᨕᨲ\0ᨷᩐ\0\0᪴\0\0᫁\0\0ᬡᬮ᭍᭒\0᯽\0ᰌƀcpr᦭ᦲ᧝ute;䄇̀;abcdsᦿᧀᧄ᧊᧕᧙戩nd;橄rcup;橉Āau᧏᧒p;橋p;橇ot;橀;쀀∩︀Āeo᧢᧥t;恁îړȀaeiu᧰᧻ᨁᨅǰ᧵\0᧸s;橍on;䄍dil耻ç䃧rc;䄉psĀ;sᨌᨍ橌m;橐ot;䄋ƀdmnᨛᨠᨦil肻¸ƭptyv;榲t脀¢;eᨭᨮ䂢räƲr;쀀𝔠ƀceiᨽᩀᩍy;䑇ckĀ;mᩇᩈ朓ark»ᩈ;䏇r΀;Ecefms᩟᩠ᩢᩫ᪤᪪᪮旋;槃ƀ;elᩩᩪᩭ䋆q;扗eɡᩴ\0\0᪈rrowĀlr᩼᪁eft;憺ight;憻ʀRSacd᪒᪔᪖᪚᪟»ཇ;擈st;抛irc;抚ash;抝nint;樐id;櫯cir;槂ubsĀ;u᪻᪼晣it»᪼ˬ᫇᫔᫺\0ᬊonĀ;eᫍᫎ䀺Ā;qÇÆɭ᫙\0\0᫢aĀ;t᫞᫟䀬;䁀ƀ;fl᫨᫩᫫戁îᅠeĀmx᫱᫶ent»᫩eóɍǧ᫾\0ᬇĀ;dኻᬂot;橭nôɆƀfryᬐᬔᬗ;쀀𝕔oäɔ脀©;sŕᬝr;愗Āaoᬥᬩrr;憵ss;朗Ācuᬲᬷr;쀀𝒸Ābpᬼ᭄Ā;eᭁᭂ櫏;櫑Ā;eᭉᭊ櫐;櫒dot;拯΀delprvw᭠᭬᭷ᮂᮬᯔ᯹arrĀlr᭨᭪;椸;椵ɰ᭲\0\0᭵r;拞c;拟arrĀ;p᭿ᮀ憶;椽̀;bcdosᮏᮐᮖᮡᮥᮨ截rcap;橈Āauᮛᮞp;橆p;橊ot;抍r;橅;쀀∪︀Ȁalrv᮵ᮿᯞᯣrrĀ;mᮼᮽ憷;椼yƀevwᯇᯔᯘqɰᯎ\0\0ᯒreã᭳uã᭵ee;拎edge;拏en耻¤䂤earrowĀlrᯮ᯳eft»ᮀight»ᮽeäᯝĀciᰁᰇoninôǷnt;戱lcty;挭ঀAHabcdefhijlorstuwz᰸᰻᰿ᱝᱩᱵᲊᲞᲬᲷ᳻᳿ᴍᵻᶑᶫᶻ᷆᷍rò΁ar;楥Ȁglrs᱈ᱍ᱒᱔ger;怠eth;愸òᄳhĀ;vᱚᱛ怐»ऊūᱡᱧarow;椏aã̕Āayᱮᱳron;䄏;䐴ƀ;ao̲ᱼᲄĀgrʿᲁr;懊tseq;橷ƀglmᲑᲔᲘ耻°䂰ta;䎴ptyv;榱ĀirᲣᲨsht;楿;쀀𝔡arĀlrᲳᲵ»ࣜ»သʀaegsv᳂͸᳖᳜᳠mƀ;oș᳊᳔ndĀ;ș᳑uit;晦amma;䏝in;拲ƀ;io᳧᳨᳸䃷de脀÷;o᳧ᳰntimes;拇nø᳷cy;䑒cɯᴆ\0\0ᴊrn;挞op;挍ʀlptuwᴘᴝᴢᵉᵕlar;䀤f;쀀𝕕ʀ;emps̋ᴭᴷᴽᵂqĀ;d͒ᴳot;扑inus;戸lus;戔quare;抡blebarwedgåúnƀadhᄮᵝᵧownarrowóᲃarpoonĀlrᵲᵶefôᲴighôᲶŢᵿᶅkaro÷གɯᶊ\0\0ᶎrn;挟op;挌ƀcotᶘᶣᶦĀryᶝᶡ;쀀𝒹;䑕l;槶rok;䄑Ādrᶰᶴot;拱iĀ;fᶺ᠖斿Āah᷀᷃ròЩaòྦangle;榦Āci᷒ᷕy;䑟grarr;柿ऀDacdefglmnopqrstuxḁḉḙḸոḼṉṡṾấắẽỡἪἷὄ὎὚ĀDoḆᴴoôᲉĀcsḎḔute耻é䃩ter;橮ȀaioyḢḧḱḶron;䄛rĀ;cḭḮ扖耻ê䃪lon;払;䑍ot;䄗ĀDrṁṅot;扒;쀀𝔢ƀ;rsṐṑṗ檚ave耻è䃨Ā;dṜṝ檖ot;檘Ȁ;ilsṪṫṲṴ檙nters;揧;愓Ā;dṹṺ檕ot;檗ƀapsẅẉẗcr;䄓tyƀ;svẒẓẕ戅et»ẓpĀ1;ẝẤĳạả;怄;怅怃ĀgsẪẬ;䅋p;怂ĀgpẴẸon;䄙f;쀀𝕖ƀalsỄỎỒrĀ;sỊị拕l;槣us;橱iƀ;lvỚớở䎵on»ớ;䏵ȀcsuvỪỳἋἣĀioữḱrc»Ḯɩỹ\0\0ỻíՈantĀglἂἆtr»ṝess»Ṻƀaeiἒ἖Ἒls;䀽st;扟vĀ;DȵἠD;橸parsl;槥ĀDaἯἳot;打rr;楱ƀcdiἾὁỸr;愯oô͒ĀahὉὋ;䎷耻ð䃰Āmrὓὗl耻ë䃫o;悬ƀcipὡὤὧl;䀡sôծĀeoὬὴctatioîՙnentialåչৡᾒ\0ᾞ\0ᾡᾧ\0\0ῆῌ\0ΐ\0ῦῪ \0 ⁚llingdotseñṄy;䑄male;晀ƀilrᾭᾳ῁lig;耀ﬃɩᾹ\0\0᾽g;耀ﬀig;耀ﬄ;쀀𝔣lig;耀ﬁlig;쀀fjƀaltῙ῜ῡt;晭ig;耀ﬂns;斱of;䆒ǰ΅\0ῳf;쀀𝕗ĀakֿῷĀ;vῼ´拔;櫙artint;樍Āao‌⁕Ācs‑⁒α‚‰‸⁅⁈\0⁐β•‥‧‪‬\0‮耻½䂽;慓耻¼䂼;慕;慙;慛Ƴ‴\0‶;慔;慖ʴ‾⁁\0\0⁃耻¾䂾;慗;慜5;慘ƶ⁌\0⁎;慚;慝8;慞l;恄wn;挢cr;쀀𝒻ࢀEabcdefgijlnorstv₂₉₟₥₰₴⃰⃵⃺⃿℃ℒℸ̗ℾ⅒↞Ā;lٍ₇;檌ƀcmpₐₕ₝ute;䇵maĀ;dₜ᳚䎳;檆reve;䄟Āiy₪₮rc;䄝;䐳ot;䄡Ȁ;lqsؾق₽⃉ƀ;qsؾٌ⃄lanô٥Ȁ;cdl٥⃒⃥⃕c;檩otĀ;o⃜⃝檀Ā;l⃢⃣檂;檄Ā;e⃪⃭쀀⋛︀s;檔r;쀀𝔤Ā;gٳ؛mel;愷cy;䑓Ȁ;Eajٚℌℎℐ;檒;檥;檤ȀEaesℛℝ℩ℴ;扩pĀ;p℣ℤ檊rox»ℤĀ;q℮ℯ檈Ā;q℮ℛim;拧pf;쀀𝕘Āci⅃ⅆr;愊mƀ;el٫ⅎ⅐;檎;檐茀>;cdlqr׮ⅠⅪⅮⅳⅹĀciⅥⅧ;檧r;橺ot;拗Par;榕uest;橼ʀadelsↄⅪ←ٖ↛ǰ↉\0↎proø₞r;楸qĀlqؿ↖lesó₈ií٫Āen↣↭rtneqq;쀀≩︀Å↪ԀAabcefkosy⇄⇇⇱⇵⇺∘∝∯≨≽ròΠȀilmr⇐⇔⇗⇛rsðᒄf»․ilôکĀdr⇠⇤cy;䑊ƀ;cwࣴ⇫⇯ir;楈;憭ar;意irc;䄥ƀalr∁∎∓rtsĀ;u∉∊晥it»∊lip;怦con;抹r;쀀𝔥sĀew∣∩arow;椥arow;椦ʀamopr∺∾≃≞≣rr;懿tht;戻kĀlr≉≓eftarrow;憩ightarrow;憪f;쀀𝕙bar;怕ƀclt≯≴≸r;쀀𝒽asè⇴rok;䄧Ābp⊂⊇ull;恃hen»ᱛૡ⊣\0⊪\0⊸⋅⋎\0⋕⋳\0\0⋸⌢⍧⍢⍿\0⎆⎪⎴cute耻í䃭ƀ;iyݱ⊰⊵rc耻î䃮;䐸Ācx⊼⊿y;䐵cl耻¡䂡ĀfrΟ⋉;쀀𝔦rave耻ì䃬Ȁ;inoܾ⋝⋩⋮Āin⋢⋦nt;樌t;戭fin;槜ta;愩lig;䄳ƀaop⋾⌚⌝ƀcgt⌅⌈⌗r;䄫ƀelpܟ⌏⌓inåގarôܠh;䄱f;抷ed;䆵ʀ;cfotӴ⌬⌱⌽⍁are;愅inĀ;t⌸⌹戞ie;槝doô⌙ʀ;celpݗ⍌⍐⍛⍡al;抺Āgr⍕⍙eróᕣã⍍arhk;樗rod;樼Ȁcgpt⍯⍲⍶⍻y;䑑on;䄯f;쀀𝕚a;䎹uest耻¿䂿Āci⎊⎏r;쀀𝒾nʀ;EdsvӴ⎛⎝⎡ӳ;拹ot;拵Ā;v⎦⎧拴;拳Ā;iݷ⎮lde;䄩ǫ⎸\0⎼cy;䑖l耻ï䃯̀cfmosu⏌⏗⏜⏡⏧⏵Āiy⏑⏕rc;䄵;䐹r;쀀𝔧ath;䈷pf;쀀𝕛ǣ⏬\0⏱r;쀀𝒿rcy;䑘kcy;䑔Ѐacfghjos␋␖␢␧␭␱␵␻ppaĀ;v␓␔䎺;䏰Āey␛␠dil;䄷;䐺r;쀀𝔨reen;䄸cy;䑅cy;䑜pf;쀀𝕜cr;쀀𝓀஀ABEHabcdefghjlmnoprstuv⑰⒁⒆⒍⒑┎┽╚▀♎♞♥♹♽⚚⚲⛘❝❨➋⟀⠁⠒ƀart⑷⑺⑼rò৆òΕail;椛arr;椎Ā;gঔ⒋;檋ar;楢ॣ⒥\0⒪\0⒱\0\0\0\0\0⒵Ⓔ\0ⓆⓈⓍ\0⓹ute;䄺mptyv;榴raîࡌbda;䎻gƀ;dlࢎⓁⓃ;榑åࢎ;檅uo耻«䂫rЀ;bfhlpst࢙ⓞⓦⓩ⓫⓮⓱⓵Ā;f࢝ⓣs;椟s;椝ë≒p;憫l;椹im;楳l;憢ƀ;ae⓿─┄檫il;椙Ā;s┉┊檭;쀀⪭︀ƀabr┕┙┝rr;椌rk;杲Āak┢┬cĀek┨┪;䁻;䁛Āes┱┳;榋lĀdu┹┻;榏;榍Ȁaeuy╆╋╖╘ron;䄾Ādi═╔il;䄼ìࢰâ┩;䐻Ȁcqrs╣╦╭╽a;椶uoĀ;rนᝆĀdu╲╷har;楧shar;楋h;憲ʀ;fgqs▋▌উ◳◿扤tʀahlrt▘▤▷◂◨rrowĀ;t࢙□aé⓶arpoonĀdu▯▴own»њp»०eftarrows;懇ightƀahs◍◖◞rrowĀ;sࣴࢧarpoonó྘quigarro÷⇰hreetimes;拋ƀ;qs▋ও◺lanôবʀ;cdgsব☊☍☝☨c;檨otĀ;o☔☕橿Ā;r☚☛檁;檃Ā;e☢☥쀀⋚︀s;檓ʀadegs☳☹☽♉♋pproøⓆot;拖qĀgq♃♅ôউgtò⒌ôছiíলƀilr♕࣡♚sht;楼;쀀𝔩Ā;Eজ♣;檑š♩♶rĀdu▲♮Ā;l॥♳;楪lk;斄cy;䑙ʀ;achtੈ⚈⚋⚑⚖rò◁orneòᴈard;楫ri;旺Āio⚟⚤dot;䅀ustĀ;a⚬⚭掰che»⚭ȀEaes⚻⚽⛉⛔;扨pĀ;p⛃⛄檉rox»⛄Ā;q⛎⛏檇Ā;q⛎⚻im;拦Ѐabnoptwz⛩⛴⛷✚✯❁❇❐Ānr⛮⛱g;柬r;懽rëࣁgƀlmr⛿✍✔eftĀar০✇ightá৲apsto;柼ightá৽parrowĀlr✥✩efô⓭ight;憬ƀafl✶✹✽r;榅;쀀𝕝us;樭imes;樴š❋❏st;戗áፎƀ;ef❗❘᠀旊nge»❘arĀ;l❤❥䀨t;榓ʀachmt❳❶❼➅➇ròࢨorneòᶌarĀ;d྘➃;業;怎ri;抿̀achiqt➘➝ੀ➢➮➻quo;怹r;쀀𝓁mƀ;egল➪➬;檍;檏Ābu┪➳oĀ;rฟ➹;怚rok;䅂萀<;cdhilqrࠫ⟒☹⟜⟠⟥⟪⟰Āci⟗⟙;檦r;橹reå◲mes;拉arr;楶uest;橻ĀPi⟵⟹ar;榖ƀ;ef⠀भ᠛旃rĀdu⠇⠍shar;楊har;楦Āen⠗⠡rtneqq;쀀≨︀Å⠞܀Dacdefhilnopsu⡀⡅⢂⢎⢓⢠⢥⢨⣚⣢⣤ઃ⣳⤂Dot;戺Ȁclpr⡎⡒⡣⡽r耻¯䂯Āet⡗⡙;時Ā;e⡞⡟朠se»⡟Ā;sျ⡨toȀ;dluျ⡳⡷⡻owîҌefôएðᏑker;斮Āoy⢇⢌mma;権;䐼ash;怔asuredangle»ᘦr;쀀𝔪o;愧ƀcdn⢯⢴⣉ro耻µ䂵Ȁ;acdᑤ⢽⣀⣄sôᚧir;櫰ot肻·Ƶusƀ;bd⣒ᤃ⣓戒Ā;uᴼ⣘;横ţ⣞⣡p;櫛ò−ðઁĀdp⣩⣮els;抧f;쀀𝕞Āct⣸⣽r;쀀𝓂pos»ᖝƀ;lm⤉⤊⤍䎼timap;抸ఀGLRVabcdefghijlmoprstuvw⥂⥓⥾⦉⦘⧚⧩⨕⨚⩘⩝⪃⪕⪤⪨⬄⬇⭄⭿⮮ⰴⱧⱼ⳩Āgt⥇⥋;쀀⋙̸Ā;v⥐௏쀀≫⃒ƀelt⥚⥲⥶ftĀar⥡⥧rrow;懍ightarrow;懎;쀀⋘̸Ā;v⥻ే쀀≪⃒ightarrow;懏ĀDd⦎⦓ash;抯ash;抮ʀbcnpt⦣⦧⦬⦱⧌la»˞ute;䅄g;쀀∠⃒ʀ;Eiop඄⦼⧀⧅⧈;쀀⩰̸d;쀀≋̸s;䅉roø඄urĀ;a⧓⧔普lĀ;s⧓ସǳ⧟\0⧣p肻 ଷmpĀ;e௹ఀʀaeouy⧴⧾⨃⨐⨓ǰ⧹\0⧻;橃on;䅈dil;䅆ngĀ;dൾ⨊ot;쀀⩭̸p;橂;䐽ash;怓΀;Aadqsxஒ⨩⨭⨻⩁⩅⩐rr;懗rĀhr⨳⨶k;椤Ā;oᏲᏰot;쀀≐̸uiöୣĀei⩊⩎ar;椨í஘istĀ;s஠டr;쀀𝔫ȀEest௅⩦⩹⩼ƀ;qs஼⩭௡ƀ;qs஼௅⩴lanô௢ií௪Ā;rஶ⪁»ஷƀAap⪊⪍⪑rò⥱rr;憮ar;櫲ƀ;svྍ⪜ྌĀ;d⪡⪢拼;拺cy;䑚΀AEadest⪷⪺⪾⫂⫅⫶⫹rò⥦;쀀≦̸rr;憚r;急Ȁ;fqs఻⫎⫣⫯tĀar⫔⫙rro÷⫁ightarro÷⪐ƀ;qs఻⪺⫪lanôౕĀ;sౕ⫴»శiíౝĀ;rవ⫾iĀ;eచథiäඐĀpt⬌⬑f;쀀𝕟膀¬;in⬙⬚⬶䂬nȀ;Edvஉ⬤⬨⬮;쀀⋹̸ot;쀀⋵̸ǡஉ⬳⬵;拷;拶iĀ;vಸ⬼ǡಸ⭁⭃;拾;拽ƀaor⭋⭣⭩rȀ;ast୻⭕⭚⭟lleì୻l;쀀⫽⃥;쀀∂̸lint;樔ƀ;ceಒ⭰⭳uåಥĀ;cಘ⭸Ā;eಒ⭽ñಘȀAait⮈⮋⮝⮧rò⦈rrƀ;cw⮔⮕⮙憛;쀀⤳̸;쀀↝̸ghtarrow»⮕riĀ;eೋೖ΀chimpqu⮽⯍⯙⬄୸⯤⯯Ȁ;cerല⯆ഷ⯉uå൅;쀀𝓃ortɭ⬅\0\0⯖ará⭖mĀ;e൮⯟Ā;q൴൳suĀbp⯫⯭å೸åഋƀbcp⯶ⰑⰙȀ;Ees⯿ⰀഢⰄ抄;쀀⫅̸etĀ;eഛⰋqĀ;qണⰀcĀ;eലⰗñസȀ;EesⰢⰣൟⰧ抅;쀀⫆̸etĀ;e൘ⰮqĀ;qൠⰣȀgilrⰽⰿⱅⱇìௗlde耻ñ䃱çృiangleĀlrⱒⱜeftĀ;eచⱚñదightĀ;eೋⱥñ೗Ā;mⱬⱭ䎽ƀ;esⱴⱵⱹ䀣ro;愖p;怇ҀDHadgilrsⲏⲔⲙⲞⲣⲰⲶⳓⳣash;抭arr;椄p;쀀≍⃒ash;抬ĀetⲨⲬ;쀀≥⃒;쀀>⃒nfin;槞ƀAetⲽⳁⳅrr;椂;쀀≤⃒Ā;rⳊⳍ쀀<⃒ie;쀀⊴⃒ĀAtⳘⳜrr;椃rie;쀀⊵⃒im;쀀∼⃒ƀAan⳰⳴ⴂrr;懖rĀhr⳺⳽k;椣Ā;oᏧᏥear;椧ቓ᪕\0\0\0\0\0\0\0\0\0\0\0\0\0ⴭ\0ⴸⵈⵠⵥ⵲ⶄᬇ\0\0ⶍⶫ\0ⷈⷎ\0ⷜ⸙⸫⸾⹃Ācsⴱ᪗ute耻ó䃳ĀiyⴼⵅrĀ;c᪞ⵂ耻ô䃴;䐾ʀabios᪠ⵒⵗǈⵚlac;䅑v;樸old;榼lig;䅓Ācr⵩⵭ir;榿;쀀𝔬ͯ⵹\0\0⵼\0ⶂn;䋛ave耻ò䃲;槁Ābmⶈ෴ar;榵Ȁacitⶕ⶘ⶥⶨrò᪀Āir⶝ⶠr;榾oss;榻nå๒;槀ƀaeiⶱⶵⶹcr;䅍ga;䏉ƀcdnⷀⷅǍron;䎿;榶pf;쀀𝕠ƀaelⷔ⷗ǒr;榷rp;榹΀;adiosvⷪⷫⷮ⸈⸍⸐⸖戨rò᪆Ȁ;efmⷷⷸ⸂⸅橝rĀ;oⷾⷿ愴f»ⷿ耻ª䂪耻º䂺gof;抶r;橖lope;橗;橛ƀclo⸟⸡⸧ò⸁ash耻ø䃸l;折iŬⸯ⸴de耻õ䃵esĀ;aǛ⸺s;樶ml耻ö䃶bar;挽ૡ⹞\0⹽\0⺀⺝\0⺢⺹\0\0⻋ຜ\0⼓\0\0⼫⾼\0⿈rȀ;astЃ⹧⹲຅脀¶;l⹭⹮䂶leìЃɩ⹸\0\0⹻m;櫳;櫽y;䐿rʀcimpt⺋⺏⺓ᡥ⺗nt;䀥od;䀮il;怰enk;怱r;쀀𝔭ƀimo⺨⺰⺴Ā;v⺭⺮䏆;䏕maô੶ne;明ƀ;tv⺿⻀⻈䏀chfork»´;䏖Āau⻏⻟nĀck⻕⻝kĀ;h⇴⻛;愎ö⇴sҀ;abcdemst⻳⻴ᤈ⻹⻽⼄⼆⼊⼎䀫cir;樣ir;樢Āouᵀ⼂;樥;橲n肻±ຝim;樦wo;樧ƀipu⼙⼠⼥ntint;樕f;쀀𝕡nd耻£䂣Ԁ;Eaceinosu່⼿⽁⽄⽇⾁⾉⾒⽾⾶;檳p;檷uå໙Ā;c໎⽌̀;acens່⽙⽟⽦⽨⽾pproø⽃urlyeñ໙ñ໎ƀaes⽯⽶⽺pprox;檹qq;檵im;拨iíໟmeĀ;s⾈ຮ怲ƀEas⽸⾐⽺ð⽵ƀdfp໬⾙⾯ƀals⾠⾥⾪lar;挮ine;挒urf;挓Ā;t໻⾴ï໻rel;抰Āci⿀⿅r;쀀𝓅;䏈ncsp;怈̀fiopsu⿚⋢⿟⿥⿫⿱r;쀀𝔮pf;쀀𝕢rime;恗cr;쀀𝓆ƀaeo⿸〉〓tĀei⿾々rnionóڰnt;樖stĀ;e【】䀿ñἙô༔઀ABHabcdefhilmnoprstux぀けさすムㄎㄫㅇㅢㅲㆎ㈆㈕㈤㈩㉘㉮㉲㊐㊰㊷ƀartぇおがròႳòϝail;検aròᱥar;楤΀cdenqrtとふへみわゔヌĀeuねぱ;쀀∽̱te;䅕iãᅮmptyv;榳gȀ;del࿑らるろ;榒;榥å࿑uo耻»䂻rր;abcfhlpstw࿜ガクシスゼゾダッデナp;極Ā;f࿠ゴs;椠;椳s;椞ë≝ð✮l;楅im;楴l;憣;憝Āaiパフil;椚oĀ;nホボ戶aló༞ƀabrョリヮrò៥rk;杳ĀakンヽcĀekヹ・;䁽;䁝Āes㄂㄄;榌lĀduㄊㄌ;榎;榐Ȁaeuyㄗㄜㄧㄩron;䅙Ādiㄡㄥil;䅗ì࿲âヺ;䑀Ȁclqsㄴㄷㄽㅄa;椷dhar;楩uoĀ;rȎȍh;憳ƀacgㅎㅟངlȀ;ipsླྀㅘㅛႜnåႻarôྩt;断ƀilrㅩဣㅮsht;楽;쀀𝔯ĀaoㅷㆆrĀduㅽㅿ»ѻĀ;l႑ㆄ;楬Ā;vㆋㆌ䏁;䏱ƀgns㆕ㇹㇼht̀ahlrstㆤㆰ㇂㇘㇤㇮rrowĀ;t࿜ㆭaéトarpoonĀduㆻㆿowîㅾp»႒eftĀah㇊㇐rrowó࿪arpoonóՑightarrows;應quigarro÷ニhreetimes;拌g;䋚ingdotseñἲƀahm㈍㈐㈓rò࿪aòՑ;怏oustĀ;a㈞㈟掱che»㈟mid;櫮Ȁabpt㈲㈽㉀㉒Ānr㈷㈺g;柭r;懾rëဃƀafl㉇㉊㉎r;榆;쀀𝕣us;樮imes;樵Āap㉝㉧rĀ;g㉣㉤䀩t;榔olint;樒arò㇣Ȁachq㉻㊀Ⴜ㊅quo;怺r;쀀𝓇Ābu・㊊oĀ;rȔȓƀhir㊗㊛㊠reåㇸmes;拊iȀ;efl㊪ၙᠡ㊫方tri;槎luhar;楨;愞ൡ㋕㋛㋟㌬㌸㍱\0㍺㎤\0\0㏬㏰\0㐨㑈㑚㒭㒱㓊㓱\0㘖\0\0㘳cute;䅛quï➺Ԁ;Eaceinpsyᇭ㋳㋵㋿㌂㌋㌏㌟㌦㌩;檴ǰ㋺\0㋼;檸on;䅡uåᇾĀ;dᇳ㌇il;䅟rc;䅝ƀEas㌖㌘㌛;檶p;檺im;择olint;樓iíሄ;䑁otƀ;be㌴ᵇ㌵担;橦΀Aacmstx㍆㍊㍗㍛㍞㍣㍭rr;懘rĀhr㍐㍒ë∨Ā;oਸ਼਴t耻§䂧i;䀻war;椩mĀin㍩ðnuóñt;朶rĀ;o㍶⁕쀀𝔰Ȁacoy㎂㎆㎑㎠rp;景Āhy㎋㎏cy;䑉;䑈rtɭ㎙\0\0㎜iäᑤaraì⹯耻­䂭Āgm㎨㎴maƀ;fv㎱㎲㎲䏃;䏂Ѐ;deglnprካ㏅㏉㏎㏖㏞㏡㏦ot;橪Ā;q኱ኰĀ;E㏓㏔檞;檠Ā;E㏛㏜檝;檟e;扆lus;樤arr;楲aròᄽȀaeit㏸㐈㐏㐗Āls㏽㐄lsetmé㍪hp;樳parsl;槤Ādlᑣ㐔e;挣Ā;e㐜㐝檪Ā;s㐢㐣檬;쀀⪬︀ƀflp㐮㐳㑂tcy;䑌Ā;b㐸㐹䀯Ā;a㐾㐿槄r;挿f;쀀𝕤aĀdr㑍ЂesĀ;u㑔㑕晠it»㑕ƀcsu㑠㑹㒟Āau㑥㑯pĀ;sᆈ㑫;쀀⊓︀pĀ;sᆴ㑵;쀀⊔︀uĀbp㑿㒏ƀ;esᆗᆜ㒆etĀ;eᆗ㒍ñᆝƀ;esᆨᆭ㒖etĀ;eᆨ㒝ñᆮƀ;afᅻ㒦ְrť㒫ֱ»ᅼaròᅈȀcemt㒹㒾㓂㓅r;쀀𝓈tmîñiì㐕aræᆾĀar㓎㓕rĀ;f㓔ឿ昆Āan㓚㓭ightĀep㓣㓪psiloîỠhé⺯s»⡒ʀbcmnp㓻㕞ሉ㖋㖎Ҁ;Edemnprs㔎㔏㔑㔕㔞㔣㔬㔱㔶抂;櫅ot;檽Ā;dᇚ㔚ot;櫃ult;櫁ĀEe㔨㔪;櫋;把lus;檿arr;楹ƀeiu㔽㕒㕕tƀ;en㔎㕅㕋qĀ;qᇚ㔏eqĀ;q㔫㔨m;櫇Ābp㕚㕜;櫕;櫓c̀;acensᇭ㕬㕲㕹㕻㌦pproø㋺urlyeñᇾñᇳƀaes㖂㖈㌛pproø㌚qñ㌗g;晪ڀ123;Edehlmnps㖩㖬㖯ሜ㖲㖴㗀㗉㗕㗚㗟㗨㗭耻¹䂹耻²䂲耻³䂳;櫆Āos㖹㖼t;檾ub;櫘Ā;dሢ㗅ot;櫄sĀou㗏㗒l;柉b;櫗arr;楻ult;櫂ĀEe㗤㗦;櫌;抋lus;櫀ƀeiu㗴㘉㘌tƀ;enሜ㗼㘂qĀ;qሢ㖲eqĀ;q㗧㗤m;櫈Ābp㘑㘓;櫔;櫖ƀAan㘜㘠㘭rr;懙rĀhr㘦㘨ë∮Ā;oਫ਩war;椪lig耻ß䃟௡㙑㙝㙠ዎ㙳㙹\0㙾㛂\0\0\0\0\0㛛㜃\0㜉㝬\0\0\0㞇ɲ㙖\0\0㙛get;挖;䏄rë๟ƀaey㙦㙫㙰ron;䅥dil;䅣;䑂lrec;挕r;쀀𝔱Ȁeiko㚆㚝㚵㚼ǲ㚋\0㚑eĀ4fኄኁaƀ;sv㚘㚙㚛䎸ym;䏑Ācn㚢㚲kĀas㚨㚮pproø዁im»ኬsðኞĀas㚺㚮ð዁rn耻þ䃾Ǭ̟㛆⋧es膀×;bd㛏㛐㛘䃗Ā;aᤏ㛕r;樱;樰ƀeps㛡㛣㜀á⩍Ȁ;bcf҆㛬㛰㛴ot;挶ir;櫱Ā;o㛹㛼쀀𝕥rk;櫚á㍢rime;怴ƀaip㜏㜒㝤dåቈ΀adempst㜡㝍㝀㝑㝗㝜㝟ngleʀ;dlqr㜰㜱㜶㝀㝂斵own»ᶻeftĀ;e⠀㜾ñम;扜ightĀ;e㊪㝋ñၚot;旬inus;樺lus;樹b;槍ime;樻ezium;揢ƀcht㝲㝽㞁Āry㝷㝻;쀀𝓉;䑆cy;䑛rok;䅧Āio㞋㞎xô᝷headĀlr㞗㞠eftarro÷ࡏightarrow»ཝऀAHabcdfghlmoprstuw㟐㟓㟗㟤㟰㟼㠎㠜㠣㠴㡑㡝㡫㢩㣌㣒㣪㣶ròϭar;楣Ācr㟜㟢ute耻ú䃺òᅐrǣ㟪\0㟭y;䑞ve;䅭Āiy㟵㟺rc耻û䃻;䑃ƀabh㠃㠆㠋ròᎭlac;䅱aòᏃĀir㠓㠘sht;楾;쀀𝔲rave耻ù䃹š㠧㠱rĀlr㠬㠮»ॗ»ႃlk;斀Āct㠹㡍ɯ㠿\0\0㡊rnĀ;e㡅㡆挜r»㡆op;挏ri;旸Āal㡖㡚cr;䅫肻¨͉Āgp㡢㡦on;䅳f;쀀𝕦̀adhlsuᅋ㡸㡽፲㢑㢠ownáᎳarpoonĀlr㢈㢌efô㠭ighô㠯iƀ;hl㢙㢚㢜䏅»ᏺon»㢚parrows;懈ƀcit㢰㣄㣈ɯ㢶\0\0㣁rnĀ;e㢼㢽挝r»㢽op;挎ng;䅯ri;旹cr;쀀𝓊ƀdir㣙㣝㣢ot;拰lde;䅩iĀ;f㜰㣨»᠓Āam㣯㣲rò㢨l耻ü䃼angle;榧ހABDacdeflnoprsz㤜㤟㤩㤭㦵㦸㦽㧟㧤㧨㧳㧹㧽㨁㨠ròϷarĀ;v㤦㤧櫨;櫩asèϡĀnr㤲㤷grt;榜΀eknprst㓣㥆㥋㥒㥝㥤㦖appá␕othinçẖƀhir㓫⻈㥙opô⾵Ā;hᎷ㥢ïㆍĀiu㥩㥭gmá㎳Ābp㥲㦄setneqĀ;q㥽㦀쀀⊊︀;쀀⫋︀setneqĀ;q㦏㦒쀀⊋︀;쀀⫌︀Āhr㦛㦟etá㚜iangleĀlr㦪㦯eft»थight»ၑy;䐲ash»ံƀelr㧄㧒㧗ƀ;beⷪ㧋㧏ar;抻q;扚lip;拮Ābt㧜ᑨaòᑩr;쀀𝔳tré㦮suĀbp㧯㧱»ജ»൙pf;쀀𝕧roð໻tré㦴Ācu㨆㨋r;쀀𝓋Ābp㨐㨘nĀEe㦀㨖»㥾nĀEe㦒㨞»㦐igzag;榚΀cefoprs㨶㨻㩖㩛㩔㩡㩪irc;䅵Ādi㩀㩑Ābg㩅㩉ar;機eĀ;qᗺ㩏;扙erp;愘r;쀀𝔴pf;쀀𝕨Ā;eᑹ㩦atèᑹcr;쀀𝓌ૣណ㪇\0㪋\0㪐㪛\0\0㪝㪨㪫㪯\0\0㫃㫎\0㫘ៜ៟tré៑r;쀀𝔵ĀAa㪔㪗ròσrò৶;䎾ĀAa㪡㪤ròθrò৫að✓is;拻ƀdptឤ㪵㪾Āfl㪺ឩ;쀀𝕩imåឲĀAa㫇㫊ròώròਁĀcq㫒ីr;쀀𝓍Āpt៖㫜ré។Ѐacefiosu㫰㫽㬈㬌㬑㬕㬛㬡cĀuy㫶㫻te耻ý䃽;䑏Āiy㬂㬆rc;䅷;䑋n耻¥䂥r;쀀𝔶cy;䑗pf;쀀𝕪cr;쀀𝓎Ācm㬦㬩y;䑎l耻ÿ䃿Ԁacdefhiosw㭂㭈㭔㭘㭤㭩㭭㭴㭺㮀cute;䅺Āay㭍㭒ron;䅾;䐷ot;䅼Āet㭝㭡træᕟa;䎶r;쀀𝔷cy;䐶grarr;懝pf;쀀𝕫cr;쀀𝓏Ājn㮅㮇;怍j;怌'.split("").map((e) => e.charCodeAt(0))
), af = new Uint16Array(
  // prettier-ignore
  "Ȁaglq	\x1Bɭ\0\0p;䀦os;䀧t;䀾t;䀼uot;䀢".split("").map((e) => e.charCodeAt(0))
);
var Yn;
const sf = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]), of = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (Yn = String.fromCodePoint) !== null && Yn !== void 0 ? Yn : function(e) {
    let t = "";
    return e > 65535 && (e -= 65536, t += String.fromCharCode(e >>> 10 & 1023 | 55296), e = 56320 | e & 1023), t += String.fromCharCode(e), t;
  }
);
function lf(e) {
  var t;
  return e >= 55296 && e <= 57343 || e > 1114111 ? 65533 : (t = sf.get(e)) !== null && t !== void 0 ? t : e;
}
var se;
(function(e) {
  e[e.NUM = 35] = "NUM", e[e.SEMI = 59] = "SEMI", e[e.EQUALS = 61] = "EQUALS", e[e.ZERO = 48] = "ZERO", e[e.NINE = 57] = "NINE", e[e.LOWER_A = 97] = "LOWER_A", e[e.LOWER_F = 102] = "LOWER_F", e[e.LOWER_X = 120] = "LOWER_X", e[e.LOWER_Z = 122] = "LOWER_Z", e[e.UPPER_A = 65] = "UPPER_A", e[e.UPPER_F = 70] = "UPPER_F", e[e.UPPER_Z = 90] = "UPPER_Z";
})(se || (se = {}));
const cf = 32;
var Ye;
(function(e) {
  e[e.VALUE_LENGTH = 49152] = "VALUE_LENGTH", e[e.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", e[e.JUMP_TABLE = 127] = "JUMP_TABLE";
})(Ye || (Ye = {}));
function ur(e) {
  return e >= se.ZERO && e <= se.NINE;
}
function ff(e) {
  return e >= se.UPPER_A && e <= se.UPPER_F || e >= se.LOWER_A && e <= se.LOWER_F;
}
function hf(e) {
  return e >= se.UPPER_A && e <= se.UPPER_Z || e >= se.LOWER_A && e <= se.LOWER_Z || ur(e);
}
function df(e) {
  return e === se.EQUALS || hf(e);
}
var ie;
(function(e) {
  e[e.EntityStart = 0] = "EntityStart", e[e.NumericStart = 1] = "NumericStart", e[e.NumericDecimal = 2] = "NumericDecimal", e[e.NumericHex = 3] = "NumericHex", e[e.NamedEntity = 4] = "NamedEntity";
})(ie || (ie = {}));
var we;
(function(e) {
  e[e.Legacy = 0] = "Legacy", e[e.Strict = 1] = "Strict", e[e.Attribute = 2] = "Attribute";
})(we || (we = {}));
class Ji {
  constructor(t, n, r) {
    this.decodeTree = t, this.emitCodePoint = n, this.errors = r, this.state = ie.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = we.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(t) {
    this.decodeMode = t, this.state = ie.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(t, n) {
    switch (this.state) {
      case ie.EntityStart:
        return t.charCodeAt(n) === se.NUM ? (this.state = ie.NumericStart, this.consumed += 1, this.stateNumericStart(t, n + 1)) : (this.state = ie.NamedEntity, this.stateNamedEntity(t, n));
      case ie.NumericStart:
        return this.stateNumericStart(t, n);
      case ie.NumericDecimal:
        return this.stateNumericDecimal(t, n);
      case ie.NumericHex:
        return this.stateNumericHex(t, n);
      case ie.NamedEntity:
        return this.stateNamedEntity(t, n);
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(t, n) {
    return n >= t.length ? -1 : (t.charCodeAt(n) | cf) === se.LOWER_X ? (this.state = ie.NumericHex, this.consumed += 1, this.stateNumericHex(t, n + 1)) : (this.state = ie.NumericDecimal, this.stateNumericDecimal(t, n));
  }
  addToNumericResult(t, n, r, u) {
    if (n !== r) {
      const a = r - n;
      this.result = this.result * Math.pow(u, a) + parseInt(t.substr(n, a), u), this.consumed += a;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(t, n) {
    const r = n;
    for (; n < t.length; ) {
      const u = t.charCodeAt(n);
      if (ur(u) || ff(u))
        n += 1;
      else
        return this.addToNumericResult(t, r, n, 16), this.emitNumericEntity(u, 3);
    }
    return this.addToNumericResult(t, r, n, 16), -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(t, n) {
    const r = n;
    for (; n < t.length; ) {
      const u = t.charCodeAt(n);
      if (ur(u))
        n += 1;
      else
        return this.addToNumericResult(t, r, n, 10), this.emitNumericEntity(u, 2);
    }
    return this.addToNumericResult(t, r, n, 10), -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(t, n) {
    var r;
    if (this.consumed <= n)
      return (r = this.errors) === null || r === void 0 || r.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (t === se.SEMI)
      this.consumed += 1;
    else if (this.decodeMode === we.Strict)
      return 0;
    return this.emitCodePoint(lf(this.result), this.consumed), this.errors && (t !== se.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(t, n) {
    const { decodeTree: r } = this;
    let u = r[this.treeIndex], a = (u & Ye.VALUE_LENGTH) >> 14;
    for (; n < t.length; n++, this.excess++) {
      const i = t.charCodeAt(n);
      if (this.treeIndex = mf(r, u, this.treeIndex + Math.max(1, a), i), this.treeIndex < 0)
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === we.Attribute && // We shouldn't have consumed any characters after the entity,
        (a === 0 || // And there should be no invalid characters.
        df(i)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (u = r[this.treeIndex], a = (u & Ye.VALUE_LENGTH) >> 14, a !== 0) {
        if (i === se.SEMI)
          return this.emitNamedEntityData(this.treeIndex, a, this.consumed + this.excess);
        this.decodeMode !== we.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var t;
    const { result: n, decodeTree: r } = this, u = (r[n] & Ye.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(n, u, this.consumed), (t = this.errors) === null || t === void 0 || t.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(t, n, r) {
    const { decodeTree: u } = this;
    return this.emitCodePoint(n === 1 ? u[t] & ~Ye.VALUE_LENGTH : u[t + 1], r), n === 3 && this.emitCodePoint(u[t + 2], r), r;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var t;
    switch (this.state) {
      case ie.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== we.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      // Otherwise, emit a numeric entity if we have one.
      case ie.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case ie.NumericHex:
        return this.emitNumericEntity(0, 3);
      case ie.NumericStart:
        return (t = this.errors) === null || t === void 0 || t.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case ie.EntityStart:
        return 0;
    }
  }
}
function Zi(e) {
  let t = "";
  const n = new Ji(e, (r) => t += of(r));
  return function(u, a) {
    let i = 0, o = 0;
    for (; (o = u.indexOf("&", o)) >= 0; ) {
      t += u.slice(i, o), n.startEntity(a);
      const c = n.write(
        u,
        // Skip the "&"
        o + 1
      );
      if (c < 0) {
        i = o + n.end();
        break;
      }
      i = o + c, o = c === 0 ? i + 1 : i;
    }
    const l = t + u.slice(i);
    return t = "", l;
  };
}
function mf(e, t, n, r) {
  const u = (t & Ye.BRANCH_LENGTH) >> 7, a = t & Ye.JUMP_TABLE;
  if (u === 0)
    return a !== 0 && r === a ? n : -1;
  if (a) {
    const l = r - a;
    return l < 0 || l >= u ? -1 : e[n + l] - 1;
  }
  let i = n, o = i + u - 1;
  for (; i <= o; ) {
    const l = i + o >>> 1, c = e[l];
    if (c < r)
      i = l + 1;
    else if (c > r)
      o = l - 1;
    else
      return e[l + u];
  }
  return -1;
}
Zi($i);
Zi(af);
var y;
(function(e) {
  e.HTML = "http://www.w3.org/1999/xhtml", e.MATHML = "http://www.w3.org/1998/Math/MathML", e.SVG = "http://www.w3.org/2000/svg", e.XLINK = "http://www.w3.org/1999/xlink", e.XML = "http://www.w3.org/XML/1998/namespace", e.XMLNS = "http://www.w3.org/2000/xmlns/";
})(y || (y = {}));
var Ze;
(function(e) {
  e.TYPE = "type", e.ACTION = "action", e.ENCODING = "encoding", e.PROMPT = "prompt", e.NAME = "name", e.COLOR = "color", e.FACE = "face", e.SIZE = "size";
})(Ze || (Ze = {}));
var be;
(function(e) {
  e.NO_QUIRKS = "no-quirks", e.QUIRKS = "quirks", e.LIMITED_QUIRKS = "limited-quirks";
})(be || (be = {}));
var _;
(function(e) {
  e.A = "a", e.ADDRESS = "address", e.ANNOTATION_XML = "annotation-xml", e.APPLET = "applet", e.AREA = "area", e.ARTICLE = "article", e.ASIDE = "aside", e.B = "b", e.BASE = "base", e.BASEFONT = "basefont", e.BGSOUND = "bgsound", e.BIG = "big", e.BLOCKQUOTE = "blockquote", e.BODY = "body", e.BR = "br", e.BUTTON = "button", e.CAPTION = "caption", e.CENTER = "center", e.CODE = "code", e.COL = "col", e.COLGROUP = "colgroup", e.DD = "dd", e.DESC = "desc", e.DETAILS = "details", e.DIALOG = "dialog", e.DIR = "dir", e.DIV = "div", e.DL = "dl", e.DT = "dt", e.EM = "em", e.EMBED = "embed", e.FIELDSET = "fieldset", e.FIGCAPTION = "figcaption", e.FIGURE = "figure", e.FONT = "font", e.FOOTER = "footer", e.FOREIGN_OBJECT = "foreignObject", e.FORM = "form", e.FRAME = "frame", e.FRAMESET = "frameset", e.H1 = "h1", e.H2 = "h2", e.H3 = "h3", e.H4 = "h4", e.H5 = "h5", e.H6 = "h6", e.HEAD = "head", e.HEADER = "header", e.HGROUP = "hgroup", e.HR = "hr", e.HTML = "html", e.I = "i", e.IMG = "img", e.IMAGE = "image", e.INPUT = "input", e.IFRAME = "iframe", e.KEYGEN = "keygen", e.LABEL = "label", e.LI = "li", e.LINK = "link", e.LISTING = "listing", e.MAIN = "main", e.MALIGNMARK = "malignmark", e.MARQUEE = "marquee", e.MATH = "math", e.MENU = "menu", e.META = "meta", e.MGLYPH = "mglyph", e.MI = "mi", e.MO = "mo", e.MN = "mn", e.MS = "ms", e.MTEXT = "mtext", e.NAV = "nav", e.NOBR = "nobr", e.NOFRAMES = "noframes", e.NOEMBED = "noembed", e.NOSCRIPT = "noscript", e.OBJECT = "object", e.OL = "ol", e.OPTGROUP = "optgroup", e.OPTION = "option", e.P = "p", e.PARAM = "param", e.PLAINTEXT = "plaintext", e.PRE = "pre", e.RB = "rb", e.RP = "rp", e.RT = "rt", e.RTC = "rtc", e.RUBY = "ruby", e.S = "s", e.SCRIPT = "script", e.SEARCH = "search", e.SECTION = "section", e.SELECT = "select", e.SOURCE = "source", e.SMALL = "small", e.SPAN = "span", e.STRIKE = "strike", e.STRONG = "strong", e.STYLE = "style", e.SUB = "sub", e.SUMMARY = "summary", e.SUP = "sup", e.TABLE = "table", e.TBODY = "tbody", e.TEMPLATE = "template", e.TEXTAREA = "textarea", e.TFOOT = "tfoot", e.TD = "td", e.TH = "th", e.THEAD = "thead", e.TITLE = "title", e.TR = "tr", e.TRACK = "track", e.TT = "tt", e.U = "u", e.UL = "ul", e.SVG = "svg", e.VAR = "var", e.WBR = "wbr", e.XMP = "xmp";
})(_ || (_ = {}));
var s;
(function(e) {
  e[e.UNKNOWN = 0] = "UNKNOWN", e[e.A = 1] = "A", e[e.ADDRESS = 2] = "ADDRESS", e[e.ANNOTATION_XML = 3] = "ANNOTATION_XML", e[e.APPLET = 4] = "APPLET", e[e.AREA = 5] = "AREA", e[e.ARTICLE = 6] = "ARTICLE", e[e.ASIDE = 7] = "ASIDE", e[e.B = 8] = "B", e[e.BASE = 9] = "BASE", e[e.BASEFONT = 10] = "BASEFONT", e[e.BGSOUND = 11] = "BGSOUND", e[e.BIG = 12] = "BIG", e[e.BLOCKQUOTE = 13] = "BLOCKQUOTE", e[e.BODY = 14] = "BODY", e[e.BR = 15] = "BR", e[e.BUTTON = 16] = "BUTTON", e[e.CAPTION = 17] = "CAPTION", e[e.CENTER = 18] = "CENTER", e[e.CODE = 19] = "CODE", e[e.COL = 20] = "COL", e[e.COLGROUP = 21] = "COLGROUP", e[e.DD = 22] = "DD", e[e.DESC = 23] = "DESC", e[e.DETAILS = 24] = "DETAILS", e[e.DIALOG = 25] = "DIALOG", e[e.DIR = 26] = "DIR", e[e.DIV = 27] = "DIV", e[e.DL = 28] = "DL", e[e.DT = 29] = "DT", e[e.EM = 30] = "EM", e[e.EMBED = 31] = "EMBED", e[e.FIELDSET = 32] = "FIELDSET", e[e.FIGCAPTION = 33] = "FIGCAPTION", e[e.FIGURE = 34] = "FIGURE", e[e.FONT = 35] = "FONT", e[e.FOOTER = 36] = "FOOTER", e[e.FOREIGN_OBJECT = 37] = "FOREIGN_OBJECT", e[e.FORM = 38] = "FORM", e[e.FRAME = 39] = "FRAME", e[e.FRAMESET = 40] = "FRAMESET", e[e.H1 = 41] = "H1", e[e.H2 = 42] = "H2", e[e.H3 = 43] = "H3", e[e.H4 = 44] = "H4", e[e.H5 = 45] = "H5", e[e.H6 = 46] = "H6", e[e.HEAD = 47] = "HEAD", e[e.HEADER = 48] = "HEADER", e[e.HGROUP = 49] = "HGROUP", e[e.HR = 50] = "HR", e[e.HTML = 51] = "HTML", e[e.I = 52] = "I", e[e.IMG = 53] = "IMG", e[e.IMAGE = 54] = "IMAGE", e[e.INPUT = 55] = "INPUT", e[e.IFRAME = 56] = "IFRAME", e[e.KEYGEN = 57] = "KEYGEN", e[e.LABEL = 58] = "LABEL", e[e.LI = 59] = "LI", e[e.LINK = 60] = "LINK", e[e.LISTING = 61] = "LISTING", e[e.MAIN = 62] = "MAIN", e[e.MALIGNMARK = 63] = "MALIGNMARK", e[e.MARQUEE = 64] = "MARQUEE", e[e.MATH = 65] = "MATH", e[e.MENU = 66] = "MENU", e[e.META = 67] = "META", e[e.MGLYPH = 68] = "MGLYPH", e[e.MI = 69] = "MI", e[e.MO = 70] = "MO", e[e.MN = 71] = "MN", e[e.MS = 72] = "MS", e[e.MTEXT = 73] = "MTEXT", e[e.NAV = 74] = "NAV", e[e.NOBR = 75] = "NOBR", e[e.NOFRAMES = 76] = "NOFRAMES", e[e.NOEMBED = 77] = "NOEMBED", e[e.NOSCRIPT = 78] = "NOSCRIPT", e[e.OBJECT = 79] = "OBJECT", e[e.OL = 80] = "OL", e[e.OPTGROUP = 81] = "OPTGROUP", e[e.OPTION = 82] = "OPTION", e[e.P = 83] = "P", e[e.PARAM = 84] = "PARAM", e[e.PLAINTEXT = 85] = "PLAINTEXT", e[e.PRE = 86] = "PRE", e[e.RB = 87] = "RB", e[e.RP = 88] = "RP", e[e.RT = 89] = "RT", e[e.RTC = 90] = "RTC", e[e.RUBY = 91] = "RUBY", e[e.S = 92] = "S", e[e.SCRIPT = 93] = "SCRIPT", e[e.SEARCH = 94] = "SEARCH", e[e.SECTION = 95] = "SECTION", e[e.SELECT = 96] = "SELECT", e[e.SOURCE = 97] = "SOURCE", e[e.SMALL = 98] = "SMALL", e[e.SPAN = 99] = "SPAN", e[e.STRIKE = 100] = "STRIKE", e[e.STRONG = 101] = "STRONG", e[e.STYLE = 102] = "STYLE", e[e.SUB = 103] = "SUB", e[e.SUMMARY = 104] = "SUMMARY", e[e.SUP = 105] = "SUP", e[e.TABLE = 106] = "TABLE", e[e.TBODY = 107] = "TBODY", e[e.TEMPLATE = 108] = "TEMPLATE", e[e.TEXTAREA = 109] = "TEXTAREA", e[e.TFOOT = 110] = "TFOOT", e[e.TD = 111] = "TD", e[e.TH = 112] = "TH", e[e.THEAD = 113] = "THEAD", e[e.TITLE = 114] = "TITLE", e[e.TR = 115] = "TR", e[e.TRACK = 116] = "TRACK", e[e.TT = 117] = "TT", e[e.U = 118] = "U", e[e.UL = 119] = "UL", e[e.SVG = 120] = "SVG", e[e.VAR = 121] = "VAR", e[e.WBR = 122] = "WBR", e[e.XMP = 123] = "XMP";
})(s || (s = {}));
const pf = /* @__PURE__ */ new Map([
  [_.A, s.A],
  [_.ADDRESS, s.ADDRESS],
  [_.ANNOTATION_XML, s.ANNOTATION_XML],
  [_.APPLET, s.APPLET],
  [_.AREA, s.AREA],
  [_.ARTICLE, s.ARTICLE],
  [_.ASIDE, s.ASIDE],
  [_.B, s.B],
  [_.BASE, s.BASE],
  [_.BASEFONT, s.BASEFONT],
  [_.BGSOUND, s.BGSOUND],
  [_.BIG, s.BIG],
  [_.BLOCKQUOTE, s.BLOCKQUOTE],
  [_.BODY, s.BODY],
  [_.BR, s.BR],
  [_.BUTTON, s.BUTTON],
  [_.CAPTION, s.CAPTION],
  [_.CENTER, s.CENTER],
  [_.CODE, s.CODE],
  [_.COL, s.COL],
  [_.COLGROUP, s.COLGROUP],
  [_.DD, s.DD],
  [_.DESC, s.DESC],
  [_.DETAILS, s.DETAILS],
  [_.DIALOG, s.DIALOG],
  [_.DIR, s.DIR],
  [_.DIV, s.DIV],
  [_.DL, s.DL],
  [_.DT, s.DT],
  [_.EM, s.EM],
  [_.EMBED, s.EMBED],
  [_.FIELDSET, s.FIELDSET],
  [_.FIGCAPTION, s.FIGCAPTION],
  [_.FIGURE, s.FIGURE],
  [_.FONT, s.FONT],
  [_.FOOTER, s.FOOTER],
  [_.FOREIGN_OBJECT, s.FOREIGN_OBJECT],
  [_.FORM, s.FORM],
  [_.FRAME, s.FRAME],
  [_.FRAMESET, s.FRAMESET],
  [_.H1, s.H1],
  [_.H2, s.H2],
  [_.H3, s.H3],
  [_.H4, s.H4],
  [_.H5, s.H5],
  [_.H6, s.H6],
  [_.HEAD, s.HEAD],
  [_.HEADER, s.HEADER],
  [_.HGROUP, s.HGROUP],
  [_.HR, s.HR],
  [_.HTML, s.HTML],
  [_.I, s.I],
  [_.IMG, s.IMG],
  [_.IMAGE, s.IMAGE],
  [_.INPUT, s.INPUT],
  [_.IFRAME, s.IFRAME],
  [_.KEYGEN, s.KEYGEN],
  [_.LABEL, s.LABEL],
  [_.LI, s.LI],
  [_.LINK, s.LINK],
  [_.LISTING, s.LISTING],
  [_.MAIN, s.MAIN],
  [_.MALIGNMARK, s.MALIGNMARK],
  [_.MARQUEE, s.MARQUEE],
  [_.MATH, s.MATH],
  [_.MENU, s.MENU],
  [_.META, s.META],
  [_.MGLYPH, s.MGLYPH],
  [_.MI, s.MI],
  [_.MO, s.MO],
  [_.MN, s.MN],
  [_.MS, s.MS],
  [_.MTEXT, s.MTEXT],
  [_.NAV, s.NAV],
  [_.NOBR, s.NOBR],
  [_.NOFRAMES, s.NOFRAMES],
  [_.NOEMBED, s.NOEMBED],
  [_.NOSCRIPT, s.NOSCRIPT],
  [_.OBJECT, s.OBJECT],
  [_.OL, s.OL],
  [_.OPTGROUP, s.OPTGROUP],
  [_.OPTION, s.OPTION],
  [_.P, s.P],
  [_.PARAM, s.PARAM],
  [_.PLAINTEXT, s.PLAINTEXT],
  [_.PRE, s.PRE],
  [_.RB, s.RB],
  [_.RP, s.RP],
  [_.RT, s.RT],
  [_.RTC, s.RTC],
  [_.RUBY, s.RUBY],
  [_.S, s.S],
  [_.SCRIPT, s.SCRIPT],
  [_.SEARCH, s.SEARCH],
  [_.SECTION, s.SECTION],
  [_.SELECT, s.SELECT],
  [_.SOURCE, s.SOURCE],
  [_.SMALL, s.SMALL],
  [_.SPAN, s.SPAN],
  [_.STRIKE, s.STRIKE],
  [_.STRONG, s.STRONG],
  [_.STYLE, s.STYLE],
  [_.SUB, s.SUB],
  [_.SUMMARY, s.SUMMARY],
  [_.SUP, s.SUP],
  [_.TABLE, s.TABLE],
  [_.TBODY, s.TBODY],
  [_.TEMPLATE, s.TEMPLATE],
  [_.TEXTAREA, s.TEXTAREA],
  [_.TFOOT, s.TFOOT],
  [_.TD, s.TD],
  [_.TH, s.TH],
  [_.THEAD, s.THEAD],
  [_.TITLE, s.TITLE],
  [_.TR, s.TR],
  [_.TRACK, s.TRACK],
  [_.TT, s.TT],
  [_.U, s.U],
  [_.UL, s.UL],
  [_.SVG, s.SVG],
  [_.VAR, s.VAR],
  [_.WBR, s.WBR],
  [_.XMP, s.XMP]
]);
function bt(e) {
  var t;
  return (t = pf.get(e)) !== null && t !== void 0 ? t : s.UNKNOWN;
}
const R = s, Ef = {
  [y.HTML]: /* @__PURE__ */ new Set([
    R.ADDRESS,
    R.APPLET,
    R.AREA,
    R.ARTICLE,
    R.ASIDE,
    R.BASE,
    R.BASEFONT,
    R.BGSOUND,
    R.BLOCKQUOTE,
    R.BODY,
    R.BR,
    R.BUTTON,
    R.CAPTION,
    R.CENTER,
    R.COL,
    R.COLGROUP,
    R.DD,
    R.DETAILS,
    R.DIR,
    R.DIV,
    R.DL,
    R.DT,
    R.EMBED,
    R.FIELDSET,
    R.FIGCAPTION,
    R.FIGURE,
    R.FOOTER,
    R.FORM,
    R.FRAME,
    R.FRAMESET,
    R.H1,
    R.H2,
    R.H3,
    R.H4,
    R.H5,
    R.H6,
    R.HEAD,
    R.HEADER,
    R.HGROUP,
    R.HR,
    R.HTML,
    R.IFRAME,
    R.IMG,
    R.INPUT,
    R.LI,
    R.LINK,
    R.LISTING,
    R.MAIN,
    R.MARQUEE,
    R.MENU,
    R.META,
    R.NAV,
    R.NOEMBED,
    R.NOFRAMES,
    R.NOSCRIPT,
    R.OBJECT,
    R.OL,
    R.P,
    R.PARAM,
    R.PLAINTEXT,
    R.PRE,
    R.SCRIPT,
    R.SECTION,
    R.SELECT,
    R.SOURCE,
    R.STYLE,
    R.SUMMARY,
    R.TABLE,
    R.TBODY,
    R.TD,
    R.TEMPLATE,
    R.TEXTAREA,
    R.TFOOT,
    R.TH,
    R.THEAD,
    R.TITLE,
    R.TR,
    R.TRACK,
    R.UL,
    R.WBR,
    R.XMP
  ]),
  [y.MATHML]: /* @__PURE__ */ new Set([R.MI, R.MO, R.MN, R.MS, R.MTEXT, R.ANNOTATION_XML]),
  [y.SVG]: /* @__PURE__ */ new Set([R.TITLE, R.FOREIGN_OBJECT, R.DESC]),
  [y.XLINK]: /* @__PURE__ */ new Set(),
  [y.XML]: /* @__PURE__ */ new Set(),
  [y.XMLNS]: /* @__PURE__ */ new Set()
}, ir = /* @__PURE__ */ new Set([R.H1, R.H2, R.H3, R.H4, R.H5, R.H6]);
_.STYLE, _.SCRIPT, _.XMP, _.IFRAME, _.NOEMBED, _.NOFRAMES, _.PLAINTEXT;
var E;
(function(e) {
  e[e.DATA = 0] = "DATA", e[e.RCDATA = 1] = "RCDATA", e[e.RAWTEXT = 2] = "RAWTEXT", e[e.SCRIPT_DATA = 3] = "SCRIPT_DATA", e[e.PLAINTEXT = 4] = "PLAINTEXT", e[e.TAG_OPEN = 5] = "TAG_OPEN", e[e.END_TAG_OPEN = 6] = "END_TAG_OPEN", e[e.TAG_NAME = 7] = "TAG_NAME", e[e.RCDATA_LESS_THAN_SIGN = 8] = "RCDATA_LESS_THAN_SIGN", e[e.RCDATA_END_TAG_OPEN = 9] = "RCDATA_END_TAG_OPEN", e[e.RCDATA_END_TAG_NAME = 10] = "RCDATA_END_TAG_NAME", e[e.RAWTEXT_LESS_THAN_SIGN = 11] = "RAWTEXT_LESS_THAN_SIGN", e[e.RAWTEXT_END_TAG_OPEN = 12] = "RAWTEXT_END_TAG_OPEN", e[e.RAWTEXT_END_TAG_NAME = 13] = "RAWTEXT_END_TAG_NAME", e[e.SCRIPT_DATA_LESS_THAN_SIGN = 14] = "SCRIPT_DATA_LESS_THAN_SIGN", e[e.SCRIPT_DATA_END_TAG_OPEN = 15] = "SCRIPT_DATA_END_TAG_OPEN", e[e.SCRIPT_DATA_END_TAG_NAME = 16] = "SCRIPT_DATA_END_TAG_NAME", e[e.SCRIPT_DATA_ESCAPE_START = 17] = "SCRIPT_DATA_ESCAPE_START", e[e.SCRIPT_DATA_ESCAPE_START_DASH = 18] = "SCRIPT_DATA_ESCAPE_START_DASH", e[e.SCRIPT_DATA_ESCAPED = 19] = "SCRIPT_DATA_ESCAPED", e[e.SCRIPT_DATA_ESCAPED_DASH = 20] = "SCRIPT_DATA_ESCAPED_DASH", e[e.SCRIPT_DATA_ESCAPED_DASH_DASH = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH", e[e.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN", e[e.SCRIPT_DATA_ESCAPED_END_TAG_OPEN = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN", e[e.SCRIPT_DATA_ESCAPED_END_TAG_NAME = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME", e[e.SCRIPT_DATA_DOUBLE_ESCAPE_START = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START", e[e.SCRIPT_DATA_DOUBLE_ESCAPED = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN", e[e.SCRIPT_DATA_DOUBLE_ESCAPE_END = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END", e[e.BEFORE_ATTRIBUTE_NAME = 31] = "BEFORE_ATTRIBUTE_NAME", e[e.ATTRIBUTE_NAME = 32] = "ATTRIBUTE_NAME", e[e.AFTER_ATTRIBUTE_NAME = 33] = "AFTER_ATTRIBUTE_NAME", e[e.BEFORE_ATTRIBUTE_VALUE = 34] = "BEFORE_ATTRIBUTE_VALUE", e[e.ATTRIBUTE_VALUE_DOUBLE_QUOTED = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED", e[e.ATTRIBUTE_VALUE_SINGLE_QUOTED = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED", e[e.ATTRIBUTE_VALUE_UNQUOTED = 37] = "ATTRIBUTE_VALUE_UNQUOTED", e[e.AFTER_ATTRIBUTE_VALUE_QUOTED = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED", e[e.SELF_CLOSING_START_TAG = 39] = "SELF_CLOSING_START_TAG", e[e.BOGUS_COMMENT = 40] = "BOGUS_COMMENT", e[e.MARKUP_DECLARATION_OPEN = 41] = "MARKUP_DECLARATION_OPEN", e[e.COMMENT_START = 42] = "COMMENT_START", e[e.COMMENT_START_DASH = 43] = "COMMENT_START_DASH", e[e.COMMENT = 44] = "COMMENT", e[e.COMMENT_LESS_THAN_SIGN = 45] = "COMMENT_LESS_THAN_SIGN", e[e.COMMENT_LESS_THAN_SIGN_BANG = 46] = "COMMENT_LESS_THAN_SIGN_BANG", e[e.COMMENT_LESS_THAN_SIGN_BANG_DASH = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH", e[e.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH", e[e.COMMENT_END_DASH = 49] = "COMMENT_END_DASH", e[e.COMMENT_END = 50] = "COMMENT_END", e[e.COMMENT_END_BANG = 51] = "COMMENT_END_BANG", e[e.DOCTYPE = 52] = "DOCTYPE", e[e.BEFORE_DOCTYPE_NAME = 53] = "BEFORE_DOCTYPE_NAME", e[e.DOCTYPE_NAME = 54] = "DOCTYPE_NAME", e[e.AFTER_DOCTYPE_NAME = 55] = "AFTER_DOCTYPE_NAME", e[e.AFTER_DOCTYPE_PUBLIC_KEYWORD = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD", e[e.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER", e[e.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED", e[e.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED", e[e.AFTER_DOCTYPE_PUBLIC_IDENTIFIER = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER", e[e.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS", e[e.AFTER_DOCTYPE_SYSTEM_KEYWORD = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD", e[e.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER", e[e.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED", e[e.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED", e[e.AFTER_DOCTYPE_SYSTEM_IDENTIFIER = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER", e[e.BOGUS_DOCTYPE = 67] = "BOGUS_DOCTYPE", e[e.CDATA_SECTION = 68] = "CDATA_SECTION", e[e.CDATA_SECTION_BRACKET = 69] = "CDATA_SECTION_BRACKET", e[e.CDATA_SECTION_END = 70] = "CDATA_SECTION_END", e[e.CHARACTER_REFERENCE = 71] = "CHARACTER_REFERENCE", e[e.AMBIGUOUS_AMPERSAND = 72] = "AMBIGUOUS_AMPERSAND";
})(E || (E = {}));
const re = {
  DATA: E.DATA,
  RCDATA: E.RCDATA,
  RAWTEXT: E.RAWTEXT,
  SCRIPT_DATA: E.SCRIPT_DATA,
  PLAINTEXT: E.PLAINTEXT,
  CDATA_SECTION: E.CDATA_SECTION
};
function Tf(e) {
  return e >= m.DIGIT_0 && e <= m.DIGIT_9;
}
function yt(e) {
  return e >= m.LATIN_CAPITAL_A && e <= m.LATIN_CAPITAL_Z;
}
function gf(e) {
  return e >= m.LATIN_SMALL_A && e <= m.LATIN_SMALL_Z;
}
function ve(e) {
  return gf(e) || yt(e);
}
function Lu(e) {
  return ve(e) || Tf(e);
}
function $t(e) {
  return e + 32;
}
function ea(e) {
  return e === m.SPACE || e === m.LINE_FEED || e === m.TABULATION || e === m.FORM_FEED;
}
function Ru(e) {
  return ea(e) || e === m.SOLIDUS || e === m.GREATER_THAN_SIGN;
}
function bf(e) {
  return e === m.NULL ? I.nullCharacterReference : e > 1114111 ? I.characterReferenceOutsideUnicodeRange : Qi(e) ? I.surrogateCharacterReference : Xi(e) ? I.noncharacterCharacterReference : Gi(e) || e === m.CARRIAGE_RETURN ? I.controlCharacterReference : null;
}
class Af {
  constructor(t, n) {
    this.options = t, this.handler = n, this.paused = !1, this.inLoop = !1, this.inForeignNode = !1, this.lastStartTagName = "", this.active = !1, this.state = E.DATA, this.returnState = E.DATA, this.entityStartPos = 0, this.consumedAfterSnapshot = -1, this.currentCharacterToken = null, this.currentToken = null, this.currentAttr = { name: "", value: "" }, this.preprocessor = new uf(n), this.currentLocation = this.getCurrentLocation(-1), this.entityDecoder = new Ji($i, (r, u) => {
      this.preprocessor.pos = this.entityStartPos + u - 1, this._flushCodePointConsumedAsCharacterReference(r);
    }, n.onParseError ? {
      missingSemicolonAfterCharacterReference: () => {
        this._err(I.missingSemicolonAfterCharacterReference, 1);
      },
      absenceOfDigitsInNumericCharacterReference: (r) => {
        this._err(I.absenceOfDigitsInNumericCharacterReference, this.entityStartPos - this.preprocessor.pos + r);
      },
      validateNumericCharacterReference: (r) => {
        const u = bf(r);
        u && this._err(u, 1);
      }
    } : void 0);
  }
  //Errors
  _err(t, n = 0) {
    var r, u;
    (u = (r = this.handler).onParseError) === null || u === void 0 || u.call(r, this.preprocessor.getError(t, n));
  }
  // NOTE: `offset` may never run across line boundaries.
  getCurrentLocation(t) {
    return this.options.sourceCodeLocationInfo ? {
      startLine: this.preprocessor.line,
      startCol: this.preprocessor.col - t,
      startOffset: this.preprocessor.offset - t,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    } : null;
  }
  _runParsingLoop() {
    if (!this.inLoop) {
      for (this.inLoop = !0; this.active && !this.paused; ) {
        this.consumedAfterSnapshot = 0;
        const t = this._consume();
        this._ensureHibernation() || this._callState(t);
      }
      this.inLoop = !1;
    }
  }
  //API
  pause() {
    this.paused = !0;
  }
  resume(t) {
    if (!this.paused)
      throw new Error("Parser was already resumed");
    this.paused = !1, !this.inLoop && (this._runParsingLoop(), this.paused || t?.());
  }
  write(t, n, r) {
    this.active = !0, this.preprocessor.write(t, n), this._runParsingLoop(), this.paused || r?.();
  }
  insertHtmlAtCurrentPos(t) {
    this.active = !0, this.preprocessor.insertHtmlAtCurrentPos(t), this._runParsingLoop();
  }
  //Hibernation
  _ensureHibernation() {
    return this.preprocessor.endOfChunkHit ? (this.preprocessor.retreat(this.consumedAfterSnapshot), this.consumedAfterSnapshot = 0, this.active = !1, !0) : !1;
  }
  //Consumption
  _consume() {
    return this.consumedAfterSnapshot++, this.preprocessor.advance();
  }
  _advanceBy(t) {
    this.consumedAfterSnapshot += t;
    for (let n = 0; n < t; n++)
      this.preprocessor.advance();
  }
  _consumeSequenceIfMatch(t, n) {
    return this.preprocessor.startsWith(t, n) ? (this._advanceBy(t.length - 1), !0) : !1;
  }
  //Token creation
  _createStartTagToken() {
    this.currentToken = {
      type: q.START_TAG,
      tagName: "",
      tagID: s.UNKNOWN,
      selfClosing: !1,
      ackSelfClosing: !1,
      attrs: [],
      location: this.getCurrentLocation(1)
    };
  }
  _createEndTagToken() {
    this.currentToken = {
      type: q.END_TAG,
      tagName: "",
      tagID: s.UNKNOWN,
      selfClosing: !1,
      ackSelfClosing: !1,
      attrs: [],
      location: this.getCurrentLocation(2)
    };
  }
  _createCommentToken(t) {
    this.currentToken = {
      type: q.COMMENT,
      data: "",
      location: this.getCurrentLocation(t)
    };
  }
  _createDoctypeToken(t) {
    this.currentToken = {
      type: q.DOCTYPE,
      name: t,
      forceQuirks: !1,
      publicId: null,
      systemId: null,
      location: this.currentLocation
    };
  }
  _createCharacterToken(t, n) {
    this.currentCharacterToken = {
      type: t,
      chars: n,
      location: this.currentLocation
    };
  }
  //Tag attributes
  _createAttr(t) {
    this.currentAttr = {
      name: t,
      value: ""
    }, this.currentLocation = this.getCurrentLocation(0);
  }
  _leaveAttrName() {
    var t, n;
    const r = this.currentToken;
    if (Ki(r, this.currentAttr.name) === null) {
      if (r.attrs.push(this.currentAttr), r.location && this.currentLocation) {
        const u = (t = (n = r.location).attrs) !== null && t !== void 0 ? t : n.attrs = /* @__PURE__ */ Object.create(null);
        u[this.currentAttr.name] = this.currentLocation, this._leaveAttrValue();
      }
    } else
      this._err(I.duplicateAttribute);
  }
  _leaveAttrValue() {
    this.currentLocation && (this.currentLocation.endLine = this.preprocessor.line, this.currentLocation.endCol = this.preprocessor.col, this.currentLocation.endOffset = this.preprocessor.offset);
  }
  //Token emission
  prepareToken(t) {
    this._emitCurrentCharacterToken(t.location), this.currentToken = null, t.location && (t.location.endLine = this.preprocessor.line, t.location.endCol = this.preprocessor.col + 1, t.location.endOffset = this.preprocessor.offset + 1), this.currentLocation = this.getCurrentLocation(-1);
  }
  emitCurrentTagToken() {
    const t = this.currentToken;
    this.prepareToken(t), t.tagID = bt(t.tagName), t.type === q.START_TAG ? (this.lastStartTagName = t.tagName, this.handler.onStartTag(t)) : (t.attrs.length > 0 && this._err(I.endTagWithAttributes), t.selfClosing && this._err(I.endTagWithTrailingSolidus), this.handler.onEndTag(t)), this.preprocessor.dropParsedChunk();
  }
  emitCurrentComment(t) {
    this.prepareToken(t), this.handler.onComment(t), this.preprocessor.dropParsedChunk();
  }
  emitCurrentDoctype(t) {
    this.prepareToken(t), this.handler.onDoctype(t), this.preprocessor.dropParsedChunk();
  }
  _emitCurrentCharacterToken(t) {
    if (this.currentCharacterToken) {
      switch (t && this.currentCharacterToken.location && (this.currentCharacterToken.location.endLine = t.startLine, this.currentCharacterToken.location.endCol = t.startCol, this.currentCharacterToken.location.endOffset = t.startOffset), this.currentCharacterToken.type) {
        case q.CHARACTER: {
          this.handler.onCharacter(this.currentCharacterToken);
          break;
        }
        case q.NULL_CHARACTER: {
          this.handler.onNullCharacter(this.currentCharacterToken);
          break;
        }
        case q.WHITESPACE_CHARACTER: {
          this.handler.onWhitespaceCharacter(this.currentCharacterToken);
          break;
        }
      }
      this.currentCharacterToken = null;
    }
  }
  _emitEOFToken() {
    const t = this.getCurrentLocation(0);
    t && (t.endLine = t.startLine, t.endCol = t.startCol, t.endOffset = t.startOffset), this._emitCurrentCharacterToken(t), this.handler.onEof({ type: q.EOF, location: t }), this.active = !1;
  }
  //Characters emission
  //OPTIMIZATION: The specification uses only one type of character token (one token per character).
  //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
  //If we have a sequence of characters that belong to the same group, the parser can process it
  //as a single solid character token.
  //So, there are 3 types of character tokens in parse5:
  //1)TokenType.NULL_CHARACTER - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
  //2)TokenType.WHITESPACE_CHARACTER - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
  //3)TokenType.CHARACTER - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
  _appendCharToCurrentCharacterToken(t, n) {
    if (this.currentCharacterToken)
      if (this.currentCharacterToken.type === t) {
        this.currentCharacterToken.chars += n;
        return;
      } else
        this.currentLocation = this.getCurrentLocation(0), this._emitCurrentCharacterToken(this.currentLocation), this.preprocessor.dropParsedChunk();
    this._createCharacterToken(t, n);
  }
  _emitCodePoint(t) {
    const n = ea(t) ? q.WHITESPACE_CHARACTER : t === m.NULL ? q.NULL_CHARACTER : q.CHARACTER;
    this._appendCharToCurrentCharacterToken(n, String.fromCodePoint(t));
  }
  //NOTE: used when we emit characters explicitly.
  //This is always for non-whitespace and non-null characters, which allows us to avoid additional checks.
  _emitChars(t) {
    this._appendCharToCurrentCharacterToken(q.CHARACTER, t);
  }
  // Character reference helpers
  _startCharacterReference() {
    this.returnState = this.state, this.state = E.CHARACTER_REFERENCE, this.entityStartPos = this.preprocessor.pos, this.entityDecoder.startEntity(this._isCharacterReferenceInAttribute() ? we.Attribute : we.Legacy);
  }
  _isCharacterReferenceInAttribute() {
    return this.returnState === E.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === E.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === E.ATTRIBUTE_VALUE_UNQUOTED;
  }
  _flushCodePointConsumedAsCharacterReference(t) {
    this._isCharacterReferenceInAttribute() ? this.currentAttr.value += String.fromCodePoint(t) : this._emitCodePoint(t);
  }
  // Calling states this way turns out to be much faster than any other approach.
  _callState(t) {
    switch (this.state) {
      case E.DATA: {
        this._stateData(t);
        break;
      }
      case E.RCDATA: {
        this._stateRcdata(t);
        break;
      }
      case E.RAWTEXT: {
        this._stateRawtext(t);
        break;
      }
      case E.SCRIPT_DATA: {
        this._stateScriptData(t);
        break;
      }
      case E.PLAINTEXT: {
        this._statePlaintext(t);
        break;
      }
      case E.TAG_OPEN: {
        this._stateTagOpen(t);
        break;
      }
      case E.END_TAG_OPEN: {
        this._stateEndTagOpen(t);
        break;
      }
      case E.TAG_NAME: {
        this._stateTagName(t);
        break;
      }
      case E.RCDATA_LESS_THAN_SIGN: {
        this._stateRcdataLessThanSign(t);
        break;
      }
      case E.RCDATA_END_TAG_OPEN: {
        this._stateRcdataEndTagOpen(t);
        break;
      }
      case E.RCDATA_END_TAG_NAME: {
        this._stateRcdataEndTagName(t);
        break;
      }
      case E.RAWTEXT_LESS_THAN_SIGN: {
        this._stateRawtextLessThanSign(t);
        break;
      }
      case E.RAWTEXT_END_TAG_OPEN: {
        this._stateRawtextEndTagOpen(t);
        break;
      }
      case E.RAWTEXT_END_TAG_NAME: {
        this._stateRawtextEndTagName(t);
        break;
      }
      case E.SCRIPT_DATA_LESS_THAN_SIGN: {
        this._stateScriptDataLessThanSign(t);
        break;
      }
      case E.SCRIPT_DATA_END_TAG_OPEN: {
        this._stateScriptDataEndTagOpen(t);
        break;
      }
      case E.SCRIPT_DATA_END_TAG_NAME: {
        this._stateScriptDataEndTagName(t);
        break;
      }
      case E.SCRIPT_DATA_ESCAPE_START: {
        this._stateScriptDataEscapeStart(t);
        break;
      }
      case E.SCRIPT_DATA_ESCAPE_START_DASH: {
        this._stateScriptDataEscapeStartDash(t);
        break;
      }
      case E.SCRIPT_DATA_ESCAPED: {
        this._stateScriptDataEscaped(t);
        break;
      }
      case E.SCRIPT_DATA_ESCAPED_DASH: {
        this._stateScriptDataEscapedDash(t);
        break;
      }
      case E.SCRIPT_DATA_ESCAPED_DASH_DASH: {
        this._stateScriptDataEscapedDashDash(t);
        break;
      }
      case E.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataEscapedLessThanSign(t);
        break;
      }
      case E.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {
        this._stateScriptDataEscapedEndTagOpen(t);
        break;
      }
      case E.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {
        this._stateScriptDataEscapedEndTagName(t);
        break;
      }
      case E.SCRIPT_DATA_DOUBLE_ESCAPE_START: {
        this._stateScriptDataDoubleEscapeStart(t);
        break;
      }
      case E.SCRIPT_DATA_DOUBLE_ESCAPED: {
        this._stateScriptDataDoubleEscaped(t);
        break;
      }
      case E.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {
        this._stateScriptDataDoubleEscapedDash(t);
        break;
      }
      case E.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {
        this._stateScriptDataDoubleEscapedDashDash(t);
        break;
      }
      case E.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataDoubleEscapedLessThanSign(t);
        break;
      }
      case E.SCRIPT_DATA_DOUBLE_ESCAPE_END: {
        this._stateScriptDataDoubleEscapeEnd(t);
        break;
      }
      case E.BEFORE_ATTRIBUTE_NAME: {
        this._stateBeforeAttributeName(t);
        break;
      }
      case E.ATTRIBUTE_NAME: {
        this._stateAttributeName(t);
        break;
      }
      case E.AFTER_ATTRIBUTE_NAME: {
        this._stateAfterAttributeName(t);
        break;
      }
      case E.BEFORE_ATTRIBUTE_VALUE: {
        this._stateBeforeAttributeValue(t);
        break;
      }
      case E.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
        this._stateAttributeValueDoubleQuoted(t);
        break;
      }
      case E.ATTRIBUTE_VALUE_SINGLE_QUOTED: {
        this._stateAttributeValueSingleQuoted(t);
        break;
      }
      case E.ATTRIBUTE_VALUE_UNQUOTED: {
        this._stateAttributeValueUnquoted(t);
        break;
      }
      case E.AFTER_ATTRIBUTE_VALUE_QUOTED: {
        this._stateAfterAttributeValueQuoted(t);
        break;
      }
      case E.SELF_CLOSING_START_TAG: {
        this._stateSelfClosingStartTag(t);
        break;
      }
      case E.BOGUS_COMMENT: {
        this._stateBogusComment(t);
        break;
      }
      case E.MARKUP_DECLARATION_OPEN: {
        this._stateMarkupDeclarationOpen(t);
        break;
      }
      case E.COMMENT_START: {
        this._stateCommentStart(t);
        break;
      }
      case E.COMMENT_START_DASH: {
        this._stateCommentStartDash(t);
        break;
      }
      case E.COMMENT: {
        this._stateComment(t);
        break;
      }
      case E.COMMENT_LESS_THAN_SIGN: {
        this._stateCommentLessThanSign(t);
        break;
      }
      case E.COMMENT_LESS_THAN_SIGN_BANG: {
        this._stateCommentLessThanSignBang(t);
        break;
      }
      case E.COMMENT_LESS_THAN_SIGN_BANG_DASH: {
        this._stateCommentLessThanSignBangDash(t);
        break;
      }
      case E.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
        this._stateCommentLessThanSignBangDashDash(t);
        break;
      }
      case E.COMMENT_END_DASH: {
        this._stateCommentEndDash(t);
        break;
      }
      case E.COMMENT_END: {
        this._stateCommentEnd(t);
        break;
      }
      case E.COMMENT_END_BANG: {
        this._stateCommentEndBang(t);
        break;
      }
      case E.DOCTYPE: {
        this._stateDoctype(t);
        break;
      }
      case E.BEFORE_DOCTYPE_NAME: {
        this._stateBeforeDoctypeName(t);
        break;
      }
      case E.DOCTYPE_NAME: {
        this._stateDoctypeName(t);
        break;
      }
      case E.AFTER_DOCTYPE_NAME: {
        this._stateAfterDoctypeName(t);
        break;
      }
      case E.AFTER_DOCTYPE_PUBLIC_KEYWORD: {
        this._stateAfterDoctypePublicKeyword(t);
        break;
      }
      case E.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateBeforeDoctypePublicIdentifier(t);
        break;
      }
      case E.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypePublicIdentifierDoubleQuoted(t);
        break;
      }
      case E.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypePublicIdentifierSingleQuoted(t);
        break;
      }
      case E.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateAfterDoctypePublicIdentifier(t);
        break;
      }
      case E.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {
        this._stateBetweenDoctypePublicAndSystemIdentifiers(t);
        break;
      }
      case E.AFTER_DOCTYPE_SYSTEM_KEYWORD: {
        this._stateAfterDoctypeSystemKeyword(t);
        break;
      }
      case E.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateBeforeDoctypeSystemIdentifier(t);
        break;
      }
      case E.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypeSystemIdentifierDoubleQuoted(t);
        break;
      }
      case E.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypeSystemIdentifierSingleQuoted(t);
        break;
      }
      case E.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateAfterDoctypeSystemIdentifier(t);
        break;
      }
      case E.BOGUS_DOCTYPE: {
        this._stateBogusDoctype(t);
        break;
      }
      case E.CDATA_SECTION: {
        this._stateCdataSection(t);
        break;
      }
      case E.CDATA_SECTION_BRACKET: {
        this._stateCdataSectionBracket(t);
        break;
      }
      case E.CDATA_SECTION_END: {
        this._stateCdataSectionEnd(t);
        break;
      }
      case E.CHARACTER_REFERENCE: {
        this._stateCharacterReference();
        break;
      }
      case E.AMBIGUOUS_AMPERSAND: {
        this._stateAmbiguousAmpersand(t);
        break;
      }
      default:
        throw new Error("Unknown state");
    }
  }
  // State machine
  // Data state
  //------------------------------------------------------------------
  _stateData(t) {
    switch (t) {
      case m.LESS_THAN_SIGN: {
        this.state = E.TAG_OPEN;
        break;
      }
      case m.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case m.NULL: {
        this._err(I.unexpectedNullCharacter), this._emitCodePoint(t);
        break;
      }
      case m.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  //  RCDATA state
  //------------------------------------------------------------------
  _stateRcdata(t) {
    switch (t) {
      case m.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case m.LESS_THAN_SIGN: {
        this.state = E.RCDATA_LESS_THAN_SIGN;
        break;
      }
      case m.NULL: {
        this._err(I.unexpectedNullCharacter), this._emitChars(te);
        break;
      }
      case m.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // RAWTEXT state
  //------------------------------------------------------------------
  _stateRawtext(t) {
    switch (t) {
      case m.LESS_THAN_SIGN: {
        this.state = E.RAWTEXT_LESS_THAN_SIGN;
        break;
      }
      case m.NULL: {
        this._err(I.unexpectedNullCharacter), this._emitChars(te);
        break;
      }
      case m.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data state
  //------------------------------------------------------------------
  _stateScriptData(t) {
    switch (t) {
      case m.LESS_THAN_SIGN: {
        this.state = E.SCRIPT_DATA_LESS_THAN_SIGN;
        break;
      }
      case m.NULL: {
        this._err(I.unexpectedNullCharacter), this._emitChars(te);
        break;
      }
      case m.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // PLAINTEXT state
  //------------------------------------------------------------------
  _statePlaintext(t) {
    switch (t) {
      case m.NULL: {
        this._err(I.unexpectedNullCharacter), this._emitChars(te);
        break;
      }
      case m.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Tag open state
  //------------------------------------------------------------------
  _stateTagOpen(t) {
    if (ve(t))
      this._createStartTagToken(), this.state = E.TAG_NAME, this._stateTagName(t);
    else
      switch (t) {
        case m.EXCLAMATION_MARK: {
          this.state = E.MARKUP_DECLARATION_OPEN;
          break;
        }
        case m.SOLIDUS: {
          this.state = E.END_TAG_OPEN;
          break;
        }
        case m.QUESTION_MARK: {
          this._err(I.unexpectedQuestionMarkInsteadOfTagName), this._createCommentToken(1), this.state = E.BOGUS_COMMENT, this._stateBogusComment(t);
          break;
        }
        case m.EOF: {
          this._err(I.eofBeforeTagName), this._emitChars("<"), this._emitEOFToken();
          break;
        }
        default:
          this._err(I.invalidFirstCharacterOfTagName), this._emitChars("<"), this.state = E.DATA, this._stateData(t);
      }
  }
  // End tag open state
  //------------------------------------------------------------------
  _stateEndTagOpen(t) {
    if (ve(t))
      this._createEndTagToken(), this.state = E.TAG_NAME, this._stateTagName(t);
    else
      switch (t) {
        case m.GREATER_THAN_SIGN: {
          this._err(I.missingEndTagName), this.state = E.DATA;
          break;
        }
        case m.EOF: {
          this._err(I.eofBeforeTagName), this._emitChars("</"), this._emitEOFToken();
          break;
        }
        default:
          this._err(I.invalidFirstCharacterOfTagName), this._createCommentToken(2), this.state = E.BOGUS_COMMENT, this._stateBogusComment(t);
      }
  }
  // Tag name state
  //------------------------------------------------------------------
  _stateTagName(t) {
    const n = this.currentToken;
    switch (t) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED: {
        this.state = E.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case m.SOLIDUS: {
        this.state = E.SELF_CLOSING_START_TAG;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this.state = E.DATA, this.emitCurrentTagToken();
        break;
      }
      case m.NULL: {
        this._err(I.unexpectedNullCharacter), n.tagName += te;
        break;
      }
      case m.EOF: {
        this._err(I.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        n.tagName += String.fromCodePoint(yt(t) ? $t(t) : t);
    }
  }
  // RCDATA less-than sign state
  //------------------------------------------------------------------
  _stateRcdataLessThanSign(t) {
    t === m.SOLIDUS ? this.state = E.RCDATA_END_TAG_OPEN : (this._emitChars("<"), this.state = E.RCDATA, this._stateRcdata(t));
  }
  // RCDATA end tag open state
  //------------------------------------------------------------------
  _stateRcdataEndTagOpen(t) {
    ve(t) ? (this.state = E.RCDATA_END_TAG_NAME, this._stateRcdataEndTagName(t)) : (this._emitChars("</"), this.state = E.RCDATA, this._stateRcdata(t));
  }
  handleSpecialEndTag(t) {
    if (!this.preprocessor.startsWith(this.lastStartTagName, !1))
      return !this._ensureHibernation();
    this._createEndTagToken();
    const n = this.currentToken;
    switch (n.tagName = this.lastStartTagName, this.preprocessor.peek(this.lastStartTagName.length)) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED:
        return this._advanceBy(this.lastStartTagName.length), this.state = E.BEFORE_ATTRIBUTE_NAME, !1;
      case m.SOLIDUS:
        return this._advanceBy(this.lastStartTagName.length), this.state = E.SELF_CLOSING_START_TAG, !1;
      case m.GREATER_THAN_SIGN:
        return this._advanceBy(this.lastStartTagName.length), this.emitCurrentTagToken(), this.state = E.DATA, !1;
      default:
        return !this._ensureHibernation();
    }
  }
  // RCDATA end tag name state
  //------------------------------------------------------------------
  _stateRcdataEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = E.RCDATA, this._stateRcdata(t));
  }
  // RAWTEXT less-than sign state
  //------------------------------------------------------------------
  _stateRawtextLessThanSign(t) {
    t === m.SOLIDUS ? this.state = E.RAWTEXT_END_TAG_OPEN : (this._emitChars("<"), this.state = E.RAWTEXT, this._stateRawtext(t));
  }
  // RAWTEXT end tag open state
  //------------------------------------------------------------------
  _stateRawtextEndTagOpen(t) {
    ve(t) ? (this.state = E.RAWTEXT_END_TAG_NAME, this._stateRawtextEndTagName(t)) : (this._emitChars("</"), this.state = E.RAWTEXT, this._stateRawtext(t));
  }
  // RAWTEXT end tag name state
  //------------------------------------------------------------------
  _stateRawtextEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = E.RAWTEXT, this._stateRawtext(t));
  }
  // Script data less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataLessThanSign(t) {
    switch (t) {
      case m.SOLIDUS: {
        this.state = E.SCRIPT_DATA_END_TAG_OPEN;
        break;
      }
      case m.EXCLAMATION_MARK: {
        this.state = E.SCRIPT_DATA_ESCAPE_START, this._emitChars("<!");
        break;
      }
      default:
        this._emitChars("<"), this.state = E.SCRIPT_DATA, this._stateScriptData(t);
    }
  }
  // Script data end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEndTagOpen(t) {
    ve(t) ? (this.state = E.SCRIPT_DATA_END_TAG_NAME, this._stateScriptDataEndTagName(t)) : (this._emitChars("</"), this.state = E.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = E.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escape start state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStart(t) {
    t === m.HYPHEN_MINUS ? (this.state = E.SCRIPT_DATA_ESCAPE_START_DASH, this._emitChars("-")) : (this.state = E.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escape start dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStartDash(t) {
    t === m.HYPHEN_MINUS ? (this.state = E.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-")) : (this.state = E.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escaped state
  //------------------------------------------------------------------
  _stateScriptDataEscaped(t) {
    switch (t) {
      case m.HYPHEN_MINUS: {
        this.state = E.SCRIPT_DATA_ESCAPED_DASH, this._emitChars("-");
        break;
      }
      case m.LESS_THAN_SIGN: {
        this.state = E.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case m.NULL: {
        this._err(I.unexpectedNullCharacter), this._emitChars(te);
        break;
      }
      case m.EOF: {
        this._err(I.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDash(t) {
    switch (t) {
      case m.HYPHEN_MINUS: {
        this.state = E.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-");
        break;
      }
      case m.LESS_THAN_SIGN: {
        this.state = E.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case m.NULL: {
        this._err(I.unexpectedNullCharacter), this.state = E.SCRIPT_DATA_ESCAPED, this._emitChars(te);
        break;
      }
      case m.EOF: {
        this._err(I.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = E.SCRIPT_DATA_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDashDash(t) {
    switch (t) {
      case m.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case m.LESS_THAN_SIGN: {
        this.state = E.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this.state = E.SCRIPT_DATA, this._emitChars(">");
        break;
      }
      case m.NULL: {
        this._err(I.unexpectedNullCharacter), this.state = E.SCRIPT_DATA_ESCAPED, this._emitChars(te);
        break;
      }
      case m.EOF: {
        this._err(I.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = E.SCRIPT_DATA_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataEscapedLessThanSign(t) {
    t === m.SOLIDUS ? this.state = E.SCRIPT_DATA_ESCAPED_END_TAG_OPEN : ve(t) ? (this._emitChars("<"), this.state = E.SCRIPT_DATA_DOUBLE_ESCAPE_START, this._stateScriptDataDoubleEscapeStart(t)) : (this._emitChars("<"), this.state = E.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data escaped end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagOpen(t) {
    ve(t) ? (this.state = E.SCRIPT_DATA_ESCAPED_END_TAG_NAME, this._stateScriptDataEscapedEndTagName(t)) : (this._emitChars("</"), this.state = E.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data escaped end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = E.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data double escape start state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeStart(t) {
    if (this.preprocessor.startsWith(me.SCRIPT, !1) && Ru(this.preprocessor.peek(me.SCRIPT.length))) {
      this._emitCodePoint(t);
      for (let n = 0; n < me.SCRIPT.length; n++)
        this._emitCodePoint(this._consume());
      this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED;
    } else this._ensureHibernation() || (this.state = E.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data double escaped state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscaped(t) {
    switch (t) {
      case m.HYPHEN_MINUS: {
        this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED_DASH, this._emitChars("-");
        break;
      }
      case m.LESS_THAN_SIGN: {
        this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case m.NULL: {
        this._err(I.unexpectedNullCharacter), this._emitChars(te);
        break;
      }
      case m.EOF: {
        this._err(I.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data double escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDash(t) {
    switch (t) {
      case m.HYPHEN_MINUS: {
        this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH, this._emitChars("-");
        break;
      }
      case m.LESS_THAN_SIGN: {
        this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case m.NULL: {
        this._err(I.unexpectedNullCharacter), this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(te);
        break;
      }
      case m.EOF: {
        this._err(I.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data double escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDashDash(t) {
    switch (t) {
      case m.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case m.LESS_THAN_SIGN: {
        this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this.state = E.SCRIPT_DATA, this._emitChars(">");
        break;
      }
      case m.NULL: {
        this._err(I.unexpectedNullCharacter), this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(te);
        break;
      }
      case m.EOF: {
        this._err(I.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data double escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedLessThanSign(t) {
    t === m.SOLIDUS ? (this.state = E.SCRIPT_DATA_DOUBLE_ESCAPE_END, this._emitChars("/")) : (this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(t));
  }
  // Script data double escape end state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeEnd(t) {
    if (this.preprocessor.startsWith(me.SCRIPT, !1) && Ru(this.preprocessor.peek(me.SCRIPT.length))) {
      this._emitCodePoint(t);
      for (let n = 0; n < me.SCRIPT.length; n++)
        this._emitCodePoint(this._consume());
      this.state = E.SCRIPT_DATA_ESCAPED;
    } else this._ensureHibernation() || (this.state = E.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(t));
  }
  // Before attribute name state
  //------------------------------------------------------------------
  _stateBeforeAttributeName(t) {
    switch (t) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED:
        break;
      case m.SOLIDUS:
      case m.GREATER_THAN_SIGN:
      case m.EOF: {
        this.state = E.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(t);
        break;
      }
      case m.EQUALS_SIGN: {
        this._err(I.unexpectedEqualsSignBeforeAttributeName), this._createAttr("="), this.state = E.ATTRIBUTE_NAME;
        break;
      }
      default:
        this._createAttr(""), this.state = E.ATTRIBUTE_NAME, this._stateAttributeName(t);
    }
  }
  // Attribute name state
  //------------------------------------------------------------------
  _stateAttributeName(t) {
    switch (t) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED:
      case m.SOLIDUS:
      case m.GREATER_THAN_SIGN:
      case m.EOF: {
        this._leaveAttrName(), this.state = E.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(t);
        break;
      }
      case m.EQUALS_SIGN: {
        this._leaveAttrName(), this.state = E.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case m.QUOTATION_MARK:
      case m.APOSTROPHE:
      case m.LESS_THAN_SIGN: {
        this._err(I.unexpectedCharacterInAttributeName), this.currentAttr.name += String.fromCodePoint(t);
        break;
      }
      case m.NULL: {
        this._err(I.unexpectedNullCharacter), this.currentAttr.name += te;
        break;
      }
      default:
        this.currentAttr.name += String.fromCodePoint(yt(t) ? $t(t) : t);
    }
  }
  // After attribute name state
  //------------------------------------------------------------------
  _stateAfterAttributeName(t) {
    switch (t) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED:
        break;
      case m.SOLIDUS: {
        this.state = E.SELF_CLOSING_START_TAG;
        break;
      }
      case m.EQUALS_SIGN: {
        this.state = E.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this.state = E.DATA, this.emitCurrentTagToken();
        break;
      }
      case m.EOF: {
        this._err(I.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._createAttr(""), this.state = E.ATTRIBUTE_NAME, this._stateAttributeName(t);
    }
  }
  // Before attribute value state
  //------------------------------------------------------------------
  _stateBeforeAttributeValue(t) {
    switch (t) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED:
        break;
      case m.QUOTATION_MARK: {
        this.state = E.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
        break;
      }
      case m.APOSTROPHE: {
        this.state = E.ATTRIBUTE_VALUE_SINGLE_QUOTED;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._err(I.missingAttributeValue), this.state = E.DATA, this.emitCurrentTagToken();
        break;
      }
      default:
        this.state = E.ATTRIBUTE_VALUE_UNQUOTED, this._stateAttributeValueUnquoted(t);
    }
  }
  // Attribute value (double-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueDoubleQuoted(t) {
    switch (t) {
      case m.QUOTATION_MARK: {
        this.state = E.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case m.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case m.NULL: {
        this._err(I.unexpectedNullCharacter), this.currentAttr.value += te;
        break;
      }
      case m.EOF: {
        this._err(I.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // Attribute value (single-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueSingleQuoted(t) {
    switch (t) {
      case m.APOSTROPHE: {
        this.state = E.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case m.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case m.NULL: {
        this._err(I.unexpectedNullCharacter), this.currentAttr.value += te;
        break;
      }
      case m.EOF: {
        this._err(I.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // Attribute value (unquoted) state
  //------------------------------------------------------------------
  _stateAttributeValueUnquoted(t) {
    switch (t) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED: {
        this._leaveAttrValue(), this.state = E.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case m.AMPERSAND: {
        this._startCharacterReference();
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._leaveAttrValue(), this.state = E.DATA, this.emitCurrentTagToken();
        break;
      }
      case m.NULL: {
        this._err(I.unexpectedNullCharacter), this.currentAttr.value += te;
        break;
      }
      case m.QUOTATION_MARK:
      case m.APOSTROPHE:
      case m.LESS_THAN_SIGN:
      case m.EQUALS_SIGN:
      case m.GRAVE_ACCENT: {
        this._err(I.unexpectedCharacterInUnquotedAttributeValue), this.currentAttr.value += String.fromCodePoint(t);
        break;
      }
      case m.EOF: {
        this._err(I.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // After attribute value (quoted) state
  //------------------------------------------------------------------
  _stateAfterAttributeValueQuoted(t) {
    switch (t) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED: {
        this._leaveAttrValue(), this.state = E.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case m.SOLIDUS: {
        this._leaveAttrValue(), this.state = E.SELF_CLOSING_START_TAG;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._leaveAttrValue(), this.state = E.DATA, this.emitCurrentTagToken();
        break;
      }
      case m.EOF: {
        this._err(I.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._err(I.missingWhitespaceBetweenAttributes), this.state = E.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(t);
    }
  }
  // Self-closing start tag state
  //------------------------------------------------------------------
  _stateSelfClosingStartTag(t) {
    switch (t) {
      case m.GREATER_THAN_SIGN: {
        const n = this.currentToken;
        n.selfClosing = !0, this.state = E.DATA, this.emitCurrentTagToken();
        break;
      }
      case m.EOF: {
        this._err(I.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._err(I.unexpectedSolidusInTag), this.state = E.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(t);
    }
  }
  // Bogus comment state
  //------------------------------------------------------------------
  _stateBogusComment(t) {
    const n = this.currentToken;
    switch (t) {
      case m.GREATER_THAN_SIGN: {
        this.state = E.DATA, this.emitCurrentComment(n);
        break;
      }
      case m.EOF: {
        this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      case m.NULL: {
        this._err(I.unexpectedNullCharacter), n.data += te;
        break;
      }
      default:
        n.data += String.fromCodePoint(t);
    }
  }
  // Markup declaration open state
  //------------------------------------------------------------------
  _stateMarkupDeclarationOpen(t) {
    this._consumeSequenceIfMatch(me.DASH_DASH, !0) ? (this._createCommentToken(me.DASH_DASH.length + 1), this.state = E.COMMENT_START) : this._consumeSequenceIfMatch(me.DOCTYPE, !1) ? (this.currentLocation = this.getCurrentLocation(me.DOCTYPE.length + 1), this.state = E.DOCTYPE) : this._consumeSequenceIfMatch(me.CDATA_START, !0) ? this.inForeignNode ? this.state = E.CDATA_SECTION : (this._err(I.cdataInHtmlContent), this._createCommentToken(me.CDATA_START.length + 1), this.currentToken.data = "[CDATA[", this.state = E.BOGUS_COMMENT) : this._ensureHibernation() || (this._err(I.incorrectlyOpenedComment), this._createCommentToken(2), this.state = E.BOGUS_COMMENT, this._stateBogusComment(t));
  }
  // Comment start state
  //------------------------------------------------------------------
  _stateCommentStart(t) {
    switch (t) {
      case m.HYPHEN_MINUS: {
        this.state = E.COMMENT_START_DASH;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._err(I.abruptClosingOfEmptyComment), this.state = E.DATA;
        const n = this.currentToken;
        this.emitCurrentComment(n);
        break;
      }
      default:
        this.state = E.COMMENT, this._stateComment(t);
    }
  }
  // Comment start dash state
  //------------------------------------------------------------------
  _stateCommentStartDash(t) {
    const n = this.currentToken;
    switch (t) {
      case m.HYPHEN_MINUS: {
        this.state = E.COMMENT_END;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._err(I.abruptClosingOfEmptyComment), this.state = E.DATA, this.emitCurrentComment(n);
        break;
      }
      case m.EOF: {
        this._err(I.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "-", this.state = E.COMMENT, this._stateComment(t);
    }
  }
  // Comment state
  //------------------------------------------------------------------
  _stateComment(t) {
    const n = this.currentToken;
    switch (t) {
      case m.HYPHEN_MINUS: {
        this.state = E.COMMENT_END_DASH;
        break;
      }
      case m.LESS_THAN_SIGN: {
        n.data += "<", this.state = E.COMMENT_LESS_THAN_SIGN;
        break;
      }
      case m.NULL: {
        this._err(I.unexpectedNullCharacter), n.data += te;
        break;
      }
      case m.EOF: {
        this._err(I.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += String.fromCodePoint(t);
    }
  }
  // Comment less-than sign state
  //------------------------------------------------------------------
  _stateCommentLessThanSign(t) {
    const n = this.currentToken;
    switch (t) {
      case m.EXCLAMATION_MARK: {
        n.data += "!", this.state = E.COMMENT_LESS_THAN_SIGN_BANG;
        break;
      }
      case m.LESS_THAN_SIGN: {
        n.data += "<";
        break;
      }
      default:
        this.state = E.COMMENT, this._stateComment(t);
    }
  }
  // Comment less-than sign bang state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBang(t) {
    t === m.HYPHEN_MINUS ? this.state = E.COMMENT_LESS_THAN_SIGN_BANG_DASH : (this.state = E.COMMENT, this._stateComment(t));
  }
  // Comment less-than sign bang dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDash(t) {
    t === m.HYPHEN_MINUS ? this.state = E.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH : (this.state = E.COMMENT_END_DASH, this._stateCommentEndDash(t));
  }
  // Comment less-than sign bang dash dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDashDash(t) {
    t !== m.GREATER_THAN_SIGN && t !== m.EOF && this._err(I.nestedComment), this.state = E.COMMENT_END, this._stateCommentEnd(t);
  }
  // Comment end dash state
  //------------------------------------------------------------------
  _stateCommentEndDash(t) {
    const n = this.currentToken;
    switch (t) {
      case m.HYPHEN_MINUS: {
        this.state = E.COMMENT_END;
        break;
      }
      case m.EOF: {
        this._err(I.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "-", this.state = E.COMMENT, this._stateComment(t);
    }
  }
  // Comment end state
  //------------------------------------------------------------------
  _stateCommentEnd(t) {
    const n = this.currentToken;
    switch (t) {
      case m.GREATER_THAN_SIGN: {
        this.state = E.DATA, this.emitCurrentComment(n);
        break;
      }
      case m.EXCLAMATION_MARK: {
        this.state = E.COMMENT_END_BANG;
        break;
      }
      case m.HYPHEN_MINUS: {
        n.data += "-";
        break;
      }
      case m.EOF: {
        this._err(I.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "--", this.state = E.COMMENT, this._stateComment(t);
    }
  }
  // Comment end bang state
  //------------------------------------------------------------------
  _stateCommentEndBang(t) {
    const n = this.currentToken;
    switch (t) {
      case m.HYPHEN_MINUS: {
        n.data += "--!", this.state = E.COMMENT_END_DASH;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._err(I.incorrectlyClosedComment), this.state = E.DATA, this.emitCurrentComment(n);
        break;
      }
      case m.EOF: {
        this._err(I.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "--!", this.state = E.COMMENT, this._stateComment(t);
    }
  }
  // DOCTYPE state
  //------------------------------------------------------------------
  _stateDoctype(t) {
    switch (t) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED: {
        this.state = E.BEFORE_DOCTYPE_NAME;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this.state = E.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(t);
        break;
      }
      case m.EOF: {
        this._err(I.eofInDoctype), this._createDoctypeToken(null);
        const n = this.currentToken;
        n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(I.missingWhitespaceBeforeDoctypeName), this.state = E.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(t);
    }
  }
  // Before DOCTYPE name state
  //------------------------------------------------------------------
  _stateBeforeDoctypeName(t) {
    if (yt(t))
      this._createDoctypeToken(String.fromCharCode($t(t))), this.state = E.DOCTYPE_NAME;
    else
      switch (t) {
        case m.SPACE:
        case m.LINE_FEED:
        case m.TABULATION:
        case m.FORM_FEED:
          break;
        case m.NULL: {
          this._err(I.unexpectedNullCharacter), this._createDoctypeToken(te), this.state = E.DOCTYPE_NAME;
          break;
        }
        case m.GREATER_THAN_SIGN: {
          this._err(I.missingDoctypeName), this._createDoctypeToken(null);
          const n = this.currentToken;
          n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = E.DATA;
          break;
        }
        case m.EOF: {
          this._err(I.eofInDoctype), this._createDoctypeToken(null);
          const n = this.currentToken;
          n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
          break;
        }
        default:
          this._createDoctypeToken(String.fromCodePoint(t)), this.state = E.DOCTYPE_NAME;
      }
  }
  // DOCTYPE name state
  //------------------------------------------------------------------
  _stateDoctypeName(t) {
    const n = this.currentToken;
    switch (t) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED: {
        this.state = E.AFTER_DOCTYPE_NAME;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this.state = E.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case m.NULL: {
        this._err(I.unexpectedNullCharacter), n.name += te;
        break;
      }
      case m.EOF: {
        this._err(I.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.name += String.fromCodePoint(yt(t) ? $t(t) : t);
    }
  }
  // After DOCTYPE name state
  //------------------------------------------------------------------
  _stateAfterDoctypeName(t) {
    const n = this.currentToken;
    switch (t) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED:
        break;
      case m.GREATER_THAN_SIGN: {
        this.state = E.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case m.EOF: {
        this._err(I.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._consumeSequenceIfMatch(me.PUBLIC, !1) ? this.state = E.AFTER_DOCTYPE_PUBLIC_KEYWORD : this._consumeSequenceIfMatch(me.SYSTEM, !1) ? this.state = E.AFTER_DOCTYPE_SYSTEM_KEYWORD : this._ensureHibernation() || (this._err(I.invalidCharacterSequenceAfterDoctypeName), n.forceQuirks = !0, this.state = E.BOGUS_DOCTYPE, this._stateBogusDoctype(t));
    }
  }
  // After DOCTYPE public keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicKeyword(t) {
    const n = this.currentToken;
    switch (t) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED: {
        this.state = E.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case m.QUOTATION_MARK: {
        this._err(I.missingWhitespaceAfterDoctypePublicKeyword), n.publicId = "", this.state = E.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case m.APOSTROPHE: {
        this._err(I.missingWhitespaceAfterDoctypePublicKeyword), n.publicId = "", this.state = E.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._err(I.missingDoctypePublicIdentifier), n.forceQuirks = !0, this.state = E.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case m.EOF: {
        this._err(I.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(I.missingQuoteBeforeDoctypePublicIdentifier), n.forceQuirks = !0, this.state = E.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Before DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypePublicIdentifier(t) {
    const n = this.currentToken;
    switch (t) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED:
        break;
      case m.QUOTATION_MARK: {
        n.publicId = "", this.state = E.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case m.APOSTROPHE: {
        n.publicId = "", this.state = E.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._err(I.missingDoctypePublicIdentifier), n.forceQuirks = !0, this.state = E.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case m.EOF: {
        this._err(I.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(I.missingQuoteBeforeDoctypePublicIdentifier), n.forceQuirks = !0, this.state = E.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // DOCTYPE public identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierDoubleQuoted(t) {
    const n = this.currentToken;
    switch (t) {
      case m.QUOTATION_MARK: {
        this.state = E.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case m.NULL: {
        this._err(I.unexpectedNullCharacter), n.publicId += te;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._err(I.abruptDoctypePublicIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = E.DATA;
        break;
      }
      case m.EOF: {
        this._err(I.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.publicId += String.fromCodePoint(t);
    }
  }
  // DOCTYPE public identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierSingleQuoted(t) {
    const n = this.currentToken;
    switch (t) {
      case m.APOSTROPHE: {
        this.state = E.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case m.NULL: {
        this._err(I.unexpectedNullCharacter), n.publicId += te;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._err(I.abruptDoctypePublicIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = E.DATA;
        break;
      }
      case m.EOF: {
        this._err(I.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.publicId += String.fromCodePoint(t);
    }
  }
  // After DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicIdentifier(t) {
    const n = this.currentToken;
    switch (t) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED: {
        this.state = E.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this.state = E.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case m.QUOTATION_MARK: {
        this._err(I.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), n.systemId = "", this.state = E.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case m.APOSTROPHE: {
        this._err(I.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), n.systemId = "", this.state = E.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case m.EOF: {
        this._err(I.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(I.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = E.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Between DOCTYPE public and system identifiers state
  //------------------------------------------------------------------
  _stateBetweenDoctypePublicAndSystemIdentifiers(t) {
    const n = this.currentToken;
    switch (t) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED:
        break;
      case m.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = E.DATA;
        break;
      }
      case m.QUOTATION_MARK: {
        n.systemId = "", this.state = E.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case m.APOSTROPHE: {
        n.systemId = "", this.state = E.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case m.EOF: {
        this._err(I.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(I.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = E.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // After DOCTYPE system keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemKeyword(t) {
    const n = this.currentToken;
    switch (t) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED: {
        this.state = E.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case m.QUOTATION_MARK: {
        this._err(I.missingWhitespaceAfterDoctypeSystemKeyword), n.systemId = "", this.state = E.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case m.APOSTROPHE: {
        this._err(I.missingWhitespaceAfterDoctypeSystemKeyword), n.systemId = "", this.state = E.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._err(I.missingDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = E.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case m.EOF: {
        this._err(I.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(I.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = E.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Before DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypeSystemIdentifier(t) {
    const n = this.currentToken;
    switch (t) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED:
        break;
      case m.QUOTATION_MARK: {
        n.systemId = "", this.state = E.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case m.APOSTROPHE: {
        n.systemId = "", this.state = E.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._err(I.missingDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = E.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case m.EOF: {
        this._err(I.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(I.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = E.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // DOCTYPE system identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierDoubleQuoted(t) {
    const n = this.currentToken;
    switch (t) {
      case m.QUOTATION_MARK: {
        this.state = E.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case m.NULL: {
        this._err(I.unexpectedNullCharacter), n.systemId += te;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._err(I.abruptDoctypeSystemIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = E.DATA;
        break;
      }
      case m.EOF: {
        this._err(I.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.systemId += String.fromCodePoint(t);
    }
  }
  // DOCTYPE system identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierSingleQuoted(t) {
    const n = this.currentToken;
    switch (t) {
      case m.APOSTROPHE: {
        this.state = E.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case m.NULL: {
        this._err(I.unexpectedNullCharacter), n.systemId += te;
        break;
      }
      case m.GREATER_THAN_SIGN: {
        this._err(I.abruptDoctypeSystemIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = E.DATA;
        break;
      }
      case m.EOF: {
        this._err(I.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.systemId += String.fromCodePoint(t);
    }
  }
  // After DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemIdentifier(t) {
    const n = this.currentToken;
    switch (t) {
      case m.SPACE:
      case m.LINE_FEED:
      case m.TABULATION:
      case m.FORM_FEED:
        break;
      case m.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = E.DATA;
        break;
      }
      case m.EOF: {
        this._err(I.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(I.unexpectedCharacterAfterDoctypeSystemIdentifier), this.state = E.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Bogus DOCTYPE state
  //------------------------------------------------------------------
  _stateBogusDoctype(t) {
    const n = this.currentToken;
    switch (t) {
      case m.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = E.DATA;
        break;
      }
      case m.NULL: {
        this._err(I.unexpectedNullCharacter);
        break;
      }
      case m.EOF: {
        this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
    }
  }
  // CDATA section state
  //------------------------------------------------------------------
  _stateCdataSection(t) {
    switch (t) {
      case m.RIGHT_SQUARE_BRACKET: {
        this.state = E.CDATA_SECTION_BRACKET;
        break;
      }
      case m.EOF: {
        this._err(I.eofInCdata), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // CDATA section bracket state
  //------------------------------------------------------------------
  _stateCdataSectionBracket(t) {
    t === m.RIGHT_SQUARE_BRACKET ? this.state = E.CDATA_SECTION_END : (this._emitChars("]"), this.state = E.CDATA_SECTION, this._stateCdataSection(t));
  }
  // CDATA section end state
  //------------------------------------------------------------------
  _stateCdataSectionEnd(t) {
    switch (t) {
      case m.GREATER_THAN_SIGN: {
        this.state = E.DATA;
        break;
      }
      case m.RIGHT_SQUARE_BRACKET: {
        this._emitChars("]");
        break;
      }
      default:
        this._emitChars("]]"), this.state = E.CDATA_SECTION, this._stateCdataSection(t);
    }
  }
  // Character reference state
  //------------------------------------------------------------------
  _stateCharacterReference() {
    let t = this.entityDecoder.write(this.preprocessor.html, this.preprocessor.pos);
    if (t < 0)
      if (this.preprocessor.lastChunkWritten)
        t = this.entityDecoder.end();
      else {
        this.active = !1, this.preprocessor.pos = this.preprocessor.html.length - 1, this.consumedAfterSnapshot = 0, this.preprocessor.endOfChunkHit = !0;
        return;
      }
    t === 0 ? (this.preprocessor.pos = this.entityStartPos, this._flushCodePointConsumedAsCharacterReference(m.AMPERSAND), this.state = !this._isCharacterReferenceInAttribute() && Lu(this.preprocessor.peek(1)) ? E.AMBIGUOUS_AMPERSAND : this.returnState) : this.state = this.returnState;
  }
  // Ambiguos ampersand state
  //------------------------------------------------------------------
  _stateAmbiguousAmpersand(t) {
    Lu(t) ? this._flushCodePointConsumedAsCharacterReference(t) : (t === m.SEMICOLON && this._err(I.unknownNamedCharacterReference), this.state = this.returnState, this._callState(t));
  }
}
const ta = /* @__PURE__ */ new Set([s.DD, s.DT, s.LI, s.OPTGROUP, s.OPTION, s.P, s.RB, s.RP, s.RT, s.RTC]), Du = /* @__PURE__ */ new Set([
  ...ta,
  s.CAPTION,
  s.COLGROUP,
  s.TBODY,
  s.TD,
  s.TFOOT,
  s.TH,
  s.THEAD,
  s.TR
]), dn = /* @__PURE__ */ new Set([
  s.APPLET,
  s.CAPTION,
  s.HTML,
  s.MARQUEE,
  s.OBJECT,
  s.TABLE,
  s.TD,
  s.TEMPLATE,
  s.TH
]), _f = /* @__PURE__ */ new Set([...dn, s.OL, s.UL]), Cf = /* @__PURE__ */ new Set([...dn, s.BUTTON]), Pu = /* @__PURE__ */ new Set([s.ANNOTATION_XML, s.MI, s.MN, s.MO, s.MS, s.MTEXT]), wu = /* @__PURE__ */ new Set([s.DESC, s.FOREIGN_OBJECT, s.TITLE]), If = /* @__PURE__ */ new Set([s.TR, s.TEMPLATE, s.HTML]), xf = /* @__PURE__ */ new Set([s.TBODY, s.TFOOT, s.THEAD, s.TEMPLATE, s.HTML]), Sf = /* @__PURE__ */ new Set([s.TABLE, s.TEMPLATE, s.HTML]), Nf = /* @__PURE__ */ new Set([s.TD, s.TH]);
class kf {
  get currentTmplContentOrNode() {
    return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current;
  }
  constructor(t, n, r) {
    this.treeAdapter = n, this.handler = r, this.items = [], this.tagIDs = [], this.stackTop = -1, this.tmplCount = 0, this.currentTagId = s.UNKNOWN, this.current = t;
  }
  //Index of element
  _indexOf(t) {
    return this.items.lastIndexOf(t, this.stackTop);
  }
  //Update current element
  _isInTemplate() {
    return this.currentTagId === s.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === y.HTML;
  }
  _updateCurrentElement() {
    this.current = this.items[this.stackTop], this.currentTagId = this.tagIDs[this.stackTop];
  }
  //Mutations
  push(t, n) {
    this.stackTop++, this.items[this.stackTop] = t, this.current = t, this.tagIDs[this.stackTop] = n, this.currentTagId = n, this._isInTemplate() && this.tmplCount++, this.handler.onItemPush(t, n, !0);
  }
  pop() {
    const t = this.current;
    this.tmplCount > 0 && this._isInTemplate() && this.tmplCount--, this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(t, !0);
  }
  replace(t, n) {
    const r = this._indexOf(t);
    this.items[r] = n, r === this.stackTop && (this.current = n);
  }
  insertAfter(t, n, r) {
    const u = this._indexOf(t) + 1;
    this.items.splice(u, 0, n), this.tagIDs.splice(u, 0, r), this.stackTop++, u === this.stackTop && this._updateCurrentElement(), this.handler.onItemPush(this.current, this.currentTagId, u === this.stackTop);
  }
  popUntilTagNamePopped(t) {
    let n = this.stackTop + 1;
    do
      n = this.tagIDs.lastIndexOf(t, n - 1);
    while (n > 0 && this.treeAdapter.getNamespaceURI(this.items[n]) !== y.HTML);
    this.shortenToLength(n < 0 ? 0 : n);
  }
  shortenToLength(t) {
    for (; this.stackTop >= t; ) {
      const n = this.current;
      this.tmplCount > 0 && this._isInTemplate() && (this.tmplCount -= 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(n, this.stackTop < t);
    }
  }
  popUntilElementPopped(t) {
    const n = this._indexOf(t);
    this.shortenToLength(n < 0 ? 0 : n);
  }
  popUntilPopped(t, n) {
    const r = this._indexOfTagNames(t, n);
    this.shortenToLength(r < 0 ? 0 : r);
  }
  popUntilNumberedHeaderPopped() {
    this.popUntilPopped(ir, y.HTML);
  }
  popUntilTableCellPopped() {
    this.popUntilPopped(Nf, y.HTML);
  }
  popAllUpToHtmlElement() {
    this.tmplCount = 0, this.shortenToLength(1);
  }
  _indexOfTagNames(t, n) {
    for (let r = this.stackTop; r >= 0; r--)
      if (t.has(this.tagIDs[r]) && this.treeAdapter.getNamespaceURI(this.items[r]) === n)
        return r;
    return -1;
  }
  clearBackTo(t, n) {
    const r = this._indexOfTagNames(t, n);
    this.shortenToLength(r + 1);
  }
  clearBackToTableContext() {
    this.clearBackTo(Sf, y.HTML);
  }
  clearBackToTableBodyContext() {
    this.clearBackTo(xf, y.HTML);
  }
  clearBackToTableRowContext() {
    this.clearBackTo(If, y.HTML);
  }
  remove(t) {
    const n = this._indexOf(t);
    n >= 0 && (n === this.stackTop ? this.pop() : (this.items.splice(n, 1), this.tagIDs.splice(n, 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(t, !1)));
  }
  //Search
  tryPeekProperlyNestedBodyElement() {
    return this.stackTop >= 1 && this.tagIDs[1] === s.BODY ? this.items[1] : null;
  }
  contains(t) {
    return this._indexOf(t) > -1;
  }
  getCommonAncestor(t) {
    const n = this._indexOf(t) - 1;
    return n >= 0 ? this.items[n] : null;
  }
  isRootHtmlElementCurrent() {
    return this.stackTop === 0 && this.tagIDs[0] === s.HTML;
  }
  //Element in scope
  hasInDynamicScope(t, n) {
    for (let r = this.stackTop; r >= 0; r--) {
      const u = this.tagIDs[r];
      switch (this.treeAdapter.getNamespaceURI(this.items[r])) {
        case y.HTML: {
          if (u === t)
            return !0;
          if (n.has(u))
            return !1;
          break;
        }
        case y.SVG: {
          if (wu.has(u))
            return !1;
          break;
        }
        case y.MATHML: {
          if (Pu.has(u))
            return !1;
          break;
        }
      }
    }
    return !0;
  }
  hasInScope(t) {
    return this.hasInDynamicScope(t, dn);
  }
  hasInListItemScope(t) {
    return this.hasInDynamicScope(t, _f);
  }
  hasInButtonScope(t) {
    return this.hasInDynamicScope(t, Cf);
  }
  hasNumberedHeaderInScope() {
    for (let t = this.stackTop; t >= 0; t--) {
      const n = this.tagIDs[t];
      switch (this.treeAdapter.getNamespaceURI(this.items[t])) {
        case y.HTML: {
          if (ir.has(n))
            return !0;
          if (dn.has(n))
            return !1;
          break;
        }
        case y.SVG: {
          if (wu.has(n))
            return !1;
          break;
        }
        case y.MATHML: {
          if (Pu.has(n))
            return !1;
          break;
        }
      }
    }
    return !0;
  }
  hasInTableScope(t) {
    for (let n = this.stackTop; n >= 0; n--)
      if (this.treeAdapter.getNamespaceURI(this.items[n]) === y.HTML)
        switch (this.tagIDs[n]) {
          case t:
            return !0;
          case s.TABLE:
          case s.HTML:
            return !1;
        }
    return !0;
  }
  hasTableBodyContextInTableScope() {
    for (let t = this.stackTop; t >= 0; t--)
      if (this.treeAdapter.getNamespaceURI(this.items[t]) === y.HTML)
        switch (this.tagIDs[t]) {
          case s.TBODY:
          case s.THEAD:
          case s.TFOOT:
            return !0;
          case s.TABLE:
          case s.HTML:
            return !1;
        }
    return !0;
  }
  hasInSelectScope(t) {
    for (let n = this.stackTop; n >= 0; n--)
      if (this.treeAdapter.getNamespaceURI(this.items[n]) === y.HTML)
        switch (this.tagIDs[n]) {
          case t:
            return !0;
          case s.OPTION:
          case s.OPTGROUP:
            break;
          default:
            return !1;
        }
    return !0;
  }
  //Implied end tags
  generateImpliedEndTags() {
    for (; ta.has(this.currentTagId); )
      this.pop();
  }
  generateImpliedEndTagsThoroughly() {
    for (; Du.has(this.currentTagId); )
      this.pop();
  }
  generateImpliedEndTagsWithExclusion(t) {
    for (; this.currentTagId !== t && Du.has(this.currentTagId); )
      this.pop();
  }
}
const qn = 3;
var ke;
(function(e) {
  e[e.Marker = 0] = "Marker", e[e.Element = 1] = "Element";
})(ke || (ke = {}));
const Mu = { type: ke.Marker };
class Of {
  constructor(t) {
    this.treeAdapter = t, this.entries = [], this.bookmark = null;
  }
  //Noah Ark's condition
  //OPTIMIZATION: at first we try to find possible candidates for exclusion using
  //lightweight heuristics without thorough attributes check.
  _getNoahArkConditionCandidates(t, n) {
    const r = [], u = n.length, a = this.treeAdapter.getTagName(t), i = this.treeAdapter.getNamespaceURI(t);
    for (let o = 0; o < this.entries.length; o++) {
      const l = this.entries[o];
      if (l.type === ke.Marker)
        break;
      const { element: c } = l;
      if (this.treeAdapter.getTagName(c) === a && this.treeAdapter.getNamespaceURI(c) === i) {
        const h = this.treeAdapter.getAttrList(c);
        h.length === u && r.push({ idx: o, attrs: h });
      }
    }
    return r;
  }
  _ensureNoahArkCondition(t) {
    if (this.entries.length < qn)
      return;
    const n = this.treeAdapter.getAttrList(t), r = this._getNoahArkConditionCandidates(t, n);
    if (r.length < qn)
      return;
    const u = new Map(n.map((i) => [i.name, i.value]));
    let a = 0;
    for (let i = 0; i < r.length; i++) {
      const o = r[i];
      o.attrs.every((l) => u.get(l.name) === l.value) && (a += 1, a >= qn && this.entries.splice(o.idx, 1));
    }
  }
  //Mutations
  insertMarker() {
    this.entries.unshift(Mu);
  }
  pushElement(t, n) {
    this._ensureNoahArkCondition(t), this.entries.unshift({
      type: ke.Element,
      element: t,
      token: n
    });
  }
  insertElementAfterBookmark(t, n) {
    const r = this.entries.indexOf(this.bookmark);
    this.entries.splice(r, 0, {
      type: ke.Element,
      element: t,
      token: n
    });
  }
  removeEntry(t) {
    const n = this.entries.indexOf(t);
    n >= 0 && this.entries.splice(n, 1);
  }
  /**
   * Clears the list of formatting elements up to the last marker.
   *
   * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker
   */
  clearToLastMarker() {
    const t = this.entries.indexOf(Mu);
    t >= 0 ? this.entries.splice(0, t + 1) : this.entries.length = 0;
  }
  //Search
  getElementEntryInScopeWithTagName(t) {
    const n = this.entries.find((r) => r.type === ke.Marker || this.treeAdapter.getTagName(r.element) === t);
    return n && n.type === ke.Element ? n : null;
  }
  getElementEntry(t) {
    return this.entries.find((n) => n.type === ke.Element && n.element === t);
  }
}
const ze = {
  //Node construction
  createDocument() {
    return {
      nodeName: "#document",
      mode: be.NO_QUIRKS,
      childNodes: []
    };
  },
  createDocumentFragment() {
    return {
      nodeName: "#document-fragment",
      childNodes: []
    };
  },
  createElement(e, t, n) {
    return {
      nodeName: e,
      tagName: e,
      attrs: n,
      namespaceURI: t,
      childNodes: [],
      parentNode: null
    };
  },
  createCommentNode(e) {
    return {
      nodeName: "#comment",
      data: e,
      parentNode: null
    };
  },
  createTextNode(e) {
    return {
      nodeName: "#text",
      value: e,
      parentNode: null
    };
  },
  //Tree mutation
  appendChild(e, t) {
    e.childNodes.push(t), t.parentNode = e;
  },
  insertBefore(e, t, n) {
    const r = e.childNodes.indexOf(n);
    e.childNodes.splice(r, 0, t), t.parentNode = e;
  },
  setTemplateContent(e, t) {
    e.content = t;
  },
  getTemplateContent(e) {
    return e.content;
  },
  setDocumentType(e, t, n, r) {
    const u = e.childNodes.find((a) => a.nodeName === "#documentType");
    if (u)
      u.name = t, u.publicId = n, u.systemId = r;
    else {
      const a = {
        nodeName: "#documentType",
        name: t,
        publicId: n,
        systemId: r,
        parentNode: null
      };
      ze.appendChild(e, a);
    }
  },
  setDocumentMode(e, t) {
    e.mode = t;
  },
  getDocumentMode(e) {
    return e.mode;
  },
  detachNode(e) {
    if (e.parentNode) {
      const t = e.parentNode.childNodes.indexOf(e);
      e.parentNode.childNodes.splice(t, 1), e.parentNode = null;
    }
  },
  insertText(e, t) {
    if (e.childNodes.length > 0) {
      const n = e.childNodes[e.childNodes.length - 1];
      if (ze.isTextNode(n)) {
        n.value += t;
        return;
      }
    }
    ze.appendChild(e, ze.createTextNode(t));
  },
  insertTextBefore(e, t, n) {
    const r = e.childNodes[e.childNodes.indexOf(n) - 1];
    r && ze.isTextNode(r) ? r.value += t : ze.insertBefore(e, ze.createTextNode(t), n);
  },
  adoptAttributes(e, t) {
    const n = new Set(e.attrs.map((r) => r.name));
    for (let r = 0; r < t.length; r++)
      n.has(t[r].name) || e.attrs.push(t[r]);
  },
  //Tree traversing
  getFirstChild(e) {
    return e.childNodes[0];
  },
  getChildNodes(e) {
    return e.childNodes;
  },
  getParentNode(e) {
    return e.parentNode;
  },
  getAttrList(e) {
    return e.attrs;
  },
  //Node data
  getTagName(e) {
    return e.tagName;
  },
  getNamespaceURI(e) {
    return e.namespaceURI;
  },
  getTextNodeContent(e) {
    return e.value;
  },
  getCommentNodeContent(e) {
    return e.data;
  },
  getDocumentTypeNodeName(e) {
    return e.name;
  },
  getDocumentTypeNodePublicId(e) {
    return e.publicId;
  },
  getDocumentTypeNodeSystemId(e) {
    return e.systemId;
  },
  //Node types
  isTextNode(e) {
    return e.nodeName === "#text";
  },
  isCommentNode(e) {
    return e.nodeName === "#comment";
  },
  isDocumentTypeNode(e) {
    return e.nodeName === "#documentType";
  },
  isElementNode(e) {
    return Object.prototype.hasOwnProperty.call(e, "tagName");
  },
  // Source code location
  setNodeSourceCodeLocation(e, t) {
    e.sourceCodeLocation = t;
  },
  getNodeSourceCodeLocation(e) {
    return e.sourceCodeLocation;
  },
  updateNodeSourceCodeLocation(e, t) {
    e.sourceCodeLocation = { ...e.sourceCodeLocation, ...t };
  }
}, na = "html", yf = "about:legacy-compat", Lf = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd", ra = [
  "+//silmaril//dtd html pro v0r11 19970101//",
  "-//as//dtd html 3.0 aswedit + extensions//",
  "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
  "-//ietf//dtd html 2.0 level 1//",
  "-//ietf//dtd html 2.0 level 2//",
  "-//ietf//dtd html 2.0 strict level 1//",
  "-//ietf//dtd html 2.0 strict level 2//",
  "-//ietf//dtd html 2.0 strict//",
  "-//ietf//dtd html 2.0//",
  "-//ietf//dtd html 2.1e//",
  "-//ietf//dtd html 3.0//",
  "-//ietf//dtd html 3.2 final//",
  "-//ietf//dtd html 3.2//",
  "-//ietf//dtd html 3//",
  "-//ietf//dtd html level 0//",
  "-//ietf//dtd html level 1//",
  "-//ietf//dtd html level 2//",
  "-//ietf//dtd html level 3//",
  "-//ietf//dtd html strict level 0//",
  "-//ietf//dtd html strict level 1//",
  "-//ietf//dtd html strict level 2//",
  "-//ietf//dtd html strict level 3//",
  "-//ietf//dtd html strict//",
  "-//ietf//dtd html//",
  "-//metrius//dtd metrius presentational//",
  "-//microsoft//dtd internet explorer 2.0 html strict//",
  "-//microsoft//dtd internet explorer 2.0 html//",
  "-//microsoft//dtd internet explorer 2.0 tables//",
  "-//microsoft//dtd internet explorer 3.0 html strict//",
  "-//microsoft//dtd internet explorer 3.0 html//",
  "-//microsoft//dtd internet explorer 3.0 tables//",
  "-//netscape comm. corp.//dtd html//",
  "-//netscape comm. corp.//dtd strict html//",
  "-//o'reilly and associates//dtd html 2.0//",
  "-//o'reilly and associates//dtd html extended 1.0//",
  "-//o'reilly and associates//dtd html extended relaxed 1.0//",
  "-//sq//dtd html 2.0 hotmetal + extensions//",
  "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
  "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
  "-//spyglass//dtd html 2.0 extended//",
  "-//sun microsystems corp.//dtd hotjava html//",
  "-//sun microsystems corp.//dtd hotjava strict html//",
  "-//w3c//dtd html 3 1995-03-24//",
  "-//w3c//dtd html 3.2 draft//",
  "-//w3c//dtd html 3.2 final//",
  "-//w3c//dtd html 3.2//",
  "-//w3c//dtd html 3.2s draft//",
  "-//w3c//dtd html 4.0 frameset//",
  "-//w3c//dtd html 4.0 transitional//",
  "-//w3c//dtd html experimental 19960712//",
  "-//w3c//dtd html experimental 970421//",
  "-//w3c//dtd w3 html//",
  "-//w3o//dtd w3 html 3.0//",
  "-//webtechs//dtd mozilla html 2.0//",
  "-//webtechs//dtd mozilla html//"
], Rf = [
  ...ra,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
], Df = /* @__PURE__ */ new Set([
  "-//w3o//dtd w3 html strict 3.0//en//",
  "-/w3c/dtd html 4.0 transitional/en",
  "html"
]), ua = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"], Pf = [
  ...ua,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
];
function Bu(e, t) {
  return t.some((n) => e.startsWith(n));
}
function wf(e) {
  return e.name === na && e.publicId === null && (e.systemId === null || e.systemId === yf);
}
function Mf(e) {
  if (e.name !== na)
    return be.QUIRKS;
  const { systemId: t } = e;
  if (t && t.toLowerCase() === Lf)
    return be.QUIRKS;
  let { publicId: n } = e;
  if (n !== null) {
    if (n = n.toLowerCase(), Df.has(n))
      return be.QUIRKS;
    let r = t === null ? Rf : ra;
    if (Bu(n, r))
      return be.QUIRKS;
    if (r = t === null ? ua : Pf, Bu(n, r))
      return be.LIMITED_QUIRKS;
  }
  return be.NO_QUIRKS;
}
const Fu = {
  TEXT_HTML: "text/html",
  APPLICATION_XML: "application/xhtml+xml"
}, Bf = "definitionurl", Ff = "definitionURL", Hf = new Map([
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((e) => [e.toLowerCase(), e])), Uf = /* @__PURE__ */ new Map([
  ["xlink:actuate", { prefix: "xlink", name: "actuate", namespace: y.XLINK }],
  ["xlink:arcrole", { prefix: "xlink", name: "arcrole", namespace: y.XLINK }],
  ["xlink:href", { prefix: "xlink", name: "href", namespace: y.XLINK }],
  ["xlink:role", { prefix: "xlink", name: "role", namespace: y.XLINK }],
  ["xlink:show", { prefix: "xlink", name: "show", namespace: y.XLINK }],
  ["xlink:title", { prefix: "xlink", name: "title", namespace: y.XLINK }],
  ["xlink:type", { prefix: "xlink", name: "type", namespace: y.XLINK }],
  ["xml:lang", { prefix: "xml", name: "lang", namespace: y.XML }],
  ["xml:space", { prefix: "xml", name: "space", namespace: y.XML }],
  ["xmlns", { prefix: "", name: "xmlns", namespace: y.XMLNS }],
  ["xmlns:xlink", { prefix: "xmlns", name: "xlink", namespace: y.XMLNS }]
]), vf = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((e) => [e.toLowerCase(), e])), zf = /* @__PURE__ */ new Set([
  s.B,
  s.BIG,
  s.BLOCKQUOTE,
  s.BODY,
  s.BR,
  s.CENTER,
  s.CODE,
  s.DD,
  s.DIV,
  s.DL,
  s.DT,
  s.EM,
  s.EMBED,
  s.H1,
  s.H2,
  s.H3,
  s.H4,
  s.H5,
  s.H6,
  s.HEAD,
  s.HR,
  s.I,
  s.IMG,
  s.LI,
  s.LISTING,
  s.MENU,
  s.META,
  s.NOBR,
  s.OL,
  s.P,
  s.PRE,
  s.RUBY,
  s.S,
  s.SMALL,
  s.SPAN,
  s.STRONG,
  s.STRIKE,
  s.SUB,
  s.SUP,
  s.TABLE,
  s.TT,
  s.U,
  s.UL,
  s.VAR
]);
function Yf(e) {
  const t = e.tagID;
  return t === s.FONT && e.attrs.some(({ name: r }) => r === Ze.COLOR || r === Ze.SIZE || r === Ze.FACE) || zf.has(t);
}
function ia(e) {
  for (let t = 0; t < e.attrs.length; t++)
    if (e.attrs[t].name === Bf) {
      e.attrs[t].name = Ff;
      break;
    }
}
function aa(e) {
  for (let t = 0; t < e.attrs.length; t++) {
    const n = Hf.get(e.attrs[t].name);
    n != null && (e.attrs[t].name = n);
  }
}
function Rr(e) {
  for (let t = 0; t < e.attrs.length; t++) {
    const n = Uf.get(e.attrs[t].name);
    n && (e.attrs[t].prefix = n.prefix, e.attrs[t].name = n.name, e.attrs[t].namespace = n.namespace);
  }
}
function qf(e) {
  const t = vf.get(e.tagName);
  t != null && (e.tagName = t, e.tagID = bt(e.tagName));
}
function jf(e, t) {
  return t === y.MATHML && (e === s.MI || e === s.MO || e === s.MN || e === s.MS || e === s.MTEXT);
}
function Vf(e, t, n) {
  if (t === y.MATHML && e === s.ANNOTATION_XML) {
    for (let r = 0; r < n.length; r++)
      if (n[r].name === Ze.ENCODING) {
        const u = n[r].value.toLowerCase();
        return u === Fu.TEXT_HTML || u === Fu.APPLICATION_XML;
      }
  }
  return t === y.SVG && (e === s.FOREIGN_OBJECT || e === s.DESC || e === s.TITLE);
}
function Wf(e, t, n, r) {
  return (!r || r === y.HTML) && Vf(e, t, n) || (!r || r === y.MATHML) && jf(e, t);
}
const Qf = "hidden", Gf = 8, Xf = 3;
var T;
(function(e) {
  e[e.INITIAL = 0] = "INITIAL", e[e.BEFORE_HTML = 1] = "BEFORE_HTML", e[e.BEFORE_HEAD = 2] = "BEFORE_HEAD", e[e.IN_HEAD = 3] = "IN_HEAD", e[e.IN_HEAD_NO_SCRIPT = 4] = "IN_HEAD_NO_SCRIPT", e[e.AFTER_HEAD = 5] = "AFTER_HEAD", e[e.IN_BODY = 6] = "IN_BODY", e[e.TEXT = 7] = "TEXT", e[e.IN_TABLE = 8] = "IN_TABLE", e[e.IN_TABLE_TEXT = 9] = "IN_TABLE_TEXT", e[e.IN_CAPTION = 10] = "IN_CAPTION", e[e.IN_COLUMN_GROUP = 11] = "IN_COLUMN_GROUP", e[e.IN_TABLE_BODY = 12] = "IN_TABLE_BODY", e[e.IN_ROW = 13] = "IN_ROW", e[e.IN_CELL = 14] = "IN_CELL", e[e.IN_SELECT = 15] = "IN_SELECT", e[e.IN_SELECT_IN_TABLE = 16] = "IN_SELECT_IN_TABLE", e[e.IN_TEMPLATE = 17] = "IN_TEMPLATE", e[e.AFTER_BODY = 18] = "AFTER_BODY", e[e.IN_FRAMESET = 19] = "IN_FRAMESET", e[e.AFTER_FRAMESET = 20] = "AFTER_FRAMESET", e[e.AFTER_AFTER_BODY = 21] = "AFTER_AFTER_BODY", e[e.AFTER_AFTER_FRAMESET = 22] = "AFTER_AFTER_FRAMESET";
})(T || (T = {}));
const Kf = {
  startLine: -1,
  startCol: -1,
  startOffset: -1,
  endLine: -1,
  endCol: -1,
  endOffset: -1
}, sa = /* @__PURE__ */ new Set([s.TABLE, s.TBODY, s.TFOOT, s.THEAD, s.TR]), Hu = {
  scriptingEnabled: !0,
  sourceCodeLocationInfo: !1,
  treeAdapter: ze,
  onParseError: null
};
class Uu {
  constructor(t, n, r = null, u = null) {
    this.fragmentContext = r, this.scriptHandler = u, this.currentToken = null, this.stopped = !1, this.insertionMode = T.INITIAL, this.originalInsertionMode = T.INITIAL, this.headElement = null, this.formElement = null, this.currentNotInHTML = !1, this.tmplInsertionModeStack = [], this.pendingCharacterTokens = [], this.hasNonWhitespacePendingCharacterToken = !1, this.framesetOk = !0, this.skipNextNewLine = !1, this.fosterParentingEnabled = !1, this.options = {
      ...Hu,
      ...t
    }, this.treeAdapter = this.options.treeAdapter, this.onParseError = this.options.onParseError, this.onParseError && (this.options.sourceCodeLocationInfo = !0), this.document = n ?? this.treeAdapter.createDocument(), this.tokenizer = new Af(this.options, this), this.activeFormattingElements = new Of(this.treeAdapter), this.fragmentContextID = r ? bt(this.treeAdapter.getTagName(r)) : s.UNKNOWN, this._setContextModes(r ?? this.document, this.fragmentContextID), this.openElements = new kf(this.document, this.treeAdapter, this);
  }
  // API
  static parse(t, n) {
    const r = new this(n);
    return r.tokenizer.write(t, !0), r.document;
  }
  static getFragmentParser(t, n) {
    const r = {
      ...Hu,
      ...n
    };
    t ?? (t = r.treeAdapter.createElement(_.TEMPLATE, y.HTML, []));
    const u = r.treeAdapter.createElement("documentmock", y.HTML, []), a = new this(r, u, t);
    return a.fragmentContextID === s.TEMPLATE && a.tmplInsertionModeStack.unshift(T.IN_TEMPLATE), a._initTokenizerForFragmentParsing(), a._insertFakeRootElement(), a._resetInsertionMode(), a._findFormInFragmentContext(), a;
  }
  getFragment() {
    const t = this.treeAdapter.getFirstChild(this.document), n = this.treeAdapter.createDocumentFragment();
    return this._adoptNodes(t, n), n;
  }
  //Errors
  /** @internal */
  _err(t, n, r) {
    var u;
    if (!this.onParseError)
      return;
    const a = (u = t.location) !== null && u !== void 0 ? u : Kf, i = {
      code: n,
      startLine: a.startLine,
      startCol: a.startCol,
      startOffset: a.startOffset,
      endLine: r ? a.startLine : a.endLine,
      endCol: r ? a.startCol : a.endCol,
      endOffset: r ? a.startOffset : a.endOffset
    };
    this.onParseError(i);
  }
  //Stack events
  /** @internal */
  onItemPush(t, n, r) {
    var u, a;
    (a = (u = this.treeAdapter).onItemPush) === null || a === void 0 || a.call(u, t), r && this.openElements.stackTop > 0 && this._setContextModes(t, n);
  }
  /** @internal */
  onItemPop(t, n) {
    var r, u;
    if (this.options.sourceCodeLocationInfo && this._setEndLocation(t, this.currentToken), (u = (r = this.treeAdapter).onItemPop) === null || u === void 0 || u.call(r, t, this.openElements.current), n) {
      let a, i;
      this.openElements.stackTop === 0 && this.fragmentContext ? (a = this.fragmentContext, i = this.fragmentContextID) : { current: a, currentTagId: i } = this.openElements, this._setContextModes(a, i);
    }
  }
  _setContextModes(t, n) {
    const r = t === this.document || this.treeAdapter.getNamespaceURI(t) === y.HTML;
    this.currentNotInHTML = !r, this.tokenizer.inForeignNode = !r && !this._isIntegrationPoint(n, t);
  }
  /** @protected */
  _switchToTextParsing(t, n) {
    this._insertElement(t, y.HTML), this.tokenizer.state = n, this.originalInsertionMode = this.insertionMode, this.insertionMode = T.TEXT;
  }
  switchToPlaintextParsing() {
    this.insertionMode = T.TEXT, this.originalInsertionMode = T.IN_BODY, this.tokenizer.state = re.PLAINTEXT;
  }
  //Fragment parsing
  /** @protected */
  _getAdjustedCurrentElement() {
    return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
  }
  /** @protected */
  _findFormInFragmentContext() {
    let t = this.fragmentContext;
    for (; t; ) {
      if (this.treeAdapter.getTagName(t) === _.FORM) {
        this.formElement = t;
        break;
      }
      t = this.treeAdapter.getParentNode(t);
    }
  }
  _initTokenizerForFragmentParsing() {
    if (!(!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== y.HTML))
      switch (this.fragmentContextID) {
        case s.TITLE:
        case s.TEXTAREA: {
          this.tokenizer.state = re.RCDATA;
          break;
        }
        case s.STYLE:
        case s.XMP:
        case s.IFRAME:
        case s.NOEMBED:
        case s.NOFRAMES:
        case s.NOSCRIPT: {
          this.tokenizer.state = re.RAWTEXT;
          break;
        }
        case s.SCRIPT: {
          this.tokenizer.state = re.SCRIPT_DATA;
          break;
        }
        case s.PLAINTEXT: {
          this.tokenizer.state = re.PLAINTEXT;
          break;
        }
      }
  }
  //Tree mutation
  /** @protected */
  _setDocumentType(t) {
    const n = t.name || "", r = t.publicId || "", u = t.systemId || "";
    if (this.treeAdapter.setDocumentType(this.document, n, r, u), t.location) {
      const i = this.treeAdapter.getChildNodes(this.document).find((o) => this.treeAdapter.isDocumentTypeNode(o));
      i && this.treeAdapter.setNodeSourceCodeLocation(i, t.location);
    }
  }
  /** @protected */
  _attachElementToTree(t, n) {
    if (this.options.sourceCodeLocationInfo) {
      const r = n && {
        ...n,
        startTag: n
      };
      this.treeAdapter.setNodeSourceCodeLocation(t, r);
    }
    if (this._shouldFosterParentOnInsertion())
      this._fosterParentElement(t);
    else {
      const r = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.appendChild(r, t);
    }
  }
  /**
   * For self-closing tags. Add an element to the tree, but skip adding it
   * to the stack.
   */
  /** @protected */
  _appendElement(t, n) {
    const r = this.treeAdapter.createElement(t.tagName, n, t.attrs);
    this._attachElementToTree(r, t.location);
  }
  /** @protected */
  _insertElement(t, n) {
    const r = this.treeAdapter.createElement(t.tagName, n, t.attrs);
    this._attachElementToTree(r, t.location), this.openElements.push(r, t.tagID);
  }
  /** @protected */
  _insertFakeElement(t, n) {
    const r = this.treeAdapter.createElement(t, y.HTML, []);
    this._attachElementToTree(r, null), this.openElements.push(r, n);
  }
  /** @protected */
  _insertTemplate(t) {
    const n = this.treeAdapter.createElement(t.tagName, y.HTML, t.attrs), r = this.treeAdapter.createDocumentFragment();
    this.treeAdapter.setTemplateContent(n, r), this._attachElementToTree(n, t.location), this.openElements.push(n, t.tagID), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(r, null);
  }
  /** @protected */
  _insertFakeRootElement() {
    const t = this.treeAdapter.createElement(_.HTML, y.HTML, []);
    this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(t, null), this.treeAdapter.appendChild(this.openElements.current, t), this.openElements.push(t, s.HTML);
  }
  /** @protected */
  _appendCommentNode(t, n) {
    const r = this.treeAdapter.createCommentNode(t.data);
    this.treeAdapter.appendChild(n, r), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(r, t.location);
  }
  /** @protected */
  _insertCharacters(t) {
    let n, r;
    if (this._shouldFosterParentOnInsertion() ? ({ parent: n, beforeElement: r } = this._findFosterParentingLocation(), r ? this.treeAdapter.insertTextBefore(n, t.chars, r) : this.treeAdapter.insertText(n, t.chars)) : (n = this.openElements.currentTmplContentOrNode, this.treeAdapter.insertText(n, t.chars)), !t.location)
      return;
    const u = this.treeAdapter.getChildNodes(n), a = r ? u.lastIndexOf(r) : u.length, i = u[a - 1];
    if (this.treeAdapter.getNodeSourceCodeLocation(i)) {
      const { endLine: l, endCol: c, endOffset: h } = t.location;
      this.treeAdapter.updateNodeSourceCodeLocation(i, { endLine: l, endCol: c, endOffset: h });
    } else this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(i, t.location);
  }
  /** @protected */
  _adoptNodes(t, n) {
    for (let r = this.treeAdapter.getFirstChild(t); r; r = this.treeAdapter.getFirstChild(t))
      this.treeAdapter.detachNode(r), this.treeAdapter.appendChild(n, r);
  }
  /** @protected */
  _setEndLocation(t, n) {
    if (this.treeAdapter.getNodeSourceCodeLocation(t) && n.location) {
      const r = n.location, u = this.treeAdapter.getTagName(t), a = (
        // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
        // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
        n.type === q.END_TAG && u === n.tagName ? {
          endTag: { ...r },
          endLine: r.endLine,
          endCol: r.endCol,
          endOffset: r.endOffset
        } : {
          endLine: r.startLine,
          endCol: r.startCol,
          endOffset: r.startOffset
        }
      );
      this.treeAdapter.updateNodeSourceCodeLocation(t, a);
    }
  }
  //Token processing
  shouldProcessStartTagTokenInForeignContent(t) {
    if (!this.currentNotInHTML)
      return !1;
    let n, r;
    return this.openElements.stackTop === 0 && this.fragmentContext ? (n = this.fragmentContext, r = this.fragmentContextID) : { current: n, currentTagId: r } = this.openElements, t.tagID === s.SVG && this.treeAdapter.getTagName(n) === _.ANNOTATION_XML && this.treeAdapter.getNamespaceURI(n) === y.MATHML ? !1 : (
      // Check that `current` is not an integration point for HTML or MathML elements.
      this.tokenizer.inForeignNode || // If it _is_ an integration point, then we might have to check that it is not an HTML
      // integration point.
      (t.tagID === s.MGLYPH || t.tagID === s.MALIGNMARK) && !this._isIntegrationPoint(r, n, y.HTML)
    );
  }
  /** @protected */
  _processToken(t) {
    switch (t.type) {
      case q.CHARACTER: {
        this.onCharacter(t);
        break;
      }
      case q.NULL_CHARACTER: {
        this.onNullCharacter(t);
        break;
      }
      case q.COMMENT: {
        this.onComment(t);
        break;
      }
      case q.DOCTYPE: {
        this.onDoctype(t);
        break;
      }
      case q.START_TAG: {
        this._processStartTag(t);
        break;
      }
      case q.END_TAG: {
        this.onEndTag(t);
        break;
      }
      case q.EOF: {
        this.onEof(t);
        break;
      }
      case q.WHITESPACE_CHARACTER: {
        this.onWhitespaceCharacter(t);
        break;
      }
    }
  }
  //Integration points
  /** @protected */
  _isIntegrationPoint(t, n, r) {
    const u = this.treeAdapter.getNamespaceURI(n), a = this.treeAdapter.getAttrList(n);
    return Wf(t, u, a, r);
  }
  //Active formatting elements reconstruction
  /** @protected */
  _reconstructActiveFormattingElements() {
    const t = this.activeFormattingElements.entries.length;
    if (t) {
      const n = this.activeFormattingElements.entries.findIndex((u) => u.type === ke.Marker || this.openElements.contains(u.element)), r = n < 0 ? t - 1 : n - 1;
      for (let u = r; u >= 0; u--) {
        const a = this.activeFormattingElements.entries[u];
        this._insertElement(a.token, this.treeAdapter.getNamespaceURI(a.element)), a.element = this.openElements.current;
      }
    }
  }
  //Close elements
  /** @protected */
  _closeTableCell() {
    this.openElements.generateImpliedEndTags(), this.openElements.popUntilTableCellPopped(), this.activeFormattingElements.clearToLastMarker(), this.insertionMode = T.IN_ROW;
  }
  /** @protected */
  _closePElement() {
    this.openElements.generateImpliedEndTagsWithExclusion(s.P), this.openElements.popUntilTagNamePopped(s.P);
  }
  //Insertion modes
  /** @protected */
  _resetInsertionMode() {
    for (let t = this.openElements.stackTop; t >= 0; t--)
      switch (t === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[t]) {
        case s.TR: {
          this.insertionMode = T.IN_ROW;
          return;
        }
        case s.TBODY:
        case s.THEAD:
        case s.TFOOT: {
          this.insertionMode = T.IN_TABLE_BODY;
          return;
        }
        case s.CAPTION: {
          this.insertionMode = T.IN_CAPTION;
          return;
        }
        case s.COLGROUP: {
          this.insertionMode = T.IN_COLUMN_GROUP;
          return;
        }
        case s.TABLE: {
          this.insertionMode = T.IN_TABLE;
          return;
        }
        case s.BODY: {
          this.insertionMode = T.IN_BODY;
          return;
        }
        case s.FRAMESET: {
          this.insertionMode = T.IN_FRAMESET;
          return;
        }
        case s.SELECT: {
          this._resetInsertionModeForSelect(t);
          return;
        }
        case s.TEMPLATE: {
          this.insertionMode = this.tmplInsertionModeStack[0];
          return;
        }
        case s.HTML: {
          this.insertionMode = this.headElement ? T.AFTER_HEAD : T.BEFORE_HEAD;
          return;
        }
        case s.TD:
        case s.TH: {
          if (t > 0) {
            this.insertionMode = T.IN_CELL;
            return;
          }
          break;
        }
        case s.HEAD: {
          if (t > 0) {
            this.insertionMode = T.IN_HEAD;
            return;
          }
          break;
        }
      }
    this.insertionMode = T.IN_BODY;
  }
  /** @protected */
  _resetInsertionModeForSelect(t) {
    if (t > 0)
      for (let n = t - 1; n > 0; n--) {
        const r = this.openElements.tagIDs[n];
        if (r === s.TEMPLATE)
          break;
        if (r === s.TABLE) {
          this.insertionMode = T.IN_SELECT_IN_TABLE;
          return;
        }
      }
    this.insertionMode = T.IN_SELECT;
  }
  //Foster parenting
  /** @protected */
  _isElementCausesFosterParenting(t) {
    return sa.has(t);
  }
  /** @protected */
  _shouldFosterParentOnInsertion() {
    return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.currentTagId);
  }
  /** @protected */
  _findFosterParentingLocation() {
    for (let t = this.openElements.stackTop; t >= 0; t--) {
      const n = this.openElements.items[t];
      switch (this.openElements.tagIDs[t]) {
        case s.TEMPLATE: {
          if (this.treeAdapter.getNamespaceURI(n) === y.HTML)
            return { parent: this.treeAdapter.getTemplateContent(n), beforeElement: null };
          break;
        }
        case s.TABLE: {
          const r = this.treeAdapter.getParentNode(n);
          return r ? { parent: r, beforeElement: n } : { parent: this.openElements.items[t - 1], beforeElement: null };
        }
      }
    }
    return { parent: this.openElements.items[0], beforeElement: null };
  }
  /** @protected */
  _fosterParentElement(t) {
    const n = this._findFosterParentingLocation();
    n.beforeElement ? this.treeAdapter.insertBefore(n.parent, t, n.beforeElement) : this.treeAdapter.appendChild(n.parent, t);
  }
  //Special elements
  /** @protected */
  _isSpecialElement(t, n) {
    const r = this.treeAdapter.getNamespaceURI(t);
    return Ef[r].has(n);
  }
  /** @internal */
  onCharacter(t) {
    if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) {
      Nd(this, t);
      return;
    }
    switch (this.insertionMode) {
      case T.INITIAL: {
        Nt(this, t);
        break;
      }
      case T.BEFORE_HTML: {
        Dt(this, t);
        break;
      }
      case T.BEFORE_HEAD: {
        Pt(this, t);
        break;
      }
      case T.IN_HEAD: {
        wt(this, t);
        break;
      }
      case T.IN_HEAD_NO_SCRIPT: {
        Mt(this, t);
        break;
      }
      case T.AFTER_HEAD: {
        Bt(this, t);
        break;
      }
      case T.IN_BODY:
      case T.IN_CAPTION:
      case T.IN_CELL:
      case T.IN_TEMPLATE: {
        la(this, t);
        break;
      }
      case T.TEXT:
      case T.IN_SELECT:
      case T.IN_SELECT_IN_TABLE: {
        this._insertCharacters(t);
        break;
      }
      case T.IN_TABLE:
      case T.IN_TABLE_BODY:
      case T.IN_ROW: {
        jn(this, t);
        break;
      }
      case T.IN_TABLE_TEXT: {
        pa(this, t);
        break;
      }
      case T.IN_COLUMN_GROUP: {
        mn(this, t);
        break;
      }
      case T.AFTER_BODY: {
        pn(this, t);
        break;
      }
      case T.AFTER_AFTER_BODY: {
        un(this, t);
        break;
      }
    }
  }
  /** @internal */
  onNullCharacter(t) {
    if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) {
      Sd(this, t);
      return;
    }
    switch (this.insertionMode) {
      case T.INITIAL: {
        Nt(this, t);
        break;
      }
      case T.BEFORE_HTML: {
        Dt(this, t);
        break;
      }
      case T.BEFORE_HEAD: {
        Pt(this, t);
        break;
      }
      case T.IN_HEAD: {
        wt(this, t);
        break;
      }
      case T.IN_HEAD_NO_SCRIPT: {
        Mt(this, t);
        break;
      }
      case T.AFTER_HEAD: {
        Bt(this, t);
        break;
      }
      case T.TEXT: {
        this._insertCharacters(t);
        break;
      }
      case T.IN_TABLE:
      case T.IN_TABLE_BODY:
      case T.IN_ROW: {
        jn(this, t);
        break;
      }
      case T.IN_COLUMN_GROUP: {
        mn(this, t);
        break;
      }
      case T.AFTER_BODY: {
        pn(this, t);
        break;
      }
      case T.AFTER_AFTER_BODY: {
        un(this, t);
        break;
      }
    }
  }
  /** @internal */
  onComment(t) {
    if (this.skipNextNewLine = !1, this.currentNotInHTML) {
      ar(this, t);
      return;
    }
    switch (this.insertionMode) {
      case T.INITIAL:
      case T.BEFORE_HTML:
      case T.BEFORE_HEAD:
      case T.IN_HEAD:
      case T.IN_HEAD_NO_SCRIPT:
      case T.AFTER_HEAD:
      case T.IN_BODY:
      case T.IN_TABLE:
      case T.IN_CAPTION:
      case T.IN_COLUMN_GROUP:
      case T.IN_TABLE_BODY:
      case T.IN_ROW:
      case T.IN_CELL:
      case T.IN_SELECT:
      case T.IN_SELECT_IN_TABLE:
      case T.IN_TEMPLATE:
      case T.IN_FRAMESET:
      case T.AFTER_FRAMESET: {
        ar(this, t);
        break;
      }
      case T.IN_TABLE_TEXT: {
        kt(this, t);
        break;
      }
      case T.AFTER_BODY: {
        rh(this, t);
        break;
      }
      case T.AFTER_AFTER_BODY:
      case T.AFTER_AFTER_FRAMESET: {
        uh(this, t);
        break;
      }
    }
  }
  /** @internal */
  onDoctype(t) {
    switch (this.skipNextNewLine = !1, this.insertionMode) {
      case T.INITIAL: {
        ih(this, t);
        break;
      }
      case T.BEFORE_HEAD:
      case T.IN_HEAD:
      case T.IN_HEAD_NO_SCRIPT:
      case T.AFTER_HEAD: {
        this._err(t, I.misplacedDoctype);
        break;
      }
      case T.IN_TABLE_TEXT: {
        kt(this, t);
        break;
      }
    }
  }
  /** @internal */
  onStartTag(t) {
    this.skipNextNewLine = !1, this.currentToken = t, this._processStartTag(t), t.selfClosing && !t.ackSelfClosing && this._err(t, I.nonVoidHtmlElementStartTagWithTrailingSolidus);
  }
  /**
   * Processes a given start tag.
   *
   * `onStartTag` checks if a self-closing tag was recognized. When a token
   * is moved inbetween multiple insertion modes, this check for self-closing
   * could lead to false positives. To avoid this, `_processStartTag` is used
   * for nested calls.
   *
   * @param token The token to process.
   * @protected
   */
  _processStartTag(t) {
    this.shouldProcessStartTagTokenInForeignContent(t) ? kd(this, t) : this._startTagOutsideForeignContent(t);
  }
  /** @protected */
  _startTagOutsideForeignContent(t) {
    switch (this.insertionMode) {
      case T.INITIAL: {
        Nt(this, t);
        break;
      }
      case T.BEFORE_HTML: {
        ah(this, t);
        break;
      }
      case T.BEFORE_HEAD: {
        oh(this, t);
        break;
      }
      case T.IN_HEAD: {
        Se(this, t);
        break;
      }
      case T.IN_HEAD_NO_SCRIPT: {
        fh(this, t);
        break;
      }
      case T.AFTER_HEAD: {
        dh(this, t);
        break;
      }
      case T.IN_BODY: {
        he(this, t);
        break;
      }
      case T.IN_TABLE: {
        mt(this, t);
        break;
      }
      case T.IN_TABLE_TEXT: {
        kt(this, t);
        break;
      }
      case T.IN_CAPTION: {
        ld(this, t);
        break;
      }
      case T.IN_COLUMN_GROUP: {
        wr(this, t);
        break;
      }
      case T.IN_TABLE_BODY: {
        Nn(this, t);
        break;
      }
      case T.IN_ROW: {
        kn(this, t);
        break;
      }
      case T.IN_CELL: {
        hd(this, t);
        break;
      }
      case T.IN_SELECT: {
        ga(this, t);
        break;
      }
      case T.IN_SELECT_IN_TABLE: {
        md(this, t);
        break;
      }
      case T.IN_TEMPLATE: {
        Ed(this, t);
        break;
      }
      case T.AFTER_BODY: {
        gd(this, t);
        break;
      }
      case T.IN_FRAMESET: {
        bd(this, t);
        break;
      }
      case T.AFTER_FRAMESET: {
        _d(this, t);
        break;
      }
      case T.AFTER_AFTER_BODY: {
        Id(this, t);
        break;
      }
      case T.AFTER_AFTER_FRAMESET: {
        xd(this, t);
        break;
      }
    }
  }
  /** @internal */
  onEndTag(t) {
    this.skipNextNewLine = !1, this.currentToken = t, this.currentNotInHTML ? Od(this, t) : this._endTagOutsideForeignContent(t);
  }
  /** @protected */
  _endTagOutsideForeignContent(t) {
    switch (this.insertionMode) {
      case T.INITIAL: {
        Nt(this, t);
        break;
      }
      case T.BEFORE_HTML: {
        sh(this, t);
        break;
      }
      case T.BEFORE_HEAD: {
        lh(this, t);
        break;
      }
      case T.IN_HEAD: {
        ch(this, t);
        break;
      }
      case T.IN_HEAD_NO_SCRIPT: {
        hh(this, t);
        break;
      }
      case T.AFTER_HEAD: {
        mh(this, t);
        break;
      }
      case T.IN_BODY: {
        Sn(this, t);
        break;
      }
      case T.TEXT: {
        Zh(this, t);
        break;
      }
      case T.IN_TABLE: {
        Ut(this, t);
        break;
      }
      case T.IN_TABLE_TEXT: {
        kt(this, t);
        break;
      }
      case T.IN_CAPTION: {
        cd(this, t);
        break;
      }
      case T.IN_COLUMN_GROUP: {
        fd(this, t);
        break;
      }
      case T.IN_TABLE_BODY: {
        sr(this, t);
        break;
      }
      case T.IN_ROW: {
        Ta(this, t);
        break;
      }
      case T.IN_CELL: {
        dd(this, t);
        break;
      }
      case T.IN_SELECT: {
        ba(this, t);
        break;
      }
      case T.IN_SELECT_IN_TABLE: {
        pd(this, t);
        break;
      }
      case T.IN_TEMPLATE: {
        Td(this, t);
        break;
      }
      case T.AFTER_BODY: {
        _a(this, t);
        break;
      }
      case T.IN_FRAMESET: {
        Ad(this, t);
        break;
      }
      case T.AFTER_FRAMESET: {
        Cd(this, t);
        break;
      }
      case T.AFTER_AFTER_BODY: {
        un(this, t);
        break;
      }
    }
  }
  /** @internal */
  onEof(t) {
    switch (this.insertionMode) {
      case T.INITIAL: {
        Nt(this, t);
        break;
      }
      case T.BEFORE_HTML: {
        Dt(this, t);
        break;
      }
      case T.BEFORE_HEAD: {
        Pt(this, t);
        break;
      }
      case T.IN_HEAD: {
        wt(this, t);
        break;
      }
      case T.IN_HEAD_NO_SCRIPT: {
        Mt(this, t);
        break;
      }
      case T.AFTER_HEAD: {
        Bt(this, t);
        break;
      }
      case T.IN_BODY:
      case T.IN_TABLE:
      case T.IN_CAPTION:
      case T.IN_COLUMN_GROUP:
      case T.IN_TABLE_BODY:
      case T.IN_ROW:
      case T.IN_CELL:
      case T.IN_SELECT:
      case T.IN_SELECT_IN_TABLE: {
        da(this, t);
        break;
      }
      case T.TEXT: {
        ed(this, t);
        break;
      }
      case T.IN_TABLE_TEXT: {
        kt(this, t);
        break;
      }
      case T.IN_TEMPLATE: {
        Aa(this, t);
        break;
      }
      case T.AFTER_BODY:
      case T.IN_FRAMESET:
      case T.AFTER_FRAMESET:
      case T.AFTER_AFTER_BODY:
      case T.AFTER_AFTER_FRAMESET: {
        Pr(this, t);
        break;
      }
    }
  }
  /** @internal */
  onWhitespaceCharacter(t) {
    if (this.skipNextNewLine && (this.skipNextNewLine = !1, t.chars.charCodeAt(0) === m.LINE_FEED)) {
      if (t.chars.length === 1)
        return;
      t.chars = t.chars.substr(1);
    }
    if (this.tokenizer.inForeignNode) {
      this._insertCharacters(t);
      return;
    }
    switch (this.insertionMode) {
      case T.IN_HEAD:
      case T.IN_HEAD_NO_SCRIPT:
      case T.AFTER_HEAD:
      case T.TEXT:
      case T.IN_COLUMN_GROUP:
      case T.IN_SELECT:
      case T.IN_SELECT_IN_TABLE:
      case T.IN_FRAMESET:
      case T.AFTER_FRAMESET: {
        this._insertCharacters(t);
        break;
      }
      case T.IN_BODY:
      case T.IN_CAPTION:
      case T.IN_CELL:
      case T.IN_TEMPLATE:
      case T.AFTER_BODY:
      case T.AFTER_AFTER_BODY:
      case T.AFTER_AFTER_FRAMESET: {
        oa(this, t);
        break;
      }
      case T.IN_TABLE:
      case T.IN_TABLE_BODY:
      case T.IN_ROW: {
        jn(this, t);
        break;
      }
      case T.IN_TABLE_TEXT: {
        ma(this, t);
        break;
      }
    }
  }
}
function $f(e, t) {
  let n = e.activeFormattingElements.getElementEntryInScopeWithTagName(t.tagName);
  return n ? e.openElements.contains(n.element) ? e.openElements.hasInScope(t.tagID) || (n = null) : (e.activeFormattingElements.removeEntry(n), n = null) : ha(e, t), n;
}
function Jf(e, t) {
  let n = null, r = e.openElements.stackTop;
  for (; r >= 0; r--) {
    const u = e.openElements.items[r];
    if (u === t.element)
      break;
    e._isSpecialElement(u, e.openElements.tagIDs[r]) && (n = u);
  }
  return n || (e.openElements.shortenToLength(r < 0 ? 0 : r), e.activeFormattingElements.removeEntry(t)), n;
}
function Zf(e, t, n) {
  let r = t, u = e.openElements.getCommonAncestor(t);
  for (let a = 0, i = u; i !== n; a++, i = u) {
    u = e.openElements.getCommonAncestor(i);
    const o = e.activeFormattingElements.getElementEntry(i), l = o && a >= Xf;
    !o || l ? (l && e.activeFormattingElements.removeEntry(o), e.openElements.remove(i)) : (i = eh(e, o), r === t && (e.activeFormattingElements.bookmark = o), e.treeAdapter.detachNode(r), e.treeAdapter.appendChild(i, r), r = i);
  }
  return r;
}
function eh(e, t) {
  const n = e.treeAdapter.getNamespaceURI(t.element), r = e.treeAdapter.createElement(t.token.tagName, n, t.token.attrs);
  return e.openElements.replace(t.element, r), t.element = r, r;
}
function th(e, t, n) {
  const r = e.treeAdapter.getTagName(t), u = bt(r);
  if (e._isElementCausesFosterParenting(u))
    e._fosterParentElement(n);
  else {
    const a = e.treeAdapter.getNamespaceURI(t);
    u === s.TEMPLATE && a === y.HTML && (t = e.treeAdapter.getTemplateContent(t)), e.treeAdapter.appendChild(t, n);
  }
}
function nh(e, t, n) {
  const r = e.treeAdapter.getNamespaceURI(n.element), { token: u } = n, a = e.treeAdapter.createElement(u.tagName, r, u.attrs);
  e._adoptNodes(t, a), e.treeAdapter.appendChild(t, a), e.activeFormattingElements.insertElementAfterBookmark(a, u), e.activeFormattingElements.removeEntry(n), e.openElements.remove(n.element), e.openElements.insertAfter(t, a, u.tagID);
}
function Dr(e, t) {
  for (let n = 0; n < Gf; n++) {
    const r = $f(e, t);
    if (!r)
      break;
    const u = Jf(e, r);
    if (!u)
      break;
    e.activeFormattingElements.bookmark = r;
    const a = Zf(e, u, r.element), i = e.openElements.getCommonAncestor(r.element);
    e.treeAdapter.detachNode(a), i && th(e, i, a), nh(e, u, r);
  }
}
function ar(e, t) {
  e._appendCommentNode(t, e.openElements.currentTmplContentOrNode);
}
function rh(e, t) {
  e._appendCommentNode(t, e.openElements.items[0]);
}
function uh(e, t) {
  e._appendCommentNode(t, e.document);
}
function Pr(e, t) {
  if (e.stopped = !0, t.location) {
    const n = e.fragmentContext ? 0 : 2;
    for (let r = e.openElements.stackTop; r >= n; r--)
      e._setEndLocation(e.openElements.items[r], t);
    if (!e.fragmentContext && e.openElements.stackTop >= 0) {
      const r = e.openElements.items[0], u = e.treeAdapter.getNodeSourceCodeLocation(r);
      if (u && !u.endTag && (e._setEndLocation(r, t), e.openElements.stackTop >= 1)) {
        const a = e.openElements.items[1], i = e.treeAdapter.getNodeSourceCodeLocation(a);
        i && !i.endTag && e._setEndLocation(a, t);
      }
    }
  }
}
function ih(e, t) {
  e._setDocumentType(t);
  const n = t.forceQuirks ? be.QUIRKS : Mf(t);
  wf(t) || e._err(t, I.nonConformingDoctype), e.treeAdapter.setDocumentMode(e.document, n), e.insertionMode = T.BEFORE_HTML;
}
function Nt(e, t) {
  e._err(t, I.missingDoctype, !0), e.treeAdapter.setDocumentMode(e.document, be.QUIRKS), e.insertionMode = T.BEFORE_HTML, e._processToken(t);
}
function ah(e, t) {
  t.tagID === s.HTML ? (e._insertElement(t, y.HTML), e.insertionMode = T.BEFORE_HEAD) : Dt(e, t);
}
function sh(e, t) {
  const n = t.tagID;
  (n === s.HTML || n === s.HEAD || n === s.BODY || n === s.BR) && Dt(e, t);
}
function Dt(e, t) {
  e._insertFakeRootElement(), e.insertionMode = T.BEFORE_HEAD, e._processToken(t);
}
function oh(e, t) {
  switch (t.tagID) {
    case s.HTML: {
      he(e, t);
      break;
    }
    case s.HEAD: {
      e._insertElement(t, y.HTML), e.headElement = e.openElements.current, e.insertionMode = T.IN_HEAD;
      break;
    }
    default:
      Pt(e, t);
  }
}
function lh(e, t) {
  const n = t.tagID;
  n === s.HEAD || n === s.BODY || n === s.HTML || n === s.BR ? Pt(e, t) : e._err(t, I.endTagWithoutMatchingOpenElement);
}
function Pt(e, t) {
  e._insertFakeElement(_.HEAD, s.HEAD), e.headElement = e.openElements.current, e.insertionMode = T.IN_HEAD, e._processToken(t);
}
function Se(e, t) {
  switch (t.tagID) {
    case s.HTML: {
      he(e, t);
      break;
    }
    case s.BASE:
    case s.BASEFONT:
    case s.BGSOUND:
    case s.LINK:
    case s.META: {
      e._appendElement(t, y.HTML), t.ackSelfClosing = !0;
      break;
    }
    case s.TITLE: {
      e._switchToTextParsing(t, re.RCDATA);
      break;
    }
    case s.NOSCRIPT: {
      e.options.scriptingEnabled ? e._switchToTextParsing(t, re.RAWTEXT) : (e._insertElement(t, y.HTML), e.insertionMode = T.IN_HEAD_NO_SCRIPT);
      break;
    }
    case s.NOFRAMES:
    case s.STYLE: {
      e._switchToTextParsing(t, re.RAWTEXT);
      break;
    }
    case s.SCRIPT: {
      e._switchToTextParsing(t, re.SCRIPT_DATA);
      break;
    }
    case s.TEMPLATE: {
      e._insertTemplate(t), e.activeFormattingElements.insertMarker(), e.framesetOk = !1, e.insertionMode = T.IN_TEMPLATE, e.tmplInsertionModeStack.unshift(T.IN_TEMPLATE);
      break;
    }
    case s.HEAD: {
      e._err(t, I.misplacedStartTagForHeadElement);
      break;
    }
    default:
      wt(e, t);
  }
}
function ch(e, t) {
  switch (t.tagID) {
    case s.HEAD: {
      e.openElements.pop(), e.insertionMode = T.AFTER_HEAD;
      break;
    }
    case s.BODY:
    case s.BR:
    case s.HTML: {
      wt(e, t);
      break;
    }
    case s.TEMPLATE: {
      rt(e, t);
      break;
    }
    default:
      e._err(t, I.endTagWithoutMatchingOpenElement);
  }
}
function rt(e, t) {
  e.openElements.tmplCount > 0 ? (e.openElements.generateImpliedEndTagsThoroughly(), e.openElements.currentTagId !== s.TEMPLATE && e._err(t, I.closingOfElementWithOpenChildElements), e.openElements.popUntilTagNamePopped(s.TEMPLATE), e.activeFormattingElements.clearToLastMarker(), e.tmplInsertionModeStack.shift(), e._resetInsertionMode()) : e._err(t, I.endTagWithoutMatchingOpenElement);
}
function wt(e, t) {
  e.openElements.pop(), e.insertionMode = T.AFTER_HEAD, e._processToken(t);
}
function fh(e, t) {
  switch (t.tagID) {
    case s.HTML: {
      he(e, t);
      break;
    }
    case s.BASEFONT:
    case s.BGSOUND:
    case s.HEAD:
    case s.LINK:
    case s.META:
    case s.NOFRAMES:
    case s.STYLE: {
      Se(e, t);
      break;
    }
    case s.NOSCRIPT: {
      e._err(t, I.nestedNoscriptInHead);
      break;
    }
    default:
      Mt(e, t);
  }
}
function hh(e, t) {
  switch (t.tagID) {
    case s.NOSCRIPT: {
      e.openElements.pop(), e.insertionMode = T.IN_HEAD;
      break;
    }
    case s.BR: {
      Mt(e, t);
      break;
    }
    default:
      e._err(t, I.endTagWithoutMatchingOpenElement);
  }
}
function Mt(e, t) {
  const n = t.type === q.EOF ? I.openElementsLeftAfterEof : I.disallowedContentInNoscriptInHead;
  e._err(t, n), e.openElements.pop(), e.insertionMode = T.IN_HEAD, e._processToken(t);
}
function dh(e, t) {
  switch (t.tagID) {
    case s.HTML: {
      he(e, t);
      break;
    }
    case s.BODY: {
      e._insertElement(t, y.HTML), e.framesetOk = !1, e.insertionMode = T.IN_BODY;
      break;
    }
    case s.FRAMESET: {
      e._insertElement(t, y.HTML), e.insertionMode = T.IN_FRAMESET;
      break;
    }
    case s.BASE:
    case s.BASEFONT:
    case s.BGSOUND:
    case s.LINK:
    case s.META:
    case s.NOFRAMES:
    case s.SCRIPT:
    case s.STYLE:
    case s.TEMPLATE:
    case s.TITLE: {
      e._err(t, I.abandonedHeadElementChild), e.openElements.push(e.headElement, s.HEAD), Se(e, t), e.openElements.remove(e.headElement);
      break;
    }
    case s.HEAD: {
      e._err(t, I.misplacedStartTagForHeadElement);
      break;
    }
    default:
      Bt(e, t);
  }
}
function mh(e, t) {
  switch (t.tagID) {
    case s.BODY:
    case s.HTML:
    case s.BR: {
      Bt(e, t);
      break;
    }
    case s.TEMPLATE: {
      rt(e, t);
      break;
    }
    default:
      e._err(t, I.endTagWithoutMatchingOpenElement);
  }
}
function Bt(e, t) {
  e._insertFakeElement(_.BODY, s.BODY), e.insertionMode = T.IN_BODY, xn(e, t);
}
function xn(e, t) {
  switch (t.type) {
    case q.CHARACTER: {
      la(e, t);
      break;
    }
    case q.WHITESPACE_CHARACTER: {
      oa(e, t);
      break;
    }
    case q.COMMENT: {
      ar(e, t);
      break;
    }
    case q.START_TAG: {
      he(e, t);
      break;
    }
    case q.END_TAG: {
      Sn(e, t);
      break;
    }
    case q.EOF: {
      da(e, t);
      break;
    }
  }
}
function oa(e, t) {
  e._reconstructActiveFormattingElements(), e._insertCharacters(t);
}
function la(e, t) {
  e._reconstructActiveFormattingElements(), e._insertCharacters(t), e.framesetOk = !1;
}
function ph(e, t) {
  e.openElements.tmplCount === 0 && e.treeAdapter.adoptAttributes(e.openElements.items[0], t.attrs);
}
function Eh(e, t) {
  const n = e.openElements.tryPeekProperlyNestedBodyElement();
  n && e.openElements.tmplCount === 0 && (e.framesetOk = !1, e.treeAdapter.adoptAttributes(n, t.attrs));
}
function Th(e, t) {
  const n = e.openElements.tryPeekProperlyNestedBodyElement();
  e.framesetOk && n && (e.treeAdapter.detachNode(n), e.openElements.popAllUpToHtmlElement(), e._insertElement(t, y.HTML), e.insertionMode = T.IN_FRAMESET);
}
function gh(e, t) {
  e.openElements.hasInButtonScope(s.P) && e._closePElement(), e._insertElement(t, y.HTML);
}
function bh(e, t) {
  e.openElements.hasInButtonScope(s.P) && e._closePElement(), ir.has(e.openElements.currentTagId) && e.openElements.pop(), e._insertElement(t, y.HTML);
}
function Ah(e, t) {
  e.openElements.hasInButtonScope(s.P) && e._closePElement(), e._insertElement(t, y.HTML), e.skipNextNewLine = !0, e.framesetOk = !1;
}
function _h(e, t) {
  const n = e.openElements.tmplCount > 0;
  (!e.formElement || n) && (e.openElements.hasInButtonScope(s.P) && e._closePElement(), e._insertElement(t, y.HTML), n || (e.formElement = e.openElements.current));
}
function Ch(e, t) {
  e.framesetOk = !1;
  const n = t.tagID;
  for (let r = e.openElements.stackTop; r >= 0; r--) {
    const u = e.openElements.tagIDs[r];
    if (n === s.LI && u === s.LI || (n === s.DD || n === s.DT) && (u === s.DD || u === s.DT)) {
      e.openElements.generateImpliedEndTagsWithExclusion(u), e.openElements.popUntilTagNamePopped(u);
      break;
    }
    if (u !== s.ADDRESS && u !== s.DIV && u !== s.P && e._isSpecialElement(e.openElements.items[r], u))
      break;
  }
  e.openElements.hasInButtonScope(s.P) && e._closePElement(), e._insertElement(t, y.HTML);
}
function Ih(e, t) {
  e.openElements.hasInButtonScope(s.P) && e._closePElement(), e._insertElement(t, y.HTML), e.tokenizer.state = re.PLAINTEXT;
}
function xh(e, t) {
  e.openElements.hasInScope(s.BUTTON) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(s.BUTTON)), e._reconstructActiveFormattingElements(), e._insertElement(t, y.HTML), e.framesetOk = !1;
}
function Sh(e, t) {
  const n = e.activeFormattingElements.getElementEntryInScopeWithTagName(_.A);
  n && (Dr(e, t), e.openElements.remove(n.element), e.activeFormattingElements.removeEntry(n)), e._reconstructActiveFormattingElements(), e._insertElement(t, y.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t);
}
function Nh(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, y.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t);
}
function kh(e, t) {
  e._reconstructActiveFormattingElements(), e.openElements.hasInScope(s.NOBR) && (Dr(e, t), e._reconstructActiveFormattingElements()), e._insertElement(t, y.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t);
}
function Oh(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, y.HTML), e.activeFormattingElements.insertMarker(), e.framesetOk = !1;
}
function yh(e, t) {
  e.treeAdapter.getDocumentMode(e.document) !== be.QUIRKS && e.openElements.hasInButtonScope(s.P) && e._closePElement(), e._insertElement(t, y.HTML), e.framesetOk = !1, e.insertionMode = T.IN_TABLE;
}
function ca(e, t) {
  e._reconstructActiveFormattingElements(), e._appendElement(t, y.HTML), e.framesetOk = !1, t.ackSelfClosing = !0;
}
function fa(e) {
  const t = Ki(e, Ze.TYPE);
  return t != null && t.toLowerCase() === Qf;
}
function Lh(e, t) {
  e._reconstructActiveFormattingElements(), e._appendElement(t, y.HTML), fa(t) || (e.framesetOk = !1), t.ackSelfClosing = !0;
}
function Rh(e, t) {
  e._appendElement(t, y.HTML), t.ackSelfClosing = !0;
}
function Dh(e, t) {
  e.openElements.hasInButtonScope(s.P) && e._closePElement(), e._appendElement(t, y.HTML), e.framesetOk = !1, t.ackSelfClosing = !0;
}
function Ph(e, t) {
  t.tagName = _.IMG, t.tagID = s.IMG, ca(e, t);
}
function wh(e, t) {
  e._insertElement(t, y.HTML), e.skipNextNewLine = !0, e.tokenizer.state = re.RCDATA, e.originalInsertionMode = e.insertionMode, e.framesetOk = !1, e.insertionMode = T.TEXT;
}
function Mh(e, t) {
  e.openElements.hasInButtonScope(s.P) && e._closePElement(), e._reconstructActiveFormattingElements(), e.framesetOk = !1, e._switchToTextParsing(t, re.RAWTEXT);
}
function Bh(e, t) {
  e.framesetOk = !1, e._switchToTextParsing(t, re.RAWTEXT);
}
function vu(e, t) {
  e._switchToTextParsing(t, re.RAWTEXT);
}
function Fh(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, y.HTML), e.framesetOk = !1, e.insertionMode = e.insertionMode === T.IN_TABLE || e.insertionMode === T.IN_CAPTION || e.insertionMode === T.IN_TABLE_BODY || e.insertionMode === T.IN_ROW || e.insertionMode === T.IN_CELL ? T.IN_SELECT_IN_TABLE : T.IN_SELECT;
}
function Hh(e, t) {
  e.openElements.currentTagId === s.OPTION && e.openElements.pop(), e._reconstructActiveFormattingElements(), e._insertElement(t, y.HTML);
}
function Uh(e, t) {
  e.openElements.hasInScope(s.RUBY) && e.openElements.generateImpliedEndTags(), e._insertElement(t, y.HTML);
}
function vh(e, t) {
  e.openElements.hasInScope(s.RUBY) && e.openElements.generateImpliedEndTagsWithExclusion(s.RTC), e._insertElement(t, y.HTML);
}
function zh(e, t) {
  e._reconstructActiveFormattingElements(), ia(t), Rr(t), t.selfClosing ? e._appendElement(t, y.MATHML) : e._insertElement(t, y.MATHML), t.ackSelfClosing = !0;
}
function Yh(e, t) {
  e._reconstructActiveFormattingElements(), aa(t), Rr(t), t.selfClosing ? e._appendElement(t, y.SVG) : e._insertElement(t, y.SVG), t.ackSelfClosing = !0;
}
function zu(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, y.HTML);
}
function he(e, t) {
  switch (t.tagID) {
    case s.I:
    case s.S:
    case s.B:
    case s.U:
    case s.EM:
    case s.TT:
    case s.BIG:
    case s.CODE:
    case s.FONT:
    case s.SMALL:
    case s.STRIKE:
    case s.STRONG: {
      Nh(e, t);
      break;
    }
    case s.A: {
      Sh(e, t);
      break;
    }
    case s.H1:
    case s.H2:
    case s.H3:
    case s.H4:
    case s.H5:
    case s.H6: {
      bh(e, t);
      break;
    }
    case s.P:
    case s.DL:
    case s.OL:
    case s.UL:
    case s.DIV:
    case s.DIR:
    case s.NAV:
    case s.MAIN:
    case s.MENU:
    case s.ASIDE:
    case s.CENTER:
    case s.FIGURE:
    case s.FOOTER:
    case s.HEADER:
    case s.HGROUP:
    case s.DIALOG:
    case s.DETAILS:
    case s.ADDRESS:
    case s.ARTICLE:
    case s.SEARCH:
    case s.SECTION:
    case s.SUMMARY:
    case s.FIELDSET:
    case s.BLOCKQUOTE:
    case s.FIGCAPTION: {
      gh(e, t);
      break;
    }
    case s.LI:
    case s.DD:
    case s.DT: {
      Ch(e, t);
      break;
    }
    case s.BR:
    case s.IMG:
    case s.WBR:
    case s.AREA:
    case s.EMBED:
    case s.KEYGEN: {
      ca(e, t);
      break;
    }
    case s.HR: {
      Dh(e, t);
      break;
    }
    case s.RB:
    case s.RTC: {
      Uh(e, t);
      break;
    }
    case s.RT:
    case s.RP: {
      vh(e, t);
      break;
    }
    case s.PRE:
    case s.LISTING: {
      Ah(e, t);
      break;
    }
    case s.XMP: {
      Mh(e, t);
      break;
    }
    case s.SVG: {
      Yh(e, t);
      break;
    }
    case s.HTML: {
      ph(e, t);
      break;
    }
    case s.BASE:
    case s.LINK:
    case s.META:
    case s.STYLE:
    case s.TITLE:
    case s.SCRIPT:
    case s.BGSOUND:
    case s.BASEFONT:
    case s.TEMPLATE: {
      Se(e, t);
      break;
    }
    case s.BODY: {
      Eh(e, t);
      break;
    }
    case s.FORM: {
      _h(e, t);
      break;
    }
    case s.NOBR: {
      kh(e, t);
      break;
    }
    case s.MATH: {
      zh(e, t);
      break;
    }
    case s.TABLE: {
      yh(e, t);
      break;
    }
    case s.INPUT: {
      Lh(e, t);
      break;
    }
    case s.PARAM:
    case s.TRACK:
    case s.SOURCE: {
      Rh(e, t);
      break;
    }
    case s.IMAGE: {
      Ph(e, t);
      break;
    }
    case s.BUTTON: {
      xh(e, t);
      break;
    }
    case s.APPLET:
    case s.OBJECT:
    case s.MARQUEE: {
      Oh(e, t);
      break;
    }
    case s.IFRAME: {
      Bh(e, t);
      break;
    }
    case s.SELECT: {
      Fh(e, t);
      break;
    }
    case s.OPTION:
    case s.OPTGROUP: {
      Hh(e, t);
      break;
    }
    case s.NOEMBED:
    case s.NOFRAMES: {
      vu(e, t);
      break;
    }
    case s.FRAMESET: {
      Th(e, t);
      break;
    }
    case s.TEXTAREA: {
      wh(e, t);
      break;
    }
    case s.NOSCRIPT: {
      e.options.scriptingEnabled ? vu(e, t) : zu(e, t);
      break;
    }
    case s.PLAINTEXT: {
      Ih(e, t);
      break;
    }
    case s.COL:
    case s.TH:
    case s.TD:
    case s.TR:
    case s.HEAD:
    case s.FRAME:
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD:
    case s.CAPTION:
    case s.COLGROUP:
      break;
    default:
      zu(e, t);
  }
}
function qh(e, t) {
  if (e.openElements.hasInScope(s.BODY) && (e.insertionMode = T.AFTER_BODY, e.options.sourceCodeLocationInfo)) {
    const n = e.openElements.tryPeekProperlyNestedBodyElement();
    n && e._setEndLocation(n, t);
  }
}
function jh(e, t) {
  e.openElements.hasInScope(s.BODY) && (e.insertionMode = T.AFTER_BODY, _a(e, t));
}
function Vh(e, t) {
  const n = t.tagID;
  e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n));
}
function Wh(e) {
  const t = e.openElements.tmplCount > 0, { formElement: n } = e;
  t || (e.formElement = null), (n || t) && e.openElements.hasInScope(s.FORM) && (e.openElements.generateImpliedEndTags(), t ? e.openElements.popUntilTagNamePopped(s.FORM) : n && e.openElements.remove(n));
}
function Qh(e) {
  e.openElements.hasInButtonScope(s.P) || e._insertFakeElement(_.P, s.P), e._closePElement();
}
function Gh(e) {
  e.openElements.hasInListItemScope(s.LI) && (e.openElements.generateImpliedEndTagsWithExclusion(s.LI), e.openElements.popUntilTagNamePopped(s.LI));
}
function Xh(e, t) {
  const n = t.tagID;
  e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTagsWithExclusion(n), e.openElements.popUntilTagNamePopped(n));
}
function Kh(e) {
  e.openElements.hasNumberedHeaderInScope() && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilNumberedHeaderPopped());
}
function $h(e, t) {
  const n = t.tagID;
  e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n), e.activeFormattingElements.clearToLastMarker());
}
function Jh(e) {
  e._reconstructActiveFormattingElements(), e._insertFakeElement(_.BR, s.BR), e.openElements.pop(), e.framesetOk = !1;
}
function ha(e, t) {
  const n = t.tagName, r = t.tagID;
  for (let u = e.openElements.stackTop; u > 0; u--) {
    const a = e.openElements.items[u], i = e.openElements.tagIDs[u];
    if (r === i && (r !== s.UNKNOWN || e.treeAdapter.getTagName(a) === n)) {
      e.openElements.generateImpliedEndTagsWithExclusion(r), e.openElements.stackTop >= u && e.openElements.shortenToLength(u);
      break;
    }
    if (e._isSpecialElement(a, i))
      break;
  }
}
function Sn(e, t) {
  switch (t.tagID) {
    case s.A:
    case s.B:
    case s.I:
    case s.S:
    case s.U:
    case s.EM:
    case s.TT:
    case s.BIG:
    case s.CODE:
    case s.FONT:
    case s.NOBR:
    case s.SMALL:
    case s.STRIKE:
    case s.STRONG: {
      Dr(e, t);
      break;
    }
    case s.P: {
      Qh(e);
      break;
    }
    case s.DL:
    case s.UL:
    case s.OL:
    case s.DIR:
    case s.DIV:
    case s.NAV:
    case s.PRE:
    case s.MAIN:
    case s.MENU:
    case s.ASIDE:
    case s.BUTTON:
    case s.CENTER:
    case s.FIGURE:
    case s.FOOTER:
    case s.HEADER:
    case s.HGROUP:
    case s.DIALOG:
    case s.ADDRESS:
    case s.ARTICLE:
    case s.DETAILS:
    case s.SEARCH:
    case s.SECTION:
    case s.SUMMARY:
    case s.LISTING:
    case s.FIELDSET:
    case s.BLOCKQUOTE:
    case s.FIGCAPTION: {
      Vh(e, t);
      break;
    }
    case s.LI: {
      Gh(e);
      break;
    }
    case s.DD:
    case s.DT: {
      Xh(e, t);
      break;
    }
    case s.H1:
    case s.H2:
    case s.H3:
    case s.H4:
    case s.H5:
    case s.H6: {
      Kh(e);
      break;
    }
    case s.BR: {
      Jh(e);
      break;
    }
    case s.BODY: {
      qh(e, t);
      break;
    }
    case s.HTML: {
      jh(e, t);
      break;
    }
    case s.FORM: {
      Wh(e);
      break;
    }
    case s.APPLET:
    case s.OBJECT:
    case s.MARQUEE: {
      $h(e, t);
      break;
    }
    case s.TEMPLATE: {
      rt(e, t);
      break;
    }
    default:
      ha(e, t);
  }
}
function da(e, t) {
  e.tmplInsertionModeStack.length > 0 ? Aa(e, t) : Pr(e, t);
}
function Zh(e, t) {
  var n;
  t.tagID === s.SCRIPT && ((n = e.scriptHandler) === null || n === void 0 || n.call(e, e.openElements.current)), e.openElements.pop(), e.insertionMode = e.originalInsertionMode;
}
function ed(e, t) {
  e._err(t, I.eofInElementThatCanContainOnlyText), e.openElements.pop(), e.insertionMode = e.originalInsertionMode, e.onEof(t);
}
function jn(e, t) {
  if (sa.has(e.openElements.currentTagId))
    switch (e.pendingCharacterTokens.length = 0, e.hasNonWhitespacePendingCharacterToken = !1, e.originalInsertionMode = e.insertionMode, e.insertionMode = T.IN_TABLE_TEXT, t.type) {
      case q.CHARACTER: {
        pa(e, t);
        break;
      }
      case q.WHITESPACE_CHARACTER: {
        ma(e, t);
        break;
      }
    }
  else
    jt(e, t);
}
function td(e, t) {
  e.openElements.clearBackToTableContext(), e.activeFormattingElements.insertMarker(), e._insertElement(t, y.HTML), e.insertionMode = T.IN_CAPTION;
}
function nd(e, t) {
  e.openElements.clearBackToTableContext(), e._insertElement(t, y.HTML), e.insertionMode = T.IN_COLUMN_GROUP;
}
function rd(e, t) {
  e.openElements.clearBackToTableContext(), e._insertFakeElement(_.COLGROUP, s.COLGROUP), e.insertionMode = T.IN_COLUMN_GROUP, wr(e, t);
}
function ud(e, t) {
  e.openElements.clearBackToTableContext(), e._insertElement(t, y.HTML), e.insertionMode = T.IN_TABLE_BODY;
}
function id(e, t) {
  e.openElements.clearBackToTableContext(), e._insertFakeElement(_.TBODY, s.TBODY), e.insertionMode = T.IN_TABLE_BODY, Nn(e, t);
}
function ad(e, t) {
  e.openElements.hasInTableScope(s.TABLE) && (e.openElements.popUntilTagNamePopped(s.TABLE), e._resetInsertionMode(), e._processStartTag(t));
}
function sd(e, t) {
  fa(t) ? e._appendElement(t, y.HTML) : jt(e, t), t.ackSelfClosing = !0;
}
function od(e, t) {
  !e.formElement && e.openElements.tmplCount === 0 && (e._insertElement(t, y.HTML), e.formElement = e.openElements.current, e.openElements.pop());
}
function mt(e, t) {
  switch (t.tagID) {
    case s.TD:
    case s.TH:
    case s.TR: {
      id(e, t);
      break;
    }
    case s.STYLE:
    case s.SCRIPT:
    case s.TEMPLATE: {
      Se(e, t);
      break;
    }
    case s.COL: {
      rd(e, t);
      break;
    }
    case s.FORM: {
      od(e, t);
      break;
    }
    case s.TABLE: {
      ad(e, t);
      break;
    }
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD: {
      ud(e, t);
      break;
    }
    case s.INPUT: {
      sd(e, t);
      break;
    }
    case s.CAPTION: {
      td(e, t);
      break;
    }
    case s.COLGROUP: {
      nd(e, t);
      break;
    }
    default:
      jt(e, t);
  }
}
function Ut(e, t) {
  switch (t.tagID) {
    case s.TABLE: {
      e.openElements.hasInTableScope(s.TABLE) && (e.openElements.popUntilTagNamePopped(s.TABLE), e._resetInsertionMode());
      break;
    }
    case s.TEMPLATE: {
      rt(e, t);
      break;
    }
    case s.BODY:
    case s.CAPTION:
    case s.COL:
    case s.COLGROUP:
    case s.HTML:
    case s.TBODY:
    case s.TD:
    case s.TFOOT:
    case s.TH:
    case s.THEAD:
    case s.TR:
      break;
    default:
      jt(e, t);
  }
}
function jt(e, t) {
  const n = e.fosterParentingEnabled;
  e.fosterParentingEnabled = !0, xn(e, t), e.fosterParentingEnabled = n;
}
function ma(e, t) {
  e.pendingCharacterTokens.push(t);
}
function pa(e, t) {
  e.pendingCharacterTokens.push(t), e.hasNonWhitespacePendingCharacterToken = !0;
}
function kt(e, t) {
  let n = 0;
  if (e.hasNonWhitespacePendingCharacterToken)
    for (; n < e.pendingCharacterTokens.length; n++)
      jt(e, e.pendingCharacterTokens[n]);
  else
    for (; n < e.pendingCharacterTokens.length; n++)
      e._insertCharacters(e.pendingCharacterTokens[n]);
  e.insertionMode = e.originalInsertionMode, e._processToken(t);
}
const Ea = /* @__PURE__ */ new Set([s.CAPTION, s.COL, s.COLGROUP, s.TBODY, s.TD, s.TFOOT, s.TH, s.THEAD, s.TR]);
function ld(e, t) {
  const n = t.tagID;
  Ea.has(n) ? e.openElements.hasInTableScope(s.CAPTION) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(s.CAPTION), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = T.IN_TABLE, mt(e, t)) : he(e, t);
}
function cd(e, t) {
  const n = t.tagID;
  switch (n) {
    case s.CAPTION:
    case s.TABLE: {
      e.openElements.hasInTableScope(s.CAPTION) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(s.CAPTION), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = T.IN_TABLE, n === s.TABLE && Ut(e, t));
      break;
    }
    case s.BODY:
    case s.COL:
    case s.COLGROUP:
    case s.HTML:
    case s.TBODY:
    case s.TD:
    case s.TFOOT:
    case s.TH:
    case s.THEAD:
    case s.TR:
      break;
    default:
      Sn(e, t);
  }
}
function wr(e, t) {
  switch (t.tagID) {
    case s.HTML: {
      he(e, t);
      break;
    }
    case s.COL: {
      e._appendElement(t, y.HTML), t.ackSelfClosing = !0;
      break;
    }
    case s.TEMPLATE: {
      Se(e, t);
      break;
    }
    default:
      mn(e, t);
  }
}
function fd(e, t) {
  switch (t.tagID) {
    case s.COLGROUP: {
      e.openElements.currentTagId === s.COLGROUP && (e.openElements.pop(), e.insertionMode = T.IN_TABLE);
      break;
    }
    case s.TEMPLATE: {
      rt(e, t);
      break;
    }
    case s.COL:
      break;
    default:
      mn(e, t);
  }
}
function mn(e, t) {
  e.openElements.currentTagId === s.COLGROUP && (e.openElements.pop(), e.insertionMode = T.IN_TABLE, e._processToken(t));
}
function Nn(e, t) {
  switch (t.tagID) {
    case s.TR: {
      e.openElements.clearBackToTableBodyContext(), e._insertElement(t, y.HTML), e.insertionMode = T.IN_ROW;
      break;
    }
    case s.TH:
    case s.TD: {
      e.openElements.clearBackToTableBodyContext(), e._insertFakeElement(_.TR, s.TR), e.insertionMode = T.IN_ROW, kn(e, t);
      break;
    }
    case s.CAPTION:
    case s.COL:
    case s.COLGROUP:
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD: {
      e.openElements.hasTableBodyContextInTableScope() && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = T.IN_TABLE, mt(e, t));
      break;
    }
    default:
      mt(e, t);
  }
}
function sr(e, t) {
  const n = t.tagID;
  switch (t.tagID) {
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD: {
      e.openElements.hasInTableScope(n) && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = T.IN_TABLE);
      break;
    }
    case s.TABLE: {
      e.openElements.hasTableBodyContextInTableScope() && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = T.IN_TABLE, Ut(e, t));
      break;
    }
    case s.BODY:
    case s.CAPTION:
    case s.COL:
    case s.COLGROUP:
    case s.HTML:
    case s.TD:
    case s.TH:
    case s.TR:
      break;
    default:
      Ut(e, t);
  }
}
function kn(e, t) {
  switch (t.tagID) {
    case s.TH:
    case s.TD: {
      e.openElements.clearBackToTableRowContext(), e._insertElement(t, y.HTML), e.insertionMode = T.IN_CELL, e.activeFormattingElements.insertMarker();
      break;
    }
    case s.CAPTION:
    case s.COL:
    case s.COLGROUP:
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD:
    case s.TR: {
      e.openElements.hasInTableScope(s.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = T.IN_TABLE_BODY, Nn(e, t));
      break;
    }
    default:
      mt(e, t);
  }
}
function Ta(e, t) {
  switch (t.tagID) {
    case s.TR: {
      e.openElements.hasInTableScope(s.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = T.IN_TABLE_BODY);
      break;
    }
    case s.TABLE: {
      e.openElements.hasInTableScope(s.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = T.IN_TABLE_BODY, sr(e, t));
      break;
    }
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD: {
      (e.openElements.hasInTableScope(t.tagID) || e.openElements.hasInTableScope(s.TR)) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = T.IN_TABLE_BODY, sr(e, t));
      break;
    }
    case s.BODY:
    case s.CAPTION:
    case s.COL:
    case s.COLGROUP:
    case s.HTML:
    case s.TD:
    case s.TH:
      break;
    default:
      Ut(e, t);
  }
}
function hd(e, t) {
  const n = t.tagID;
  Ea.has(n) ? (e.openElements.hasInTableScope(s.TD) || e.openElements.hasInTableScope(s.TH)) && (e._closeTableCell(), kn(e, t)) : he(e, t);
}
function dd(e, t) {
  const n = t.tagID;
  switch (n) {
    case s.TD:
    case s.TH: {
      e.openElements.hasInTableScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = T.IN_ROW);
      break;
    }
    case s.TABLE:
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD:
    case s.TR: {
      e.openElements.hasInTableScope(n) && (e._closeTableCell(), Ta(e, t));
      break;
    }
    case s.BODY:
    case s.CAPTION:
    case s.COL:
    case s.COLGROUP:
    case s.HTML:
      break;
    default:
      Sn(e, t);
  }
}
function ga(e, t) {
  switch (t.tagID) {
    case s.HTML: {
      he(e, t);
      break;
    }
    case s.OPTION: {
      e.openElements.currentTagId === s.OPTION && e.openElements.pop(), e._insertElement(t, y.HTML);
      break;
    }
    case s.OPTGROUP: {
      e.openElements.currentTagId === s.OPTION && e.openElements.pop(), e.openElements.currentTagId === s.OPTGROUP && e.openElements.pop(), e._insertElement(t, y.HTML);
      break;
    }
    case s.HR: {
      e.openElements.currentTagId === s.OPTION && e.openElements.pop(), e.openElements.currentTagId === s.OPTGROUP && e.openElements.pop(), e._appendElement(t, y.HTML), t.ackSelfClosing = !0;
      break;
    }
    case s.INPUT:
    case s.KEYGEN:
    case s.TEXTAREA:
    case s.SELECT: {
      e.openElements.hasInSelectScope(s.SELECT) && (e.openElements.popUntilTagNamePopped(s.SELECT), e._resetInsertionMode(), t.tagID !== s.SELECT && e._processStartTag(t));
      break;
    }
    case s.SCRIPT:
    case s.TEMPLATE: {
      Se(e, t);
      break;
    }
  }
}
function ba(e, t) {
  switch (t.tagID) {
    case s.OPTGROUP: {
      e.openElements.stackTop > 0 && e.openElements.currentTagId === s.OPTION && e.openElements.tagIDs[e.openElements.stackTop - 1] === s.OPTGROUP && e.openElements.pop(), e.openElements.currentTagId === s.OPTGROUP && e.openElements.pop();
      break;
    }
    case s.OPTION: {
      e.openElements.currentTagId === s.OPTION && e.openElements.pop();
      break;
    }
    case s.SELECT: {
      e.openElements.hasInSelectScope(s.SELECT) && (e.openElements.popUntilTagNamePopped(s.SELECT), e._resetInsertionMode());
      break;
    }
    case s.TEMPLATE: {
      rt(e, t);
      break;
    }
  }
}
function md(e, t) {
  const n = t.tagID;
  n === s.CAPTION || n === s.TABLE || n === s.TBODY || n === s.TFOOT || n === s.THEAD || n === s.TR || n === s.TD || n === s.TH ? (e.openElements.popUntilTagNamePopped(s.SELECT), e._resetInsertionMode(), e._processStartTag(t)) : ga(e, t);
}
function pd(e, t) {
  const n = t.tagID;
  n === s.CAPTION || n === s.TABLE || n === s.TBODY || n === s.TFOOT || n === s.THEAD || n === s.TR || n === s.TD || n === s.TH ? e.openElements.hasInTableScope(n) && (e.openElements.popUntilTagNamePopped(s.SELECT), e._resetInsertionMode(), e.onEndTag(t)) : ba(e, t);
}
function Ed(e, t) {
  switch (t.tagID) {
    // First, handle tags that can start without a mode change
    case s.BASE:
    case s.BASEFONT:
    case s.BGSOUND:
    case s.LINK:
    case s.META:
    case s.NOFRAMES:
    case s.SCRIPT:
    case s.STYLE:
    case s.TEMPLATE:
    case s.TITLE: {
      Se(e, t);
      break;
    }
    // Re-process the token in the appropriate mode
    case s.CAPTION:
    case s.COLGROUP:
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD: {
      e.tmplInsertionModeStack[0] = T.IN_TABLE, e.insertionMode = T.IN_TABLE, mt(e, t);
      break;
    }
    case s.COL: {
      e.tmplInsertionModeStack[0] = T.IN_COLUMN_GROUP, e.insertionMode = T.IN_COLUMN_GROUP, wr(e, t);
      break;
    }
    case s.TR: {
      e.tmplInsertionModeStack[0] = T.IN_TABLE_BODY, e.insertionMode = T.IN_TABLE_BODY, Nn(e, t);
      break;
    }
    case s.TD:
    case s.TH: {
      e.tmplInsertionModeStack[0] = T.IN_ROW, e.insertionMode = T.IN_ROW, kn(e, t);
      break;
    }
    default:
      e.tmplInsertionModeStack[0] = T.IN_BODY, e.insertionMode = T.IN_BODY, he(e, t);
  }
}
function Td(e, t) {
  t.tagID === s.TEMPLATE && rt(e, t);
}
function Aa(e, t) {
  e.openElements.tmplCount > 0 ? (e.openElements.popUntilTagNamePopped(s.TEMPLATE), e.activeFormattingElements.clearToLastMarker(), e.tmplInsertionModeStack.shift(), e._resetInsertionMode(), e.onEof(t)) : Pr(e, t);
}
function gd(e, t) {
  t.tagID === s.HTML ? he(e, t) : pn(e, t);
}
function _a(e, t) {
  var n;
  if (t.tagID === s.HTML) {
    if (e.fragmentContext || (e.insertionMode = T.AFTER_AFTER_BODY), e.options.sourceCodeLocationInfo && e.openElements.tagIDs[0] === s.HTML) {
      e._setEndLocation(e.openElements.items[0], t);
      const r = e.openElements.items[1];
      r && !(!((n = e.treeAdapter.getNodeSourceCodeLocation(r)) === null || n === void 0) && n.endTag) && e._setEndLocation(r, t);
    }
  } else
    pn(e, t);
}
function pn(e, t) {
  e.insertionMode = T.IN_BODY, xn(e, t);
}
function bd(e, t) {
  switch (t.tagID) {
    case s.HTML: {
      he(e, t);
      break;
    }
    case s.FRAMESET: {
      e._insertElement(t, y.HTML);
      break;
    }
    case s.FRAME: {
      e._appendElement(t, y.HTML), t.ackSelfClosing = !0;
      break;
    }
    case s.NOFRAMES: {
      Se(e, t);
      break;
    }
  }
}
function Ad(e, t) {
  t.tagID === s.FRAMESET && !e.openElements.isRootHtmlElementCurrent() && (e.openElements.pop(), !e.fragmentContext && e.openElements.currentTagId !== s.FRAMESET && (e.insertionMode = T.AFTER_FRAMESET));
}
function _d(e, t) {
  switch (t.tagID) {
    case s.HTML: {
      he(e, t);
      break;
    }
    case s.NOFRAMES: {
      Se(e, t);
      break;
    }
  }
}
function Cd(e, t) {
  t.tagID === s.HTML && (e.insertionMode = T.AFTER_AFTER_FRAMESET);
}
function Id(e, t) {
  t.tagID === s.HTML ? he(e, t) : un(e, t);
}
function un(e, t) {
  e.insertionMode = T.IN_BODY, xn(e, t);
}
function xd(e, t) {
  switch (t.tagID) {
    case s.HTML: {
      he(e, t);
      break;
    }
    case s.NOFRAMES: {
      Se(e, t);
      break;
    }
  }
}
function Sd(e, t) {
  t.chars = te, e._insertCharacters(t);
}
function Nd(e, t) {
  e._insertCharacters(t), e.framesetOk = !1;
}
function Ca(e) {
  for (; e.treeAdapter.getNamespaceURI(e.openElements.current) !== y.HTML && !e._isIntegrationPoint(e.openElements.currentTagId, e.openElements.current); )
    e.openElements.pop();
}
function kd(e, t) {
  if (Yf(t))
    Ca(e), e._startTagOutsideForeignContent(t);
  else {
    const n = e._getAdjustedCurrentElement(), r = e.treeAdapter.getNamespaceURI(n);
    r === y.MATHML ? ia(t) : r === y.SVG && (qf(t), aa(t)), Rr(t), t.selfClosing ? e._appendElement(t, r) : e._insertElement(t, r), t.ackSelfClosing = !0;
  }
}
function Od(e, t) {
  if (t.tagID === s.P || t.tagID === s.BR) {
    Ca(e), e._endTagOutsideForeignContent(t);
    return;
  }
  for (let n = e.openElements.stackTop; n > 0; n--) {
    const r = e.openElements.items[n];
    if (e.treeAdapter.getNamespaceURI(r) === y.HTML) {
      e._endTagOutsideForeignContent(t);
      break;
    }
    const u = e.treeAdapter.getTagName(r);
    if (u.toLowerCase() === t.tagName) {
      t.tagName = u, e.openElements.shortenToLength(n);
      break;
    }
  }
}
_.AREA, _.BASE, _.BASEFONT, _.BGSOUND, _.BR, _.COL, _.EMBED, _.FRAME, _.HR, _.IMG, _.INPUT, _.KEYGEN, _.LINK, _.META, _.PARAM, _.SOURCE, _.TRACK, _.WBR;
const yd = /<(\/?)(iframe|noembed|noframes|plaintext|script|style|textarea|title|xmp)(?=[\t\n\f\r />])/gi, Ld = /* @__PURE__ */ new Set([
  "mdxFlowExpression",
  "mdxJsxFlowElement",
  "mdxJsxTextElement",
  "mdxTextExpression",
  "mdxjsEsm"
]), Yu = { sourceCodeLocationInfo: !0, scriptingEnabled: !1 };
function Ia(e, t) {
  const n = vd(e), r = ci("type", {
    handlers: { root: Rd, element: Dd, text: Pd, comment: Sa, doctype: wd, raw: Bd },
    unknown: Fd
  }), u = {
    parser: n ? new Uu(Yu) : Uu.getFragmentParser(void 0, Yu),
    handle(o) {
      r(o, u);
    },
    stitches: !1,
    options: t || {}
  };
  r(e, u), At(u, je());
  const a = n ? u.parser.document : u.parser.getFragment(), i = z0(a, {
    // To do: support `space`?
    file: u.options.file
  });
  return u.stitches && Tn(i, "comment", function(o, l, c) {
    const h = (
      /** @type {Stitch} */
      /** @type {unknown} */
      o
    );
    if (h.value.stitch && c && l !== void 0) {
      const f = c.children;
      return f[l] = h.value.stitch, l;
    }
  }), i.type === "root" && i.children.length === 1 && i.children[0].type === e.type ? i.children[0] : i;
}
function xa(e, t) {
  let n = -1;
  if (e)
    for (; ++n < e.length; )
      t.handle(e[n]);
}
function Rd(e, t) {
  xa(e.children, t);
}
function Dd(e, t) {
  Hd(e, t), xa(e.children, t), Ud(e, t);
}
function Pd(e, t) {
  t.parser.tokenizer.state > 4 && (t.parser.tokenizer.state = 0);
  const n = {
    type: q.CHARACTER,
    chars: e.value,
    location: Vt(e)
  };
  At(t, je(e)), t.parser.currentToken = n, t.parser._processToken(t.parser.currentToken);
}
function wd(e, t) {
  const n = {
    type: q.DOCTYPE,
    name: "html",
    forceQuirks: !1,
    publicId: "",
    systemId: "",
    location: Vt(e)
  };
  At(t, je(e)), t.parser.currentToken = n, t.parser._processToken(t.parser.currentToken);
}
function Md(e, t) {
  t.stitches = !0;
  const n = zd(e);
  if ("children" in e && "children" in n) {
    const r = (
      /** @type {Root} */
      Ia({ type: "root", children: e.children }, t.options)
    );
    n.children = r.children;
  }
  Sa({ type: "comment", value: { stitch: n } }, t);
}
function Sa(e, t) {
  const n = e.value, r = {
    type: q.COMMENT,
    data: n,
    location: Vt(e)
  };
  At(t, je(e)), t.parser.currentToken = r, t.parser._processToken(t.parser.currentToken);
}
function Bd(e, t) {
  if (t.parser.tokenizer.preprocessor.html = "", t.parser.tokenizer.preprocessor.pos = -1, t.parser.tokenizer.preprocessor.lastGapPos = -2, t.parser.tokenizer.preprocessor.gapStack = [], t.parser.tokenizer.preprocessor.skipNextNewLine = !1, t.parser.tokenizer.preprocessor.lastChunkWritten = !1, t.parser.tokenizer.preprocessor.endOfChunkHit = !1, t.parser.tokenizer.preprocessor.isEol = !1, Na(t, je(e)), t.parser.tokenizer.write(
    t.options.tagfilter ? e.value.replace(yd, "&lt;$1$2") : e.value,
    !1
  ), t.parser.tokenizer._runParsingLoop(), t.parser.tokenizer.state === 72 || // @ts-expect-error: removed.
  t.parser.tokenizer.state === 78) {
    t.parser.tokenizer.preprocessor.lastChunkWritten = !0;
    const n = t.parser.tokenizer._consume();
    t.parser.tokenizer._callState(n);
  }
}
function Fd(e, t) {
  const n = (
    /** @type {Nodes} */
    e
  );
  if (t.options.passThrough && t.options.passThrough.includes(n.type))
    Md(n, t);
  else {
    let r = "";
    throw Ld.has(n.type) && (r = ". It looks like you are using MDX nodes with `hast-util-raw` (or `rehype-raw`). If you use this because you are using remark or rehype plugins that inject `'html'` nodes, then please raise an issue with that plugin, as its a bad and slow idea. If you use this because you are using markdown syntax, then you have to configure this utility (or plugin) to pass through these nodes (see `passThrough` in docs), but you can also migrate to use the MDX syntax"), new Error("Cannot compile `" + n.type + "` node" + r);
  }
}
function At(e, t) {
  Na(e, t);
  const n = e.parser.tokenizer.currentCharacterToken;
  n && n.location && (n.location.endLine = e.parser.tokenizer.preprocessor.line, n.location.endCol = e.parser.tokenizer.preprocessor.col + 1, n.location.endOffset = e.parser.tokenizer.preprocessor.offset + 1, e.parser.currentToken = n, e.parser._processToken(e.parser.currentToken)), e.parser.tokenizer.paused = !1, e.parser.tokenizer.inLoop = !1, e.parser.tokenizer.active = !1, e.parser.tokenizer.returnState = re.DATA, e.parser.tokenizer.charRefCode = -1, e.parser.tokenizer.consumedAfterSnapshot = -1, e.parser.tokenizer.currentLocation = null, e.parser.tokenizer.currentCharacterToken = null, e.parser.tokenizer.currentToken = null, e.parser.tokenizer.currentAttr = { name: "", value: "" };
}
function Na(e, t) {
  if (t && t.offset !== void 0) {
    const n = {
      startLine: t.line,
      startCol: t.column,
      startOffset: t.offset,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    };
    e.parser.tokenizer.preprocessor.lineStartPos = -t.column + 1, e.parser.tokenizer.preprocessor.droppedBufferSize = t.offset, e.parser.tokenizer.preprocessor.line = t.line, e.parser.tokenizer.currentLocation = n;
  }
}
function Hd(e, t) {
  const n = e.tagName.toLowerCase();
  if (t.parser.tokenizer.state === re.PLAINTEXT) return;
  At(t, je(e));
  const r = t.parser.openElements.current;
  let u = "namespaceURI" in r ? r.namespaceURI : Je.html;
  u === Je.html && n === "svg" && (u = Je.svg);
  const a = W0(
    // Shallow clone to not delve into `children`: we only need the attributes.
    { ...e, children: [] },
    { space: u === Je.svg ? "svg" : "html" }
  ), i = {
    type: q.START_TAG,
    tagName: n,
    tagID: bt(n),
    // We always send start and end tags.
    selfClosing: !1,
    ackSelfClosing: !1,
    // Always element.
    /* c8 ignore next */
    attrs: "attrs" in a ? a.attrs : [],
    location: Vt(e)
  };
  t.parser.currentToken = i, t.parser._processToken(t.parser.currentToken), t.parser.tokenizer.lastStartTagName = n;
}
function Ud(e, t) {
  const n = e.tagName.toLowerCase();
  if (!t.parser.tokenizer.inForeignNode && Ds.includes(n) || t.parser.tokenizer.state === re.PLAINTEXT) return;
  At(t, hr(e));
  const r = {
    type: q.END_TAG,
    tagName: n,
    tagID: bt(n),
    selfClosing: !1,
    ackSelfClosing: !1,
    attrs: [],
    location: Vt(e)
  };
  t.parser.currentToken = r, t.parser._processToken(t.parser.currentToken), // Current element is closed.
  n === t.parser.tokenizer.lastStartTagName && // `<textarea>` and `<title>`
  (t.parser.tokenizer.state === re.RCDATA || // `<iframe>`, `<noembed>`, `<noframes>`, `<style>`, `<xmp>`
  t.parser.tokenizer.state === re.RAWTEXT || // `<script>`
  t.parser.tokenizer.state === re.SCRIPT_DATA) && (t.parser.tokenizer.state = re.DATA);
}
function vd(e) {
  const t = e.type === "root" ? e.children[0] : e;
  return !!(t && (t.type === "doctype" || t.type === "element" && t.tagName.toLowerCase() === "html"));
}
function Vt(e) {
  const t = je(e) || {
    line: void 0,
    column: void 0,
    offset: void 0
  }, n = hr(e) || {
    line: void 0,
    column: void 0,
    offset: void 0
  };
  return {
    startLine: t.line,
    startCol: t.column,
    startOffset: t.offset,
    endLine: n.line,
    endCol: n.column,
    endOffset: n.offset
  };
}
function zd(e) {
  return "children" in e ? Iu({ ...e, children: [] }) : Iu(e);
}
function Yd(e) {
  return function(t, n) {
    return (
      /** @type {Root} */
      Ia(t, { ...e, file: n })
    );
  };
}
function qd(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function jd(e, t, n) {
  const u = fi((n || {}).ignore || []), a = Vd(t);
  let i = -1;
  for (; ++i < a.length; )
    Ps(e, "text", o);
  function o(c, h) {
    let f = -1, p;
    for (; ++f < h.length; ) {
      const d = h[f], A = p ? p.children : void 0;
      if (u(
        d,
        A ? A.indexOf(d) : void 0,
        p
      ))
        return;
      p = d;
    }
    if (p)
      return l(c, h);
  }
  function l(c, h) {
    const f = h[h.length - 1], p = a[i][0], d = a[i][1];
    let A = 0;
    const L = f.children.indexOf(c);
    let x = !1, w = [];
    p.lastIndex = 0;
    let D = p.exec(c.value);
    for (; D; ) {
      const z = D.index, Y = {
        index: D.index,
        input: D.input,
        stack: [...h, c]
      };
      let k = d(...D, Y);
      if (typeof k == "string" && (k = k.length > 0 ? { type: "text", value: k } : void 0), k === !1 ? p.lastIndex = z + 1 : (A !== z && w.push({
        type: "text",
        value: c.value.slice(A, z)
      }), Array.isArray(k) ? w.push(...k) : k && w.push(k), A = z + D[0].length, x = !0), !p.global)
        break;
      D = p.exec(c.value);
    }
    return x ? (A < c.value.length && w.push({ type: "text", value: c.value.slice(A) }), f.children.splice(L, 1, ...w)) : w = [c], L + w.length;
  }
}
function Vd(e) {
  const t = [];
  if (!Array.isArray(e))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const n = !e[0] || Array.isArray(e[0]) ? e : [e];
  let r = -1;
  for (; ++r < n.length; ) {
    const u = n[r];
    t.push([Wd(u[0]), Qd(u[1])]);
  }
  return t;
}
function Wd(e) {
  return typeof e == "string" ? new RegExp(qd(e), "g") : e;
}
function Qd(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
const Vn = "phrasing", Wn = ["autolink", "link", "image", "label"];
function Gd() {
  return {
    transforms: [tm],
    enter: {
      literalAutolink: Kd,
      literalAutolinkEmail: Qn,
      literalAutolinkHttp: Qn,
      literalAutolinkWww: Qn
    },
    exit: {
      literalAutolink: em,
      literalAutolinkEmail: Zd,
      literalAutolinkHttp: $d,
      literalAutolinkWww: Jd
    }
  };
}
function Xd() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: Vn,
        notInConstruct: Wn
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: Vn,
        notInConstruct: Wn
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: Vn,
        notInConstruct: Wn
      }
    ]
  };
}
function Kd(e) {
  this.enter({ type: "link", title: null, url: "", children: [] }, e);
}
function Qn(e) {
  this.config.enter.autolinkProtocol.call(this, e);
}
function $d(e) {
  this.config.exit.autolinkProtocol.call(this, e);
}
function Jd(e) {
  this.config.exit.data.call(this, e);
  const t = this.stack[this.stack.length - 1];
  Me(t.type === "link"), t.url = "http://" + this.sliceSerialize(e);
}
function Zd(e) {
  this.config.exit.autolinkEmail.call(this, e);
}
function em(e) {
  this.exit(e);
}
function tm(e) {
  jd(
    e,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, nm],
      [/(?<=^|\s|\p{P}|\p{S})([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/gu, rm]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function nm(e, t, n, r, u) {
  let a = "";
  if (!ka(u) || (/^w/i.test(t) && (n = t + n, t = "", a = "http://"), !um(n)))
    return !1;
  const i = im(n + r);
  if (!i[0]) return !1;
  const o = {
    type: "link",
    title: null,
    url: a + t + i[0],
    children: [{ type: "text", value: t + i[0] }]
  };
  return i[1] ? [o, { type: "text", value: i[1] }] : o;
}
function rm(e, t, n, r) {
  return (
    // Not an expected previous character.
    !ka(r, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(n) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + t + "@" + n,
      children: [{ type: "text", value: t + "@" + n }]
    }
  );
}
function um(e) {
  const t = e.split(".");
  return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
}
function im(e) {
  const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
  if (!t)
    return [e, void 0];
  e = e.slice(0, t.index);
  let n = t[0], r = n.indexOf(")");
  const u = Wr(e, "(");
  let a = Wr(e, ")");
  for (; r !== -1 && u > a; )
    e += n.slice(0, r + 1), n = n.slice(r + 1), r = n.indexOf(")"), a++;
  return [e, n];
}
function ka(e, t) {
  const n = e.input.charCodeAt(e.index - 1);
  return (e.index === 0 || tt(n) || bn(n)) && // If it’s an email, the previous character should not be a slash.
  (!t || n !== 47);
}
function Wt(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
Oa.peek = mm;
function am() {
  this.buffer();
}
function sm(e) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, e);
}
function om() {
  this.buffer();
}
function lm(e) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    e
  );
}
function cm(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  Me(n.type === "footnoteReference"), n.identifier = Wt(
    this.sliceSerialize(e)
  ).toLowerCase(), n.label = t;
}
function fm(e) {
  this.exit(e);
}
function hm(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  Me(n.type === "footnoteDefinition"), n.identifier = Wt(
    this.sliceSerialize(e)
  ).toLowerCase(), n.label = t;
}
function dm(e) {
  this.exit(e);
}
function mm() {
  return "[";
}
function Oa(e, t, n, r) {
  const u = n.createTracker(r);
  let a = u.move("[^");
  const i = n.enter("footnoteReference"), o = n.enter("reference");
  return a += u.move(
    n.safe(n.associationId(e), { after: "]", before: a })
  ), o(), i(), a += u.move("]"), a;
}
function pm() {
  return {
    enter: {
      gfmFootnoteCallString: am,
      gfmFootnoteCall: sm,
      gfmFootnoteDefinitionLabelString: om,
      gfmFootnoteDefinition: lm
    },
    exit: {
      gfmFootnoteCallString: cm,
      gfmFootnoteCall: fm,
      gfmFootnoteDefinitionLabelString: hm,
      gfmFootnoteDefinition: dm
    }
  };
}
function Em(e) {
  let t = !1;
  return e && e.firstLineBlank && (t = !0), {
    handlers: { footnoteDefinition: n, footnoteReference: Oa },
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
  };
  function n(r, u, a, i) {
    const o = a.createTracker(i);
    let l = o.move("[^");
    const c = a.enter("footnoteDefinition"), h = a.enter("label");
    return l += o.move(
      a.safe(a.associationId(r), { before: l, after: "]" })
    ), h(), l += o.move("]:"), r.children && r.children.length > 0 && (o.shift(4), l += o.move(
      (t ? `
` : " ") + a.indentLines(
        a.containerFlow(r, o.current()),
        t ? ya : Tm
      )
    )), c(), l;
  }
}
function Tm(e, t, n) {
  return t === 0 ? e : ya(e, t, n);
}
function ya(e, t, n) {
  return (n ? "" : "    ") + e;
}
const gm = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
La.peek = Im;
function bm() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: _m },
    exit: { strikethrough: Cm }
  };
}
function Am() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: gm
      }
    ],
    handlers: { delete: La }
  };
}
function _m(e) {
  this.enter({ type: "delete", children: [] }, e);
}
function Cm(e) {
  this.exit(e);
}
function La(e, t, n, r) {
  const u = n.createTracker(r), a = n.enter("strikethrough");
  let i = u.move("~~");
  return i += n.containerPhrasing(e, {
    ...u.current(),
    before: i,
    after: "~"
  }), i += u.move("~~"), a(), i;
}
function Im() {
  return "~";
}
function xm(e) {
  return e.length;
}
function Sm(e, t) {
  const n = t || {}, r = (n.align || []).concat(), u = n.stringLength || xm, a = [], i = [], o = [], l = [];
  let c = 0, h = -1;
  for (; ++h < e.length; ) {
    const C = [], L = [];
    let x = -1;
    for (e[h].length > c && (c = e[h].length); ++x < e[h].length; ) {
      const w = Nm(e[h][x]);
      if (n.alignDelimiters !== !1) {
        const D = u(w);
        L[x] = D, (l[x] === void 0 || D > l[x]) && (l[x] = D);
      }
      C.push(w);
    }
    i[h] = C, o[h] = L;
  }
  let f = -1;
  if (typeof r == "object" && "length" in r)
    for (; ++f < c; )
      a[f] = qu(r[f]);
  else {
    const C = qu(r);
    for (; ++f < c; )
      a[f] = C;
  }
  f = -1;
  const p = [], d = [];
  for (; ++f < c; ) {
    const C = a[f];
    let L = "", x = "";
    C === 99 ? (L = ":", x = ":") : C === 108 ? L = ":" : C === 114 && (x = ":");
    let w = n.alignDelimiters === !1 ? 1 : Math.max(
      1,
      l[f] - L.length - x.length
    );
    const D = L + "-".repeat(w) + x;
    n.alignDelimiters !== !1 && (w = L.length + w + x.length, w > l[f] && (l[f] = w), d[f] = w), p[f] = D;
  }
  i.splice(1, 0, p), o.splice(1, 0, d), h = -1;
  const A = [];
  for (; ++h < i.length; ) {
    const C = i[h], L = o[h];
    f = -1;
    const x = [];
    for (; ++f < c; ) {
      const w = C[f] || "";
      let D = "", z = "";
      if (n.alignDelimiters !== !1) {
        const Y = l[f] - (L[f] || 0), k = a[f];
        k === 114 ? D = " ".repeat(Y) : k === 99 ? Y % 2 ? (D = " ".repeat(Y / 2 + 0.5), z = " ".repeat(Y / 2 - 0.5)) : (D = " ".repeat(Y / 2), z = D) : z = " ".repeat(Y);
      }
      n.delimiterStart !== !1 && !f && x.push("|"), n.padding !== !1 && // Don’t add the opening space if we’re not aligning and the cell is
      // empty: there will be a closing space.
      !(n.alignDelimiters === !1 && w === "") && (n.delimiterStart !== !1 || f) && x.push(" "), n.alignDelimiters !== !1 && x.push(D), x.push(w), n.alignDelimiters !== !1 && x.push(z), n.padding !== !1 && x.push(" "), (n.delimiterEnd !== !1 || f !== c - 1) && x.push("|");
    }
    A.push(
      n.delimiterEnd === !1 ? x.join("").replace(/ +$/, "") : x.join("")
    );
  }
  return A.join(`
`);
}
function Nm(e) {
  return e == null ? "" : String(e);
}
function qu(e) {
  const t = typeof e == "string" ? e.codePointAt(0) : 0;
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
}
function km(e, t, n, r) {
  const u = n.enter("blockquote"), a = n.createTracker(r);
  a.move("> "), a.shift(2);
  const i = n.indentLines(
    n.containerFlow(e, a.current()),
    Om
  );
  return u(), i;
}
function Om(e, t, n) {
  return ">" + (n ? "" : " ") + e;
}
function ym(e, t) {
  return ju(e, t.inConstruct, !0) && !ju(e, t.notInConstruct, !1);
}
function ju(e, t, n) {
  if (typeof t == "string" && (t = [t]), !t || t.length === 0)
    return n;
  let r = -1;
  for (; ++r < t.length; )
    if (e.includes(t[r]))
      return !0;
  return !1;
}
function Vu(e, t, n, r) {
  let u = -1;
  for (; ++u < n.unsafe.length; )
    if (n.unsafe[u].character === `
` && ym(n.stack, n.unsafe[u]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function Lm(e, t) {
  const n = String(e);
  let r = n.indexOf(t), u = r, a = 0, i = 0;
  if (typeof t != "string")
    throw new TypeError("Expected substring");
  for (; r !== -1; )
    r === u ? ++a > i && (i = a) : a = 1, u = r + t.length, r = n.indexOf(t, u);
  return i;
}
function Rm(e, t) {
  return !!(t.options.fences === !1 && e.value && // If there’s no info…
  !e.lang && // And there’s a non-whitespace character…
  /[^ \r\n]/.test(e.value) && // And the value doesn’t start or end in a blank…
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
}
function Dm(e) {
  const t = e.options.fence || "`";
  if (t !== "`" && t !== "~")
    throw new Error(
      "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return t;
}
function Pm(e, t, n, r) {
  const u = Dm(n), a = e.value || "", i = u === "`" ? "GraveAccent" : "Tilde";
  if (Rm(e, n)) {
    const f = n.enter("codeIndented"), p = n.indentLines(a, wm);
    return f(), p;
  }
  const o = n.createTracker(r), l = u.repeat(Math.max(Lm(a, u) + 1, 3)), c = n.enter("codeFenced");
  let h = o.move(l);
  if (e.lang) {
    const f = n.enter(`codeFencedLang${i}`);
    h += o.move(
      n.safe(e.lang, {
        before: h,
        after: " ",
        encode: ["`"],
        ...o.current()
      })
    ), f();
  }
  if (e.lang && e.meta) {
    const f = n.enter(`codeFencedMeta${i}`);
    h += o.move(" "), h += o.move(
      n.safe(e.meta, {
        before: h,
        after: `
`,
        encode: ["`"],
        ...o.current()
      })
    ), f();
  }
  return h += o.move(`
`), a && (h += o.move(a + `
`)), h += o.move(l), c(), h;
}
function wm(e, t, n) {
  return (n ? "" : "    ") + e;
}
function Mr(e) {
  const t = e.options.quote || '"';
  if (t !== '"' && t !== "'")
    throw new Error(
      "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
    );
  return t;
}
function Mm(e, t, n, r) {
  const u = Mr(n), a = u === '"' ? "Quote" : "Apostrophe", i = n.enter("definition");
  let o = n.enter("label");
  const l = n.createTracker(r);
  let c = l.move("[");
  return c += l.move(
    n.safe(n.associationId(e), {
      before: c,
      after: "]",
      ...l.current()
    })
  ), c += l.move("]: "), o(), // If there’s no url, or…
  !e.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (o = n.enter("destinationLiteral"), c += l.move("<"), c += l.move(
    n.safe(e.url, { before: c, after: ">", ...l.current() })
  ), c += l.move(">")) : (o = n.enter("destinationRaw"), c += l.move(
    n.safe(e.url, {
      before: c,
      after: e.title ? " " : `
`,
      ...l.current()
    })
  )), o(), e.title && (o = n.enter(`title${a}`), c += l.move(" " + u), c += l.move(
    n.safe(e.title, {
      before: c,
      after: u,
      ...l.current()
    })
  ), c += l.move(u), o()), i(), c;
}
function Bm(e) {
  const t = e.options.emphasis || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return t;
}
function vt(e) {
  return "&#x" + e.toString(16).toUpperCase() + ";";
}
function En(e, t, n) {
  const r = dt(e), u = dt(t);
  return r === void 0 ? u === void 0 ? (
    // Letter inside:
    // we have to encode *both* letters for `_` as it is looser.
    // it already forms for `*` (and GFMs `~`).
    n === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
  ) : u === 1 ? (
    // Whitespace inside: encode both (letter, whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: encode outer (letter)
    { inside: !1, outside: !0 }
  ) : r === 1 ? u === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : u === 1 ? (
    // Whitespace inside: encode both (whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  ) : u === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : u === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: !0, outside: !1 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  );
}
Ra.peek = Fm;
function Ra(e, t, n, r) {
  const u = Bm(n), a = n.enter("emphasis"), i = n.createTracker(r), o = i.move(u);
  let l = i.move(
    n.containerPhrasing(e, {
      after: u,
      before: o,
      ...i.current()
    })
  );
  const c = l.charCodeAt(0), h = En(
    r.before.charCodeAt(r.before.length - 1),
    c,
    u
  );
  h.inside && (l = vt(c) + l.slice(1));
  const f = l.charCodeAt(l.length - 1), p = En(r.after.charCodeAt(0), f, u);
  p.inside && (l = l.slice(0, -1) + vt(f));
  const d = i.move(u);
  return a(), n.attentionEncodeSurroundingInfo = {
    after: p.outside,
    before: h.outside
  }, o + l + d;
}
function Fm(e, t, n) {
  return n.options.emphasis || "*";
}
function Hm(e, t) {
  let n = !1;
  return Tn(e, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return n = !0, ws;
  }), !!((!e.depth || e.depth < 3) && mr(e) && (t.options.setext || n));
}
function Um(e, t, n, r) {
  const u = Math.max(Math.min(6, e.depth || 1), 1), a = n.createTracker(r);
  if (Hm(e, n)) {
    const h = n.enter("headingSetext"), f = n.enter("phrasing"), p = n.containerPhrasing(e, {
      ...a.current(),
      before: `
`,
      after: `
`
    });
    return f(), h(), p + `
` + (u === 1 ? "=" : "-").repeat(
      // The whole size…
      p.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)…
      (Math.max(p.lastIndexOf("\r"), p.lastIndexOf(`
`)) + 1)
    );
  }
  const i = "#".repeat(u), o = n.enter("headingAtx"), l = n.enter("phrasing");
  a.move(i + " ");
  let c = n.containerPhrasing(e, {
    before: "# ",
    after: `
`,
    ...a.current()
  });
  return /^[\t ]/.test(c) && (c = vt(c.charCodeAt(0)) + c.slice(1)), c = c ? i + " " + c : i, n.options.closeAtx && (c += " " + i), l(), o(), c;
}
Da.peek = vm;
function Da(e) {
  return e.value || "";
}
function vm() {
  return "<";
}
Pa.peek = zm;
function Pa(e, t, n, r) {
  const u = Mr(n), a = u === '"' ? "Quote" : "Apostrophe", i = n.enter("image");
  let o = n.enter("label");
  const l = n.createTracker(r);
  let c = l.move("![");
  return c += l.move(
    n.safe(e.alt, { before: c, after: "]", ...l.current() })
  ), c += l.move("]("), o(), // If there’s no url but there is a title…
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (o = n.enter("destinationLiteral"), c += l.move("<"), c += l.move(
    n.safe(e.url, { before: c, after: ">", ...l.current() })
  ), c += l.move(">")) : (o = n.enter("destinationRaw"), c += l.move(
    n.safe(e.url, {
      before: c,
      after: e.title ? " " : ")",
      ...l.current()
    })
  )), o(), e.title && (o = n.enter(`title${a}`), c += l.move(" " + u), c += l.move(
    n.safe(e.title, {
      before: c,
      after: u,
      ...l.current()
    })
  ), c += l.move(u), o()), c += l.move(")"), i(), c;
}
function zm() {
  return "!";
}
wa.peek = Ym;
function wa(e, t, n, r) {
  const u = e.referenceType, a = n.enter("imageReference");
  let i = n.enter("label");
  const o = n.createTracker(r);
  let l = o.move("![");
  const c = n.safe(e.alt, {
    before: l,
    after: "]",
    ...o.current()
  });
  l += o.move(c + "]["), i();
  const h = n.stack;
  n.stack = [], i = n.enter("reference");
  const f = n.safe(n.associationId(e), {
    before: l,
    after: "]",
    ...o.current()
  });
  return i(), n.stack = h, a(), u === "full" || !c || c !== f ? l += o.move(f + "]") : u === "shortcut" ? l = l.slice(0, -1) : l += o.move("]"), l;
}
function Ym() {
  return "!";
}
Ma.peek = qm;
function Ma(e, t, n) {
  let r = e.value || "", u = "`", a = -1;
  for (; new RegExp("(^|[^`])" + u + "([^`]|$)").test(r); )
    u += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++a < n.unsafe.length; ) {
    const i = n.unsafe[a], o = n.compilePattern(i);
    let l;
    if (i.atBreak)
      for (; l = o.exec(r); ) {
        let c = l.index;
        r.charCodeAt(c) === 10 && r.charCodeAt(c - 1) === 13 && c--, r = r.slice(0, c) + " " + r.slice(l.index + 1);
      }
  }
  return u + r + u;
}
function qm() {
  return "`";
}
function Ba(e, t) {
  const n = mr(e);
  return !!(!t.options.resourceLink && // If there’s a url…
  e.url && // And there’s a no title…
  !e.title && // And the content of `node` is a single text node…
  e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the content…
  (n === e.url || "mailto:" + n === e.url) && // And that starts w/ a protocol…
  /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesn’t contain ASCII control codes (character escapes and
  // references don’t work), space, or angle brackets…
  !/[\0- <>\u007F]/.test(e.url));
}
Fa.peek = jm;
function Fa(e, t, n, r) {
  const u = Mr(n), a = u === '"' ? "Quote" : "Apostrophe", i = n.createTracker(r);
  let o, l;
  if (Ba(e, n)) {
    const h = n.stack;
    n.stack = [], o = n.enter("autolink");
    let f = i.move("<");
    return f += i.move(
      n.containerPhrasing(e, {
        before: f,
        after: ">",
        ...i.current()
      })
    ), f += i.move(">"), o(), n.stack = h, f;
  }
  o = n.enter("link"), l = n.enter("label");
  let c = i.move("[");
  return c += i.move(
    n.containerPhrasing(e, {
      before: c,
      after: "](",
      ...i.current()
    })
  ), c += i.move("]("), l(), // If there’s no url but there is a title…
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (l = n.enter("destinationLiteral"), c += i.move("<"), c += i.move(
    n.safe(e.url, { before: c, after: ">", ...i.current() })
  ), c += i.move(">")) : (l = n.enter("destinationRaw"), c += i.move(
    n.safe(e.url, {
      before: c,
      after: e.title ? " " : ")",
      ...i.current()
    })
  )), l(), e.title && (l = n.enter(`title${a}`), c += i.move(" " + u), c += i.move(
    n.safe(e.title, {
      before: c,
      after: u,
      ...i.current()
    })
  ), c += i.move(u), l()), c += i.move(")"), o(), c;
}
function jm(e, t, n) {
  return Ba(e, n) ? "<" : "[";
}
Ha.peek = Vm;
function Ha(e, t, n, r) {
  const u = e.referenceType, a = n.enter("linkReference");
  let i = n.enter("label");
  const o = n.createTracker(r);
  let l = o.move("[");
  const c = n.containerPhrasing(e, {
    before: l,
    after: "]",
    ...o.current()
  });
  l += o.move(c + "]["), i();
  const h = n.stack;
  n.stack = [], i = n.enter("reference");
  const f = n.safe(n.associationId(e), {
    before: l,
    after: "]",
    ...o.current()
  });
  return i(), n.stack = h, a(), u === "full" || !c || c !== f ? l += o.move(f + "]") : u === "shortcut" ? l = l.slice(0, -1) : l += o.move("]"), l;
}
function Vm() {
  return "[";
}
function Br(e) {
  const t = e.options.bullet || "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return t;
}
function Wm(e) {
  const t = Br(e), n = e.options.bulletOther;
  if (!n)
    return t === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (n === t)
    throw new Error(
      "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different"
    );
  return n;
}
function Qm(e) {
  const t = e.options.bulletOrdered || ".";
  if (t !== "." && t !== ")")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return t;
}
function Ua(e) {
  const t = e.options.rule || "*";
  if (t !== "*" && t !== "-" && t !== "_")
    throw new Error(
      "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return t;
}
function Gm(e, t, n, r) {
  const u = n.enter("list"), a = n.bulletCurrent;
  let i = e.ordered ? Qm(n) : Br(n);
  const o = e.ordered ? i === "." ? ")" : "." : Wm(n);
  let l = t && n.bulletLastUsed ? i === n.bulletLastUsed : !1;
  if (!e.ordered) {
    const h = e.children ? e.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (i === "*" || i === "-") && // Empty first list item:
      h && (!h.children || !h.children[0]) && // Directly in two other list items:
      n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
      n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (l = !0), Ua(n) === i && h
    ) {
      let f = -1;
      for (; ++f < e.children.length; ) {
        const p = e.children[f];
        if (p && p.type === "listItem" && p.children && p.children[0] && p.children[0].type === "thematicBreak") {
          l = !0;
          break;
        }
      }
    }
  }
  l && (i = o), n.bulletCurrent = i;
  const c = n.containerFlow(e, r);
  return n.bulletLastUsed = i, n.bulletCurrent = a, u(), c;
}
function Xm(e) {
  const t = e.options.listItemIndent || "one";
  if (t !== "tab" && t !== "one" && t !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return t;
}
function Km(e, t, n, r) {
  const u = Xm(n);
  let a = n.bulletCurrent || Br(n);
  t && t.type === "list" && t.ordered && (a = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (n.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + a);
  let i = a.length + 1;
  (u === "tab" || u === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (i = Math.ceil(i / 4) * 4);
  const o = n.createTracker(r);
  o.move(a + " ".repeat(i - a.length)), o.shift(i);
  const l = n.enter("listItem"), c = n.indentLines(
    n.containerFlow(e, o.current()),
    h
  );
  return l(), c;
  function h(f, p, d) {
    return p ? (d ? "" : " ".repeat(i)) + f : (d ? a : a + " ".repeat(i - a.length)) + f;
  }
}
function $m(e, t, n, r) {
  const u = n.enter("paragraph"), a = n.enter("phrasing"), i = n.containerPhrasing(e, r);
  return a(), u(), i;
}
const Jm = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  fi([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function Zm(e, t, n, r) {
  return (e.children.some(function(i) {
    return Jm(i);
  }) ? n.containerPhrasing : n.containerFlow).call(n, e, r);
}
function e1(e) {
  const t = e.options.strong || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
    );
  return t;
}
va.peek = t1;
function va(e, t, n, r) {
  const u = e1(n), a = n.enter("strong"), i = n.createTracker(r), o = i.move(u + u);
  let l = i.move(
    n.containerPhrasing(e, {
      after: u,
      before: o,
      ...i.current()
    })
  );
  const c = l.charCodeAt(0), h = En(
    r.before.charCodeAt(r.before.length - 1),
    c,
    u
  );
  h.inside && (l = vt(c) + l.slice(1));
  const f = l.charCodeAt(l.length - 1), p = En(r.after.charCodeAt(0), f, u);
  p.inside && (l = l.slice(0, -1) + vt(f));
  const d = i.move(u + u);
  return a(), n.attentionEncodeSurroundingInfo = {
    after: p.outside,
    before: h.outside
  }, o + l + d;
}
function t1(e, t, n) {
  return n.options.strong || "*";
}
function n1(e, t, n, r) {
  return n.safe(e.value, r);
}
function r1(e) {
  const t = e.options.ruleRepetition || 3;
  if (t < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return t;
}
function u1(e, t, n) {
  const r = (Ua(n) + (n.options.ruleSpaces ? " " : "")).repeat(r1(n));
  return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const za = {
  blockquote: km,
  break: Vu,
  code: Pm,
  definition: Mm,
  emphasis: Ra,
  hardBreak: Vu,
  heading: Um,
  html: Da,
  image: Pa,
  imageReference: wa,
  inlineCode: Ma,
  link: Fa,
  linkReference: Ha,
  list: Gm,
  listItem: Km,
  paragraph: $m,
  root: Zm,
  strong: va,
  text: n1,
  thematicBreak: u1
};
function i1() {
  return {
    enter: {
      table: a1,
      tableData: Wu,
      tableHeader: Wu,
      tableRow: o1
    },
    exit: {
      codeText: l1,
      table: s1,
      tableData: Gn,
      tableHeader: Gn,
      tableRow: Gn
    }
  };
}
function a1(e) {
  const t = e._align;
  this.enter(
    {
      type: "table",
      align: t.map(function(n) {
        return n === "none" ? null : n;
      }),
      children: []
    },
    e
  ), this.data.inTable = !0;
}
function s1(e) {
  this.exit(e), this.data.inTable = void 0;
}
function o1(e) {
  this.enter({ type: "tableRow", children: [] }, e);
}
function Gn(e) {
  this.exit(e);
}
function Wu(e) {
  this.enter({ type: "tableCell", children: [] }, e);
}
function l1(e) {
  let t = this.resume();
  this.data.inTable && (t = t.replace(/\\([\\|])/g, c1));
  const n = this.stack[this.stack.length - 1];
  Me(n.type === "inlineCode"), n.value = t, this.exit(e);
}
function c1(e, t) {
  return t === "|" ? t : e;
}
function f1(e) {
  const t = e || {}, n = t.tableCellPadding, r = t.tablePipeAlign, u = t.stringLength, a = n ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: p,
      table: i,
      tableCell: l,
      tableRow: o
    }
  };
  function i(d, A, C, L) {
    return c(h(d, C, L), d.align);
  }
  function o(d, A, C, L) {
    const x = f(d, C, L), w = c([x]);
    return w.slice(0, w.indexOf(`
`));
  }
  function l(d, A, C, L) {
    const x = C.enter("tableCell"), w = C.enter("phrasing"), D = C.containerPhrasing(d, {
      ...L,
      before: a,
      after: a
    });
    return w(), x(), D;
  }
  function c(d, A) {
    return Sm(d, {
      align: A,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: n,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: u
    });
  }
  function h(d, A, C) {
    const L = d.children;
    let x = -1;
    const w = [], D = A.enter("table");
    for (; ++x < L.length; )
      w[x] = f(L[x], A, C);
    return D(), w;
  }
  function f(d, A, C) {
    const L = d.children;
    let x = -1;
    const w = [], D = A.enter("tableRow");
    for (; ++x < L.length; )
      w[x] = l(L[x], d, A, C);
    return D(), w;
  }
  function p(d, A, C) {
    let L = za.inlineCode(d, A, C);
    return C.stack.includes("tableCell") && (L = L.replace(/\|/g, "\\$&")), L;
  }
}
function h1() {
  return {
    exit: {
      taskListCheckValueChecked: Qu,
      taskListCheckValueUnchecked: Qu,
      paragraph: m1
    }
  };
}
function d1() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: p1 }
  };
}
function Qu(e) {
  const t = this.stack[this.stack.length - 2];
  Me(t.type === "listItem"), t.checked = e.type === "taskListCheckValueChecked";
}
function m1(e) {
  const t = this.stack[this.stack.length - 2];
  if (t && t.type === "listItem" && typeof t.checked == "boolean") {
    const n = this.stack[this.stack.length - 1];
    Me(n.type === "paragraph");
    const r = n.children[0];
    if (r && r.type === "text") {
      const u = t.children;
      let a = -1, i;
      for (; ++a < u.length; ) {
        const o = u[a];
        if (o.type === "paragraph") {
          i = o;
          break;
        }
      }
      i === n && (r.value = r.value.slice(1), r.value.length === 0 ? n.children.shift() : n.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, n.position.start = Object.assign({}, r.position.start)));
    }
  }
  this.exit(e);
}
function p1(e, t, n, r) {
  const u = e.children[0], a = typeof e.checked == "boolean" && u && u.type === "paragraph", i = "[" + (e.checked ? "x" : " ") + "] ", o = n.createTracker(r);
  a && o.move(i);
  let l = za.listItem(e, t, n, {
    ...r,
    ...o.current()
  });
  return a && (l = l.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, c)), l;
  function c(h) {
    return h + i;
  }
}
function E1() {
  return [
    Gd(),
    pm(),
    bm(),
    i1(),
    h1()
  ];
}
function T1(e) {
  return {
    extensions: [
      Xd(),
      Em(e),
      Am(),
      f1(e),
      d1()
    ]
  };
}
function an(e, t, n, r) {
  const u = e.length;
  let a = 0, i;
  if (t < 0 ? t = -t > u ? 0 : u + t : t = t > u ? u : t, n = n > 0 ? n : 0, r.length < 1e4)
    i = Array.from(r), i.unshift(t, n), e.splice(...i);
  else
    for (n && e.splice(t, n); a < r.length; )
      i = r.slice(a, a + 1e4), i.unshift(t, 0), e.splice(...i), a += 1e4, t += 1e4;
}
const Gu = {}.hasOwnProperty;
function g1(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; )
    b1(t, e[n]);
  return t;
}
function b1(e, t) {
  let n;
  for (n in t) {
    const u = (Gu.call(e, n) ? e[n] : void 0) || (e[n] = {}), a = t[n];
    let i;
    if (a)
      for (i in a) {
        Gu.call(u, i) || (u[i] = []);
        const o = a[i];
        A1(
          // @ts-expect-error Looks like a list.
          u[i],
          Array.isArray(o) ? o : o ? [o] : []
        );
      }
  }
}
function A1(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; )
    (t[n].add === "after" ? e : r).push(t[n]);
  an(e, 0, 0, r);
}
const _1 = {
  tokenize: k1,
  partial: !0
}, Ya = {
  tokenize: O1,
  partial: !0
}, qa = {
  tokenize: y1,
  partial: !0
}, ja = {
  tokenize: L1,
  partial: !0
}, C1 = {
  tokenize: R1,
  partial: !0
}, Va = {
  name: "wwwAutolink",
  tokenize: S1,
  previous: Qa
}, Wa = {
  name: "protocolAutolink",
  tokenize: N1,
  previous: Ga
}, Be = {
  name: "emailAutolink",
  tokenize: x1,
  previous: Xa
}, ye = {};
function I1() {
  return {
    text: ye
  };
}
let Ke = 48;
for (; Ke < 123; )
  ye[Ke] = Be, Ke++, Ke === 58 ? Ke = 65 : Ke === 91 && (Ke = 97);
ye[43] = Be;
ye[45] = Be;
ye[46] = Be;
ye[95] = Be;
ye[72] = [Be, Wa];
ye[104] = [Be, Wa];
ye[87] = [Be, Va];
ye[119] = [Be, Va];
function x1(e, t, n) {
  const r = this;
  let u, a;
  return i;
  function i(f) {
    return !or(f) || !Xa.call(r, r.previous) || Fr(r.events) ? n(f) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), o(f));
  }
  function o(f) {
    return or(f) ? (e.consume(f), o) : f === 64 ? (e.consume(f), l) : n(f);
  }
  function l(f) {
    return f === 46 ? e.check(C1, h, c)(f) : f === 45 || f === 95 || fe(f) ? (a = !0, e.consume(f), l) : h(f);
  }
  function c(f) {
    return e.consume(f), u = !0, l;
  }
  function h(f) {
    return a && u && de(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(f)) : n(f);
  }
}
function S1(e, t, n) {
  const r = this;
  return u;
  function u(i) {
    return i !== 87 && i !== 119 || !Qa.call(r, r.previous) || Fr(r.events) ? n(i) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(_1, e.attempt(Ya, e.attempt(qa, a), n), n)(i));
  }
  function a(i) {
    return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(i);
  }
}
function N1(e, t, n) {
  const r = this;
  let u = "", a = !1;
  return i;
  function i(f) {
    return (f === 72 || f === 104) && Ga.call(r, r.previous) && !Fr(r.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), u += String.fromCodePoint(f), e.consume(f), o) : n(f);
  }
  function o(f) {
    if (de(f) && u.length < 5)
      return u += String.fromCodePoint(f), e.consume(f), o;
    if (f === 58) {
      const p = u.toLowerCase();
      if (p === "http" || p === "https")
        return e.consume(f), l;
    }
    return n(f);
  }
  function l(f) {
    return f === 47 ? (e.consume(f), a ? c : (a = !0, l)) : n(f);
  }
  function c(f) {
    return f === null || on(f) || J(f) || tt(f) || bn(f) ? n(f) : e.attempt(Ya, e.attempt(qa, h), n)(f);
  }
  function h(f) {
    return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(f);
  }
}
function k1(e, t, n) {
  let r = 0;
  return u;
  function u(i) {
    return (i === 87 || i === 119) && r < 3 ? (r++, e.consume(i), u) : i === 46 && r === 3 ? (e.consume(i), a) : n(i);
  }
  function a(i) {
    return i === null ? n(i) : t(i);
  }
}
function O1(e, t, n) {
  let r, u, a;
  return i;
  function i(c) {
    return c === 46 || c === 95 ? e.check(ja, l, o)(c) : c === null || J(c) || tt(c) || c !== 45 && bn(c) ? l(c) : (a = !0, e.consume(c), i);
  }
  function o(c) {
    return c === 95 ? r = !0 : (u = r, r = void 0), e.consume(c), i;
  }
  function l(c) {
    return u || r || !a ? n(c) : t(c);
  }
}
function y1(e, t) {
  let n = 0, r = 0;
  return u;
  function u(i) {
    return i === 40 ? (n++, e.consume(i), u) : i === 41 && r < n ? a(i) : i === 33 || i === 34 || i === 38 || i === 39 || i === 41 || i === 42 || i === 44 || i === 46 || i === 58 || i === 59 || i === 60 || i === 63 || i === 93 || i === 95 || i === 126 ? e.check(ja, t, a)(i) : i === null || J(i) || tt(i) ? t(i) : (e.consume(i), u);
  }
  function a(i) {
    return i === 41 && r++, e.consume(i), u;
  }
}
function L1(e, t, n) {
  return r;
  function r(o) {
    return o === 33 || o === 34 || o === 39 || o === 41 || o === 42 || o === 44 || o === 46 || o === 58 || o === 59 || o === 63 || o === 95 || o === 126 ? (e.consume(o), r) : o === 38 ? (e.consume(o), a) : o === 93 ? (e.consume(o), u) : (
      // `<` is an end.
      o === 60 || // So is whitespace.
      o === null || J(o) || tt(o) ? t(o) : n(o)
    );
  }
  function u(o) {
    return o === null || o === 40 || o === 91 || J(o) || tt(o) ? t(o) : r(o);
  }
  function a(o) {
    return de(o) ? i(o) : n(o);
  }
  function i(o) {
    return o === 59 ? (e.consume(o), r) : de(o) ? (e.consume(o), i) : n(o);
  }
}
function R1(e, t, n) {
  return r;
  function r(a) {
    return e.consume(a), u;
  }
  function u(a) {
    return fe(a) ? n(a) : t(a);
  }
}
function Qa(e) {
  return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || J(e);
}
function Ga(e) {
  return !de(e);
}
function Xa(e) {
  return !(e === 47 || or(e));
}
function or(e) {
  return e === 43 || e === 45 || e === 46 || e === 95 || fe(e);
}
function Fr(e) {
  let t = e.length, n = !1;
  for (; t--; ) {
    const r = e[t][1];
    if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
      n = !0;
      break;
    }
    if (r._gfmAutolinkLiteralWalkedInto) {
      n = !1;
      break;
    }
  }
  return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n;
}
function D1(e, t, n) {
  const r = [];
  let u = -1;
  for (; ++u < e.length; ) {
    const a = e[u].resolveAll;
    a && !r.includes(a) && (t = a(t, n), r.push(a));
  }
  return t;
}
const P1 = {
  partial: !0,
  tokenize: w1
};
function w1(e, t, n) {
  return r;
  function r(a) {
    return j(a) ? W(e, u, "linePrefix")(a) : u(a);
  }
  function u(a) {
    return a === null || H(a) ? t(a) : n(a);
  }
}
const M1 = {
  tokenize: q1,
  partial: !0
};
function B1() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: v1,
        continuation: {
          tokenize: z1
        },
        exit: Y1
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: U1
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: F1,
        resolveTo: H1
      }
    }
  };
}
function F1(e, t, n) {
  const r = this;
  let u = r.events.length;
  const a = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let i;
  for (; u--; ) {
    const l = r.events[u][1];
    if (l.type === "labelImage") {
      i = l;
      break;
    }
    if (l.type === "gfmFootnoteCall" || l.type === "labelLink" || l.type === "label" || l.type === "image" || l.type === "link")
      break;
  }
  return o;
  function o(l) {
    if (!i || !i._balanced)
      return n(l);
    const c = Wt(r.sliceSerialize({
      start: i.end,
      end: r.now()
    }));
    return c.codePointAt(0) !== 94 || !a.includes(c.slice(1)) ? n(l) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(l), e.exit("gfmFootnoteCallLabelMarker"), t(l));
  }
}
function H1(e, t) {
  let n = e.length;
  for (; n--; )
    if (e[n][1].type === "labelImage" && e[n][0] === "enter") {
      e[n][1];
      break;
    }
  e[n + 1][1].type = "data", e[n + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, e[n + 3][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, u = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, e[n + 3][1].end),
    end: Object.assign({}, e[n + 3][1].end)
  };
  u.end.column++, u.end.offset++, u.end._bufferIndex++;
  const a = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, u.end),
    end: Object.assign({}, e[e.length - 1][1].start)
  }, i = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, a.start),
    end: Object.assign({}, a.end)
  }, o = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    e[n + 1],
    e[n + 2],
    ["enter", r, t],
    // The `[`
    e[n + 3],
    e[n + 4],
    // The `^`.
    ["enter", u, t],
    ["exit", u, t],
    // Everything in between.
    ["enter", a, t],
    ["enter", i, t],
    ["exit", i, t],
    ["exit", a, t],
    // The ending (`]`, properly parsed and labelled).
    e[e.length - 2],
    e[e.length - 1],
    ["exit", r, t]
  ];
  return e.splice(n, e.length - n + 1, ...o), e;
}
function U1(e, t, n) {
  const r = this, u = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let a = 0, i;
  return o;
  function o(f) {
    return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(f), e.exit("gfmFootnoteCallLabelMarker"), l;
  }
  function l(f) {
    return f !== 94 ? n(f) : (e.enter("gfmFootnoteCallMarker"), e.consume(f), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", c);
  }
  function c(f) {
    if (
      // Too long.
      a > 999 || // Closing brace with nothing.
      f === 93 && !i || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      f === null || f === 91 || J(f)
    )
      return n(f);
    if (f === 93) {
      e.exit("chunkString");
      const p = e.exit("gfmFootnoteCallString");
      return u.includes(Wt(r.sliceSerialize(p))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(f), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : n(f);
    }
    return J(f) || (i = !0), a++, e.consume(f), f === 92 ? h : c;
  }
  function h(f) {
    return f === 91 || f === 92 || f === 93 ? (e.consume(f), a++, c) : c(f);
  }
}
function v1(e, t, n) {
  const r = this, u = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let a, i = 0, o;
  return l;
  function l(A) {
    return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(A), e.exit("gfmFootnoteDefinitionLabelMarker"), c;
  }
  function c(A) {
    return A === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(A), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", h) : n(A);
  }
  function h(A) {
    if (
      // Too long.
      i > 999 || // Closing brace with nothing.
      A === 93 && !o || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      A === null || A === 91 || J(A)
    )
      return n(A);
    if (A === 93) {
      e.exit("chunkString");
      const C = e.exit("gfmFootnoteDefinitionLabelString");
      return a = Wt(r.sliceSerialize(C)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(A), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), p;
    }
    return J(A) || (o = !0), i++, e.consume(A), A === 92 ? f : h;
  }
  function f(A) {
    return A === 91 || A === 92 || A === 93 ? (e.consume(A), i++, h) : h(A);
  }
  function p(A) {
    return A === 58 ? (e.enter("definitionMarker"), e.consume(A), e.exit("definitionMarker"), u.includes(a) || u.push(a), W(e, d, "gfmFootnoteDefinitionWhitespace")) : n(A);
  }
  function d(A) {
    return t(A);
  }
}
function z1(e, t, n) {
  return e.check(P1, t, e.attempt(M1, t, n));
}
function Y1(e) {
  e.exit("gfmFootnoteDefinition");
}
function q1(e, t, n) {
  const r = this;
  return W(e, u, "gfmFootnoteDefinitionIndent", 5);
  function u(a) {
    const i = r.events[r.events.length - 1];
    return i && i[1].type === "gfmFootnoteDefinitionIndent" && i[2].sliceSerialize(i[1], !0).length === 4 ? t(a) : n(a);
  }
}
function j1(e) {
  let n = (e || {}).singleTilde;
  const r = {
    name: "strikethrough",
    tokenize: a,
    resolveAll: u
  };
  return n == null && (n = !0), {
    text: {
      126: r
    },
    insideSpan: {
      null: [r]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function u(i, o) {
    let l = -1;
    for (; ++l < i.length; )
      if (i[l][0] === "enter" && i[l][1].type === "strikethroughSequenceTemporary" && i[l][1]._close) {
        let c = l;
        for (; c--; )
          if (i[c][0] === "exit" && i[c][1].type === "strikethroughSequenceTemporary" && i[c][1]._open && // If the sizes are the same:
          i[l][1].end.offset - i[l][1].start.offset === i[c][1].end.offset - i[c][1].start.offset) {
            i[l][1].type = "strikethroughSequence", i[c][1].type = "strikethroughSequence";
            const h = {
              type: "strikethrough",
              start: Object.assign({}, i[c][1].start),
              end: Object.assign({}, i[l][1].end)
            }, f = {
              type: "strikethroughText",
              start: Object.assign({}, i[c][1].end),
              end: Object.assign({}, i[l][1].start)
            }, p = [["enter", h, o], ["enter", i[c][1], o], ["exit", i[c][1], o], ["enter", f, o]], d = o.parser.constructs.insideSpan.null;
            d && an(p, p.length, 0, D1(d, i.slice(c + 1, l), o)), an(p, p.length, 0, [["exit", f, o], ["enter", i[l][1], o], ["exit", i[l][1], o], ["exit", h, o]]), an(i, c - 1, l - c + 3, p), l = c + p.length - 2;
            break;
          }
      }
    for (l = -1; ++l < i.length; )
      i[l][1].type === "strikethroughSequenceTemporary" && (i[l][1].type = "data");
    return i;
  }
  function a(i, o, l) {
    const c = this.previous, h = this.events;
    let f = 0;
    return p;
    function p(A) {
      return c === 126 && h[h.length - 1][1].type !== "characterEscape" ? l(A) : (i.enter("strikethroughSequenceTemporary"), d(A));
    }
    function d(A) {
      const C = dt(c);
      if (A === 126)
        return f > 1 ? l(A) : (i.consume(A), f++, d);
      if (f < 2 && !n) return l(A);
      const L = i.exit("strikethroughSequenceTemporary"), x = dt(A);
      return L._open = !x || x === 2 && !!C, L._close = !C || C === 2 && !!x, o(A);
    }
  }
}
class V1 {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(t, n, r) {
    W1(this, t, n, r);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(t) {
    if (this.map.sort(function(a, i) {
      return a[0] - i[0];
    }), this.map.length === 0)
      return;
    let n = this.map.length;
    const r = [];
    for (; n > 0; )
      n -= 1, r.push(t.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]), t.length = this.map[n][0];
    r.push(t.slice()), t.length = 0;
    let u = r.pop();
    for (; u; ) {
      for (const a of u)
        t.push(a);
      u = r.pop();
    }
    this.map.length = 0;
  }
}
function W1(e, t, n, r) {
  let u = 0;
  if (!(n === 0 && r.length === 0)) {
    for (; u < e.map.length; ) {
      if (e.map[u][0] === t) {
        e.map[u][1] += n, e.map[u][2].push(...r);
        return;
      }
      u += 1;
    }
    e.map.push([t, n, r]);
  }
}
function Q1(e, t) {
  let n = !1;
  const r = [];
  for (; t < e.length; ) {
    const u = e[t];
    if (n) {
      if (u[0] === "enter")
        u[1].type === "tableContent" && r.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (u[1].type === "tableContent") {
        if (e[t - 1][1].type === "tableDelimiterMarker") {
          const a = r.length - 1;
          r[a] = r[a] === "left" ? "center" : "right";
        }
      } else if (u[1].type === "tableDelimiterRow")
        break;
    } else u[0] === "enter" && u[1].type === "tableDelimiterRow" && (n = !0);
    t += 1;
  }
  return r;
}
function G1() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: X1,
        resolveAll: K1
      }
    }
  };
}
function X1(e, t, n) {
  const r = this;
  let u = 0, a = 0, i;
  return o;
  function o(S) {
    let B = r.events.length - 1;
    for (; B > -1; ) {
      const ne = r.events[B][1].type;
      if (ne === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      ne === "linePrefix") B--;
      else break;
    }
    const F = B > -1 ? r.events[B][1].type : null, $ = F === "tableHead" || F === "tableRow" ? k : l;
    return $ === k && r.parser.lazy[r.now().line] ? n(S) : $(S);
  }
  function l(S) {
    return e.enter("tableHead"), e.enter("tableRow"), c(S);
  }
  function c(S) {
    return S === 124 || (i = !0, a += 1), h(S);
  }
  function h(S) {
    return S === null ? n(S) : H(S) ? a > 1 ? (a = 0, r.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(S), e.exit("lineEnding"), d) : n(S) : j(S) ? W(e, h, "whitespace")(S) : (a += 1, i && (i = !1, u += 1), S === 124 ? (e.enter("tableCellDivider"), e.consume(S), e.exit("tableCellDivider"), i = !0, h) : (e.enter("data"), f(S)));
  }
  function f(S) {
    return S === null || S === 124 || J(S) ? (e.exit("data"), h(S)) : (e.consume(S), S === 92 ? p : f);
  }
  function p(S) {
    return S === 92 || S === 124 ? (e.consume(S), f) : f(S);
  }
  function d(S) {
    return r.interrupt = !1, r.parser.lazy[r.now().line] ? n(S) : (e.enter("tableDelimiterRow"), i = !1, j(S) ? W(e, A, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(S) : A(S));
  }
  function A(S) {
    return S === 45 || S === 58 ? L(S) : S === 124 ? (i = !0, e.enter("tableCellDivider"), e.consume(S), e.exit("tableCellDivider"), C) : Y(S);
  }
  function C(S) {
    return j(S) ? W(e, L, "whitespace")(S) : L(S);
  }
  function L(S) {
    return S === 58 ? (a += 1, i = !0, e.enter("tableDelimiterMarker"), e.consume(S), e.exit("tableDelimiterMarker"), x) : S === 45 ? (a += 1, x(S)) : S === null || H(S) ? z(S) : Y(S);
  }
  function x(S) {
    return S === 45 ? (e.enter("tableDelimiterFiller"), w(S)) : Y(S);
  }
  function w(S) {
    return S === 45 ? (e.consume(S), w) : S === 58 ? (i = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(S), e.exit("tableDelimiterMarker"), D) : (e.exit("tableDelimiterFiller"), D(S));
  }
  function D(S) {
    return j(S) ? W(e, z, "whitespace")(S) : z(S);
  }
  function z(S) {
    return S === 124 ? A(S) : S === null || H(S) ? !i || u !== a ? Y(S) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(S)) : Y(S);
  }
  function Y(S) {
    return n(S);
  }
  function k(S) {
    return e.enter("tableRow"), Q(S);
  }
  function Q(S) {
    return S === 124 ? (e.enter("tableCellDivider"), e.consume(S), e.exit("tableCellDivider"), Q) : S === null || H(S) ? (e.exit("tableRow"), t(S)) : j(S) ? W(e, Q, "whitespace")(S) : (e.enter("data"), ee(S));
  }
  function ee(S) {
    return S === null || S === 124 || J(S) ? (e.exit("data"), Q(S)) : (e.consume(S), S === 92 ? X : ee);
  }
  function X(S) {
    return S === 92 || S === 124 ? (e.consume(S), ee) : ee(S);
  }
}
function K1(e, t) {
  let n = -1, r = !0, u = 0, a = [0, 0, 0, 0], i = [0, 0, 0, 0], o = !1, l = 0, c, h, f;
  const p = new V1();
  for (; ++n < e.length; ) {
    const d = e[n], A = d[1];
    d[0] === "enter" ? A.type === "tableHead" ? (o = !1, l !== 0 && (Xu(p, t, l, c, h), h = void 0, l = 0), c = {
      type: "table",
      start: Object.assign({}, A.start),
      // Note: correct end is set later.
      end: Object.assign({}, A.end)
    }, p.add(n, 0, [["enter", c, t]])) : A.type === "tableRow" || A.type === "tableDelimiterRow" ? (r = !0, f = void 0, a = [0, 0, 0, 0], i = [0, n + 1, 0, 0], o && (o = !1, h = {
      type: "tableBody",
      start: Object.assign({}, A.start),
      // Note: correct end is set later.
      end: Object.assign({}, A.end)
    }, p.add(n, 0, [["enter", h, t]])), u = A.type === "tableDelimiterRow" ? 2 : h ? 3 : 1) : u && (A.type === "data" || A.type === "tableDelimiterMarker" || A.type === "tableDelimiterFiller") ? (r = !1, i[2] === 0 && (a[1] !== 0 && (i[0] = i[1], f = Jt(p, t, a, u, void 0, f), a = [0, 0, 0, 0]), i[2] = n)) : A.type === "tableCellDivider" && (r ? r = !1 : (a[1] !== 0 && (i[0] = i[1], f = Jt(p, t, a, u, void 0, f)), a = i, i = [a[1], n, 0, 0])) : A.type === "tableHead" ? (o = !0, l = n) : A.type === "tableRow" || A.type === "tableDelimiterRow" ? (l = n, a[1] !== 0 ? (i[0] = i[1], f = Jt(p, t, a, u, n, f)) : i[1] !== 0 && (f = Jt(p, t, i, u, n, f)), u = 0) : u && (A.type === "data" || A.type === "tableDelimiterMarker" || A.type === "tableDelimiterFiller") && (i[3] = n);
  }
  for (l !== 0 && Xu(p, t, l, c, h), p.consume(t.events), n = -1; ++n < t.events.length; ) {
    const d = t.events[n];
    d[0] === "enter" && d[1].type === "table" && (d[1]._align = Q1(t.events, n));
  }
  return e;
}
function Jt(e, t, n, r, u, a) {
  const i = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", o = "tableContent";
  n[0] !== 0 && (a.end = Object.assign({}, lt(t.events, n[0])), e.add(n[0], 0, [["exit", a, t]]));
  const l = lt(t.events, n[1]);
  if (a = {
    type: i,
    start: Object.assign({}, l),
    // Note: correct end is set later.
    end: Object.assign({}, l)
  }, e.add(n[1], 0, [["enter", a, t]]), n[2] !== 0) {
    const c = lt(t.events, n[2]), h = lt(t.events, n[3]), f = {
      type: o,
      start: Object.assign({}, c),
      end: Object.assign({}, h)
    };
    if (e.add(n[2], 0, [["enter", f, t]]), r !== 2) {
      const p = t.events[n[2]], d = t.events[n[3]];
      if (p[1].end = Object.assign({}, d[1].end), p[1].type = "chunkText", p[1].contentType = "text", n[3] > n[2] + 1) {
        const A = n[2] + 1, C = n[3] - n[2] - 1;
        e.add(A, C, []);
      }
    }
    e.add(n[3] + 1, 0, [["exit", f, t]]);
  }
  return u !== void 0 && (a.end = Object.assign({}, lt(t.events, u)), e.add(u, 0, [["exit", a, t]]), a = void 0), a;
}
function Xu(e, t, n, r, u) {
  const a = [], i = lt(t.events, n);
  u && (u.end = Object.assign({}, i), a.push(["exit", u, t])), r.end = Object.assign({}, i), a.push(["exit", r, t]), e.add(n + 1, 0, a);
}
function lt(e, t) {
  const n = e[t], r = n[0] === "enter" ? "start" : "end";
  return n[1][r];
}
const $1 = {
  name: "tasklistCheck",
  tokenize: Z1
};
function J1() {
  return {
    text: {
      91: $1
    }
  };
}
function Z1(e, t, n) {
  const r = this;
  return u;
  function u(l) {
    return (
      // Exit if there’s stuff before.
      r.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r._gfmTasklistFirstContentOfListItem ? n(l) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(l), e.exit("taskListCheckMarker"), a)
    );
  }
  function a(l) {
    return J(l) ? (e.enter("taskListCheckValueUnchecked"), e.consume(l), e.exit("taskListCheckValueUnchecked"), i) : l === 88 || l === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(l), e.exit("taskListCheckValueChecked"), i) : n(l);
  }
  function i(l) {
    return l === 93 ? (e.enter("taskListCheckMarker"), e.consume(l), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), o) : n(l);
  }
  function o(l) {
    return H(l) ? t(l) : j(l) ? e.check({
      tokenize: ep
    }, t, n)(l) : n(l);
  }
}
function ep(e, t, n) {
  return W(e, r, "whitespace");
  function r(u) {
    return u === null ? n(u) : t(u);
  }
}
function tp(e) {
  return g1([
    I1(),
    B1(),
    j1(e),
    G1(),
    J1()
  ]);
}
const np = {};
function rp(e) {
  const t = (
    /** @type {Processor<Root>} */
    this
  ), n = e || np, r = t.data(), u = r.micromarkExtensions || (r.micromarkExtensions = []), a = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), i = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  u.push(tp(n)), a.push(E1()), i.push(T1(n));
}
const up = ({
  children: e,
  title: t = "Code",
  language: n,
  showCopy: r = "hover",
  showLanguageIndicator: u,
  showLineNumbers: a,
  ...i
}) => {
  const [o, l] = Gs(), c = qe(null);
  return e ? /* @__PURE__ */ O.jsxs(
    "div",
    {
      className: ae(
        "border code-block-wrapper relative group rounded-md overflow-hidden",
        a && "line-numbers",
        i.className
      ),
      children: [
        /* @__PURE__ */ O.jsxs("div", { className: "border-b flex items-center h-10 font-sans bg-black/2", children: [
          /* @__PURE__ */ O.jsxs("div", { className: "flex items-center gap-1.5 flex-1 text-sm w-full px-3", children: [
            /* @__PURE__ */ O.jsx(vs, { language: n }),
            t
          ] }),
          " ",
          r !== "never" && /* @__PURE__ */ O.jsx(
            "button",
            {
              type: "button",
              "aria-label": "Copy code",
              title: "Copy code",
              className: ae(
                "transition px-2 py-2 mx-1 rounded-sm",
                !o && "hover:bg-accent hover:brightness-95"
              ),
              disabled: o,
              onClick: () => {
                c.current?.textContent && l(c.current.textContent);
              },
              children: o ? /* @__PURE__ */ O.jsx(qs, { className: "text-emerald-600", size: 14 }) : /* @__PURE__ */ O.jsx(js, { size: 14 })
            }
          )
        ] }),
        /* @__PURE__ */ O.jsx(
          "div",
          {
            className: "code-block text-sm not-prose scrollbar [&_code]:px-3 [&_code]:py-2",
            ref: c,
            children: e
          }
        )
      ]
    }
  ) : null;
}, Ka = si({
  activeAnchor: "",
  setActiveAnchor: () => {
  },
  observe: () => {
  },
  unobserve: () => {
  }
}), Hr = () => oi(Ka), ip = () => {
  const e = qe(null), { observe: t, unobserve: n } = Hr();
  return et(() => {
    const u = e.current;
    if (u)
      return t(u), () => n(u);
  }, [t, n]), { ref: li((u) => {
    u && (e.current = u);
  }, []) };
}, NE = ({ children: e }) => {
  const [t, n] = sn(""), r = qe(null), u = qe(/* @__PURE__ */ new Set()), a = qe(/* @__PURE__ */ new Set());
  et(() => (r.current = new IntersectionObserver(
    (l) => {
      for (const c of l)
        c.isIntersecting && c.target.id && n(c.target.id);
    },
    {
      rootMargin: "0px 0px -80% 0px",
      threshold: 0.75
    }
  ), a.current.forEach((l) => {
    u.current.add(l), r.current?.observe(l);
  }), a.current.clear(), () => r.current?.disconnect()), []), et(() => {
    const l = u.current, c = () => {
      const h = window.scrollY === 0, f = window.innerHeight + window.scrollY >= document.body.scrollHeight;
      if (h)
        n("");
      else if (f) {
        const d = Array.from(l).pop()?.id ?? "";
        n(d);
      }
    };
    return document.addEventListener("scroll", c), () => {
      l.clear(), document.removeEventListener("scroll", c);
    };
  }, []);
  const i = Ft(() => ({
    observe: (l) => {
      if (l) {
        if (!r.current) {
          a.current.add(l);
          return;
        }
        u.current.add(l), r.current.observe(l);
      }
    },
    unobserve: (l) => {
      l && (a.current.delete(l), u.current.delete(l), r.current?.unobserve(l));
    }
  }), []), o = Ft(
    () => ({ activeAnchor: t, setActiveAnchor: n, ...i }),
    [t, i]
  );
  return /* @__PURE__ */ O.jsx(Ka, { value: o, children: e });
}, ap = pt.Provider, sp = pt.Root, op = pt.Trigger, lp = (e) => /* @__PURE__ */ O.jsx(
  pt.Arrow,
  {
    ...e,
    className: ae(e.className, "fill-border")
  }
), $a = Es.forwardRef(({ className: e, sideOffset: t = 4, ...n }, r) => /* @__PURE__ */ O.jsx(
  pt.Content,
  {
    ref: r,
    sideOffset: t,
    className: ae(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      e
    ),
    ...n
  }
));
$a.displayName = pt.Content.displayName;
const cp = {
  green: "bg-green-400 dark:bg-green-800",
  blue: "bg-sky-400 dark:bg-sky-800",
  yellow: "bg-yellow-400 dark:bg-yellow-800",
  red: "bg-red-400 dark:bg-red-800",
  purple: "bg-purple-400 dark:bg-purple-600",
  indigo: "bg-indigo-400 dark:bg-indigo-600",
  gray: "bg-gray-400 dark:bg-gray-600",
  outline: "border border-border rounded-md text-foreground"
}, fp = {
  green: "text-green-500 dark:text-green-600",
  blue: "text-sky-400 dark:text-sky-600",
  yellow: "text-yellow-400 dark:text-yellow-600",
  red: "text-red-400 dark:text-red-600",
  purple: "text-purple-400 dark:text-purple-600",
  indigo: "text-indigo-400 dark:text-indigo-600",
  gray: "text-gray-400 dark:text-gray-600",
  outline: ""
}, Ku = ({
  color: e,
  label: t,
  className: n,
  invert: r
}) => /* @__PURE__ */ O.jsx(
  "span",
  {
    className: ae(
      "flex items-center duration-200 transition-opacity text-center uppercase text-[0.65rem] leading-5 font-bold rounded-sm text-background dark:text-zinc-50 h-full",
      e === "outline" ? "px-3" : "mt-0.5 px-1",
      r ? fp[e] : cp[e],
      n
    ),
    children: t
  }
);
var hp = Object.getOwnPropertyNames, dp = Object.getOwnPropertySymbols, mp = Object.prototype.hasOwnProperty;
function $u(e, t) {
  return function(r, u, a) {
    return e(r, u, a) && t(r, u, a);
  };
}
function Zt(e) {
  return function(n, r, u) {
    if (!n || !r || typeof n != "object" || typeof r != "object")
      return e(n, r, u);
    var a = u.cache, i = a.get(n), o = a.get(r);
    if (i && o)
      return i === r && o === n;
    a.set(n, r), a.set(r, n);
    var l = e(n, r, u);
    return a.delete(n), a.delete(r), l;
  };
}
function Ju(e) {
  return hp(e).concat(dp(e));
}
var pp = Object.hasOwn || function(e, t) {
  return mp.call(e, t);
};
function ut(e, t) {
  return e === t || !e && !t && e !== e && t !== t;
}
var Ep = "__v", Tp = "__o", gp = "_owner", Zu = Object.getOwnPropertyDescriptor, ei = Object.keys;
function bp(e, t, n) {
  var r = e.length;
  if (t.length !== r)
    return !1;
  for (; r-- > 0; )
    if (!n.equals(e[r], t[r], r, r, e, t, n))
      return !1;
  return !0;
}
function Ap(e, t) {
  return ut(e.getTime(), t.getTime());
}
function _p(e, t) {
  return e.name === t.name && e.message === t.message && e.cause === t.cause && e.stack === t.stack;
}
function Cp(e, t) {
  return e === t;
}
function ti(e, t, n) {
  var r = e.size;
  if (r !== t.size)
    return !1;
  if (!r)
    return !0;
  for (var u = new Array(r), a = e.entries(), i, o, l = 0; (i = a.next()) && !i.done; ) {
    for (var c = t.entries(), h = !1, f = 0; (o = c.next()) && !o.done; ) {
      if (u[f]) {
        f++;
        continue;
      }
      var p = i.value, d = o.value;
      if (n.equals(p[0], d[0], l, f, e, t, n) && n.equals(p[1], d[1], p[0], d[0], e, t, n)) {
        h = u[f] = !0;
        break;
      }
      f++;
    }
    if (!h)
      return !1;
    l++;
  }
  return !0;
}
var Ip = ut;
function xp(e, t, n) {
  var r = ei(e), u = r.length;
  if (ei(t).length !== u)
    return !1;
  for (; u-- > 0; )
    if (!Ja(e, t, n, r[u]))
      return !1;
  return !0;
}
function Ot(e, t, n) {
  var r = Ju(e), u = r.length;
  if (Ju(t).length !== u)
    return !1;
  for (var a, i, o; u-- > 0; )
    if (a = r[u], !Ja(e, t, n, a) || (i = Zu(e, a), o = Zu(t, a), (i || o) && (!i || !o || i.configurable !== o.configurable || i.enumerable !== o.enumerable || i.writable !== o.writable)))
      return !1;
  return !0;
}
function Sp(e, t) {
  return ut(e.valueOf(), t.valueOf());
}
function Np(e, t) {
  return e.source === t.source && e.flags === t.flags;
}
function ni(e, t, n) {
  var r = e.size;
  if (r !== t.size)
    return !1;
  if (!r)
    return !0;
  for (var u = new Array(r), a = e.values(), i, o; (i = a.next()) && !i.done; ) {
    for (var l = t.values(), c = !1, h = 0; (o = l.next()) && !o.done; ) {
      if (!u[h] && n.equals(i.value, o.value, i.value, o.value, e, t, n)) {
        c = u[h] = !0;
        break;
      }
      h++;
    }
    if (!c)
      return !1;
  }
  return !0;
}
function kp(e, t) {
  var n = e.length;
  if (t.length !== n)
    return !1;
  for (; n-- > 0; )
    if (e[n] !== t[n])
      return !1;
  return !0;
}
function Op(e, t) {
  return e.hostname === t.hostname && e.pathname === t.pathname && e.protocol === t.protocol && e.port === t.port && e.hash === t.hash && e.username === t.username && e.password === t.password;
}
function Ja(e, t, n, r) {
  return (r === gp || r === Tp || r === Ep) && (e.$$typeof || t.$$typeof) ? !0 : pp(t, r) && n.equals(e[r], t[r], r, r, e, t, n);
}
var yp = "[object Arguments]", Lp = "[object Boolean]", Rp = "[object Date]", Dp = "[object Error]", Pp = "[object Map]", wp = "[object Number]", Mp = "[object Object]", Bp = "[object RegExp]", Fp = "[object Set]", Hp = "[object String]", Up = "[object URL]", vp = Array.isArray, ri = typeof ArrayBuffer == "function" && ArrayBuffer.isView ? ArrayBuffer.isView : null, ui = Object.assign, zp = Object.prototype.toString.call.bind(Object.prototype.toString);
function Yp(e) {
  var t = e.areArraysEqual, n = e.areDatesEqual, r = e.areErrorsEqual, u = e.areFunctionsEqual, a = e.areMapsEqual, i = e.areNumbersEqual, o = e.areObjectsEqual, l = e.arePrimitiveWrappersEqual, c = e.areRegExpsEqual, h = e.areSetsEqual, f = e.areTypedArraysEqual, p = e.areUrlsEqual;
  return function(A, C, L) {
    if (A === C)
      return !0;
    if (A == null || C == null)
      return !1;
    var x = typeof A;
    if (x !== typeof C)
      return !1;
    if (x !== "object")
      return x === "number" ? i(A, C, L) : x === "function" ? u(A, C, L) : !1;
    var w = A.constructor;
    if (w !== C.constructor)
      return !1;
    if (w === Object)
      return o(A, C, L);
    if (vp(A))
      return t(A, C, L);
    if (ri != null && ri(A))
      return f(A, C, L);
    if (w === Date)
      return n(A, C, L);
    if (w === RegExp)
      return c(A, C, L);
    if (w === Map)
      return a(A, C, L);
    if (w === Set)
      return h(A, C, L);
    var D = zp(A);
    return D === Rp ? n(A, C, L) : D === Bp ? c(A, C, L) : D === Pp ? a(A, C, L) : D === Fp ? h(A, C, L) : D === Mp ? typeof A.then != "function" && typeof C.then != "function" && o(A, C, L) : D === Up ? p(A, C, L) : D === Dp ? r(A, C, L) : D === yp ? o(A, C, L) : D === Lp || D === wp || D === Hp ? l(A, C, L) : !1;
  };
}
function qp(e) {
  var t = e.circular, n = e.createCustomConfig, r = e.strict, u = {
    areArraysEqual: r ? Ot : bp,
    areDatesEqual: Ap,
    areErrorsEqual: _p,
    areFunctionsEqual: Cp,
    areMapsEqual: r ? $u(ti, Ot) : ti,
    areNumbersEqual: Ip,
    areObjectsEqual: r ? Ot : xp,
    arePrimitiveWrappersEqual: Sp,
    areRegExpsEqual: Np,
    areSetsEqual: r ? $u(ni, Ot) : ni,
    areTypedArraysEqual: r ? Ot : kp,
    areUrlsEqual: Op
  };
  if (n && (u = ui({}, u, n(u))), t) {
    var a = Zt(u.areArraysEqual), i = Zt(u.areMapsEqual), o = Zt(u.areObjectsEqual), l = Zt(u.areSetsEqual);
    u = ui({}, u, {
      areArraysEqual: a,
      areMapsEqual: i,
      areObjectsEqual: o,
      areSetsEqual: l
    });
  }
  return u;
}
function jp(e) {
  return function(t, n, r, u, a, i, o) {
    return e(t, n, o);
  };
}
function Vp(e) {
  var t = e.circular, n = e.comparator, r = e.createState, u = e.equals, a = e.strict;
  if (r)
    return function(l, c) {
      var h = r(), f = h.cache, p = f === void 0 ? t ? /* @__PURE__ */ new WeakMap() : void 0 : f, d = h.meta;
      return n(l, c, {
        cache: p,
        equals: u,
        meta: d,
        strict: a
      });
    };
  if (t)
    return function(l, c) {
      return n(l, c, {
        cache: /* @__PURE__ */ new WeakMap(),
        equals: u,
        meta: void 0,
        strict: a
      });
    };
  var i = {
    cache: void 0,
    equals: u,
    meta: void 0,
    strict: a
  };
  return function(l, c) {
    return n(l, c, i);
  };
}
var Wp = We();
We({ strict: !0 });
We({ circular: !0 });
We({
  circular: !0,
  strict: !0
});
We({
  createInternalComparator: function() {
    return ut;
  }
});
We({
  strict: !0,
  createInternalComparator: function() {
    return ut;
  }
});
We({
  circular: !0,
  createInternalComparator: function() {
    return ut;
  }
});
We({
  circular: !0,
  createInternalComparator: function() {
    return ut;
  },
  strict: !0
});
function We(e) {
  e === void 0 && (e = {});
  var t = e.circular, n = t === void 0 ? !1 : t, r = e.createInternalComparator, u = e.createState, a = e.strict, i = a === void 0 ? !1 : a, o = qp(e), l = Yp(o), c = r ? r(l) : jp(l);
  return Vp({ circular: n, comparator: l, createState: u, equals: c, strict: i });
}
const Qp = ({
  category: e,
  onRequestClose: t
}) => {
  const n = xs(e), [r, u] = sn(!1), a = gn(), i = e.collapsible ?? !0, o = e.collapsed ?? !0, l = !!(!i || !o || n), [c, h] = sn(l), f = Xs(e.link?.path ?? "");
  et(() => {
    n && h(!0);
  }, [n]);
  const p = i && /* @__PURE__ */ O.jsx(
    $s,
    {
      onClick: (C) => {
        C.preventDefault(), h((L) => !L), u(!0);
      },
      variant: "ghost",
      size: "icon",
      className: "size-6 hover:bg-[hsl(from_var(--accent)_h_s_calc(l+6*var(--dark)))]",
      children: /* @__PURE__ */ O.jsx(
        Vs,
        {
          size: 16,
          className: ae(
            r && "transition",
            "shrink-0 group-data-[state=open]:rotate-90 rtl:rotate-180"
          )
        }
      )
    }
  ), d = e.icon && /* @__PURE__ */ O.jsx(
    e.icon,
    {
      size: 16,
      className: ae("align-[-0.125em] ", f && "text-primary")
    }
  ), A = en({
    className: [
      "group text-start font-medium",
      i || typeof e.link < "u" ? "cursor-pointer" : "cursor-default hover:bg-transparent"
    ]
  });
  return /* @__PURE__ */ O.jsxs(
    yn.Root,
    {
      className: "flex flex-col",
      defaultOpen: l,
      open: c,
      onOpenChange: () => h(!0),
      children: [
        /* @__PURE__ */ O.jsx(yn.Trigger, { className: "group", asChild: !0, disabled: !i, children: e.link?.type === "doc" ? /* @__PURE__ */ O.jsxs(
          dr,
          {
            to: {
              pathname: Xn(e.link.path),
              search: a.search
            },
            className: A,
            onClick: () => {
              u(!0), f && !c && h(!0);
            },
            children: [
              d,
              /* @__PURE__ */ O.jsxs("div", { className: "flex items-center gap-2 justify-between w-full text-foreground/80 group-aria-[current='page']:text-primary", children: [
                /* @__PURE__ */ O.jsx("div", { className: "truncate", children: e.label }),
                p
              ] })
            ]
          }
        ) : (
          // biome-ignore lint/a11y/noStaticElementInteractions: This is only to track if the user has interacted
          /* @__PURE__ */ O.jsxs(
            "div",
            {
              onClick: () => u(!0),
              onKeyUp: (C) => {
                (C.key === "Enter" || C.key === " ") && u(!0);
              },
              className: A,
              children: [
                d,
                /* @__PURE__ */ O.jsxs("div", { className: "flex items-center justify-between w-full", children: [
                  /* @__PURE__ */ O.jsx("div", { className: "flex gap-2 truncate w-full", children: e.label }),
                  p
                ] })
              ]
            }
          )
        ) }),
        /* @__PURE__ */ O.jsx(
          yn.Content,
          {
            className: ae(
              // CollapsibleContent class is used to animate and it should only be applied when the user has triggered the toggle
              r && "CollapsibleContent",
              e.items.length === 0 && "hidden",
              "ms-6 my-1"
            ),
            children: /* @__PURE__ */ O.jsx("ul", { className: "relative after:absolute after:-start-(--padding-nav-item) after:translate-x-[1.5px] after:top-0 after:bottom-0 after:w-px after:bg-border", children: e.items.map((C) => /* @__PURE__ */ O.jsx(
              Gp,
              {
                onRequestClose: t,
                item: C
              },
              C.type + (C.label ?? "") + ("path" in C ? C.path : "") + ("file" in C ? C.file : "") + ("to" in C ? C.to : "")
            )) })
          }
        )
      ]
    }
  );
}, Za = cr(Qp, Wp);
Za.displayName = "NavigationCategory";
const ii = ({
  label: e,
  className: t
}) => {
  const n = qe(null), [r, u] = sn(!1);
  return et(() => {
    n.current && n.current.offsetWidth < n.current.scrollWidth && u(!0);
  }, []), /* @__PURE__ */ O.jsxs(O.Fragment, { children: [
    /* @__PURE__ */ O.jsx(
      "span",
      {
        className: ae("truncate flex-1", t),
        title: e,
        ref: n,
        children: e
      }
    ),
    r && /* @__PURE__ */ O.jsx(ap, { delayDuration: 500, children: /* @__PURE__ */ O.jsxs(sp, { disableHoverableContent: !0, children: [
      /* @__PURE__ */ O.jsx(op, { className: "absolute inset-0 z-10" }),
      /* @__PURE__ */ O.jsxs(
        $a,
        {
          className: "max-w-64 rounded-lg",
          side: "bottom",
          align: "center",
          children: [
            /* @__PURE__ */ O.jsx(lp, {}),
            e
          ]
        }
      )
    ] }) })
  ] });
}, es = "data-anchor", Gp = ({
  item: e,
  onRequestClose: t
}) => {
  const n = gn(), { activeAnchor: r } = Hr(), u = _s(), a = fr();
  if (!Ss(u, a)(e))
    return null;
  switch (e.type) {
    case "category":
      return /* @__PURE__ */ O.jsx(Za, { category: e, onRequestClose: t });
    case "doc":
      return /* @__PURE__ */ O.jsxs(
        dr,
        {
          viewTransition: !0,
          className: ({ isActive: i, isPending: o }) => en({ isActive: i, isPending: o }),
          to: Xn(e.path),
          onClick: t,
          end: !0,
          children: [
            e.icon && /* @__PURE__ */ O.jsx(e.icon, { size: 16, className: "align-[-0.125em]" }),
            e.badge ? /* @__PURE__ */ O.jsxs(O.Fragment, { children: [
              e.label && /* @__PURE__ */ O.jsx(ii, { label: e.label, className: "flex-1" }),
              /* @__PURE__ */ O.jsx(Ku, { ...e.badge })
            ] }) : e.label
          ]
        }
      );
    case "link":
    case "custom-page": {
      const i = e.type === "link" ? e.to : Xn(e.path);
      return i.startsWith("http") ? /* @__PURE__ */ O.jsxs(
        "a",
        {
          className: en(),
          href: i,
          target: "target" in e ? e.target : "_blank",
          rel: "noopener noreferrer",
          onClick: t,
          children: [
            e.icon && /* @__PURE__ */ O.jsx(e.icon, { size: 16, className: "align-[-0.125em]" }),
            /* @__PURE__ */ O.jsx("span", { className: "whitespace-normal", children: e.label }),
            /* @__PURE__ */ O.jsx("span", { className: "whitespace-nowrap", children: /* @__PURE__ */ O.jsx(Ws, { className: "inline -translate-y-0.5", size: 12 }) })
          ]
        }
      ) : /* @__PURE__ */ O.jsxs(
        ns,
        {
          to: {
            pathname: i.split("#")[0],
            hash: i.split("#")[1],
            search: n.search
          },
          [es]: i.split("#")[1],
          className: en({
            isActive: i === [n.pathname, r].filter(Boolean).join("#")
          }),
          onClick: t,
          children: [
            e.icon && /* @__PURE__ */ O.jsx(e.icon, { size: 16, className: "align-[-0.125em]" }),
            e.badge ? /* @__PURE__ */ O.jsxs(O.Fragment, { children: [
              e.label && /* @__PURE__ */ O.jsx(ii, { label: e.label }),
              /* @__PURE__ */ O.jsx(Ku, { ...e.badge })
            ] }) : /* @__PURE__ */ O.jsx("span", { className: "break-all", children: e.label })
          ]
        }
      );
    }
  }
}, Xp = (e, t = { block: "center" }) => {
  if (!e) return;
  const n = e.getBoundingClientRect();
  n.top >= 0 && n.left >= 0 && n.bottom <= (window.innerHeight || document.documentElement.clientHeight) && n.right <= (window.innerWidth || document.documentElement.clientWidth) || e.scrollIntoView(t);
}, ts = () => {
  const { setActiveAnchor: e } = Hr();
  return li(
    (n) => {
      const r = n.replace(/^#/, ""), u = r.split("/").at(0);
      if (!u) return !1;
      const a = document.getElementById(decodeURIComponent(r)), i = document.querySelector(
        `[${es}="${u}"]`
      );
      return a ? (a.scrollIntoView(), Xp(i), requestIdleCallback(() => e(u)), !0) : !1;
    },
    [e]
  );
}, kE = () => {
  const e = gn(), t = ts(), n = qe(!1);
  et(() => {
    !e.hash || !n.current || t(e.hash);
  }, [e.hash, t]), et(() => {
    if (!e.hash) {
      n.current = !0;
      return;
    }
    const r = new MutationObserver((u, a) => {
      t(e.hash) && (n.current = !0, a.disconnect());
    });
    return r.observe(document.body, { childList: !0, subtree: !0 }), () => r.disconnect();
  }, [e.hash, t]);
}, ns = (e) => {
  const t = gn(), n = ts(), r = Ks(e.to), [u, a] = r.split("#"), i = (o) => {
    e.onClick?.(o), !(a !== t.hash.slice(1) || u !== t.pathname) && (o.preventDefault(), n(a));
  };
  return /* @__PURE__ */ O.jsx(dr, { ...e, onClick: i });
}, Kp = hi("", {
  variants: {
    size: {
      sm: "max-w-sm",
      md: "max-w-md",
      lg: "max-w-lg",
      xl: "max-w-xl",
      "2xl": "max-w-2xl",
      full: "max-w-full"
    },
    align: {
      center: "mx-auto",
      start: "me-auto",
      end: "ms-auto"
    }
  },
  defaultVariants: {
    size: "xl",
    align: "center"
  }
}), $p = ({
  caption: e,
  className: t,
  size: n = "xl",
  align: r = "center",
  children: u
}) => /* @__PURE__ */ O.jsxs("figure", { className: ae(Kp({ size: n, align: r }), t), children: [
  /* @__PURE__ */ O.jsx("div", { className: "relative overflow-hidden rounded-lg border border-border bg-muted/50 p-1 shadow-sm", children: /* @__PURE__ */ O.jsx("div", { className: "not-prose rounded-md [&_img]:rounded-md! relative overflow-hidden bg-background", children: u }) }),
  e && /* @__PURE__ */ O.jsx("figcaption", { className: "mt-3 text-center text-sm text-muted-foreground", children: e })
] }), Jp = hi("group relative", {
  variants: {
    level: {
      6: "text-md",
      5: "text-lg",
      4: "text-xl",
      3: "text-xl font-semibold",
      2: "text-2xl font-bold",
      1: "text-4xl font-extrabold"
    }
  },
  defaultVariants: {
    level: 1
  }
}), Zp = (e) => {
  switch (e) {
    case 1:
      return "h1";
    case 2:
      return "h2";
    case 3:
      return "h3";
    case 4:
      return "h4";
    case 5:
      return "h5";
    case 6:
      return "h6";
    default:
      return "h1";
  }
}, $e = ({
  level: e,
  children: t,
  id: n,
  className: r,
  registerNavigationAnchor: u
}) => {
  const a = Zp(e ?? 1), { ref: i } = ip();
  return /* @__PURE__ */ O.jsxs(
    a,
    {
      className: Jp({
        className: ae("flex items-center gap-[0.33em]", r),
        level: e
      }),
      ref: u ? i : void 0,
      id: n,
      children: [
        t,
        n && /* @__PURE__ */ O.jsx(
          "a",
          {
            href: `#${n}`,
            className: "rounded text-[0.8em] text-muted-foreground p-0.5 -m-0.5 opacity-0 group-hover:opacity-50 hover:text-primary hover:!opacity-100 transition-opacity duration-200",
            "aria-label": `Link to ${n}`,
            children: /* @__PURE__ */ O.jsx(Qs, { className: "size-[0.75em] min-w-4 min-h-4" })
          }
        )
      ]
    }
  );
}, eE = ({
  asChild: e,
  onClick: t,
  enabled: n = !0,
  ...r
}) => {
  const u = e ? Js : "span";
  return /* @__PURE__ */ O.jsx(
    u,
    {
      onClick: (a) => {
        if (n) {
          const i = document.createRange();
          i.selectNodeContents(a.currentTarget);
          const o = window.getSelection();
          o?.removeAllRanges(), o?.addRange(i);
        }
        t?.(a);
      },
      ...r
    }
  );
}, tE = ({
  className: e,
  children: t,
  selectOnClick: n,
  onClick: r
}) => /* @__PURE__ */ O.jsx(eE, { asChild: !0, enabled: n, onClick: r, children: /* @__PURE__ */ O.jsx(
  "code",
  {
    className: ae(
      "font-mono border p-1 py-0.5 rounded-sm bg-border/50 dark:bg-border/70 [overflow-wrap:anywhere]",
      e
    ),
    children: t
  }
) }), nE = {
  img: ({ node: e, ...t }) => /\.(mp4|webm|mov|avi)$/.test(t.src ?? "") ? (
    // biome-ignore lint/a11y/useMediaCaption: No in control of the caption here
    /* @__PURE__ */ O.jsx(
      "video",
      {
        src: t.src,
        controls: !0,
        playsInline: !0,
        autoPlay: !0,
        loop: !0,
        className: ae("rounded-lg", t.className)
      }
    )
  ) : /* @__PURE__ */ O.jsx(
    "img",
    {
      alt: t.alt,
      ...t,
      className: ae("rounded-lg", t.className)
    }
  ),
  Framed: $p,
  h1: ({ children: e, id: t }) => /* @__PURE__ */ O.jsx($e, { level: 1, id: t, children: e }),
  h2: ({ children: e, id: t }) => /* @__PURE__ */ O.jsx($e, { level: 2, id: t, children: e }),
  h3: ({ children: e, id: t }) => /* @__PURE__ */ O.jsx($e, { level: 3, id: t, children: e }),
  h4: ({ children: e, id: t }) => /* @__PURE__ */ O.jsx($e, { level: 4, id: t, children: e }),
  h5: ({ children: e, id: t }) => /* @__PURE__ */ O.jsx($e, { level: 5, id: t, children: e }),
  h6: ({ children: e, id: t }) => /* @__PURE__ */ O.jsx($e, { level: 6, id: t, children: e }),
  a: ({ href: e, node: t, ...n }) => e && !e.startsWith("http") ? /* @__PURE__ */ O.jsx(ns, { to: e, relative: "path", ...n }) : /* @__PURE__ */ O.jsx("a", { href: e, target: "_blank", ...n, rel: "noreferrer" }),
  Button: Zs,
  Callout: Ue,
  Stepper: eo,
  SyntaxHighlight: Ms,
  tip: (e) => /* @__PURE__ */ O.jsx(Ue, { type: "tip", ...e }),
  info: (e) => /* @__PURE__ */ O.jsx(Ue, { type: "info", ...e }),
  note: (e) => /* @__PURE__ */ O.jsx(Ue, { type: "note", ...e }),
  caution: (e) => /* @__PURE__ */ O.jsx(Ue, { type: "caution", ...e }),
  warning: (e) => /* @__PURE__ */ O.jsx(Ue, { type: "caution", ...e }),
  danger: (e) => /* @__PURE__ */ O.jsx(Ue, { type: "danger", ...e }),
  pre: (e) => /* @__PURE__ */ O.jsx("pre", { className: ae("not-prose my-4", e.className), ...e }),
  code: ({
    className: e,
    node: t,
    children: n,
    title: r,
    inline: u,
    showLineNumbers: a,
    ...i
  }) => {
    const o = e?.match(/language?-(\w+)/);
    return u === "true" || u === !0 ? /* @__PURE__ */ O.jsx(tE, { className: ae(e, "inline"), children: n }) : /* @__PURE__ */ O.jsx(
      up,
      {
        language: o?.[1],
        showLanguageIndicator: !0,
        showLineNumbers: a,
        title: r,
        children: /* @__PURE__ */ O.jsx(
          "code",
          {
            className: ae(e, "overflow-x-auto scrollbar not-inline"),
            ...i,
            children: n
          }
        )
      }
    );
  }
}, rE = "prose dark:prose-invert prose-neutral typography", rs = ({
  children: e,
  className: t
}) => /* @__PURE__ */ O.jsx("div", { className: ae(rE, t), children: e }), uE = [rp], us = cr(
  ({
    content: e,
    className: t,
    components: n
  }) => {
    const { syntaxHighlighting: r } = fr().options, u = Ft(
      () => [
        Yd,
        ...Bs(
          r?.themes,
          r?.highlighter
        )
      ],
      [r?.themes, r?.highlighter]
    ), a = Ft(
      () => ({ ...nE, ...n }),
      [n]
    );
    return /* @__PURE__ */ O.jsx(rs, { className: t, children: /* @__PURE__ */ O.jsx(
      m0,
      {
        remarkPlugins: uE,
        rehypePlugins: u,
        components: a,
        children: e
      }
    ) });
  }
);
us.displayName = "Markdown";
const is = ({
  slots: e = {}
} = {}) => {
  const t = new Map(
    Object.entries(e).map(([r, u]) => [
      r,
      [{ id: r, content: u, type: "replace", sequence: 0 }]
    ])
  ), n = [];
  return Cs()((r, u) => ({
    items: t,
    sequences: /* @__PURE__ */ new Map(),
    getItems: (a) => u().items.get(a) ?? n,
    setSlot: (a, i, o, l) => r((c) => {
      if (o == null) return c;
      const h = new Map(c.items), f = new Map(c.sequences), d = (h.get(i) ?? []).filter((x) => x.id !== a), C = (f.get(i) ?? 0) + 1;
      f.set(i, C);
      const L = {
        id: a,
        content: o,
        type: l,
        // Use negative sequence values for "prepend" to ensure they are sorted before positive values for "append".
        sequence: l === "prepend" ? -C : C
      };
      if (l === "replace") {
        const x = d.filter(
          (w) => w.type !== "replace"
        );
        h.set(i, [...x, L]);
      } else
        h.set(i, [...d, L]);
      return { items: h, sequences: f };
    }),
    clearSlot: (a, i) => r((o) => {
      const l = new Map(o.items), c = new Map(o.sequences), f = (l.get(i) ?? []).filter((p) => p.id !== a);
      return f.length === 0 ? (l.delete(i), c.delete(i)) : l.set(i, f), { items: l, sequences: c };
    })
  }));
}, as = si(is()), OE = ({
  children: e,
  slots: t
}) => {
  const n = qe(is({ slots: t })).current;
  return /* @__PURE__ */ O.jsx(as, { value: n, children: e });
};
function lr(e) {
  const t = oi(as);
  return Is(t, e);
}
const ai = ["prepend", "replace", "append"], iE = (e) => {
  const t = As(), n = lr((r) => r.getItems(e));
  return Ft(() => n.length === 0 ? [] : n.toSorted((r, u) => {
    const a = ai.indexOf(r.type) - ai.indexOf(u.type);
    return a !== 0 ? a : r.sequence - u.sequence;
  }).map(
    (r) => typeof r.content == "function" ? /* @__PURE__ */ O.jsx(r.content, { ...t }, r.id) : /* @__PURE__ */ O.jsx(Ts, { children: r.content }, r.id)
  ), [n, t]);
}, yE = {
  Source: ({
    name: e,
    children: t,
    type: n = "replace"
  }) => {
    const r = gs(), u = lr((i) => i.setSlot), a = lr((i) => i.clearSlot);
    return bs(() => (u(r, e, t, n), () => a(r, e)), [r, e, t, n, u, a]), null;
  },
  Target: ({ name: e, fallback: t }) => {
    const n = iE(e);
    return n.length === 0 ? t : n;
  }
}, ss = cr(
  ({ code: e, children: t, embedded: n, ...r }) => {
    const { syntaxHighlighting: u } = fr().options;
    Us(u?.highlighter, "Highlighter not found");
    const a = Fs(
      u.highlighter,
      e ?? t,
      r.language,
      u.themes
    );
    return n ? /* @__PURE__ */ O.jsx(Ys, { ...r, children: a }) : /* @__PURE__ */ O.jsx(zs, { ...r, children: a });
  }
);
ss.displayName = "SyntaxHighlight";
const aE = ({
  children: e,
  className: t
}) => {
  if (process.env.NODE_ENV === "development")
    return /* @__PURE__ */ O.jsx(Ue, { type: "caution", title: "Developer hint", className: t, children: /* @__PURE__ */ O.jsxs("div", { className: "flex flex-col gap-2", children: [
      typeof e == "string" ? /* @__PURE__ */ O.jsx(us, { content: e }) : /* @__PURE__ */ O.jsx("div", { children: e }),
      /* @__PURE__ */ O.jsx("small", { className: "italic", children: "Note: This hint is only shown in development mode." })
    ] }) });
};
function LE({ error: e }) {
  const t = e instanceof Error ? e.message : "Something went wrong", n = e instanceof Qr ? e.developerHint : void 0, r = e instanceof Qr ? e.title : "Something went wrong", u = e instanceof Error ? e.stack : void 0, a = e instanceof Error ? e.cause : void 0, i = a instanceof Error ? String(a.stack) : u;
  return /* @__PURE__ */ O.jsxs(rs, { className: "grid grid-cols-1 !max-w-none pt-(--padding-content-top)", children: [
    /* @__PURE__ */ O.jsx($e, { level: 1, children: r }),
    "Error: ",
    t,
    n && /* @__PURE__ */ O.jsx(aE, { className: "mb-4", children: n }),
    i && /* @__PURE__ */ O.jsx(
      ss,
      {
        className: "max-h-[400px] [&>pre]:p-4",
        language: "js",
        code: i
      }
    )
  ] });
}
export {
  ns as A,
  aE as D,
  LE as E,
  $e as H,
  tE as I,
  us as M,
  Gp as N,
  eE as S,
  rs as T,
  NE as V,
  yE as a,
  nE as b,
  OE as c,
  Wp as d,
  qd as e,
  kE as f,
  sp as g,
  op as h,
  $a as i,
  ap as j,
  Xp as s,
  Hr as u
};
//# sourceMappingURL=ErrorAlert-xpVkFS_n.js.map
