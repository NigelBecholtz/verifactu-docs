import * as c from "react";
/**
 * react-router v7.8.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
var $a = (e) => {
  throw TypeError(e);
}, vo = (e, t, r) => t.has(e) || $a("Cannot " + r), er = (e, t, r) => (vo(e, t, "read from private field"), r ? r.call(e) : t.get(e)), go = (e, t, r) => t.has(e) ? $a("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r), wo = /* @__PURE__ */ ((e) => (e.Pop = "POP", e.Push = "PUSH", e.Replace = "REPLACE", e))(wo || {}), la = "popstate";
function Na(e = {}) {
  let { initialEntries: t = ["/"], initialIndex: r, v5Compat: a = !1 } = e, n;
  n = t.map(
    (m, y) => d(
      m,
      typeof m == "string" ? null : m.state,
      y === 0 ? "default" : void 0
    )
  );
  let o = s(
    r ?? n.length - 1
  ), i = "POP", l = null;
  function s(m) {
    return Math.min(Math.max(m, 0), n.length - 1);
  }
  function u() {
    return n[o];
  }
  function d(m, y = null, C) {
    let g = Te(
      n ? u().pathname : "/",
      m,
      y,
      C
    );
    return V(
      g.pathname.charAt(0) === "/",
      `relative pathnames are not supported in memory history: ${JSON.stringify(
        m
      )}`
    ), g;
  }
  function f(m) {
    return typeof m == "string" ? m : fe(m);
  }
  return {
    get index() {
      return o;
    },
    get action() {
      return i;
    },
    get location() {
      return u();
    },
    createHref: f,
    createURL(m) {
      return new URL(f(m), "http://localhost");
    },
    encodeLocation(m) {
      let y = typeof m == "string" ? Ee(m) : m;
      return {
        pathname: y.pathname || "",
        search: y.search || "",
        hash: y.hash || ""
      };
    },
    push(m, y) {
      i = "PUSH";
      let C = d(m, y);
      o += 1, n.splice(o, n.length, C), a && l && l({ action: i, location: C, delta: 1 });
    },
    replace(m, y) {
      i = "REPLACE";
      let C = d(m, y);
      n[o] = C, a && l && l({ action: i, location: C, delta: 0 });
    },
    go(m) {
      i = "POP";
      let y = s(o + m), C = n[y];
      o = y, l && l({ action: i, location: C, delta: m });
    },
    listen(m) {
      return l = m, () => {
        l = null;
      };
    }
  };
}
function Fa(e = {}) {
  function t(a, n) {
    let { pathname: o, search: i, hash: l } = a.location;
    return Te(
      "",
      { pathname: o, search: i, hash: l },
      // state defaults to `null` because `window.history.state` does
      n.state && n.state.usr || null,
      n.state && n.state.key || "default"
    );
  }
  function r(a, n) {
    return typeof n == "string" ? n : fe(n);
  }
  return Aa(
    t,
    r,
    null,
    e
  );
}
function ka(e = {}) {
  function t(n, o) {
    let {
      pathname: i = "/",
      search: l = "",
      hash: s = ""
    } = Ee(n.location.hash.substring(1));
    return !i.startsWith("/") && !i.startsWith(".") && (i = "/" + i), Te(
      "",
      { pathname: i, search: l, hash: s },
      // state defaults to `null` because `window.history.state` does
      o.state && o.state.usr || null,
      o.state && o.state.key || "default"
    );
  }
  function r(n, o) {
    let i = n.document.querySelector("base"), l = "";
    if (i && i.getAttribute("href")) {
      let s = n.location.href, u = s.indexOf("#");
      l = u === -1 ? s : s.slice(0, u);
    }
    return l + "#" + (typeof o == "string" ? o : fe(o));
  }
  function a(n, o) {
    V(
      n.pathname.charAt(0) === "/",
      `relative pathnames are not supported in hash history.push(${JSON.stringify(
        o
      )})`
    );
  }
  return Aa(
    t,
    r,
    a,
    e
  );
}
function I(e, t) {
  if (e === !1 || e === null || typeof e > "u")
    throw new Error(t);
}
function V(e, t) {
  if (!e) {
    typeof console < "u" && console.warn(t);
    try {
      throw new Error(t);
    } catch {
    }
  }
}
function bo() {
  return Math.random().toString(36).substring(2, 10);
}
function sa(e, t) {
  return {
    usr: e.state,
    key: e.key,
    idx: t
  };
}
function Te(e, t, r = null, a) {
  return {
    pathname: typeof e == "string" ? e : e.pathname,
    search: "",
    hash: "",
    ...typeof t == "string" ? Ee(t) : t,
    state: r,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: t && t.key || a || bo()
  };
}
function fe({
  pathname: e = "/",
  search: t = "",
  hash: r = ""
}) {
  return t && t !== "?" && (e += t.charAt(0) === "?" ? t : "?" + t), r && r !== "#" && (e += r.charAt(0) === "#" ? r : "#" + r), e;
}
function Ee(e) {
  let t = {};
  if (e) {
    let r = e.indexOf("#");
    r >= 0 && (t.hash = e.substring(r), e = e.substring(0, r));
    let a = e.indexOf("?");
    a >= 0 && (t.search = e.substring(a), e = e.substring(0, a)), e && (t.pathname = e);
  }
  return t;
}
function Aa(e, t, r, a = {}) {
  let { window: n = document.defaultView, v5Compat: o = !1 } = a, i = n.history, l = "POP", s = null, u = d();
  u == null && (u = 0, i.replaceState({ ...i.state, idx: u }, ""));
  function d() {
    return (i.state || { idx: null }).idx;
  }
  function f() {
    l = "POP";
    let g = d(), b = g == null ? null : g - u;
    u = g, s && s({ action: l, location: C.location, delta: b });
  }
  function h(g, b) {
    l = "PUSH";
    let R = Te(C.location, g, b);
    r && r(R, g), u = d() + 1;
    let x = sa(R, u), P = C.createHref(R);
    try {
      i.pushState(x, "", P);
    } catch (E) {
      if (E instanceof DOMException && E.name === "DataCloneError")
        throw E;
      n.location.assign(P);
    }
    o && s && s({ action: l, location: C.location, delta: 1 });
  }
  function m(g, b) {
    l = "REPLACE";
    let R = Te(C.location, g, b);
    r && r(R, g), u = d();
    let x = sa(R, u), P = C.createHref(R);
    i.replaceState(x, "", P), o && s && s({ action: l, location: C.location, delta: 0 });
  }
  function y(g) {
    return Ia(g);
  }
  let C = {
    get action() {
      return l;
    },
    get location() {
      return e(n, i);
    },
    listen(g) {
      if (s)
        throw new Error("A history only accepts one active listener");
      return n.addEventListener(la, f), s = g, () => {
        n.removeEventListener(la, f), s = null;
      };
    },
    createHref(g) {
      return t(n, g);
    },
    createURL: y,
    encodeLocation(g) {
      let b = y(g);
      return {
        pathname: b.pathname,
        search: b.search,
        hash: b.hash
      };
    },
    push: h,
    replace: m,
    go(g) {
      return i.go(g);
    }
  };
  return C;
}
function Ia(e, t = !1) {
  let r = "http://localhost";
  typeof window < "u" && (r = window.location.origin !== "null" ? window.location.origin : window.location.href), I(r, "No window.location.(origin|href) available to create URL");
  let a = typeof e == "string" ? e : fe(e);
  return a = a.replace(/ $/, "%20"), !t && a.startsWith("//") && (a = r + a), new URL(a, r);
}
function as(e) {
  return { defaultValue: e };
}
var ht, et = class {
  /**
   * Create a new `unstable_RouterContextProvider` instance
   * @param init An optional initial context map to populate the provider with
   */
  constructor(e) {
    if (go(this, ht, /* @__PURE__ */ new Map()), e)
      for (let [t, r] of e)
        this.set(t, r);
  }
  /**
   * Access a value from the context. If no value has been set for the context,
   * it will return the context's `defaultValue` if provided, or throw an error
   * if no `defaultValue` was set.
   * @param context The context to get the value for
   * @returns The value for the context, or the context's `defaultValue` if no
   * value was set
   */
  get(e) {
    if (er(this, ht).has(e))
      return er(this, ht).get(e);
    if (e.defaultValue !== void 0)
      return e.defaultValue;
    throw new Error("No value found for context");
  }
  /**
   * Set a value for the context. If the context already has a value set, this
   * will overwrite it.
   *
   * @param context The context to set the value for
   * @param value The value to set for the context
   * @returns {void}
   */
  set(e, t) {
    er(this, ht).set(e, t);
  }
};
ht = /* @__PURE__ */ new WeakMap();
var Eo = /* @__PURE__ */ new Set([
  "lazy",
  "caseSensitive",
  "path",
  "id",
  "index",
  "children"
]);
function Ro(e) {
  return Eo.has(
    e
  );
}
var So = /* @__PURE__ */ new Set([
  "lazy",
  "caseSensitive",
  "path",
  "id",
  "index",
  "unstable_middleware",
  "children"
]);
function Co(e) {
  return So.has(
    e
  );
}
function Po(e) {
  return e.index === !0;
}
function Ve(e, t, r = [], a = {}, n = !1) {
  return e.map((o, i) => {
    let l = [...r, String(i)], s = typeof o.id == "string" ? o.id : l.join("-");
    if (I(
      o.index !== !0 || !o.children,
      "Cannot specify children on an index route"
    ), I(
      n || !a[s],
      `Found a route id collision on id "${s}".  Route id's must be globally unique within Data Router usages`
    ), Po(o)) {
      let u = {
        ...o,
        ...t(o),
        id: s
      };
      return a[s] = u, u;
    } else {
      let u = {
        ...o,
        ...t(o),
        id: s,
        children: void 0
      };
      return a[s] = u, o.children && (u.children = Ve(
        o.children,
        t,
        l,
        a,
        n
      )), u;
    }
  });
}
function Se(e, t, r = "/") {
  return $t(e, t, r, !1);
}
function $t(e, t, r, a) {
  let n = typeof t == "string" ? Ee(t) : t, o = se(n.pathname || "/", r);
  if (o == null)
    return null;
  let i = Ha(e);
  xo(i);
  let l = null;
  for (let s = 0; l == null && s < i.length; ++s) {
    let u = Ba(o);
    l = Fo(
      i[s],
      u,
      a
    );
  }
  return l;
}
function ja(e, t) {
  let { route: r, pathname: a, params: n } = e;
  return {
    id: r.id,
    pathname: a,
    params: n,
    data: t[r.id],
    loaderData: t[r.id],
    handle: r.handle
  };
}
function Ha(e, t = [], r = [], a = "", n = !1) {
  let o = (i, l, s = n, u) => {
    let d = {
      relativePath: u === void 0 ? i.path || "" : u,
      caseSensitive: i.caseSensitive === !0,
      childrenIndex: l,
      route: i
    };
    if (d.relativePath.startsWith("/")) {
      if (!d.relativePath.startsWith(a) && s)
        return;
      I(
        d.relativePath.startsWith(a),
        `Absolute route path "${d.relativePath}" nested under path "${a}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`
      ), d.relativePath = d.relativePath.slice(a.length);
    }
    let f = Le([a, d.relativePath]), h = r.concat(d);
    i.children && i.children.length > 0 && (I(
      // Our types know better, but runtime JS may not!
      // @ts-expect-error
      i.index !== !0,
      `Index routes must not have child routes. Please remove all child routes from route path "${f}".`
    ), Ha(
      i.children,
      t,
      h,
      f,
      s
    )), !(i.path == null && !i.index) && t.push({
      path: f,
      score: $o(f, i.index),
      routesMeta: h
    });
  };
  return e.forEach((i, l) => {
    if (i.path === "" || !i.path?.includes("?"))
      o(i, l);
    else
      for (let s of Ua(i.path))
        o(i, l, !0, s);
  }), t;
}
function Ua(e) {
  let t = e.split("/");
  if (t.length === 0) return [];
  let [r, ...a] = t, n = r.endsWith("?"), o = r.replace(/\?$/, "");
  if (a.length === 0)
    return n ? [o, ""] : [o];
  let i = Ua(a.join("/")), l = [];
  return l.push(
    ...i.map(
      (s) => s === "" ? o : [o, s].join("/")
    )
  ), n && l.push(...i), l.map(
    (s) => e.startsWith("/") && s === "" ? "/" : s
  );
}
function xo(e) {
  e.sort(
    (t, r) => t.score !== r.score ? r.score - t.score : No(
      t.routesMeta.map((a) => a.childrenIndex),
      r.routesMeta.map((a) => a.childrenIndex)
    )
  );
}
var Lo = /^:[\w-]+$/, Do = 3, Mo = 2, To = 1, _o = 10, Oo = -2, ua = (e) => e === "*";
function $o(e, t) {
  let r = e.split("/"), a = r.length;
  return r.some(ua) && (a += Oo), t && (a += Mo), r.filter((n) => !ua(n)).reduce(
    (n, o) => n + (Lo.test(o) ? Do : o === "" ? To : _o),
    a
  );
}
function No(e, t) {
  return e.length === t.length && e.slice(0, -1).every((a, n) => a === t[n]) ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    e[e.length - 1] - t[t.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function Fo(e, t, r = !1) {
  let { routesMeta: a } = e, n = {}, o = "/", i = [];
  for (let l = 0; l < a.length; ++l) {
    let s = a[l], u = l === a.length - 1, d = o === "/" ? t : t.slice(o.length) || "/", f = mt(
      { path: s.relativePath, caseSensitive: s.caseSensitive, end: u },
      d
    ), h = s.route;
    if (!f && u && r && !a[a.length - 1].route.index && (f = mt(
      {
        path: s.relativePath,
        caseSensitive: s.caseSensitive,
        end: !1
      },
      d
    )), !f)
      return null;
    Object.assign(n, f.params), i.push({
      // TODO: Can this as be avoided?
      params: n,
      pathname: Le([o, f.pathname]),
      pathnameBase: jo(
        Le([o, f.pathnameBase])
      ),
      route: h
    }), f.pathnameBase !== "/" && (o = Le([o, f.pathnameBase]));
  }
  return i;
}
function ns(e, t = {}) {
  let r = e;
  r.endsWith("*") && r !== "*" && !r.endsWith("/*") && (V(
    !1,
    `Route path "${r}" will be treated as if it were "${r.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${r.replace(/\*$/, "/*")}".`
  ), r = r.replace(/\*$/, "/*"));
  const a = r.startsWith("/") ? "/" : "", n = (i) => i == null ? "" : typeof i == "string" ? i : String(i), o = r.split(/\/+/).map((i, l, s) => {
    if (l === s.length - 1 && i === "*")
      return n(t["*"]);
    const d = i.match(/^:([\w-]+)(\??)$/);
    if (d) {
      const [, f, h] = d;
      let m = t[f];
      return I(h === "?" || m != null, `Missing ":${f}" param`), encodeURIComponent(n(m));
    }
    return i.replace(/\?$/g, "");
  }).filter((i) => !!i);
  return a + o.join("/");
}
function mt(e, t) {
  typeof e == "string" && (e = { path: e, caseSensitive: !1, end: !0 });
  let [r, a] = za(
    e.path,
    e.caseSensitive,
    e.end
  ), n = t.match(r);
  if (!n) return null;
  let o = n[0], i = o.replace(/(.)\/+$/, "$1"), l = n.slice(1);
  return {
    params: a.reduce(
      (u, { paramName: d, isOptional: f }, h) => {
        if (d === "*") {
          let y = l[h] || "";
          i = o.slice(0, o.length - y.length).replace(/(.)\/+$/, "$1");
        }
        const m = l[h];
        return f && !m ? u[d] = void 0 : u[d] = (m || "").replace(/%2F/g, "/"), u;
      },
      {}
    ),
    pathname: o,
    pathnameBase: i,
    pattern: e
  };
}
function za(e, t = !1, r = !0) {
  V(
    e === "*" || !e.endsWith("*") || e.endsWith("/*"),
    `Route path "${e}" will be treated as if it were "${e.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${e.replace(/\*$/, "/*")}".`
  );
  let a = [], n = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(
    /\/:([\w-]+)(\?)?/g,
    (i, l, s) => (a.push({ paramName: l, isOptional: s != null }), s ? "/?([^\\/]+)?" : "/([^\\/]+)")
  ).replace(/\/([\w-]+)\?(\/|$)/g, "(/$1)?$2");
  return e.endsWith("*") ? (a.push({ paramName: "*" }), n += e === "*" || e === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : r ? n += "\\/*$" : e !== "" && e !== "/" && (n += "(?:(?=\\/|$))"), [new RegExp(n, t ? void 0 : "i"), a];
}
function Ba(e) {
  try {
    return e.split("/").map((t) => decodeURIComponent(t).replace(/\//g, "%2F")).join("/");
  } catch (t) {
    return V(
      !1,
      `The URL path "${e}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${t}).`
    ), e;
  }
}
function se(e, t) {
  if (t === "/") return e;
  if (!e.toLowerCase().startsWith(t.toLowerCase()))
    return null;
  let r = t.endsWith("/") ? t.length - 1 : t.length, a = e.charAt(r);
  return a && a !== "/" ? null : e.slice(r) || "/";
}
function ko({
  basename: e,
  pathname: t
}) {
  return t === "/" ? e : Le([e, t]);
}
function Ao(e, t = "/") {
  let {
    pathname: r,
    search: a = "",
    hash: n = ""
  } = typeof e == "string" ? Ee(e) : e;
  return {
    pathname: r ? r.startsWith("/") ? r : Io(r, t) : t,
    search: Ho(a),
    hash: Uo(n)
  };
}
function Io(e, t) {
  let r = t.replace(/\/+$/, "").split("/");
  return e.split("/").forEach((n) => {
    n === ".." ? r.length > 1 && r.pop() : n !== "." && r.push(n);
  }), r.length > 1 ? r.join("/") : "/";
}
function tr(e, t, r, a) {
  return `Cannot include a '${e}' character in a manually specified \`to.${t}\` field [${JSON.stringify(
    a
  )}].  Please separate it out to the \`to.${r}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`;
}
function Wa(e) {
  return e.filter(
    (t, r) => r === 0 || t.route.path && t.route.path.length > 0
  );
}
function zt(e) {
  let t = Wa(e);
  return t.map(
    (r, a) => a === t.length - 1 ? r.pathname : r.pathnameBase
  );
}
function Bt(e, t, r, a = !1) {
  let n;
  typeof e == "string" ? n = Ee(e) : (n = { ...e }, I(
    !n.pathname || !n.pathname.includes("?"),
    tr("?", "pathname", "search", n)
  ), I(
    !n.pathname || !n.pathname.includes("#"),
    tr("#", "pathname", "hash", n)
  ), I(
    !n.search || !n.search.includes("#"),
    tr("#", "search", "hash", n)
  ));
  let o = e === "" || n.pathname === "", i = o ? "/" : n.pathname, l;
  if (i == null)
    l = r;
  else {
    let f = t.length - 1;
    if (!a && i.startsWith("..")) {
      let h = i.split("/");
      for (; h[0] === ".."; )
        h.shift(), f -= 1;
      n.pathname = h.join("/");
    }
    l = f >= 0 ? t[f] : "/";
  }
  let s = Ao(n, l), u = i && i !== "/" && i.endsWith("/"), d = (o || i === ".") && r.endsWith("/");
  return !s.pathname.endsWith("/") && (u || d) && (s.pathname += "/"), s;
}
var Le = (e) => e.join("/").replace(/\/\/+/g, "/"), jo = (e) => e.replace(/\/+$/, "").replace(/^\/*/, "/"), Ho = (e) => !e || e === "?" ? "" : e.startsWith("?") ? e : "?" + e, Uo = (e) => !e || e === "#" ? "" : e.startsWith("#") ? e : "#" + e, zo = class {
  constructor(e, t) {
    this.type = "DataWithResponseInit", this.data = e, this.init = t || null;
  }
};
function Bo(e, t) {
  return new zo(
    e,
    typeof t == "number" ? { status: t } : t
  );
}
var Sr = (e, t = 302) => {
  let r = t;
  typeof r == "number" ? r = { status: r } : typeof r.status > "u" && (r.status = 302);
  let a = new Headers(r.headers);
  return a.set("Location", e), new Response(null, { ...r, headers: a });
}, os = (e, t) => {
  let r = Sr(e, t);
  return r.headers.set("X-Remix-Reload-Document", "true"), r;
}, is = (e, t) => {
  let r = Sr(e, t);
  return r.headers.set("X-Remix-Replace", "true"), r;
}, De = class {
  constructor(e, t, r, a = !1) {
    this.status = e, this.statusText = t || "", this.internal = a, r instanceof Error ? (this.data = r.toString(), this.error = r) : this.data = r;
  }
};
function be(e) {
  return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.internal == "boolean" && "data" in e;
}
var Ya = [
  "POST",
  "PUT",
  "PATCH",
  "DELETE"
], Wo = new Set(
  Ya
), Yo = [
  "GET",
  ...Ya
], Jo = new Set(Yo), Ja = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]), Vo = /* @__PURE__ */ new Set([307, 308]), Nt = {
  state: "idle",
  location: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0,
  json: void 0,
  text: void 0
}, Cr = {
  state: "idle",
  data: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0,
  json: void 0,
  text: void 0
}, Ye = {
  state: "unblocked",
  proceed: void 0,
  reset: void 0,
  location: void 0
}, Ko = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, Pr = (e) => Ko.test(e), Va = (e) => ({
  hasErrorBoundary: !!e.hasErrorBoundary
}), Ka = "remix-router-transitions", Xa = Symbol("ResetLoaderData");
function xr(e) {
  const t = e.window ? e.window : typeof window < "u" ? window : void 0, r = typeof t < "u" && typeof t.document < "u" && typeof t.document.createElement < "u";
  I(
    e.routes.length > 0,
    "You must provide a non-empty routes array to createRouter"
  );
  let a = e.hydrationRouteProperties || [], n = e.mapRouteProperties || Va, o = {}, i = Ve(
    e.routes,
    n,
    void 0,
    o
  ), l, s = e.basename || "/";
  s.startsWith("/") || (s = `/${s}`);
  let u = e.dataStrategy || ri, d = {
    ...e.future
  }, f = null, h = /* @__PURE__ */ new Set(), m = null, y = null, C = null, g = e.hydrationData != null, b = Se(i, e.history.location, s), R = !1, x = null, P;
  if (b == null && !e.patchRoutesOnNavigation) {
    let p = Z(404, {
      pathname: e.history.location.pathname
    }), { matches: w, route: S } = tt(i);
    P = !0, b = w, x = { [S.id]: p };
  } else if (b && !e.hydrationData && St(
    b,
    i,
    e.history.location.pathname
  ).active && (b = null), b)
    if (b.some((p) => p.route.lazy))
      P = !1;
    else if (!b.some((p) => p.route.loader))
      P = !0;
    else {
      let p = e.hydrationData ? e.hydrationData.loaderData : null, w = e.hydrationData ? e.hydrationData.errors : null;
      if (w) {
        let S = b.findIndex(
          (L) => w[L.route.id] !== void 0
        );
        P = b.slice(0, S + 1).every(
          (L) => !sr(L.route, p, w)
        );
      } else
        P = b.every(
          (S) => !sr(S.route, p, w)
        );
    }
  else {
    P = !1, b = [];
    let p = St(
      null,
      i,
      e.history.location.pathname
    );
    p.active && p.matches && (R = !0, b = p.matches);
  }
  let E, v = {
    historyAction: e.history.action,
    location: e.history.location,
    matches: b,
    initialized: P,
    navigation: Nt,
    // Don't restore on initial updateState() if we were SSR'd
    restoreScrollPosition: e.hydrationData != null ? !1 : null,
    preventScrollReset: !1,
    revalidation: "idle",
    loaderData: e.hydrationData && e.hydrationData.loaderData || {},
    actionData: e.hydrationData && e.hydrationData.actionData || null,
    errors: e.hydrationData && e.hydrationData.errors || x,
    fetchers: /* @__PURE__ */ new Map(),
    blockers: /* @__PURE__ */ new Map()
  }, _ = "POP", D = !1, T, $ = !1, U = /* @__PURE__ */ new Map(), K = null, z = !1, J = !1, ue = /* @__PURE__ */ new Set(), B = /* @__PURE__ */ new Map(), ye = 0, ce = -1, Re = /* @__PURE__ */ new Map(), de = /* @__PURE__ */ new Set(), ve = /* @__PURE__ */ new Map(), Ce = /* @__PURE__ */ new Map(), Pe = /* @__PURE__ */ new Set(), je = /* @__PURE__ */ new Map(), Et, lt = null;
  function qn() {
    if (f = e.history.listen(
      ({ action: p, location: w, delta: S }) => {
        if (Et) {
          Et(), Et = void 0;
          return;
        }
        V(
          je.size === 0 || S != null,
          "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL."
        );
        let L = aa({
          currentLocation: v.location,
          nextLocation: w,
          historyAction: p
        });
        if (L && S != null) {
          let M = new Promise((N) => {
            Et = N;
          });
          e.history.go(S * -1), Rt(L, {
            state: "blocked",
            location: w,
            proceed() {
              Rt(L, {
                state: "proceeding",
                proceed: void 0,
                reset: void 0,
                location: w
              }), M.then(() => e.history.go(S));
            },
            reset() {
              let N = new Map(v.blockers);
              N.set(L, Ye), re({ blockers: N });
            }
          });
          return;
        }
        return He(p, w);
      }
    ), r) {
      ci(t, U);
      let p = () => di(t, U);
      t.addEventListener("pagehide", p), K = () => t.removeEventListener("pagehide", p);
    }
    return v.initialized || He("POP", v.location, {
      initialHydration: !0
    }), E;
  }
  function eo() {
    f && f(), K && K(), h.clear(), T && T.abort(), v.fetchers.forEach((p, w) => Qt(w)), v.blockers.forEach((p, w) => ra(w));
  }
  function to(p) {
    return h.add(p), () => h.delete(p);
  }
  function re(p, w = {}) {
    p.matches && (p.matches = p.matches.map((M) => {
      let N = o[M.route.id], k = M.route;
      return k.element !== N.element || k.errorElement !== N.errorElement || k.hydrateFallbackElement !== N.hydrateFallbackElement ? {
        ...M,
        route: N
      } : M;
    })), v = {
      ...v,
      ...p
    };
    let S = [], L = [];
    v.fetchers.forEach((M, N) => {
      M.state === "idle" && (Pe.has(N) ? S.push(N) : L.push(N));
    }), Pe.forEach((M) => {
      !v.fetchers.has(M) && !B.has(M) && S.push(M);
    }), [...h].forEach(
      (M) => M(v, {
        deletedFetchers: S,
        viewTransitionOpts: w.viewTransitionOpts,
        flushSync: w.flushSync === !0
      })
    ), S.forEach((M) => Qt(M)), L.forEach((M) => v.fetchers.delete(M));
  }
  function Qe(p, w, { flushSync: S } = {}) {
    let L = v.actionData != null && v.navigation.formMethod != null && le(v.navigation.formMethod) && v.navigation.state === "loading" && p.state?._isRedirect !== !0, M;
    w.actionData ? Object.keys(w.actionData).length > 0 ? M = w.actionData : M = null : L ? M = v.actionData : M = null;
    let N = w.loaderData ? Ea(
      v.loaderData,
      w.loaderData,
      w.matches || [],
      w.errors
    ) : v.loaderData, k = v.blockers;
    k.size > 0 && (k = new Map(k), k.forEach((A, F) => k.set(F, Ye)));
    let O = z ? !1 : oa(p, w.matches || v.matches), j = D === !0 || v.navigation.formMethod != null && le(v.navigation.formMethod) && p.state?._isRedirect !== !0;
    l && (i = l, l = void 0), z || _ === "POP" || (_ === "PUSH" ? e.history.push(p, p.state) : _ === "REPLACE" && e.history.replace(p, p.state));
    let H;
    if (_ === "POP") {
      let A = U.get(v.location.pathname);
      A && A.has(p.pathname) ? H = {
        currentLocation: v.location,
        nextLocation: p
      } : U.has(p.pathname) && (H = {
        currentLocation: p,
        nextLocation: v.location
      });
    } else if ($) {
      let A = U.get(v.location.pathname);
      A ? A.add(p.pathname) : (A = /* @__PURE__ */ new Set([p.pathname]), U.set(v.location.pathname, A)), H = {
        currentLocation: v.location,
        nextLocation: p
      };
    }
    re(
      {
        ...w,
        // matches, errors, fetchers go through as-is
        actionData: M,
        loaderData: N,
        historyAction: _,
        location: p,
        initialized: !0,
        navigation: Nt,
        revalidation: "idle",
        restoreScrollPosition: O,
        preventScrollReset: j,
        blockers: k
      },
      {
        viewTransitionOpts: H,
        flushSync: S === !0
      }
    ), _ = "POP", D = !1, $ = !1, z = !1, J = !1, lt?.resolve(), lt = null;
  }
  async function Xr(p, w) {
    if (typeof p == "number") {
      e.history.go(p);
      return;
    }
    let S = lr(
      v.location,
      v.matches,
      s,
      p,
      w?.fromRouteId,
      w?.relative
    ), { path: L, submission: M, error: N } = da(
      !1,
      S,
      w
    ), k = v.location, O = Te(v.location, L, w && w.state);
    O = {
      ...O,
      ...e.history.encodeLocation(O)
    };
    let j = w && w.replace != null ? w.replace : void 0, H = "PUSH";
    j === !0 ? H = "REPLACE" : j === !1 || M != null && le(M.formMethod) && M.formAction === v.location.pathname + v.location.search && (H = "REPLACE");
    let A = w && "preventScrollReset" in w ? w.preventScrollReset === !0 : void 0, F = (w && w.flushSync) === !0, W = aa({
      currentLocation: k,
      nextLocation: O,
      historyAction: H
    });
    if (W) {
      Rt(W, {
        state: "blocked",
        location: O,
        proceed() {
          Rt(W, {
            state: "proceeding",
            proceed: void 0,
            reset: void 0,
            location: O
          }), Xr(p, w);
        },
        reset() {
          let G = new Map(v.blockers);
          G.set(W, Ye), re({ blockers: G });
        }
      });
      return;
    }
    await He(H, O, {
      submission: M,
      // Send through the formData serialization error if we have one so we can
      // render at the right error boundary after we match routes
      pendingError: N,
      preventScrollReset: A,
      replace: w && w.replace,
      enableViewTransition: w && w.viewTransition,
      flushSync: F
    });
  }
  function ro() {
    lt || (lt = fi()), Gt(), re({ revalidation: "loading" });
    let p = lt.promise;
    return v.navigation.state === "submitting" ? p : v.navigation.state === "idle" ? (He(v.historyAction, v.location, {
      startUninterruptedRevalidation: !0
    }), p) : (He(
      _ || v.historyAction,
      v.navigation.location,
      {
        overrideNavigation: v.navigation,
        // Proxy through any rending view transition
        enableViewTransition: $ === !0
      }
    ), p);
  }
  async function He(p, w, S) {
    T && T.abort(), T = null, _ = p, z = (S && S.startUninterruptedRevalidation) === !0, ho(v.location, v.matches), D = (S && S.preventScrollReset) === !0, $ = (S && S.enableViewTransition) === !0;
    let L = l || i, M = S && S.overrideNavigation, N = S?.initialHydration && v.matches && v.matches.length > 0 && !R ? (
      // `matchRoutes()` has already been called if we're in here via `router.initialize()`
      v.matches
    ) : Se(L, w, s), k = (S && S.flushSync) === !0;
    if (N && v.initialized && !J && ni(v.location, w) && !(S && S.submission && le(S.submission.formMethod))) {
      Qe(w, { matches: N }, { flushSync: k });
      return;
    }
    let O = St(N, L, w.pathname);
    if (O.active && O.matches && (N = O.matches), !N) {
      let { error: ie, notFoundMatches: Q, route: X } = Zt(
        w.pathname
      );
      Qe(
        w,
        {
          matches: Q,
          loaderData: {},
          errors: {
            [X.id]: ie
          }
        },
        { flushSync: k }
      );
      return;
    }
    T = new AbortController();
    let j = qe(
      e.history,
      w,
      T.signal,
      S && S.submission
    ), H = e.unstable_getContext ? await e.unstable_getContext() : new et(), A;
    if (S && S.pendingError)
      A = [
        we(N).route.id,
        { type: "error", error: S.pendingError }
      ];
    else if (S && S.submission && le(S.submission.formMethod)) {
      let ie = await ao(
        j,
        w,
        S.submission,
        N,
        H,
        O.active,
        S && S.initialHydration === !0,
        { replace: S.replace, flushSync: k }
      );
      if (ie.shortCircuited)
        return;
      if (ie.pendingActionResult) {
        let [Q, X] = ie.pendingActionResult;
        if (te(X) && be(X.error) && X.error.status === 404) {
          T = null, Qe(w, {
            matches: ie.matches,
            loaderData: {},
            errors: {
              [Q]: X.error
            }
          });
          return;
        }
      }
      N = ie.matches || N, A = ie.pendingActionResult, M = rr(w, S.submission), k = !1, O.active = !1, j = qe(
        e.history,
        j.url,
        j.signal
      );
    }
    let {
      shortCircuited: F,
      matches: W,
      loaderData: G,
      errors: ee
    } = await no(
      j,
      w,
      N,
      H,
      O.active,
      M,
      S && S.submission,
      S && S.fetcherSubmission,
      S && S.replace,
      S && S.initialHydration === !0,
      k,
      A
    );
    F || (T = null, Qe(w, {
      matches: W || N,
      ...Ra(A),
      loaderData: G,
      errors: ee
    }));
  }
  async function ao(p, w, S, L, M, N, k, O = {}) {
    Gt();
    let j = si(w, S);
    if (re({ navigation: j }, { flushSync: O.flushSync === !0 }), N) {
      let F = await Ct(
        L,
        w.pathname,
        p.signal
      );
      if (F.type === "aborted")
        return { shortCircuited: !0 };
      if (F.type === "error") {
        if (F.partialMatches.length === 0) {
          let { matches: G, route: ee } = tt(i);
          return {
            matches: G,
            pendingActionResult: [
              ee.id,
              {
                type: "error",
                error: F.error
              }
            ]
          };
        }
        let W = we(F.partialMatches).route.id;
        return {
          matches: F.partialMatches,
          pendingActionResult: [
            W,
            {
              type: "error",
              error: F.error
            }
          ]
        };
      } else if (F.matches)
        L = F.matches;
      else {
        let { notFoundMatches: W, error: G, route: ee } = Zt(
          w.pathname
        );
        return {
          matches: W,
          pendingActionResult: [
            ee.id,
            {
              type: "error",
              error: G
            }
          ]
        };
      }
    }
    let H, A = rt(L, w);
    if (!A.route.action && !A.route.lazy)
      H = {
        type: "error",
        error: Z(405, {
          method: p.method,
          pathname: w.pathname,
          routeId: A.route.id
        })
      };
    else {
      let F = Ae(
        n,
        o,
        p,
        L,
        A,
        k ? [] : a,
        M
      ), W = await st(
        p,
        F,
        M,
        null
      );
      if (H = W[A.route.id], !H) {
        for (let G of L)
          if (W[G.route.id]) {
            H = W[G.route.id];
            break;
          }
      }
      if (p.signal.aborted)
        return { shortCircuited: !0 };
    }
    if (ke(H)) {
      let F;
      return O && O.replace != null ? F = O.replace : F = ga(
        H.response.headers.get("Location"),
        new URL(p.url),
        s
      ) === v.location.pathname + v.location.search, await Ue(p, H, !0, {
        submission: S,
        replace: F
      }), { shortCircuited: !0 };
    }
    if (te(H)) {
      let F = we(L, A.route.id);
      return (O && O.replace) !== !0 && (_ = "PUSH"), {
        matches: L,
        pendingActionResult: [
          F.route.id,
          H,
          A.route.id
        ]
      };
    }
    return {
      matches: L,
      pendingActionResult: [A.route.id, H]
    };
  }
  async function no(p, w, S, L, M, N, k, O, j, H, A, F) {
    let W = N || rr(w, k), G = k || O || Ca(W), ee = !z && !H;
    if (M) {
      if (ee) {
        let ae = Gr(F);
        re(
          {
            navigation: W,
            ...ae !== void 0 ? { actionData: ae } : {}
          },
          {
            flushSync: A
          }
        );
      }
      let Y = await Ct(
        S,
        w.pathname,
        p.signal
      );
      if (Y.type === "aborted")
        return { shortCircuited: !0 };
      if (Y.type === "error") {
        if (Y.partialMatches.length === 0) {
          let { matches: Ze, route: We } = tt(i);
          return {
            matches: Ze,
            loaderData: {},
            errors: {
              [We.id]: Y.error
            }
          };
        }
        let ae = we(Y.partialMatches).route.id;
        return {
          matches: Y.partialMatches,
          loaderData: {},
          errors: {
            [ae]: Y.error
          }
        };
      } else if (Y.matches)
        S = Y.matches;
      else {
        let { error: ae, notFoundMatches: Ze, route: We } = Zt(
          w.pathname
        );
        return {
          matches: Ze,
          loaderData: {},
          errors: {
            [We.id]: ae
          }
        };
      }
    }
    let ie = l || i, { dsMatches: Q, revalidatingFetchers: X } = fa(
      p,
      L,
      n,
      o,
      e.history,
      v,
      S,
      G,
      w,
      H ? [] : a,
      H === !0,
      J,
      ue,
      Pe,
      ve,
      de,
      ie,
      s,
      e.patchRoutesOnNavigation != null,
      F
    );
    if (ce = ++ye, !e.dataStrategy && !Q.some((Y) => Y.shouldLoad) && !Q.some((Y) => Y.route.unstable_middleware) && X.length === 0) {
      let Y = ea();
      return Qe(
        w,
        {
          matches: S,
          loaderData: {},
          // Commit pending error if we're short circuiting
          errors: F && te(F[1]) ? { [F[0]]: F[1].error } : null,
          ...Ra(F),
          ...Y ? { fetchers: new Map(v.fetchers) } : {}
        },
        { flushSync: A }
      ), { shortCircuited: !0 };
    }
    if (ee) {
      let Y = {};
      if (!M) {
        Y.navigation = W;
        let ae = Gr(F);
        ae !== void 0 && (Y.actionData = ae);
      }
      X.length > 0 && (Y.fetchers = oo(X)), re(Y, { flushSync: A });
    }
    X.forEach((Y) => {
      $e(Y.key), Y.controller && B.set(Y.key, Y.controller);
    });
    let ze = () => X.forEach((Y) => $e(Y.key));
    T && T.signal.addEventListener(
      "abort",
      ze
    );
    let { loaderResults: ut, fetcherResults: Ne } = await Qr(
      Q,
      X,
      p,
      L
    );
    if (p.signal.aborted)
      return { shortCircuited: !0 };
    T && T.signal.removeEventListener(
      "abort",
      ze
    ), X.forEach((Y) => B.delete(Y.key));
    let xe = Dt(ut);
    if (xe)
      return await Ue(p, xe.result, !0, {
        replace: j
      }), { shortCircuited: !0 };
    if (xe = Dt(Ne), xe)
      return de.add(xe.key), await Ue(p, xe.result, !0, {
        replace: j
      }), { shortCircuited: !0 };
    let { loaderData: qt, errors: ct } = ba(
      v,
      S,
      ut,
      F,
      X,
      Ne
    );
    H && v.errors && (ct = { ...v.errors, ...ct });
    let Be = ea(), Pt = ta(ce), xt = Be || Pt || X.length > 0;
    return {
      matches: S,
      loaderData: qt,
      errors: ct,
      ...xt ? { fetchers: new Map(v.fetchers) } : {}
    };
  }
  function Gr(p) {
    if (p && !te(p[1]))
      return {
        [p[0]]: p[1].data
      };
    if (v.actionData)
      return Object.keys(v.actionData).length === 0 ? null : v.actionData;
  }
  function oo(p) {
    return p.forEach((w) => {
      let S = v.fetchers.get(w.key), L = dt(
        void 0,
        S ? S.data : void 0
      );
      v.fetchers.set(w.key, L);
    }), new Map(v.fetchers);
  }
  async function io(p, w, S, L) {
    $e(p);
    let M = (L && L.flushSync) === !0, N = l || i, k = lr(
      v.location,
      v.matches,
      s,
      S,
      w,
      L?.relative
    ), O = Se(N, k, s), j = St(O, N, k);
    if (j.active && j.matches && (O = j.matches), !O) {
      Me(
        p,
        w,
        Z(404, { pathname: k }),
        { flushSync: M }
      );
      return;
    }
    let { path: H, submission: A, error: F } = da(
      !0,
      k,
      L
    );
    if (F) {
      Me(p, w, F, { flushSync: M });
      return;
    }
    let W = e.unstable_getContext ? await e.unstable_getContext() : new et(), G = (L && L.preventScrollReset) === !0;
    if (A && le(A.formMethod)) {
      await lo(
        p,
        w,
        H,
        O,
        W,
        j.active,
        M,
        G,
        A
      );
      return;
    }
    ve.set(p, { routeId: w, path: H }), await so(
      p,
      w,
      H,
      O,
      W,
      j.active,
      M,
      G,
      A
    );
  }
  async function lo(p, w, S, L, M, N, k, O, j) {
    Gt(), ve.delete(p);
    let H = v.fetchers.get(p);
    Oe(p, ui(j, H), {
      flushSync: k
    });
    let A = new AbortController(), F = qe(
      e.history,
      S,
      A.signal,
      j
    );
    if (N) {
      let q = await Ct(
        L,
        new URL(F.url).pathname,
        F.signal,
        p
      );
      if (q.type === "aborted")
        return;
      if (q.type === "error") {
        Me(p, w, q.error, { flushSync: k });
        return;
      } else if (q.matches)
        L = q.matches;
      else {
        Me(
          p,
          w,
          Z(404, { pathname: S }),
          { flushSync: k }
        );
        return;
      }
    }
    let W = rt(L, S);
    if (!W.route.action && !W.route.lazy) {
      let q = Z(405, {
        method: j.formMethod,
        pathname: S,
        routeId: w
      });
      Me(p, w, q, { flushSync: k });
      return;
    }
    B.set(p, A);
    let G = ye, ee = Ae(
      n,
      o,
      F,
      L,
      W,
      a,
      M
    ), Q = (await st(
      F,
      ee,
      M,
      p
    ))[W.route.id];
    if (F.signal.aborted) {
      B.get(p) === A && B.delete(p);
      return;
    }
    if (Pe.has(p)) {
      if (ke(Q) || te(Q)) {
        Oe(p, Fe(void 0));
        return;
      }
    } else {
      if (ke(Q))
        if (B.delete(p), ce > G) {
          Oe(p, Fe(void 0));
          return;
        } else
          return de.add(p), Oe(p, dt(j)), Ue(F, Q, !1, {
            fetcherSubmission: j,
            preventScrollReset: O
          });
      if (te(Q)) {
        Me(p, w, Q.error);
        return;
      }
    }
    let X = v.navigation.location || v.location, ze = qe(
      e.history,
      X,
      A.signal
    ), ut = l || i, Ne = v.navigation.state !== "idle" ? Se(ut, v.navigation.location, s) : v.matches;
    I(Ne, "Didn't find any matches after fetcher action");
    let xe = ++ye;
    Re.set(p, xe);
    let qt = dt(j, Q.data);
    v.fetchers.set(p, qt);
    let { dsMatches: ct, revalidatingFetchers: Be } = fa(
      ze,
      M,
      n,
      o,
      e.history,
      v,
      Ne,
      j,
      X,
      a,
      !1,
      J,
      ue,
      Pe,
      ve,
      de,
      ut,
      s,
      e.patchRoutesOnNavigation != null,
      [W.route.id, Q]
    );
    Be.filter((q) => q.key !== p).forEach((q) => {
      let Lt = q.key, ia = v.fetchers.get(Lt), yo = dt(
        void 0,
        ia ? ia.data : void 0
      );
      v.fetchers.set(Lt, yo), $e(Lt), q.controller && B.set(Lt, q.controller);
    }), re({ fetchers: new Map(v.fetchers) });
    let Pt = () => Be.forEach((q) => $e(q.key));
    A.signal.addEventListener(
      "abort",
      Pt
    );
    let { loaderResults: xt, fetcherResults: Y } = await Qr(
      ct,
      Be,
      ze,
      M
    );
    if (A.signal.aborted)
      return;
    if (A.signal.removeEventListener(
      "abort",
      Pt
    ), Re.delete(p), B.delete(p), Be.forEach((q) => B.delete(q.key)), v.fetchers.has(p)) {
      let q = Fe(Q.data);
      v.fetchers.set(p, q);
    }
    let ae = Dt(xt);
    if (ae)
      return Ue(
        ze,
        ae.result,
        !1,
        { preventScrollReset: O }
      );
    if (ae = Dt(Y), ae)
      return de.add(ae.key), Ue(
        ze,
        ae.result,
        !1,
        { preventScrollReset: O }
      );
    let { loaderData: Ze, errors: We } = ba(
      v,
      Ne,
      xt,
      void 0,
      Be,
      Y
    );
    ta(xe), v.navigation.state === "loading" && xe > ce ? (I(_, "Expected pending action"), T && T.abort(), Qe(v.navigation.location, {
      matches: Ne,
      loaderData: Ze,
      errors: We,
      fetchers: new Map(v.fetchers)
    })) : (re({
      errors: We,
      loaderData: Ea(
        v.loaderData,
        Ze,
        Ne,
        We
      ),
      fetchers: new Map(v.fetchers)
    }), J = !1);
  }
  async function so(p, w, S, L, M, N, k, O, j) {
    let H = v.fetchers.get(p);
    Oe(
      p,
      dt(
        j,
        H ? H.data : void 0
      ),
      { flushSync: k }
    );
    let A = new AbortController(), F = qe(
      e.history,
      S,
      A.signal
    );
    if (N) {
      let X = await Ct(
        L,
        new URL(F.url).pathname,
        F.signal,
        p
      );
      if (X.type === "aborted")
        return;
      if (X.type === "error") {
        Me(p, w, X.error, { flushSync: k });
        return;
      } else if (X.matches)
        L = X.matches;
      else {
        Me(
          p,
          w,
          Z(404, { pathname: S }),
          { flushSync: k }
        );
        return;
      }
    }
    let W = rt(L, S);
    B.set(p, A);
    let G = ye, ee = Ae(
      n,
      o,
      F,
      L,
      W,
      a,
      M
    ), Q = (await st(
      F,
      ee,
      M,
      p
    ))[W.route.id];
    if (B.get(p) === A && B.delete(p), !F.signal.aborted) {
      if (Pe.has(p)) {
        Oe(p, Fe(void 0));
        return;
      }
      if (ke(Q))
        if (ce > G) {
          Oe(p, Fe(void 0));
          return;
        } else {
          de.add(p), await Ue(F, Q, !1, {
            preventScrollReset: O
          });
          return;
        }
      if (te(Q)) {
        Me(p, w, Q.error);
        return;
      }
      Oe(p, Fe(Q.data));
    }
  }
  async function Ue(p, w, S, {
    submission: L,
    fetcherSubmission: M,
    preventScrollReset: N,
    replace: k
  } = {}) {
    w.response.headers.has("X-Remix-Revalidate") && (J = !0);
    let O = w.response.headers.get("Location");
    I(O, "Expected a Location header on the redirect Response"), O = ga(
      O,
      new URL(p.url),
      s
    );
    let j = Te(v.location, O, {
      _isRedirect: !0
    });
    if (r) {
      let ee = !1;
      if (w.response.headers.has("X-Remix-Reload-Document"))
        ee = !0;
      else if (Pr(O)) {
        const ie = Ia(O, !0);
        ee = // Hard reload if it's an absolute URL to a new origin
        ie.origin !== t.location.origin || // Hard reload if it's an absolute URL that does not match our basename
        se(ie.pathname, s) == null;
      }
      if (ee) {
        k ? t.location.replace(O) : t.location.assign(O);
        return;
      }
    }
    T = null;
    let H = k === !0 || w.response.headers.has("X-Remix-Replace") ? "REPLACE" : "PUSH", { formMethod: A, formAction: F, formEncType: W } = v.navigation;
    !L && !M && A && F && W && (L = Ca(v.navigation));
    let G = L || M;
    if (Vo.has(w.response.status) && G && le(G.formMethod))
      await He(H, j, {
        submission: {
          ...G,
          formAction: O
        },
        // Preserve these flags across redirects
        preventScrollReset: N || D,
        enableViewTransition: S ? $ : void 0
      });
    else {
      let ee = rr(
        j,
        L
      );
      await He(H, j, {
        overrideNavigation: ee,
        // Send fetcher submissions through for shouldRevalidate
        fetcherSubmission: M,
        // Preserve these flags across redirects
        preventScrollReset: N || D,
        enableViewTransition: S ? $ : void 0
      });
    }
  }
  async function st(p, w, S, L) {
    let M, N = {};
    try {
      M = await tn(
        u,
        p,
        w,
        L,
        S,
        !1
      );
    } catch (k) {
      return w.filter((O) => O.shouldLoad).forEach((O) => {
        N[O.route.id] = {
          type: "error",
          error: k
        };
      }), N;
    }
    if (p.signal.aborted)
      return N;
    for (let [k, O] of Object.entries(M))
      if (un(O)) {
        let j = O.result;
        N[k] = {
          type: "redirect",
          response: nn(
            j,
            p,
            k,
            w,
            s
          )
        };
      } else
        N[k] = await an(O);
    return N;
  }
  async function Qr(p, w, S, L) {
    let M = st(
      S,
      p,
      L,
      null
    ), N = Promise.all(
      w.map(async (j) => {
        if (j.matches && j.match && j.request && j.controller) {
          let A = (await st(
            j.request,
            j.matches,
            L,
            j.key
          ))[j.match.route.id];
          return { [j.key]: A };
        } else
          return Promise.resolve({
            [j.key]: {
              type: "error",
              error: Z(404, {
                pathname: j.path
              })
            }
          });
      })
    ), k = await M, O = (await N).reduce(
      (j, H) => Object.assign(j, H),
      {}
    );
    return {
      loaderResults: k,
      fetcherResults: O
    };
  }
  function Gt() {
    J = !0, ve.forEach((p, w) => {
      B.has(w) && ue.add(w), $e(w);
    });
  }
  function Oe(p, w, S = {}) {
    v.fetchers.set(p, w), re(
      { fetchers: new Map(v.fetchers) },
      { flushSync: (S && S.flushSync) === !0 }
    );
  }
  function Me(p, w, S, L = {}) {
    let M = we(v.matches, w);
    Qt(p), re(
      {
        errors: {
          [M.route.id]: S
        },
        fetchers: new Map(v.fetchers)
      },
      { flushSync: (L && L.flushSync) === !0 }
    );
  }
  function Zr(p) {
    return Ce.set(p, (Ce.get(p) || 0) + 1), Pe.has(p) && Pe.delete(p), v.fetchers.get(p) || Cr;
  }
  function Qt(p) {
    let w = v.fetchers.get(p);
    B.has(p) && !(w && w.state === "loading" && Re.has(p)) && $e(p), ve.delete(p), Re.delete(p), de.delete(p), Pe.delete(p), ue.delete(p), v.fetchers.delete(p);
  }
  function uo(p) {
    let w = (Ce.get(p) || 0) - 1;
    w <= 0 ? (Ce.delete(p), Pe.add(p)) : Ce.set(p, w), re({ fetchers: new Map(v.fetchers) });
  }
  function $e(p) {
    let w = B.get(p);
    w && (w.abort(), B.delete(p));
  }
  function qr(p) {
    for (let w of p) {
      let S = Zr(w), L = Fe(S.data);
      v.fetchers.set(w, L);
    }
  }
  function ea() {
    let p = [], w = !1;
    for (let S of de) {
      let L = v.fetchers.get(S);
      I(L, `Expected fetcher: ${S}`), L.state === "loading" && (de.delete(S), p.push(S), w = !0);
    }
    return qr(p), w;
  }
  function ta(p) {
    let w = [];
    for (let [S, L] of Re)
      if (L < p) {
        let M = v.fetchers.get(S);
        I(M, `Expected fetcher: ${S}`), M.state === "loading" && ($e(S), Re.delete(S), w.push(S));
      }
    return qr(w), w.length > 0;
  }
  function co(p, w) {
    let S = v.blockers.get(p) || Ye;
    return je.get(p) !== w && je.set(p, w), S;
  }
  function ra(p) {
    v.blockers.delete(p), je.delete(p);
  }
  function Rt(p, w) {
    let S = v.blockers.get(p) || Ye;
    I(
      S.state === "unblocked" && w.state === "blocked" || S.state === "blocked" && w.state === "blocked" || S.state === "blocked" && w.state === "proceeding" || S.state === "blocked" && w.state === "unblocked" || S.state === "proceeding" && w.state === "unblocked",
      `Invalid blocker state transition: ${S.state} -> ${w.state}`
    );
    let L = new Map(v.blockers);
    L.set(p, w), re({ blockers: L });
  }
  function aa({
    currentLocation: p,
    nextLocation: w,
    historyAction: S
  }) {
    if (je.size === 0)
      return;
    je.size > 1 && V(!1, "A router only supports one blocker at a time");
    let L = Array.from(je.entries()), [M, N] = L[L.length - 1], k = v.blockers.get(M);
    if (!(k && k.state === "proceeding") && N({ currentLocation: p, nextLocation: w, historyAction: S }))
      return M;
  }
  function Zt(p) {
    let w = Z(404, { pathname: p }), S = l || i, { matches: L, route: M } = tt(S);
    return { notFoundMatches: L, route: M, error: w };
  }
  function fo(p, w, S) {
    if (m = p, C = w, y = S || null, !g && v.navigation === Nt) {
      g = !0;
      let L = oa(v.location, v.matches);
      L != null && re({ restoreScrollPosition: L });
    }
    return () => {
      m = null, C = null, y = null;
    };
  }
  function na(p, w) {
    return y && y(
      p,
      w.map((L) => ja(L, v.loaderData))
    ) || p.key;
  }
  function ho(p, w) {
    if (m && C) {
      let S = na(p, w);
      m[S] = C();
    }
  }
  function oa(p, w) {
    if (m) {
      let S = na(p, w), L = m[S];
      if (typeof L == "number")
        return L;
    }
    return null;
  }
  function St(p, w, S) {
    if (e.patchRoutesOnNavigation)
      if (p) {
        if (Object.keys(p[0].params).length > 0)
          return { active: !0, matches: $t(
            w,
            S,
            s,
            !0
          ) };
      } else
        return { active: !0, matches: $t(
          w,
          S,
          s,
          !0
        ) || [] };
    return { active: !1, matches: null };
  }
  async function Ct(p, w, S, L) {
    if (!e.patchRoutesOnNavigation)
      return { type: "success", matches: p };
    let M = p;
    for (; ; ) {
      let N = l == null, k = l || i, O = o;
      try {
        await e.patchRoutesOnNavigation({
          signal: S,
          path: w,
          matches: M,
          fetcherKey: L,
          patch: (A, F) => {
            S.aborted || ha(
              A,
              F,
              k,
              O,
              n,
              !1
            );
          }
        });
      } catch (A) {
        return { type: "error", error: A, partialMatches: M };
      } finally {
        N && !S.aborted && (i = [...i]);
      }
      if (S.aborted)
        return { type: "aborted" };
      let j = Se(k, w, s);
      if (j)
        return { type: "success", matches: j };
      let H = $t(
        k,
        w,
        s,
        !0
      );
      if (!H || M.length === H.length && M.every(
        (A, F) => A.route.id === H[F].route.id
      ))
        return { type: "success", matches: null };
      M = H;
    }
  }
  function mo(p) {
    o = {}, l = Ve(
      p,
      n,
      void 0,
      o
    );
  }
  function po(p, w, S = !1) {
    let L = l == null;
    ha(
      p,
      w,
      l || i,
      o,
      n,
      S
    ), L && (i = [...i], re({}));
  }
  return E = {
    get basename() {
      return s;
    },
    get future() {
      return d;
    },
    get state() {
      return v;
    },
    get routes() {
      return i;
    },
    get window() {
      return t;
    },
    initialize: qn,
    subscribe: to,
    enableScrollRestoration: fo,
    navigate: Xr,
    fetch: io,
    revalidate: ro,
    // Passthrough to history-aware createHref used by useHref so we get proper
    // hash-aware URLs in DOM paths
    createHref: (p) => e.history.createHref(p),
    encodeLocation: (p) => e.history.encodeLocation(p),
    getFetcher: Zr,
    deleteFetcher: uo,
    dispose: eo,
    getBlocker: co,
    deleteBlocker: ra,
    patchRoutes: po,
    _internalFetchControllers: B,
    // TODO: Remove setRoutes, it's temporary to avoid dealing with
    // updating the tree while validating the update algorithm.
    _internalSetRoutes: mo,
    _internalSetStateDoNotUseOrYouWillBreakYourApp(p) {
      re(p);
    }
  }, E;
}
function Xo(e, t) {
  I(
    e.length > 0,
    "You must provide a non-empty routes array to createStaticHandler"
  );
  let r = {}, a = (t ? t.basename : null) || "/", n = t?.mapRouteProperties || Va, o = Ve(
    e,
    n,
    void 0,
    r
  );
  async function i(h, {
    requestContext: m,
    filterMatchesToLoad: y,
    skipLoaderErrorBubbling: C,
    skipRevalidation: g,
    dataStrategy: b,
    unstable_generateMiddlewareResponse: R
  } = {}) {
    let x = new URL(h.url), P = h.method, E = Te("", fe(x), null, "default"), v = Se(o, E, a);
    if (m = m ?? new et(), !fr(P) && P !== "HEAD") {
      let D = Z(405, { method: P }), { matches: T, route: $ } = tt(o), U = {
        basename: a,
        location: E,
        matches: T,
        loaderData: {},
        actionData: null,
        errors: {
          [$.id]: D
        },
        statusCode: D.status,
        loaderHeaders: {},
        actionHeaders: {}
      };
      return R ? R(() => Promise.resolve(U)) : U;
    } else if (!v) {
      let D = Z(404, { pathname: E.pathname }), { matches: T, route: $ } = tt(o), U = {
        basename: a,
        location: E,
        matches: T,
        loaderData: {},
        actionData: null,
        errors: {
          [$.id]: D
        },
        statusCode: D.status,
        loaderHeaders: {},
        actionHeaders: {}
      };
      return R ? R(() => Promise.resolve(U)) : U;
    }
    if (R) {
      I(
        m instanceof et,
        "When using middleware in `staticHandler.query()`, any provided `requestContext` must be an instance of `unstable_RouterContextProvider`"
      );
      try {
        await ya(
          v,
          r,
          n
        );
        let D, T = await va(
          {
            request: h,
            matches: v,
            params: v[0].params,
            // If we're calling middleware then it must be enabled so we can cast
            // this to the proper type knowing it's not an `AppLoadContext`
            context: m
          },
          async () => await R(
            async (U, K = {}) => {
              let z = await s(
                U,
                E,
                v,
                m,
                b || null,
                C === !0,
                null,
                "filterMatchesToLoad" in K ? K.filterMatchesToLoad ?? null : null,
                g === !0
              );
              return ne(z) ? z : (D = { location: E, basename: a, ...z }, D);
            }
          ),
          async ($, U) => {
            if (Sa($))
              return $;
            if (ne($))
              try {
                $ = new De(
                  $.status,
                  $.statusText,
                  await rn($)
                );
              } catch (K) {
                $ = K;
              }
            if (Je($) && ($ = oi($)), D) {
              U in D.loaderData && (D.loaderData[U] = void 0);
              let K = Go(
                o,
                D,
                $,
                C ? U : we(v, U).route.id
              );
              return R(
                () => Promise.resolve(K)
              );
            } else {
              let K = C ? U : we(
                v,
                v.find(
                  (J) => J.route.id === U || J.route.loader
                )?.route.id || U
              ).route.id, z = {
                matches: v,
                location: E,
                basename: a,
                loaderData: {},
                actionData: null,
                errors: {
                  [K]: $
                },
                statusCode: be($) ? $.status : 500,
                actionHeaders: {},
                loaderHeaders: {}
              };
              return R(
                () => Promise.resolve(z)
              );
            }
          }
        );
        return I(ne(T), "Expected a response in query()"), T;
      } catch (D) {
        if (ne(D))
          return D;
        throw D;
      }
    }
    let _ = await s(
      h,
      E,
      v,
      m,
      b || null,
      C === !0,
      null,
      y || null,
      g === !0
    );
    return ne(_) ? _ : { location: E, basename: a, ..._ };
  }
  async function l(h, {
    routeId: m,
    requestContext: y,
    dataStrategy: C,
    unstable_generateMiddlewareResponse: g
  } = {}) {
    let b = new URL(h.url), R = h.method, x = Te("", fe(b), null, "default"), P = Se(o, x, a);
    if (y = y ?? new et(), !fr(R) && R !== "HEAD" && R !== "OPTIONS")
      throw Z(405, { method: R });
    if (!P)
      throw Z(404, { pathname: x.pathname });
    let E = m ? P.find((D) => D.route.id === m) : rt(P, x);
    if (m && !E)
      throw Z(403, {
        pathname: x.pathname,
        routeId: m
      });
    if (!E)
      throw Z(404, { pathname: x.pathname });
    if (g)
      return I(
        y instanceof et,
        "When using middleware in `staticHandler.queryRoute()`, any provided `requestContext` must be an instance of `unstable_RouterContextProvider`"
      ), await ya(P, r, n), await va(
        {
          request: h,
          matches: P,
          params: P[0].params,
          // If we're calling middleware then it must be enabled so we can cast
          // this to the proper type knowing it's not an `AppLoadContext`
          context: y
        },
        async () => await g(
          async ($) => {
            let U = await s(
              $,
              x,
              P,
              y,
              C || null,
              !1,
              E,
              null,
              !1
            ), K = _(U);
            return ne(K) ? K : typeof K == "string" ? new Response(K) : Response.json(K);
          }
        ),
        (T) => {
          if (Je(T))
            return Promise.resolve(dr(T));
          if (ne(T))
            return Promise.resolve(T);
          throw T;
        }
      );
    let v = await s(
      h,
      x,
      P,
      y,
      C || null,
      !1,
      E,
      null,
      !1
    );
    return _(v);
    function _(D) {
      if (ne(D))
        return D;
      let T = D.errors ? Object.values(D.errors)[0] : void 0;
      if (T !== void 0)
        throw T;
      if (D.actionData)
        return Object.values(D.actionData)[0];
      if (D.loaderData)
        return Object.values(D.loaderData)[0];
    }
  }
  async function s(h, m, y, C, g, b, R, x, P) {
    I(
      h.signal,
      "query()/queryRoute() requests must contain an AbortController signal"
    );
    try {
      if (le(h.method))
        return await u(
          h,
          y,
          R || rt(y, m),
          C,
          g,
          b,
          R != null,
          x,
          P
        );
      let E = await d(
        h,
        y,
        C,
        g,
        b,
        R,
        x
      );
      return ne(E) ? E : {
        ...E,
        actionData: null,
        actionHeaders: {}
      };
    } catch (E) {
      if (sn(E) && ne(E.result)) {
        if (E.type === "error")
          throw E.result;
        return E.result;
      }
      if (Sa(E))
        return E;
      throw E;
    }
  }
  async function u(h, m, y, C, g, b, R, x, P) {
    let E;
    if (!y.route.action && !y.route.lazy) {
      let D = Z(405, {
        method: h.method,
        pathname: new URL(h.url).pathname,
        routeId: y.route.id
      });
      if (R)
        throw D;
      E = {
        type: "error",
        error: D
      };
    } else {
      let D = Ae(
        n,
        r,
        h,
        m,
        y,
        [],
        C
      );
      E = (await f(
        h,
        D,
        R,
        C,
        g
      ))[y.route.id], h.signal.aborted && ca(h, R);
    }
    if (ke(E))
      throw new Response(null, {
        status: E.response.status,
        headers: {
          Location: E.response.headers.get("Location")
        }
      });
    if (R) {
      if (te(E))
        throw E.error;
      return {
        matches: [y],
        loaderData: {},
        actionData: { [y.route.id]: E.data },
        errors: null,
        // Note: statusCode + headers are unused here since queryRoute will
        // return the raw Response or value
        statusCode: 200,
        loaderHeaders: {},
        actionHeaders: {}
      };
    }
    if (P)
      if (te(E)) {
        let D = b ? y : we(m, y.route.id);
        return {
          statusCode: be(E.error) ? E.error.status : E.statusCode != null ? E.statusCode : 500,
          actionData: null,
          actionHeaders: {
            ...E.headers ? { [y.route.id]: E.headers } : {}
          },
          matches: m,
          loaderData: {},
          errors: {
            [D.route.id]: E.error
          },
          loaderHeaders: {}
        };
      } else
        return {
          actionData: {
            [y.route.id]: E.data
          },
          actionHeaders: E.headers ? { [y.route.id]: E.headers } : {},
          matches: m,
          loaderData: {},
          errors: null,
          statusCode: E.statusCode || 200,
          loaderHeaders: {}
        };
    let v = new Request(h.url, {
      headers: h.headers,
      redirect: h.redirect,
      signal: h.signal
    });
    if (te(E)) {
      let D = b ? y : we(m, y.route.id);
      return {
        ...await d(
          v,
          m,
          C,
          g,
          b,
          null,
          x,
          [D.route.id, E]
        ),
        statusCode: be(E.error) ? E.error.status : E.statusCode != null ? E.statusCode : 500,
        actionData: null,
        actionHeaders: {
          ...E.headers ? { [y.route.id]: E.headers } : {}
        }
      };
    }
    return {
      ...await d(
        v,
        m,
        C,
        g,
        b,
        null,
        x
      ),
      actionData: {
        [y.route.id]: E.data
      },
      // action status codes take precedence over loader status codes
      ...E.statusCode ? { statusCode: E.statusCode } : {},
      actionHeaders: E.headers ? { [y.route.id]: E.headers } : {}
    };
  }
  async function d(h, m, y, C, g, b, R, x) {
    let P = b != null;
    if (P && !b?.route.loader && !b?.route.lazy)
      throw Z(400, {
        method: h.method,
        pathname: new URL(h.url).pathname,
        routeId: b?.route.id
      });
    let E;
    if (b)
      E = Ae(
        n,
        r,
        h,
        m,
        b,
        [],
        y
      );
    else {
      let D = x && te(x[1]) ? (
        // Up to but not including the boundary
        m.findIndex((T) => T.route.id === x[0]) - 1
      ) : void 0;
      E = m.map((T, $) => D != null && $ > D ? pt(
        n,
        r,
        h,
        T,
        [],
        y,
        !1
      ) : pt(
        n,
        r,
        h,
        T,
        [],
        y,
        (T.route.loader || T.route.lazy) != null && (!R || R(T))
      ));
    }
    if (!C && !E.some((D) => D.shouldLoad))
      return {
        matches: m,
        loaderData: {},
        errors: x && te(x[1]) ? {
          [x[0]]: x[1].error
        } : null,
        statusCode: 200,
        loaderHeaders: {}
      };
    let v = await f(
      h,
      E,
      P,
      y,
      C
    );
    return h.signal.aborted && ca(h, P), {
      ...on(
        m,
        v,
        x,
        !0,
        g
      ),
      matches: m
    };
  }
  async function f(h, m, y, C, g) {
    let b = await tn(
      g || ur,
      h,
      m,
      null,
      C,
      !0
    ), R = {};
    return await Promise.all(
      m.map(async (x) => {
        if (!(x.route.id in b))
          return;
        let P = b[x.route.id];
        if (un(P)) {
          let E = P.result;
          throw nn(
            E,
            h,
            x.route.id,
            m,
            a
          );
        }
        if (y) {
          if (ne(P.result))
            throw P;
          if (Je(P.result))
            throw dr(P.result);
        }
        R[x.route.id] = await an(P);
      })
    ), R;
  }
  return {
    dataRoutes: o,
    query: i,
    queryRoute: l
  };
}
function Go(e, t, r, a) {
  let n = a || t._deepestRenderedBoundaryId || e[0].id;
  return {
    ...t,
    statusCode: be(r) ? r.status : 500,
    errors: {
      [n]: r
    }
  };
}
function ca(e, t) {
  if (e.signal.reason !== void 0)
    throw e.signal.reason;
  let r = t ? "queryRoute" : "query";
  throw new Error(
    `${r}() call aborted without an \`AbortSignal.reason\`: ${e.method} ${e.url}`
  );
}
function Qo(e) {
  return e != null && ("formData" in e && e.formData != null || "body" in e && e.body !== void 0);
}
function lr(e, t, r, a, n, o) {
  let i, l;
  if (n) {
    i = [];
    for (let u of t)
      if (i.push(u), u.route.id === n) {
        l = u;
        break;
      }
  } else
    i = t, l = t[t.length - 1];
  let s = Bt(
    a || ".",
    zt(i),
    se(e.pathname, r) || e.pathname,
    o === "path"
  );
  if (a == null && (s.search = e.search, s.hash = e.hash), (a == null || a === "" || a === ".") && l) {
    let u = Dr(s.search);
    if (l.route.index && !u)
      s.search = s.search ? s.search.replace(/^\?/, "?index&") : "?index";
    else if (!l.route.index && u) {
      let d = new URLSearchParams(s.search), f = d.getAll("index");
      d.delete("index"), f.filter((m) => m).forEach((m) => d.append("index", m));
      let h = d.toString();
      s.search = h ? `?${h}` : "";
    }
  }
  return r !== "/" && (s.pathname = ko({ basename: r, pathname: s.pathname })), fe(s);
}
function da(e, t, r) {
  if (!r || !Qo(r))
    return { path: t };
  if (r.formMethod && !fr(r.formMethod))
    return {
      path: t,
      error: Z(405, { method: r.formMethod })
    };
  let a = () => ({
    path: t,
    error: Z(400, { type: "invalid-body" })
  }), o = (r.formMethod || "get").toUpperCase(), i = ln(t);
  if (r.body !== void 0) {
    if (r.formEncType === "text/plain") {
      if (!le(o))
        return a();
      let f = typeof r.body == "string" ? r.body : r.body instanceof FormData || r.body instanceof URLSearchParams ? (
        // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data
        Array.from(r.body.entries()).reduce(
          (h, [m, y]) => `${h}${m}=${y}
`,
          ""
        )
      ) : String(r.body);
      return {
        path: t,
        submission: {
          formMethod: o,
          formAction: i,
          formEncType: r.formEncType,
          formData: void 0,
          json: void 0,
          text: f
        }
      };
    } else if (r.formEncType === "application/json") {
      if (!le(o))
        return a();
      try {
        let f = typeof r.body == "string" ? JSON.parse(r.body) : r.body;
        return {
          path: t,
          submission: {
            formMethod: o,
            formAction: i,
            formEncType: r.formEncType,
            formData: void 0,
            json: f,
            text: void 0
          }
        };
      } catch {
        return a();
      }
    }
  }
  I(
    typeof FormData == "function",
    "FormData is not available in this environment"
  );
  let l, s;
  if (r.formData)
    l = cr(r.formData), s = r.formData;
  else if (r.body instanceof FormData)
    l = cr(r.body), s = r.body;
  else if (r.body instanceof URLSearchParams)
    l = r.body, s = wa(l);
  else if (r.body == null)
    l = new URLSearchParams(), s = new FormData();
  else
    try {
      l = new URLSearchParams(r.body), s = wa(l);
    } catch {
      return a();
    }
  let u = {
    formMethod: o,
    formAction: i,
    formEncType: r && r.formEncType || "application/x-www-form-urlencoded",
    formData: s,
    json: void 0,
    text: void 0
  };
  if (le(u.formMethod))
    return { path: t, submission: u };
  let d = Ee(t);
  return e && d.search && Dr(d.search) && l.append("index", ""), d.search = `?${l}`, { path: fe(d), submission: u };
}
function fa(e, t, r, a, n, o, i, l, s, u, d, f, h, m, y, C, g, b, R, x) {
  let P = x ? te(x[1]) ? x[1].error : x[1].data : void 0, E = n.createURL(o.location), v = n.createURL(s), _;
  if (d && o.errors) {
    let z = Object.keys(o.errors)[0];
    _ = i.findIndex((J) => J.route.id === z);
  } else if (x && te(x[1])) {
    let z = x[0];
    _ = i.findIndex((J) => J.route.id === z) - 1;
  }
  let D = x ? x[1].statusCode : void 0, T = D && D >= 400, $ = {
    currentUrl: E,
    currentParams: o.matches[0]?.params || {},
    nextUrl: v,
    nextParams: i[0].params,
    ...l,
    actionResult: P,
    actionStatus: D
  }, U = i.map((z, J) => {
    let { route: ue } = z, B = null;
    if (_ != null && J > _ ? B = !1 : ue.lazy ? B = !0 : ue.loader == null ? B = !1 : d ? B = sr(
      ue,
      o.loaderData,
      o.errors
    ) : Zo(o.loaderData, o.matches[J], z) && (B = !0), B !== null)
      return pt(
        r,
        a,
        e,
        z,
        u,
        t,
        B
      );
    let ye = T ? !1 : (
      // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
      f || E.pathname + E.search === v.pathname + v.search || // Search params affect all loaders
      E.search !== v.search || qo(o.matches[J], z)
    ), ce = {
      ...$,
      defaultShouldRevalidate: ye
    }, Re = It(z, ce);
    return pt(
      r,
      a,
      e,
      z,
      u,
      t,
      Re,
      ce
    );
  }), K = [];
  return y.forEach((z, J) => {
    if (d || !i.some((Ce) => Ce.route.id === z.routeId) || m.has(J))
      return;
    let ue = o.fetchers.get(J), B = ue && ue.state !== "idle" && ue.data === void 0, ye = Se(g, z.path, b);
    if (!ye) {
      if (R && B)
        return;
      K.push({
        key: J,
        routeId: z.routeId,
        path: z.path,
        matches: null,
        match: null,
        request: null,
        controller: null
      });
      return;
    }
    if (C.has(J))
      return;
    let ce = rt(ye, z.path), Re = new AbortController(), de = qe(
      n,
      z.path,
      Re.signal
    ), ve = null;
    if (h.has(J))
      h.delete(J), ve = Ae(
        r,
        a,
        de,
        ye,
        ce,
        u,
        t
      );
    else if (B)
      f && (ve = Ae(
        r,
        a,
        de,
        ye,
        ce,
        u,
        t
      ));
    else {
      let Ce = {
        ...$,
        defaultShouldRevalidate: T ? !1 : f
      };
      It(ce, Ce) && (ve = Ae(
        r,
        a,
        de,
        ye,
        ce,
        u,
        t,
        Ce
      ));
    }
    ve && K.push({
      key: J,
      routeId: z.routeId,
      path: z.path,
      matches: ve,
      match: ce,
      request: de,
      controller: Re
    });
  }), { dsMatches: U, revalidatingFetchers: K };
}
function sr(e, t, r) {
  if (e.lazy)
    return !0;
  if (!e.loader)
    return !1;
  let a = t != null && e.id in t, n = r != null && r[e.id] !== void 0;
  return !a && n ? !1 : typeof e.loader == "function" && e.loader.hydrate === !0 ? !0 : !a && !n;
}
function Zo(e, t, r) {
  let a = (
    // [a] -> [a, b]
    !t || // [a, b] -> [a, c]
    r.route.id !== t.route.id
  ), n = !e.hasOwnProperty(r.route.id);
  return a || n;
}
function qo(e, t) {
  let r = e.route.path;
  return (
    // param change for this match, /users/123 -> /users/456
    e.pathname !== t.pathname || // splat param changed, which is not present in match.path
    // e.g. /files/images/avatar.jpg -> files/finances.xls
    r != null && r.endsWith("*") && e.params["*"] !== t.params["*"]
  );
}
function It(e, t) {
  if (e.route.shouldRevalidate) {
    let r = e.route.shouldRevalidate(t);
    if (typeof r == "boolean")
      return r;
  }
  return t.defaultShouldRevalidate;
}
function ha(e, t, r, a, n, o) {
  let i;
  if (e) {
    let u = a[e];
    I(
      u,
      `No route found to patch children into: routeId = ${e}`
    ), u.children || (u.children = []), i = u.children;
  } else
    i = r;
  let l = [], s = [];
  if (t.forEach((u) => {
    let d = i.find(
      (f) => Ga(u, f)
    );
    d ? s.push({ existingRoute: d, newRoute: u }) : l.push(u);
  }), l.length > 0) {
    let u = Ve(
      l,
      n,
      [e || "_", "patch", String(i?.length || "0")],
      a
    );
    i.push(...u);
  }
  if (o && s.length > 0)
    for (let u = 0; u < s.length; u++) {
      let { existingRoute: d, newRoute: f } = s[u], h = d, [m] = Ve(
        [f],
        n,
        [],
        // Doesn't matter for mutated routes since they already have an id
        {},
        // Don't touch the manifest here since we're updating in place
        !0
      );
      Object.assign(h, {
        element: m.element ? m.element : h.element,
        errorElement: m.errorElement ? m.errorElement : h.errorElement,
        hydrateFallbackElement: m.hydrateFallbackElement ? m.hydrateFallbackElement : h.hydrateFallbackElement
      });
    }
}
function Ga(e, t) {
  return "id" in e && "id" in t && e.id === t.id ? !0 : e.index === t.index && e.path === t.path && e.caseSensitive === t.caseSensitive ? (!e.children || e.children.length === 0) && (!t.children || t.children.length === 0) ? !0 : e.children.every(
    (r, a) => t.children?.some((n) => Ga(r, n))
  ) : !1;
}
var ma = /* @__PURE__ */ new WeakMap(), Lr = ({
  key: e,
  route: t,
  manifest: r,
  mapRouteProperties: a
}) => {
  let n = r[t.id];
  if (I(n, "No route found in manifest"), !n.lazy || typeof n.lazy != "object")
    return;
  let o = n.lazy[e];
  if (!o)
    return;
  let i = ma.get(n);
  i || (i = {}, ma.set(n, i));
  let l = i[e];
  if (l)
    return l;
  let s = (async () => {
    let u = Ro(e), f = n[e] !== void 0 && e !== "hasErrorBoundary";
    if (u)
      V(
        !u,
        "Route property " + e + " is not a supported lazy route property. This property will be ignored."
      ), i[e] = Promise.resolve();
    else if (f)
      V(
        !1,
        `Route "${n.id}" has a static property "${e}" defined. The lazy property will be ignored.`
      );
    else {
      let h = await o();
      h != null && (Object.assign(n, { [e]: h }), Object.assign(n, a(n)));
    }
    typeof n.lazy == "object" && (n.lazy[e] = void 0, Object.values(n.lazy).every((h) => h === void 0) && (n.lazy = void 0));
  })();
  return i[e] = s, s;
}, pa = /* @__PURE__ */ new WeakMap();
function ei(e, t, r, a, n) {
  let o = r[e.id];
  if (I(o, "No route found in manifest"), !e.lazy)
    return {
      lazyRoutePromise: void 0,
      lazyHandlerPromise: void 0
    };
  if (typeof e.lazy == "function") {
    let d = pa.get(o);
    if (d)
      return {
        lazyRoutePromise: d,
        lazyHandlerPromise: d
      };
    let f = (async () => {
      I(
        typeof e.lazy == "function",
        "No lazy route function found"
      );
      let h = await e.lazy(), m = {};
      for (let y in h) {
        let C = h[y];
        if (C === void 0)
          continue;
        let g = Co(y), R = o[y] !== void 0 && // This property isn't static since it should always be updated based
        // on the route updates
        y !== "hasErrorBoundary";
        g ? V(
          !g,
          "Route property " + y + " is not a supported property to be returned from a lazy route function. This property will be ignored."
        ) : R ? V(
          !R,
          `Route "${o.id}" has a static property "${y}" defined but its lazy function is also returning a value for this property. The lazy route property "${y}" will be ignored.`
        ) : m[y] = C;
      }
      Object.assign(o, m), Object.assign(o, {
        // To keep things framework agnostic, we use the provided `mapRouteProperties`
        // function to set the framework-aware properties (`element`/`hasErrorBoundary`)
        // since the logic will differ between frameworks.
        ...a(o),
        lazy: void 0
      });
    })();
    return pa.set(o, f), f.catch(() => {
    }), {
      lazyRoutePromise: f,
      lazyHandlerPromise: f
    };
  }
  let i = Object.keys(e.lazy), l = [], s;
  for (let d of i) {
    if (n && n.includes(d))
      continue;
    let f = Lr({
      key: d,
      route: e,
      manifest: r,
      mapRouteProperties: a
    });
    f && (l.push(f), d === t && (s = f));
  }
  let u = l.length > 0 ? Promise.all(l).then(() => {
  }) : void 0;
  return u?.catch(() => {
  }), s?.catch(() => {
  }), {
    lazyRoutePromise: u,
    lazyHandlerPromise: s
  };
}
function ti(e) {
  return e !== void 0;
}
function ya(e, t, r) {
  let a = e.map(({ route: n }) => {
    if (!(typeof n.lazy != "object" || !n.lazy.unstable_middleware))
      return Lr({
        key: "unstable_middleware",
        route: n,
        manifest: t,
        mapRouteProperties: r
      });
  }).filter(ti);
  return a.length > 0 ? Promise.all(a) : void 0;
}
async function ur(e) {
  let t = e.matches.filter((n) => n.shouldLoad), r = {};
  return (await Promise.all(t.map((n) => n.resolve()))).forEach((n, o) => {
    r[t[o].route.id] = n;
  }), r;
}
async function ri(e) {
  return e.matches.some((t) => t.route.unstable_middleware) ? Qa(e, () => ur(e)) : ur(e);
}
function va(e, t, r) {
  return Za(
    e,
    t,
    a,
    ne,
    r
  );
  function a(n) {
    return Je(n) ? dr(n) : n;
  }
}
function Qa(e, t) {
  return Za(
    e,
    t,
    (a) => a,
    // No post-processing needed on the client
    ii,
    r
  );
  function r(a, n, o) {
    if (o)
      return Promise.resolve(
        Object.assign(o.value, {
          [n]: { type: "error", result: a }
        })
      );
    {
      let { matches: i } = e, l = Math.min(
        // Throwing route
        i.findIndex((u) => u.route.id === n) || 0,
        // or the shallowest route that needs to load data
        i.findIndex((u) => u.unstable_shouldCallHandler()) || 0
      ), s = we(
        i,
        i[l].route.id
      ).route.id;
      return Promise.resolve({
        [s]: { type: "error", result: a }
      });
    }
  }
}
async function Za(e, t, r, a, n) {
  let { matches: o, request: i, params: l, context: s } = e, u = o.flatMap(
    (f) => f.route.unstable_middleware ? f.route.unstable_middleware.map((h) => [f.route.id, h]) : []
  );
  return await qa(
    { request: i, params: l, context: s },
    u,
    t,
    r,
    a,
    n
  );
}
async function qa(e, t, r, a, n, o, i = 0) {
  let { request: l } = e;
  if (l.signal.aborted)
    throw l.signal.reason ?? new Error(`Request aborted: ${l.method} ${l.url}`);
  let s = t[i];
  if (!s)
    return await r();
  let [u, d] = s, f, h = async () => {
    if (f)
      throw new Error("You may only call `next()` once per middleware");
    try {
      return f = { value: await qa(
        e,
        t,
        r,
        a,
        n,
        o,
        i + 1
      ) }, f.value;
    } catch (m) {
      return f = { value: await o(m, u, f) }, f.value;
    }
  };
  try {
    let m = await d(e, h), y = m != null ? a(m) : void 0;
    return n(y) ? y : f ? y ?? f.value : (f = { value: await h() }, f.value);
  } catch (m) {
    return await o(m, u, f);
  }
}
function en(e, t, r, a, n) {
  let o = Lr({
    key: "unstable_middleware",
    route: a.route,
    manifest: t,
    mapRouteProperties: e
  }), i = ei(
    a.route,
    le(r.method) ? "action" : "loader",
    t,
    e,
    n
  );
  return {
    middleware: o,
    route: i.lazyRoutePromise,
    handler: i.lazyHandlerPromise
  };
}
function pt(e, t, r, a, n, o, i, l = null) {
  let s = !1, u = en(
    e,
    t,
    r,
    a,
    n
  );
  return {
    ...a,
    _lazyPromises: u,
    shouldLoad: i,
    unstable_shouldRevalidateArgs: l,
    unstable_shouldCallHandler(d) {
      return s = !0, l ? typeof d == "boolean" ? It(a, {
        ...l,
        defaultShouldRevalidate: d
      }) : It(a, l) : i;
    },
    resolve(d) {
      return s || i || d && !le(r.method) && (a.route.lazy || a.route.loader) ? ai({
        request: r,
        match: a,
        lazyHandlerPromise: u?.handler,
        lazyRoutePromise: u?.route,
        handlerOverride: d,
        scopedContext: o
      }) : Promise.resolve({ type: "data", result: void 0 });
    }
  };
}
function Ae(e, t, r, a, n, o, i, l = null) {
  return a.map((s) => s.route.id !== n.route.id ? {
    ...s,
    shouldLoad: !1,
    unstable_shouldRevalidateArgs: l,
    unstable_shouldCallHandler: () => !1,
    _lazyPromises: en(
      e,
      t,
      r,
      s,
      o
    ),
    resolve: () => Promise.resolve({ type: "data", result: void 0 })
  } : pt(
    e,
    t,
    r,
    s,
    o,
    i,
    !0,
    l
  ));
}
async function tn(e, t, r, a, n, o) {
  r.some((u) => u._lazyPromises?.middleware) && await Promise.all(r.map((u) => u._lazyPromises?.middleware));
  let i = {
    request: t,
    params: r[0].params,
    context: n,
    matches: r
  }, s = await e({
    ...i,
    fetcherKey: a,
    unstable_runClientMiddleware: o ? () => {
      throw new Error(
        "You cannot call `unstable_runClientMiddleware()` from a static handler `dataStrategy`. Middleware is run outside of `dataStrategy` during SSR in order to bubble up the Response.  You can enable middleware via the `respond` API in `query`/`queryRoute`"
      );
    } : (u) => {
      let d = i;
      return Qa(d, () => u({
        ...d,
        fetcherKey: a,
        unstable_runClientMiddleware: () => {
          throw new Error(
            "Cannot call `unstable_runClientMiddleware()` from within an `unstable_runClientMiddleware` handler"
          );
        }
      }));
    }
  });
  try {
    await Promise.all(
      r.flatMap((u) => [
        u._lazyPromises?.handler,
        u._lazyPromises?.route
      ])
    );
  } catch {
  }
  return s;
}
async function ai({
  request: e,
  match: t,
  lazyHandlerPromise: r,
  lazyRoutePromise: a,
  handlerOverride: n,
  scopedContext: o
}) {
  let i, l, s = le(e.method), u = s ? "action" : "loader", d = (f) => {
    let h, m = new Promise((g, b) => h = b);
    l = () => h(), e.signal.addEventListener("abort", l);
    let y = (g) => typeof f != "function" ? Promise.reject(
      new Error(
        `You cannot call the handler for a route which defines a boolean "${u}" [routeId: ${t.route.id}]`
      )
    ) : f(
      {
        request: e,
        params: t.params,
        context: o
      },
      ...g !== void 0 ? [g] : []
    ), C = (async () => {
      try {
        return { type: "data", result: await (n ? n((b) => y(b)) : y()) };
      } catch (g) {
        return { type: "error", result: g };
      }
    })();
    return Promise.race([C, m]);
  };
  try {
    let f = s ? t.route.action : t.route.loader;
    if (r || a)
      if (f) {
        let h, [m] = await Promise.all([
          // If the handler throws, don't let it immediately bubble out,
          // since we need to let the lazy() execution finish so we know if this
          // route has a boundary that can handle the error
          d(f).catch((y) => {
            h = y;
          }),
          // Ensure all lazy route promises are resolved before continuing
          r,
          a
        ]);
        if (h !== void 0)
          throw h;
        i = m;
      } else {
        await r;
        let h = s ? t.route.action : t.route.loader;
        if (h)
          [i] = await Promise.all([d(h), a]);
        else if (u === "action") {
          let m = new URL(e.url), y = m.pathname + m.search;
          throw Z(405, {
            method: e.method,
            pathname: y,
            routeId: t.route.id
          });
        } else
          return { type: "data", result: void 0 };
      }
    else if (f)
      i = await d(f);
    else {
      let h = new URL(e.url), m = h.pathname + h.search;
      throw Z(404, {
        pathname: m
      });
    }
  } catch (f) {
    return { type: "error", result: f };
  } finally {
    l && e.signal.removeEventListener("abort", l);
  }
  return i;
}
async function rn(e) {
  let t = e.headers.get("Content-Type");
  return t && /\bapplication\/json\b/.test(t) ? e.body == null ? null : e.json() : e.text();
}
async function an(e) {
  let { result: t, type: r } = e;
  if (ne(t)) {
    let a;
    try {
      a = await rn(t);
    } catch (n) {
      return { type: "error", error: n };
    }
    return r === "error" ? {
      type: "error",
      error: new De(t.status, t.statusText, a),
      statusCode: t.status,
      headers: t.headers
    } : {
      type: "data",
      data: a,
      statusCode: t.status,
      headers: t.headers
    };
  }
  return r === "error" ? Je(t) ? t.data instanceof Error ? {
    type: "error",
    error: t.data,
    statusCode: t.init?.status,
    headers: t.init?.headers ? new Headers(t.init.headers) : void 0
  } : {
    type: "error",
    error: new De(
      t.init?.status || 500,
      void 0,
      t.data
    ),
    statusCode: be(t) ? t.status : void 0,
    headers: t.init?.headers ? new Headers(t.init.headers) : void 0
  } : {
    type: "error",
    error: t,
    statusCode: be(t) ? t.status : void 0
  } : Je(t) ? {
    type: "data",
    data: t.data,
    statusCode: t.init?.status,
    headers: t.init?.headers ? new Headers(t.init.headers) : void 0
  } : { type: "data", data: t };
}
function nn(e, t, r, a, n) {
  let o = e.headers.get("Location");
  if (I(
    o,
    "Redirects returned/thrown from loaders/actions must have a Location header"
  ), !Pr(o)) {
    let i = a.slice(
      0,
      a.findIndex((l) => l.route.id === r) + 1
    );
    o = lr(
      new URL(t.url),
      i,
      n,
      o
    ), e.headers.set("Location", o);
  }
  return e;
}
function ga(e, t, r) {
  if (Pr(e)) {
    let a = e, n = a.startsWith("//") ? new URL(t.protocol + a) : new URL(a), o = se(n.pathname, r) != null;
    if (n.origin === t.origin && o)
      return n.pathname + n.search + n.hash;
  }
  return e;
}
function qe(e, t, r, a) {
  let n = e.createURL(ln(t)).toString(), o = { signal: r };
  if (a && le(a.formMethod)) {
    let { formMethod: i, formEncType: l } = a;
    o.method = i.toUpperCase(), l === "application/json" ? (o.headers = new Headers({ "Content-Type": l }), o.body = JSON.stringify(a.json)) : l === "text/plain" ? o.body = a.text : l === "application/x-www-form-urlencoded" && a.formData ? o.body = cr(a.formData) : o.body = a.formData;
  }
  return new Request(n, o);
}
function cr(e) {
  let t = new URLSearchParams();
  for (let [r, a] of e.entries())
    t.append(r, typeof a == "string" ? a : a.name);
  return t;
}
function wa(e) {
  let t = new FormData();
  for (let [r, a] of e.entries())
    t.append(r, a);
  return t;
}
function on(e, t, r, a = !1, n = !1) {
  let o = {}, i = null, l, s = !1, u = {}, d = r && te(r[1]) ? r[1].error : void 0;
  return e.forEach((f) => {
    if (!(f.route.id in t))
      return;
    let h = f.route.id, m = t[h];
    if (I(
      !ke(m),
      "Cannot handle redirect results in processLoaderData"
    ), te(m)) {
      let y = m.error;
      if (d !== void 0 && (y = d, d = void 0), i = i || {}, n)
        i[h] = y;
      else {
        let C = we(e, h);
        i[C.route.id] == null && (i[C.route.id] = y);
      }
      a || (o[h] = Xa), s || (s = !0, l = be(m.error) ? m.error.status : 500), m.headers && (u[h] = m.headers);
    } else
      o[h] = m.data, m.statusCode && m.statusCode !== 200 && !s && (l = m.statusCode), m.headers && (u[h] = m.headers);
  }), d !== void 0 && r && (i = { [r[0]]: d }, r[2] && (o[r[2]] = void 0)), {
    loaderData: o,
    errors: i,
    statusCode: l || 200,
    loaderHeaders: u
  };
}
function ba(e, t, r, a, n, o) {
  let { loaderData: i, errors: l } = on(
    t,
    r,
    a
  );
  return n.filter((s) => !s.matches || s.matches.some((u) => u.shouldLoad)).forEach((s) => {
    let { key: u, match: d, controller: f } = s;
    if (f && f.signal.aborted)
      return;
    let h = o[u];
    if (I(h, "Did not find corresponding fetcher result"), te(h)) {
      let m = we(e.matches, d?.route.id);
      l && l[m.route.id] || (l = {
        ...l,
        [m.route.id]: h.error
      }), e.fetchers.delete(u);
    } else if (ke(h))
      I(!1, "Unhandled fetcher revalidation redirect");
    else {
      let m = Fe(h.data);
      e.fetchers.set(u, m);
    }
  }), { loaderData: i, errors: l };
}
function Ea(e, t, r, a) {
  let n = Object.entries(t).filter(([, o]) => o !== Xa).reduce((o, [i, l]) => (o[i] = l, o), {});
  for (let o of r) {
    let i = o.route.id;
    if (!t.hasOwnProperty(i) && e.hasOwnProperty(i) && o.route.loader && (n[i] = e[i]), a && a.hasOwnProperty(i))
      break;
  }
  return n;
}
function Ra(e) {
  return e ? te(e[1]) ? {
    // Clear out prior actionData on errors
    actionData: {}
  } : {
    actionData: {
      [e[0]]: e[1].data
    }
  } : {};
}
function we(e, t) {
  return (t ? e.slice(0, e.findIndex((a) => a.route.id === t) + 1) : [...e]).reverse().find((a) => a.route.hasErrorBoundary === !0) || e[0];
}
function tt(e) {
  let t = e.length === 1 ? e[0] : e.find((r) => r.index || !r.path || r.path === "/") || {
    id: "__shim-error-route__"
  };
  return {
    matches: [
      {
        params: {},
        pathname: "",
        pathnameBase: "",
        route: t
      }
    ],
    route: t
  };
}
function Z(e, {
  pathname: t,
  routeId: r,
  method: a,
  type: n,
  message: o
} = {}) {
  let i = "Unknown Server Error", l = "Unknown @remix-run/router error";
  return e === 400 ? (i = "Bad Request", a && t && r ? l = `You made a ${a} request to "${t}" but did not provide a \`loader\` for route "${r}", so there is no way to handle the request.` : n === "invalid-body" && (l = "Unable to encode submission body")) : e === 403 ? (i = "Forbidden", l = `Route "${r}" does not match URL "${t}"`) : e === 404 ? (i = "Not Found", l = `No route matches URL "${t}"`) : e === 405 && (i = "Method Not Allowed", a && t && r ? l = `You made a ${a.toUpperCase()} request to "${t}" but did not provide an \`action\` for route "${r}", so there is no way to handle the request.` : a && (l = `Invalid request method "${a.toUpperCase()}"`)), new De(
    e || 500,
    i,
    new Error(l),
    !0
  );
}
function Dt(e) {
  let t = Object.entries(e);
  for (let r = t.length - 1; r >= 0; r--) {
    let [a, n] = t[r];
    if (ke(n))
      return { key: a, result: n };
  }
}
function ln(e) {
  let t = typeof e == "string" ? Ee(e) : e;
  return fe({ ...t, hash: "" });
}
function ni(e, t) {
  return e.pathname !== t.pathname || e.search !== t.search ? !1 : e.hash === "" ? t.hash !== "" : e.hash === t.hash ? !0 : t.hash !== "";
}
function dr(e) {
  return Response.json(e.data, e.init ?? void 0);
}
function oi(e) {
  return new De(
    e.init?.status ?? 500,
    e.init?.statusText ?? "Internal Server Error",
    e.data
  );
}
function ii(e) {
  return e != null && typeof e == "object" && Object.entries(e).every(
    ([t, r]) => typeof t == "string" && sn(r)
  );
}
function sn(e) {
  return e != null && typeof e == "object" && "type" in e && "result" in e && (e.type === "data" || e.type === "error");
}
function un(e) {
  return ne(e.result) && Ja.has(e.result.status);
}
function te(e) {
  return e.type === "error";
}
function ke(e) {
  return (e && e.type) === "redirect";
}
function Je(e) {
  return typeof e == "object" && e != null && "type" in e && "data" in e && "init" in e && e.type === "DataWithResponseInit";
}
function ne(e) {
  return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.headers == "object" && typeof e.body < "u";
}
function li(e) {
  return Ja.has(e);
}
function Sa(e) {
  return ne(e) && li(e.status) && e.headers.has("Location");
}
function fr(e) {
  return Jo.has(e.toUpperCase());
}
function le(e) {
  return Wo.has(e.toUpperCase());
}
function Dr(e) {
  return new URLSearchParams(e).getAll("index").some((t) => t === "");
}
function rt(e, t) {
  let r = typeof t == "string" ? Ee(t).search : t.search;
  if (e[e.length - 1].route.index && Dr(r || ""))
    return e[e.length - 1];
  let a = Wa(e);
  return a[a.length - 1];
}
function Ca(e) {
  let { formMethod: t, formAction: r, formEncType: a, text: n, formData: o, json: i } = e;
  if (!(!t || !r || !a)) {
    if (n != null)
      return {
        formMethod: t,
        formAction: r,
        formEncType: a,
        formData: void 0,
        json: void 0,
        text: n
      };
    if (o != null)
      return {
        formMethod: t,
        formAction: r,
        formEncType: a,
        formData: o,
        json: void 0,
        text: void 0
      };
    if (i !== void 0)
      return {
        formMethod: t,
        formAction: r,
        formEncType: a,
        formData: void 0,
        json: i,
        text: void 0
      };
  }
}
function rr(e, t) {
  return t ? {
    state: "loading",
    location: e,
    formMethod: t.formMethod,
    formAction: t.formAction,
    formEncType: t.formEncType,
    formData: t.formData,
    json: t.json,
    text: t.text
  } : {
    state: "loading",
    location: e,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0
  };
}
function si(e, t) {
  return {
    state: "submitting",
    location: e,
    formMethod: t.formMethod,
    formAction: t.formAction,
    formEncType: t.formEncType,
    formData: t.formData,
    json: t.json,
    text: t.text
  };
}
function dt(e, t) {
  return e ? {
    state: "loading",
    formMethod: e.formMethod,
    formAction: e.formAction,
    formEncType: e.formEncType,
    formData: e.formData,
    json: e.json,
    text: e.text,
    data: t
  } : {
    state: "loading",
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
    data: t
  };
}
function ui(e, t) {
  return {
    state: "submitting",
    formMethod: e.formMethod,
    formAction: e.formAction,
    formEncType: e.formEncType,
    formData: e.formData,
    json: e.json,
    text: e.text,
    data: t ? t.data : void 0
  };
}
function Fe(e) {
  return {
    state: "idle",
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
    data: e
  };
}
function ci(e, t) {
  try {
    let r = e.sessionStorage.getItem(
      Ka
    );
    if (r) {
      let a = JSON.parse(r);
      for (let [n, o] of Object.entries(a || {}))
        o && Array.isArray(o) && t.set(n, new Set(o || []));
    }
  } catch {
  }
}
function di(e, t) {
  if (t.size > 0) {
    let r = {};
    for (let [a, n] of t)
      r[a] = [...n];
    try {
      e.sessionStorage.setItem(
        Ka,
        JSON.stringify(r)
      );
    } catch (a) {
      V(
        !1,
        `Failed to save applied view transitions in sessionStorage (${a}).`
      );
    }
  }
}
function fi() {
  let e, t, r = new Promise((a, n) => {
    e = async (o) => {
      a(o);
      try {
        await r;
      } catch {
      }
    }, t = async (o) => {
      n(o);
      try {
        await r;
      } catch {
      }
    };
  });
  return {
    promise: r,
    //@ts-ignore
    resolve: e,
    //@ts-ignore
    reject: t
  };
}
var _e = c.createContext(null);
_e.displayName = "DataRouter";
var Ke = c.createContext(null);
Ke.displayName = "DataRouterState";
var hi = c.createContext(!1);
function mi() {
  return c.useContext(hi);
}
var Wt = c.createContext({
  isTransitioning: !1
});
Wt.displayName = "ViewTransition";
var Yt = c.createContext(
  /* @__PURE__ */ new Map()
);
Yt.displayName = "Fetchers";
var yt = c.createContext(null);
yt.displayName = "Await";
var he = c.createContext(
  null
);
he.displayName = "Navigation";
var ot = c.createContext(
  null
);
ot.displayName = "Location";
var me = c.createContext({
  outlet: null,
  matches: [],
  isDataRoute: !1
});
me.displayName = "Route";
var Mr = c.createContext(null);
Mr.displayName = "RouteError";
function pi(e, { relative: t } = {}) {
  I(
    Xe(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useHref() may be used only in the context of a <Router> component."
  );
  let { basename: r, navigator: a } = c.useContext(he), { hash: n, pathname: o, search: i } = gt(e, { relative: t }), l = o;
  return r !== "/" && (l = o === "/" ? r : Le([r, o])), a.createHref({ pathname: l, search: i, hash: n });
}
function Xe() {
  return c.useContext(ot) != null;
}
function pe() {
  return I(
    Xe(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useLocation() may be used only in the context of a <Router> component."
  ), c.useContext(ot).location;
}
function ls() {
  return c.useContext(ot).navigationType;
}
function ss(e) {
  I(
    Xe(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useMatch() may be used only in the context of a <Router> component."
  );
  let { pathname: t } = pe();
  return c.useMemo(
    () => mt(e, Ba(t)),
    [t, e]
  );
}
var cn = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function dn(e) {
  c.useContext(he).static || c.useLayoutEffect(e);
}
function Tr() {
  let { isDataRoute: e } = c.useContext(me);
  return e ? Mi() : yi();
}
function yi() {
  I(
    Xe(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useNavigate() may be used only in the context of a <Router> component."
  );
  let e = c.useContext(_e), { basename: t, navigator: r } = c.useContext(he), { matches: a } = c.useContext(me), { pathname: n } = pe(), o = JSON.stringify(zt(a)), i = c.useRef(!1);
  return dn(() => {
    i.current = !0;
  }), c.useCallback(
    (s, u = {}) => {
      if (V(i.current, cn), !i.current) return;
      if (typeof s == "number") {
        r.go(s);
        return;
      }
      let d = Bt(
        s,
        JSON.parse(o),
        n,
        u.relative === "path"
      );
      e == null && t !== "/" && (d.pathname = d.pathname === "/" ? t : Le([t, d.pathname])), (u.replace ? r.replace : r.push)(
        d,
        u.state,
        u
      );
    },
    [
      t,
      r,
      o,
      n,
      e
    ]
  );
}
var fn = c.createContext(null);
function us() {
  return c.useContext(fn);
}
function vi(e) {
  let t = c.useContext(me).outlet;
  return t && /* @__PURE__ */ c.createElement(fn.Provider, { value: e }, t);
}
function _r() {
  let { matches: e } = c.useContext(me), t = e[e.length - 1];
  return t ? t.params : {};
}
function gt(e, { relative: t } = {}) {
  let { matches: r } = c.useContext(me), { pathname: a } = pe(), n = JSON.stringify(zt(r));
  return c.useMemo(
    () => Bt(
      e,
      JSON.parse(n),
      a,
      t === "path"
    ),
    [e, n, a, t]
  );
}
function gi(e, t) {
  return Or(e, t);
}
function Or(e, t, r, a, n) {
  I(
    Xe(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useRoutes() may be used only in the context of a <Router> component."
  );
  let { navigator: o } = c.useContext(he), { matches: i } = c.useContext(me), l = i[i.length - 1], s = l ? l.params : {}, u = l ? l.pathname : "/", d = l ? l.pathnameBase : "/", f = l && l.route;
  {
    let R = f && f.path || "";
    mn(
      u,
      !f || R.endsWith("*") || R.endsWith("*?"),
      `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${u}" (under <Route path="${R}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${R}"> to <Route path="${R === "/" ? "*" : `${R}/*`}">.`
    );
  }
  let h = pe(), m;
  if (t) {
    let R = typeof t == "string" ? Ee(t) : t;
    I(
      d === "/" || R.pathname?.startsWith(d),
      `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${d}" but pathname "${R.pathname}" was given in the \`location\` prop.`
    ), m = R;
  } else
    m = h;
  let y = m.pathname || "/", C = y;
  if (d !== "/") {
    let R = d.replace(/^\//, "").split("/");
    C = "/" + y.replace(/^\//, "").split("/").slice(R.length).join("/");
  }
  let g = Se(e, { pathname: C });
  V(
    f || g != null,
    `No routes matched location "${m.pathname}${m.search}${m.hash}" `
  ), V(
    g == null || g[g.length - 1].route.element !== void 0 || g[g.length - 1].route.Component !== void 0 || g[g.length - 1].route.lazy !== void 0,
    `Matched leaf route at location "${m.pathname}${m.search}${m.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`
  );
  let b = hn(
    g && g.map(
      (R) => Object.assign({}, R, {
        params: Object.assign({}, s, R.params),
        pathname: Le([
          d,
          // Re-encode pathnames that were decoded inside matchRoutes
          o.encodeLocation ? o.encodeLocation(R.pathname).pathname : R.pathname
        ]),
        pathnameBase: R.pathnameBase === "/" ? d : Le([
          d,
          // Re-encode pathnames that were decoded inside matchRoutes
          o.encodeLocation ? o.encodeLocation(R.pathnameBase).pathname : R.pathnameBase
        ])
      })
    ),
    i,
    r,
    a,
    n
  );
  return t && b ? /* @__PURE__ */ c.createElement(
    ot.Provider,
    {
      value: {
        location: {
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default",
          ...m
        },
        navigationType: "POP"
        /* Pop */
      }
    },
    b
  ) : b;
}
function wi() {
  let e = Ir(), t = be(e) ? `${e.status} ${e.statusText}` : e instanceof Error ? e.message : JSON.stringify(e), r = e instanceof Error ? e.stack : null, a = "rgba(200,200,200, 0.5)", n = { padding: "0.5rem", backgroundColor: a }, o = { padding: "2px 4px", backgroundColor: a }, i = null;
  return console.error(
    "Error handled by React Router default ErrorBoundary:",
    e
  ), i = /* @__PURE__ */ c.createElement(c.Fragment, null, /* @__PURE__ */ c.createElement("p", null, " Hey developer "), /* @__PURE__ */ c.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ c.createElement("code", { style: o }, "ErrorBoundary"), " or", " ", /* @__PURE__ */ c.createElement("code", { style: o }, "errorElement"), " prop on your route.")), /* @__PURE__ */ c.createElement(c.Fragment, null, /* @__PURE__ */ c.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ c.createElement("h3", { style: { fontStyle: "italic" } }, t), r ? /* @__PURE__ */ c.createElement("pre", { style: n }, r) : null, i);
}
var bi = /* @__PURE__ */ c.createElement(wi, null), Ei = class extends c.Component {
  constructor(e) {
    super(e), this.state = {
      location: e.location,
      revalidation: e.revalidation,
      error: e.error
    };
  }
  static getDerivedStateFromError(e) {
    return { error: e };
  }
  static getDerivedStateFromProps(e, t) {
    return t.location !== e.location || t.revalidation !== "idle" && e.revalidation === "idle" ? {
      error: e.error,
      location: e.location,
      revalidation: e.revalidation
    } : {
      error: e.error !== void 0 ? e.error : t.error,
      location: t.location,
      revalidation: e.revalidation || t.revalidation
    };
  }
  componentDidCatch(e, t) {
    this.props.unstable_onError ? this.props.unstable_onError(e, t) : console.error(
      "React Router caught the following error during render",
      e
    );
  }
  render() {
    return this.state.error !== void 0 ? /* @__PURE__ */ c.createElement(me.Provider, { value: this.props.routeContext }, /* @__PURE__ */ c.createElement(
      Mr.Provider,
      {
        value: this.state.error,
        children: this.props.component
      }
    )) : this.props.children;
  }
};
function Ri({ routeContext: e, match: t, children: r }) {
  let a = c.useContext(_e);
  return a && a.static && a.staticContext && (t.route.errorElement || t.route.ErrorBoundary) && (a.staticContext._deepestRenderedBoundaryId = t.route.id), /* @__PURE__ */ c.createElement(me.Provider, { value: e }, r);
}
function hn(e, t = [], r = null, a = null, n = null) {
  if (e == null) {
    if (!r)
      return null;
    if (r.errors)
      e = r.matches;
    else if (t.length === 0 && !r.initialized && r.matches.length > 0)
      e = r.matches;
    else
      return null;
  }
  let o = e, i = r?.errors;
  if (i != null) {
    let u = o.findIndex(
      (d) => d.route.id && i?.[d.route.id] !== void 0
    );
    I(
      u >= 0,
      `Could not find a matching route for errors on route IDs: ${Object.keys(
        i
      ).join(",")}`
    ), o = o.slice(
      0,
      Math.min(o.length, u + 1)
    );
  }
  let l = !1, s = -1;
  if (r)
    for (let u = 0; u < o.length; u++) {
      let d = o[u];
      if ((d.route.HydrateFallback || d.route.hydrateFallbackElement) && (s = u), d.route.id) {
        let { loaderData: f, errors: h } = r, m = d.route.loader && !f.hasOwnProperty(d.route.id) && (!h || h[d.route.id] === void 0);
        if (d.route.lazy || m) {
          l = !0, s >= 0 ? o = o.slice(0, s + 1) : o = [o[0]];
          break;
        }
      }
    }
  return o.reduceRight(
    (u, d, f) => {
      let h, m = !1, y = null, C = null;
      r && (h = i && d.route.id ? i[d.route.id] : void 0, y = d.route.errorElement || bi, l && (s < 0 && f === 0 ? (mn(
        "route-fallback",
        !1,
        "No `HydrateFallback` element provided to render during initial hydration"
      ), m = !0, C = null) : s === f && (m = !0, C = d.route.hydrateFallbackElement || null)));
      let g = t.concat(o.slice(0, f + 1)), b = () => {
        let R;
        return h ? R = y : m ? R = C : d.route.Component ? R = /* @__PURE__ */ c.createElement(d.route.Component, null) : d.route.element ? R = d.route.element : R = u, /* @__PURE__ */ c.createElement(
          Ri,
          {
            match: d,
            routeContext: {
              outlet: u,
              matches: g,
              isDataRoute: r != null
            },
            children: R
          }
        );
      };
      return r && (d.route.ErrorBoundary || d.route.errorElement || f === 0) ? /* @__PURE__ */ c.createElement(
        Ei,
        {
          location: r.location,
          revalidation: r.revalidation,
          component: y,
          error: h,
          children: b(),
          routeContext: { outlet: null, matches: g, isDataRoute: !0 },
          unstable_onError: a
        }
      ) : b();
    },
    null
  );
}
function $r(e) {
  return `${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function Nr(e) {
  let t = c.useContext(_e);
  return I(t, $r(e)), t;
}
function Ie(e) {
  let t = c.useContext(Ke);
  return I(t, $r(e)), t;
}
function Si(e) {
  let t = c.useContext(me);
  return I(t, $r(e)), t;
}
function wt(e) {
  let t = Si(e), r = t.matches[t.matches.length - 1];
  return I(
    r.route.id,
    `${e} can only be used on routes that contain a unique "id"`
  ), r.route.id;
}
function Ci() {
  return wt(
    "useRouteId"
    /* UseRouteId */
  );
}
function Pi() {
  return Ie(
    "useNavigation"
    /* UseNavigation */
  ).navigation;
}
function cs() {
  let e = Nr(
    "useRevalidator"
    /* UseRevalidator */
  ), t = Ie(
    "useRevalidator"
    /* UseRevalidator */
  ), r = c.useCallback(async () => {
    await e.router.revalidate();
  }, [e.router]);
  return c.useMemo(
    () => ({ revalidate: r, state: t.revalidation }),
    [r, t.revalidation]
  );
}
function Fr() {
  let { matches: e, loaderData: t } = Ie(
    "useMatches"
    /* UseMatches */
  );
  return c.useMemo(
    () => e.map((r) => ja(r, t)),
    [e, t]
  );
}
function kr() {
  let e = Ie(
    "useLoaderData"
    /* UseLoaderData */
  ), t = wt(
    "useLoaderData"
    /* UseLoaderData */
  );
  return e.loaderData[t];
}
function ds(e) {
  return Ie(
    "useRouteLoaderData"
    /* UseRouteLoaderData */
  ).loaderData[e];
}
function Ar() {
  let e = Ie(
    "useActionData"
    /* UseActionData */
  ), t = wt(
    "useLoaderData"
    /* UseLoaderData */
  );
  return e.actionData ? e.actionData[t] : void 0;
}
function Ir() {
  let e = c.useContext(Mr), t = Ie(
    "useRouteError"
    /* UseRouteError */
  ), r = wt(
    "useRouteError"
    /* UseRouteError */
  );
  return e !== void 0 ? e : t.errors?.[r];
}
function xi() {
  return c.useContext(yt)?._data;
}
function fs() {
  return c.useContext(yt)?._error;
}
var Li = 0;
function Di(e) {
  let { router: t, basename: r } = Nr(
    "useBlocker"
    /* UseBlocker */
  ), a = Ie(
    "useBlocker"
    /* UseBlocker */
  ), [n, o] = c.useState(""), i = c.useCallback(
    (l) => {
      if (typeof e != "function")
        return !!e;
      if (r === "/")
        return e(l);
      let { currentLocation: s, nextLocation: u, historyAction: d } = l;
      return e({
        currentLocation: {
          ...s,
          pathname: se(s.pathname, r) || s.pathname
        },
        nextLocation: {
          ...u,
          pathname: se(u.pathname, r) || u.pathname
        },
        historyAction: d
      });
    },
    [r, e]
  );
  return c.useEffect(() => {
    let l = String(++Li);
    return o(l), () => t.deleteBlocker(l);
  }, [t]), c.useEffect(() => {
    n !== "" && t.getBlocker(n, i);
  }, [t, n, i]), n && a.blockers.has(n) ? a.blockers.get(n) : Ye;
}
function Mi() {
  let { router: e } = Nr(
    "useNavigate"
    /* UseNavigateStable */
  ), t = wt(
    "useNavigate"
    /* UseNavigateStable */
  ), r = c.useRef(!1);
  return dn(() => {
    r.current = !0;
  }), c.useCallback(
    async (n, o = {}) => {
      V(r.current, cn), r.current && (typeof n == "number" ? e.navigate(n) : await e.navigate(n, { fromRouteId: t, ...o }));
    },
    [e, t]
  );
}
var Pa = {};
function mn(e, t, r) {
  !t && !Pa[e] && (Pa[e] = !0, V(!1, r));
}
var xa = {};
function hr(e, t) {
  !e && !xa[t] && (xa[t] = !0, console.warn(t));
}
function bt(e) {
  let t = {
    // Note: this check also occurs in createRoutesFromChildren so update
    // there if you change this -- please and thank you!
    hasErrorBoundary: e.hasErrorBoundary || e.ErrorBoundary != null || e.errorElement != null
  };
  return e.Component && (e.element && V(
    !1,
    "You should not include both `Component` and `element` on your route - `Component` will be used."
  ), Object.assign(t, {
    element: c.createElement(e.Component),
    Component: void 0
  })), e.HydrateFallback && (e.hydrateFallbackElement && V(
    !1,
    "You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used."
  ), Object.assign(t, {
    hydrateFallbackElement: c.createElement(e.HydrateFallback),
    HydrateFallback: void 0
  })), e.ErrorBoundary && (e.errorElement && V(
    !1,
    "You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used."
  ), Object.assign(t, {
    errorElement: c.createElement(e.ErrorBoundary),
    ErrorBoundary: void 0
  })), t;
}
var jr = [
  "HydrateFallback",
  "hydrateFallbackElement"
];
function hs(e, t) {
  return xr({
    basename: t?.basename,
    unstable_getContext: t?.unstable_getContext,
    future: t?.future,
    history: Na({
      initialEntries: t?.initialEntries,
      initialIndex: t?.initialIndex
    }),
    hydrationData: t?.hydrationData,
    routes: e,
    hydrationRouteProperties: jr,
    mapRouteProperties: bt,
    dataStrategy: t?.dataStrategy,
    patchRoutesOnNavigation: t?.patchRoutesOnNavigation
  }).initialize();
}
var Ti = class {
  constructor() {
    this.status = "pending", this.promise = new Promise((e, t) => {
      this.resolve = (r) => {
        this.status === "pending" && (this.status = "resolved", e(r));
      }, this.reject = (r) => {
        this.status === "pending" && (this.status = "rejected", t(r));
      };
    });
  }
};
function ms({
  router: e,
  flushSync: t,
  unstable_onError: r
}) {
  let [a, n] = c.useState(e.state), [o, i] = c.useState(), [l, s] = c.useState({
    isTransitioning: !1
  }), [u, d] = c.useState(), [f, h] = c.useState(), [m, y] = c.useState(), C = c.useRef(/* @__PURE__ */ new Map()), g = c.useCallback(
    (E) => {
      n((v) => (E.errors && r && Object.entries(E.errors).forEach(([_, D]) => {
        v.errors?.[_] !== D && r(D);
      }), E));
    },
    [r]
  ), b = c.useCallback(
    (E, { deletedFetchers: v, flushSync: _, viewTransitionOpts: D }) => {
      E.fetchers.forEach(($, U) => {
        $.data !== void 0 && C.current.set(U, $.data);
      }), v.forEach(($) => C.current.delete($)), hr(
        _ === !1 || t != null,
        'You provided the `flushSync` option to a router update, but you are not using the `<RouterProvider>` from `react-router/dom` so `ReactDOM.flushSync()` is unavailable.  Please update your app to `import { RouterProvider } from "react-router/dom"` and ensure you have `react-dom` installed as a dependency to use the `flushSync` option.'
      );
      let T = e.window != null && e.window.document != null && typeof e.window.document.startViewTransition == "function";
      if (hr(
        D == null || T,
        "You provided the `viewTransition` option to a router update, but you do not appear to be running in a DOM environment as `window.startViewTransition` is not available."
      ), !D || !T) {
        t && _ ? t(() => g(E)) : c.startTransition(() => g(E));
        return;
      }
      if (t && _) {
        t(() => {
          f && (u && u.resolve(), f.skipTransition()), s({
            isTransitioning: !0,
            flushSync: !0,
            currentLocation: D.currentLocation,
            nextLocation: D.nextLocation
          });
        });
        let $ = e.window.document.startViewTransition(() => {
          t(() => g(E));
        });
        $.finished.finally(() => {
          t(() => {
            d(void 0), h(void 0), i(void 0), s({ isTransitioning: !1 });
          });
        }), t(() => h($));
        return;
      }
      f ? (u && u.resolve(), f.skipTransition(), y({
        state: E,
        currentLocation: D.currentLocation,
        nextLocation: D.nextLocation
      })) : (i(E), s({
        isTransitioning: !0,
        flushSync: !1,
        currentLocation: D.currentLocation,
        nextLocation: D.nextLocation
      }));
    },
    [
      e.window,
      t,
      f,
      u,
      g
    ]
  );
  c.useLayoutEffect(() => e.subscribe(b), [e, b]), c.useEffect(() => {
    l.isTransitioning && !l.flushSync && d(new Ti());
  }, [l]), c.useEffect(() => {
    if (u && o && e.window) {
      let E = o, v = u.promise, _ = e.window.document.startViewTransition(async () => {
        c.startTransition(() => g(E)), await v;
      });
      _.finished.finally(() => {
        d(void 0), h(void 0), i(void 0), s({ isTransitioning: !1 });
      }), h(_);
    }
  }, [o, u, e.window, g]), c.useEffect(() => {
    u && o && a.location.key === o.location.key && u.resolve();
  }, [u, f, a.location, o]), c.useEffect(() => {
    !l.isTransitioning && m && (i(m.state), s({
      isTransitioning: !0,
      flushSync: !1,
      currentLocation: m.currentLocation,
      nextLocation: m.nextLocation
    }), y(void 0));
  }, [l.isTransitioning, m]);
  let R = c.useMemo(() => ({
    createHref: e.createHref,
    encodeLocation: e.encodeLocation,
    go: (E) => e.navigate(E),
    push: (E, v, _) => e.navigate(E, {
      state: v,
      preventScrollReset: _?.preventScrollReset
    }),
    replace: (E, v, _) => e.navigate(E, {
      replace: !0,
      state: v,
      preventScrollReset: _?.preventScrollReset
    })
  }), [e]), x = e.basename || "/", P = c.useMemo(
    () => ({
      router: e,
      navigator: R,
      static: !1,
      basename: x,
      unstable_onError: r
    }),
    [e, R, x, r]
  );
  return /* @__PURE__ */ c.createElement(c.Fragment, null, /* @__PURE__ */ c.createElement(_e.Provider, { value: P }, /* @__PURE__ */ c.createElement(Ke.Provider, { value: a }, /* @__PURE__ */ c.createElement(Yt.Provider, { value: C.current }, /* @__PURE__ */ c.createElement(Wt.Provider, { value: l }, /* @__PURE__ */ c.createElement(
    Ge,
    {
      basename: x,
      location: a.location,
      navigationType: a.historyAction,
      navigator: R
    },
    /* @__PURE__ */ c.createElement(
      _i,
      {
        routes: e.routes,
        future: e.future,
        state: a,
        unstable_onError: r
      }
    )
  ))))), null);
}
var _i = c.memo(Oi);
function Oi({
  routes: e,
  future: t,
  state: r,
  unstable_onError: a
}) {
  return Or(e, void 0, r, a, t);
}
function ps({
  basename: e,
  children: t,
  initialEntries: r,
  initialIndex: a
}) {
  let n = c.useRef();
  n.current == null && (n.current = Na({
    initialEntries: r,
    initialIndex: a,
    v5Compat: !0
  }));
  let o = n.current, [i, l] = c.useState({
    action: o.action,
    location: o.location
  }), s = c.useCallback(
    (u) => {
      c.startTransition(() => l(u));
    },
    [l]
  );
  return c.useLayoutEffect(() => o.listen(s), [o, s]), /* @__PURE__ */ c.createElement(
    Ge,
    {
      basename: e,
      children: t,
      location: i.location,
      navigationType: i.action,
      navigator: o
    }
  );
}
function ys({
  to: e,
  replace: t,
  state: r,
  relative: a
}) {
  I(
    Xe(),
    // TODO: This error is probably because they somehow have 2 versions of
    // the router loaded. We can help them understand how to avoid that.
    "<Navigate> may be used only in the context of a <Router> component."
  );
  let { static: n } = c.useContext(he);
  V(
    !n,
    "<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change."
  );
  let { matches: o } = c.useContext(me), { pathname: i } = pe(), l = Tr(), s = Bt(
    e,
    zt(o),
    i,
    a === "path"
  ), u = JSON.stringify(s);
  return c.useEffect(() => {
    l(JSON.parse(u), { replace: t, state: r, relative: a });
  }, [l, u, a, t, r]), null;
}
function vs(e) {
  return vi(e.context);
}
function $i(e) {
  I(
    !1,
    "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>."
  );
}
function Ge({
  basename: e = "/",
  children: t = null,
  location: r,
  navigationType: a = "POP",
  navigator: n,
  static: o = !1
}) {
  I(
    !Xe(),
    "You cannot render a <Router> inside another <Router>. You should never have more than one in your app."
  );
  let i = e.replace(/^\/*/, "/"), l = c.useMemo(
    () => ({
      basename: i,
      navigator: n,
      static: o,
      future: {}
    }),
    [i, n, o]
  );
  typeof r == "string" && (r = Ee(r));
  let {
    pathname: s = "/",
    search: u = "",
    hash: d = "",
    state: f = null,
    key: h = "default"
  } = r, m = c.useMemo(() => {
    let y = se(s, i);
    return y == null ? null : {
      location: {
        pathname: y,
        search: u,
        hash: d,
        state: f,
        key: h
      },
      navigationType: a
    };
  }, [i, s, u, d, f, h, a]);
  return V(
    m != null,
    `<Router basename="${i}"> is not able to match the URL "${s}${u}${d}" because it does not start with the basename, so the <Router> won't render anything.`
  ), m == null ? null : /* @__PURE__ */ c.createElement(he.Provider, { value: l }, /* @__PURE__ */ c.createElement(ot.Provider, { children: t, value: m }));
}
function gs({
  children: e,
  location: t
}) {
  return gi(jt(e), t);
}
function ws({
  children: e,
  errorElement: t,
  resolve: r
}) {
  let a = c.useContext(_e);
  return /* @__PURE__ */ c.createElement(
    Ni,
    {
      resolve: r,
      errorElement: t,
      unstable_onError: a?.unstable_onError
    },
    /* @__PURE__ */ c.createElement(Fi, null, e)
  );
}
var Ni = class extends c.Component {
  constructor(e) {
    super(e), this.state = { error: null };
  }
  static getDerivedStateFromError(e) {
    return { error: e };
  }
  componentDidCatch(e, t) {
    this.props.unstable_onError ? this.props.unstable_onError(e, t) : console.error(
      "<Await> caught the following error during render",
      e,
      t
    );
  }
  render() {
    let { children: e, errorElement: t, resolve: r } = this.props, a = null, n = 0;
    if (!(r instanceof Promise))
      n = 1, a = Promise.resolve(), Object.defineProperty(a, "_tracked", { get: () => !0 }), Object.defineProperty(a, "_data", { get: () => r });
    else if (this.state.error) {
      n = 2;
      let o = this.state.error;
      a = Promise.reject().catch(() => {
      }), Object.defineProperty(a, "_tracked", { get: () => !0 }), Object.defineProperty(a, "_error", { get: () => o });
    } else r._tracked ? (a = r, n = "_error" in a ? 2 : "_data" in a ? 1 : 0) : (n = 0, Object.defineProperty(r, "_tracked", { get: () => !0 }), a = r.then(
      (o) => Object.defineProperty(r, "_data", { get: () => o }),
      (o) => {
        this.props.unstable_onError?.(o), Object.defineProperty(r, "_error", { get: () => o });
      }
    ));
    if (n === 2 && !t)
      throw a._error;
    if (n === 2)
      return /* @__PURE__ */ c.createElement(yt.Provider, { value: a, children: t });
    if (n === 1)
      return /* @__PURE__ */ c.createElement(yt.Provider, { value: a, children: e });
    throw a;
  }
};
function Fi({
  children: e
}) {
  let t = xi(), r = typeof e == "function" ? e(t) : e;
  return /* @__PURE__ */ c.createElement(c.Fragment, null, r);
}
function jt(e, t = []) {
  let r = [];
  return c.Children.forEach(e, (a, n) => {
    if (!c.isValidElement(a))
      return;
    let o = [...t, n];
    if (a.type === c.Fragment) {
      r.push.apply(
        r,
        jt(a.props.children, o)
      );
      return;
    }
    I(
      a.type === $i,
      `[${typeof a.type == "string" ? a.type : a.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`
    ), I(
      !a.props.index || !a.props.children,
      "An index route cannot have child routes."
    );
    let i = {
      id: a.props.id || o.join("-"),
      caseSensitive: a.props.caseSensitive,
      element: a.props.element,
      Component: a.props.Component,
      index: a.props.index,
      path: a.props.path,
      loader: a.props.loader,
      action: a.props.action,
      hydrateFallbackElement: a.props.hydrateFallbackElement,
      HydrateFallback: a.props.HydrateFallback,
      errorElement: a.props.errorElement,
      ErrorBoundary: a.props.ErrorBoundary,
      hasErrorBoundary: a.props.hasErrorBoundary === !0 || a.props.ErrorBoundary != null || a.props.errorElement != null,
      shouldRevalidate: a.props.shouldRevalidate,
      handle: a.props.handle,
      lazy: a.props.lazy
    };
    a.props.children && (i.children = jt(
      a.props.children,
      o
    )), r.push(i);
  }), r;
}
var bs = jt;
function Es(e) {
  return hn(e);
}
function pn() {
  return {
    params: _r(),
    loaderData: kr(),
    actionData: Ar(),
    matches: Fr()
  };
}
function Rs({
  children: e
}) {
  const t = pn();
  return c.cloneElement(e, t);
}
function Ss(e) {
  return function() {
    const r = pn();
    return c.createElement(e, r);
  };
}
function yn() {
  return {
    params: _r(),
    loaderData: kr(),
    actionData: Ar()
  };
}
function Cs({
  children: e
}) {
  const t = yn();
  return c.cloneElement(e, t);
}
function Ps(e) {
  return function() {
    const r = yn();
    return c.createElement(e, r);
  };
}
function vn() {
  return {
    params: _r(),
    loaderData: kr(),
    actionData: Ar(),
    error: Ir()
  };
}
function xs({
  children: e
}) {
  const t = vn();
  return c.cloneElement(e, t);
}
function Ls(e) {
  return function() {
    const r = vn();
    return c.createElement(e, r);
  };
}
var Ft = "get", kt = "application/x-www-form-urlencoded";
function Jt(e) {
  return e != null && typeof e.tagName == "string";
}
function ki(e) {
  return Jt(e) && e.tagName.toLowerCase() === "button";
}
function Ai(e) {
  return Jt(e) && e.tagName.toLowerCase() === "form";
}
function Ii(e) {
  return Jt(e) && e.tagName.toLowerCase() === "input";
}
function ji(e) {
  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
}
function Hi(e, t) {
  return e.button === 0 && // Ignore everything but left clicks
  (!t || t === "_self") && // Let browser handle "target=_blank" etc.
  !ji(e);
}
function mr(e = "") {
  return new URLSearchParams(
    typeof e == "string" || Array.isArray(e) || e instanceof URLSearchParams ? e : Object.keys(e).reduce((t, r) => {
      let a = e[r];
      return t.concat(
        Array.isArray(a) ? a.map((n) => [r, n]) : [[r, a]]
      );
    }, [])
  );
}
function Ui(e, t) {
  let r = mr(e);
  return t && t.forEach((a, n) => {
    r.has(n) || t.getAll(n).forEach((o) => {
      r.append(n, o);
    });
  }), r;
}
var Mt = null;
function zi() {
  if (Mt === null)
    try {
      new FormData(
        document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0
      ), Mt = !1;
    } catch {
      Mt = !0;
    }
  return Mt;
}
var Bi = /* @__PURE__ */ new Set([
  "application/x-www-form-urlencoded",
  "multipart/form-data",
  "text/plain"
]);
function ar(e) {
  return e != null && !Bi.has(e) ? (V(
    !1,
    `"${e}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${kt}"`
  ), null) : e;
}
function Wi(e, t) {
  let r, a, n, o, i;
  if (Ai(e)) {
    let l = e.getAttribute("action");
    a = l ? se(l, t) : null, r = e.getAttribute("method") || Ft, n = ar(e.getAttribute("enctype")) || kt, o = new FormData(e);
  } else if (ki(e) || Ii(e) && (e.type === "submit" || e.type === "image")) {
    let l = e.form;
    if (l == null)
      throw new Error(
        'Cannot submit a <button> or <input type="submit"> without a <form>'
      );
    let s = e.getAttribute("formaction") || l.getAttribute("action");
    if (a = s ? se(s, t) : null, r = e.getAttribute("formmethod") || l.getAttribute("method") || Ft, n = ar(e.getAttribute("formenctype")) || ar(l.getAttribute("enctype")) || kt, o = new FormData(l, e), !zi()) {
      let { name: u, type: d, value: f } = e;
      if (d === "image") {
        let h = u ? `${u}.` : "";
        o.append(`${h}x`, "0"), o.append(`${h}y`, "0");
      } else u && o.append(u, f);
    }
  } else {
    if (Jt(e))
      throw new Error(
        'Cannot submit element that is not <form>, <button>, or <input type="submit|image">'
      );
    r = Ft, a = null, n = kt, i = e;
  }
  return o && n === "text/plain" && (i = o, o = void 0), { action: a, method: r.toLowerCase(), encType: n, formData: o, body: i };
}
var gn = -1, wn = -2, bn = -3, En = -4, Hr = -5, Rn = -6, Sn = -7, Cn = "B", Pn = "D", at = "E", pr = "M", xn = "N", nt = "P", Ln = "R", yr = "S", Dn = "Y", Mn = "U", vr = "Z", Tn = class {
  constructor() {
    this.promise = new Promise((e, t) => {
      this.resolve = e, this.reject = t;
    });
  }
};
function Yi() {
  const e = new TextDecoder();
  let t = "";
  return new TransformStream({
    transform(r, a) {
      const n = e.decode(r, { stream: !0 }), o = (t + n).split(`
`);
      t = o.pop() || "";
      for (const i of o)
        a.enqueue(i);
    },
    flush(r) {
      t && r.enqueue(t);
    }
  });
}
function ge(e) {
  const { indices: t } = this, r = t.get(e);
  if (r) return [r];
  if (e === void 0) return Sn;
  if (e === null) return Hr;
  if (Number.isNaN(e)) return wn;
  if (e === Number.POSITIVE_INFINITY) return Rn;
  if (e === Number.NEGATIVE_INFINITY) return bn;
  if (e === 0 && 1 / e < 0) return En;
  const a = this.index++;
  return t.set(e, a), Ji.call(this, e, a), a;
}
function Ji(e, t) {
  const { deferred: r, plugins: a, postPlugins: n } = this, o = this.stringified, i = [[e, t]];
  for (; i.length > 0; ) {
    const [l, s] = i.pop(), u = (f) => Object.keys(f).map((h) => `"_${ge.call(this, h)}":${ge.call(this, f[h])}`).join(",");
    let d = null;
    switch (typeof l) {
      case "boolean":
      case "number":
      case "string":
        o[s] = JSON.stringify(l);
        break;
      case "bigint":
        o[s] = `["${Cn}","${l}"]`;
        break;
      case "symbol": {
        const f = Symbol.keyFor(l);
        f ? o[s] = `["${Dn}",${JSON.stringify(f)}]` : d = new Error(
          "Cannot encode symbol unless created with Symbol.for()"
        );
        break;
      }
      case "object": {
        if (!l) {
          o[s] = `${Hr}`;
          break;
        }
        const f = Array.isArray(l);
        let h = !1;
        if (!f && a)
          for (const m of a) {
            const y = m(l);
            if (Array.isArray(y)) {
              h = !0;
              const [C, ...g] = y;
              o[s] = `[${JSON.stringify(C)}`, g.length > 0 && (o[s] += `,${g.map((b) => ge.call(this, b)).join(",")}`), o[s] += "]";
              break;
            }
          }
        if (!h) {
          let m = f ? "[" : "{";
          if (f) {
            for (let y = 0; y < l.length; y++)
              m += (y ? "," : "") + (y in l ? ge.call(this, l[y]) : gn);
            o[s] = `${m}]`;
          } else if (l instanceof Date) {
            const y = l.getTime();
            o[s] = `["${Pn}",${Number.isNaN(y) ? JSON.stringify("invalid") : y}]`;
          } else l instanceof URL ? o[s] = `["${Mn}",${JSON.stringify(l.href)}]` : l instanceof RegExp ? o[s] = `["${Ln}",${JSON.stringify(
            l.source
          )},${JSON.stringify(l.flags)}]` : l instanceof Set ? l.size > 0 ? o[s] = `["${yr}",${[...l].map((y) => ge.call(this, y)).join(",")}]` : o[s] = `["${yr}"]` : l instanceof Map ? l.size > 0 ? o[s] = `["${pr}",${[...l].flatMap(([y, C]) => [
            ge.call(this, y),
            ge.call(this, C)
          ]).join(",")}]` : o[s] = `["${pr}"]` : l instanceof Promise ? (o[s] = `["${nt}",${s}]`, r[s] = l) : l instanceof Error ? (o[s] = `["${at}",${JSON.stringify(l.message)}`, l.name !== "Error" && (o[s] += `,${JSON.stringify(l.name)}`), o[s] += "]") : Object.getPrototypeOf(l) === null ? o[s] = `["${xn}",{${u(l)}}]` : Ki(l) ? o[s] = `{${u(l)}}` : d = new Error("Cannot encode object with prototype");
        }
        break;
      }
      default: {
        const f = Array.isArray(l);
        let h = !1;
        if (!f && a)
          for (const m of a) {
            const y = m(l);
            if (Array.isArray(y)) {
              h = !0;
              const [C, ...g] = y;
              o[s] = `[${JSON.stringify(C)}`, g.length > 0 && (o[s] += `,${g.map((b) => ge.call(this, b)).join(",")}`), o[s] += "]";
              break;
            }
          }
        h || (d = new Error("Cannot encode function or unexpected type"));
      }
    }
    if (d) {
      let f = !1;
      if (n)
        for (const h of n) {
          const m = h(l);
          if (Array.isArray(m)) {
            f = !0;
            const [y, ...C] = m;
            o[s] = `[${JSON.stringify(y)}`, C.length > 0 && (o[s] += `,${C.map((g) => ge.call(this, g)).join(",")}`), o[s] += "]";
            break;
          }
        }
      if (!f)
        throw d;
    }
  }
}
var Vi = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
function Ki(e) {
  const t = Object.getPrototypeOf(e);
  return t === Object.prototype || t === null || Object.getOwnPropertyNames(t).sort().join("\0") === Vi;
}
var nr = typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : void 0;
function gr(e) {
  const { hydrated: t, values: r } = this;
  if (typeof e == "number") return La.call(this, e);
  if (!Array.isArray(e) || !e.length) throw new SyntaxError();
  const a = r.length;
  for (const n of e)
    r.push(n);
  return t.length = r.length, La.call(this, a);
}
function La(e) {
  const { hydrated: t, values: r, deferred: a, plugins: n } = this;
  let o;
  const i = [
    [
      e,
      (s) => {
        o = s;
      }
    ]
  ];
  let l = [];
  for (; i.length > 0; ) {
    const [s, u] = i.pop();
    switch (s) {
      case Sn:
        u(void 0);
        continue;
      case Hr:
        u(null);
        continue;
      case wn:
        u(NaN);
        continue;
      case Rn:
        u(1 / 0);
        continue;
      case bn:
        u(-1 / 0);
        continue;
      case En:
        u(-0);
        continue;
    }
    if (t[s]) {
      u(t[s]);
      continue;
    }
    const d = r[s];
    if (!d || typeof d != "object") {
      t[s] = d, u(d);
      continue;
    }
    if (Array.isArray(d))
      if (typeof d[0] == "string") {
        const [f, h, m] = d;
        switch (f) {
          case Pn:
            u(t[s] = new Date(h));
            continue;
          case Mn:
            u(t[s] = new URL(h));
            continue;
          case Cn:
            u(t[s] = BigInt(h));
            continue;
          case Ln:
            u(t[s] = new RegExp(h, m));
            continue;
          case Dn:
            u(t[s] = Symbol.for(h));
            continue;
          case yr:
            const y = /* @__PURE__ */ new Set();
            t[s] = y;
            for (let P = d.length - 1; P > 0; P--)
              i.push([
                d[P],
                (E) => {
                  y.add(E);
                }
              ]);
            u(y);
            continue;
          case pr:
            const C = /* @__PURE__ */ new Map();
            t[s] = C;
            for (let P = d.length - 2; P > 0; P -= 2) {
              const E = [];
              i.push([
                d[P + 1],
                (v) => {
                  E[1] = v;
                }
              ]), i.push([
                d[P],
                (v) => {
                  E[0] = v;
                }
              ]), l.push(() => {
                C.set(E[0], E[1]);
              });
            }
            u(C);
            continue;
          case xn:
            const g = /* @__PURE__ */ Object.create(null);
            t[s] = g;
            for (const P of Object.keys(h).reverse()) {
              const E = [];
              i.push([
                h[P],
                (v) => {
                  E[1] = v;
                }
              ]), i.push([
                Number(P.slice(1)),
                (v) => {
                  E[0] = v;
                }
              ]), l.push(() => {
                g[E[0]] = E[1];
              });
            }
            u(g);
            continue;
          case nt:
            if (t[h])
              u(t[s] = t[h]);
            else {
              const P = new Tn();
              a[h] = P, u(t[s] = P.promise);
            }
            continue;
          case at:
            const [, b, R] = d;
            let x = R && nr && nr[R] ? new nr[R](b) : new Error(b);
            t[s] = x, u(x);
            continue;
          case vr:
            u(t[s] = t[h]);
            continue;
          default:
            if (Array.isArray(n)) {
              const P = [], E = d.slice(1);
              for (let v = 0; v < E.length; v++) {
                const _ = E[v];
                i.push([
                  _,
                  (D) => {
                    P[v] = D;
                  }
                ]);
              }
              l.push(() => {
                for (const v of n) {
                  const _ = v(d[0], ...P);
                  if (_) {
                    u(t[s] = _.value);
                    return;
                  }
                }
                throw new SyntaxError();
              });
              continue;
            }
            throw new SyntaxError();
        }
      } else {
        const f = [];
        t[s] = f;
        for (let h = 0; h < d.length; h++) {
          const m = d[h];
          m !== gn && i.push([
            m,
            (y) => {
              f[h] = y;
            }
          ]);
        }
        u(f);
        continue;
      }
    else {
      const f = {};
      t[s] = f;
      for (const h of Object.keys(d).reverse()) {
        const m = [];
        i.push([
          d[h],
          (y) => {
            m[1] = y;
          }
        ]), i.push([
          Number(h.slice(1)),
          (y) => {
            m[0] = y;
          }
        ]), l.push(() => {
          f[m[0]] = m[1];
        });
      }
      u(f);
      continue;
    }
  }
  for (; l.length > 0; )
    l.pop()();
  return o;
}
async function Xi(e, t) {
  const { plugins: r } = t ?? {}, a = new Tn(), n = e.pipeThrough(Yi()).getReader(), o = {
    values: [],
    hydrated: [],
    deferred: {},
    plugins: r
  }, i = await Gi.call(o, n);
  let l = a.promise;
  return i.done ? a.resolve() : l = Qi.call(o, n).then(a.resolve).catch((s) => {
    for (const u of Object.values(o.deferred))
      u.reject(s);
    a.reject(s);
  }), {
    done: l.then(() => n.closed),
    value: i.value
  };
}
async function Gi(e) {
  const t = await e.read();
  if (!t.value)
    throw new SyntaxError();
  let r;
  try {
    r = JSON.parse(t.value);
  } catch {
    throw new SyntaxError();
  }
  return {
    done: t.done,
    value: gr.call(this, r)
  };
}
async function Qi(e) {
  let t = await e.read();
  for (; !t.done; ) {
    if (!t.value) continue;
    const r = t.value;
    switch (r[0]) {
      case nt: {
        const a = r.indexOf(":"), n = Number(r.slice(1, a)), o = this.deferred[n];
        if (!o)
          throw new Error(`Deferred ID ${n} not found in stream`);
        const i = r.slice(a + 1);
        let l;
        try {
          l = JSON.parse(i);
        } catch {
          throw new SyntaxError();
        }
        const s = gr.call(this, l);
        o.resolve(s);
        break;
      }
      case at: {
        const a = r.indexOf(":"), n = Number(r.slice(1, a)), o = this.deferred[n];
        if (!o)
          throw new Error(`Deferred ID ${n} not found in stream`);
        const i = r.slice(a + 1);
        let l;
        try {
          l = JSON.parse(i);
        } catch {
          throw new SyntaxError();
        }
        const s = gr.call(this, l);
        o.reject(s);
        break;
      }
      default:
        throw new SyntaxError();
    }
    t = await e.read();
  }
}
function Ds(e, t) {
  const { plugins: r, postPlugins: a, signal: n } = t ?? {}, o = {
    deferred: {},
    index: 0,
    indices: /* @__PURE__ */ new Map(),
    stringified: [],
    plugins: r,
    postPlugins: a,
    signal: n
  }, i = new TextEncoder();
  let l = 0;
  return new ReadableStream({
    async start(u) {
      const d = ge.call(o, e);
      if (Array.isArray(d))
        throw new Error("This should never happen");
      d < 0 ? u.enqueue(i.encode(`${d}
`)) : (u.enqueue(
        i.encode(`[${o.stringified.join(",")}]
`)
      ), l = o.stringified.length - 1);
      const f = /* @__PURE__ */ new WeakSet();
      if (Object.keys(o.deferred).length) {
        let h;
        const m = new Promise((y, C) => {
          if (h = y, n) {
            const g = () => C(n.reason || new Error("Signal was aborted."));
            n.aborted ? g() : n.addEventListener("abort", (b) => {
              g();
            });
          }
        });
        for (; Object.keys(o.deferred).length > 0; ) {
          for (const [y, C] of Object.entries(
            o.deferred
          ))
            f.has(C) || f.add(
              // biome-ignore lint/suspicious/noAssignInExpressions: <explanation>
              o.deferred[Number(y)] = Promise.race([
                m,
                C
              ]).then(
                (g) => {
                  const b = ge.call(o, g);
                  if (Array.isArray(b))
                    u.enqueue(
                      i.encode(
                        `${nt}${y}:[["${vr}",${b[0]}]]
`
                      )
                    ), o.index++, l++;
                  else if (b < 0)
                    u.enqueue(
                      i.encode(
                        `${nt}${y}:${b}
`
                      )
                    );
                  else {
                    const R = o.stringified.slice(l + 1).join(",");
                    u.enqueue(
                      i.encode(
                        `${nt}${y}:[${R}]
`
                      )
                    ), l = o.stringified.length - 1;
                  }
                },
                (g) => {
                  (!g || typeof g != "object" || !(g instanceof Error)) && (g = new Error("An unknown error occurred"));
                  const b = ge.call(o, g);
                  if (Array.isArray(b))
                    u.enqueue(
                      i.encode(
                        `${at}${y}:[["${vr}",${b[0]}]]
`
                      )
                    ), o.index++, l++;
                  else if (b < 0)
                    u.enqueue(
                      i.encode(
                        `${at}${y}:${b}
`
                      )
                    );
                  else {
                    const R = o.stringified.slice(l + 1).join(",");
                    u.enqueue(
                      i.encode(
                        `${at}${y}:[${R}]
`
                      )
                    ), l = o.stringified.length - 1;
                  }
                }
              ).finally(() => {
                delete o.deferred[Number(y)];
              })
            );
          await Promise.race(Object.values(o.deferred));
        }
        h();
      }
      await Promise.all(Object.values(o.deferred)), u.close();
    }
  });
}
async function Zi(e) {
  let t = { signal: e.signal };
  if (e.method !== "GET") {
    t.method = e.method;
    let r = e.headers.get("Content-Type");
    r && /\bapplication\/json\b/.test(r) ? (t.headers = { "Content-Type": r }, t.body = JSON.stringify(await e.json())) : r && /\btext\/plain\b/.test(r) ? (t.headers = { "Content-Type": r }, t.body = await e.text()) : r && /\bapplication\/x-www-form-urlencoded\b/.test(r) ? t.body = new URLSearchParams(await e.text()) : t.body = await e.formData();
  }
  return t;
}
var qi = {
  "&": "\\u0026",
  ">": "\\u003e",
  "<": "\\u003c",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
}, el = /[&><\u2028\u2029]/g;
function tl(e) {
  return e.replace(el, (t) => qi[t]);
}
function Da(e) {
  return { __html: e };
}
function oe(e, t) {
  if (e === !1 || e === null || typeof e > "u")
    throw new Error(t);
}
var wr = Symbol("SingleFetchRedirect"), _n = class extends Error {
}, rl = 202, al = /* @__PURE__ */ new Set([100, 101, 204, 205]);
function nl({
  context: e,
  identifier: t,
  reader: r,
  textDecoder: a,
  nonce: n
}) {
  if (!e.renderMeta || !e.renderMeta.didRenderScripts)
    return null;
  e.renderMeta.streamCache || (e.renderMeta.streamCache = {});
  let { streamCache: o } = e.renderMeta, i = o[t];
  if (i || (i = o[t] = r.read().then((d) => {
    o[t].result = {
      done: d.done,
      value: a.decode(d.value, { stream: !0 })
    };
  }).catch((d) => {
    o[t].error = d;
  })), i.error)
    throw i.error;
  if (i.result === void 0)
    throw i;
  let { done: l, value: s } = i.result, u = s ? /* @__PURE__ */ c.createElement(
    "script",
    {
      nonce: n,
      dangerouslySetInnerHTML: {
        __html: `window.__reactRouterContext.streamController.enqueue(${tl(
          JSON.stringify(s)
        )});`
      }
    }
  ) : null;
  return l ? /* @__PURE__ */ c.createElement(c.Fragment, null, u, /* @__PURE__ */ c.createElement(
    "script",
    {
      nonce: n,
      dangerouslySetInnerHTML: {
        __html: "window.__reactRouterContext.streamController.close();"
      }
    }
  )) : /* @__PURE__ */ c.createElement(c.Fragment, null, u, /* @__PURE__ */ c.createElement(c.Suspense, null, /* @__PURE__ */ c.createElement(
    nl,
    {
      context: e,
      identifier: t + 1,
      reader: r,
      textDecoder: a,
      nonce: n
    }
  )));
}
function Ms(e, t, r, a, n) {
  let o = ol(
    e,
    (i) => {
      let l = t.routes[i.route.id];
      oe(l, "Route not found in manifest");
      let s = r[i.route.id];
      return {
        hasLoader: l.hasLoader,
        hasClientLoader: l.hasClientLoader,
        hasShouldRevalidate: !!s?.shouldRevalidate
      };
    },
    fl,
    a,
    n
  );
  return async (i) => i.unstable_runClientMiddleware(o);
}
function ol(e, t, r, a, n, o = () => !0) {
  return async (i) => {
    let { request: l, matches: s, fetcherKey: u } = i, d = e();
    if (l.method !== "GET")
      return il(i, r, n);
    let f = s.some((h) => {
      let { hasLoader: m, hasClientLoader: y } = t(h);
      return h.unstable_shouldCallHandler() && m && !y;
    });
    return !a && !f ? ll(i, t, r, n) : u ? cl(i, r, n) : sl(
      i,
      d,
      t,
      r,
      a,
      n,
      o
    );
  };
}
async function il(e, t, r) {
  let a = e.matches.find((i) => i.unstable_shouldCallHandler());
  oe(a, "No action match found");
  let n, o = await a.resolve(async (i) => await i(async () => {
    let { data: s, status: u } = await t(e, r, [
      a.route.id
    ]);
    return n = u, vt(s, a.route.id);
  }));
  return ne(o.result) || be(o.result) || Je(o.result) ? { [a.route.id]: o } : {
    [a.route.id]: {
      type: o.type,
      result: Bo(o.result, n)
    }
  };
}
async function ll(e, t, r, a) {
  let n = e.matches.filter(
    (i) => i.unstable_shouldCallHandler()
  ), o = {};
  return await Promise.all(
    n.map(
      (i) => i.resolve(async (l) => {
        try {
          let { hasClientLoader: s } = t(i), u = i.route.id, d = s ? await l(async () => {
            let { data: f } = await r(e, a, [u]);
            return vt(f, u);
          }) : await l();
          o[i.route.id] = { type: "data", result: d };
        } catch (s) {
          o[i.route.id] = { type: "error", result: s };
        }
      })
    )
  ), o;
}
async function sl(e, t, r, a, n, o, i = () => !0) {
  let l = /* @__PURE__ */ new Set(), s = !1, u = e.matches.map(() => Ma()), d = Ma(), f = {}, h = Promise.all(
    e.matches.map(
      async (y, C) => y.resolve(async (g) => {
        u[C].resolve();
        let b = y.route.id, { hasLoader: R, hasClientLoader: x, hasShouldRevalidate: P } = r(y), E = !y.unstable_shouldRevalidateArgs || y.unstable_shouldRevalidateArgs.actionStatus == null || y.unstable_shouldRevalidateArgs.actionStatus < 400;
        if (!y.unstable_shouldCallHandler(E)) {
          s || (s = y.unstable_shouldRevalidateArgs != null && // This is a revalidation,
          R && // for a route with a server loader,
          P === !0);
          return;
        }
        if (i(y) && x) {
          R && (s = !0);
          try {
            let _ = await g(async () => {
              let { data: D } = await a(e, o, [b]);
              return vt(D, b);
            });
            f[b] = { type: "data", result: _ };
          } catch (_) {
            f[b] = { type: "error", result: _ };
          }
          return;
        }
        R && l.add(b);
        try {
          let _ = await g(async () => {
            let D = await d.promise;
            return vt(D, b);
          });
          f[b] = { type: "data", result: _ };
        } catch (_) {
          f[b] = { type: "error", result: _ };
        }
      })
    )
  );
  if (await Promise.all(u.map((y) => y.promise)), (!t.state.initialized && t.state.navigation.state === "idle" || l.size === 0) && !window.__reactRouterHdrActive)
    d.resolve({ routes: {} });
  else {
    let y = n && s && l.size > 0 ? [...l.keys()] : void 0;
    try {
      let C = await a(e, o, y);
      d.resolve(C.data);
    } catch (C) {
      d.reject(C);
    }
  }
  return await h, await ul(
    d.promise,
    e.matches,
    l,
    f
  ), f;
}
async function ul(e, t, r, a) {
  try {
    let n, o = await e;
    if ("routes" in o) {
      for (let i of t)
        if (i.route.id in o.routes) {
          let l = o.routes[i.route.id];
          if ("error" in l) {
            n = l.error, a[i.route.id]?.result == null && (a[i.route.id] = {
              type: "error",
              result: n
            });
            break;
          }
        }
    }
    n !== void 0 && Array.from(r.values()).forEach((i) => {
      a[i].result instanceof _n && (a[i].result = n);
    });
  } catch {
  }
}
async function cl(e, t, r) {
  let a = e.matches.find((i) => i.unstable_shouldCallHandler());
  oe(a, "No fetcher match found");
  let n = a.route.id, o = await a.resolve(
    async (i) => i(async () => {
      let { data: l } = await t(e, r, [n]);
      return vt(l, n);
    })
  );
  return { [a.route.id]: o };
}
function dl(e) {
  let t = e.searchParams.getAll("index");
  e.searchParams.delete("index");
  let r = [];
  for (let a of t)
    a && r.push(a);
  for (let a of r)
    e.searchParams.append("index", a);
  return e;
}
function On(e, t, r) {
  let a = typeof e == "string" ? new URL(
    e,
    // This can be called during the SSR flow via PrefetchPageLinksImpl so
    // don't assume window is available
    typeof window > "u" ? "server://singlefetch/" : window.location.origin
  ) : e;
  return a.pathname === "/" ? a.pathname = `_root.${r}` : t && se(a.pathname, t) === "/" ? a.pathname = `${t.replace(/\/$/, "")}/_root.${r}` : a.pathname = `${a.pathname.replace(/\/$/, "")}.${r}`, a;
}
async function fl(e, t, r) {
  let { request: a } = e, n = On(a.url, t, "data");
  a.method === "GET" && (n = dl(n), r && n.searchParams.set("_routes", r.join(",")));
  let o = await fetch(n, await Zi(a));
  if (o.status === 404 && !o.headers.has("X-Remix-Response"))
    throw new De(404, "Not Found", !0);
  if (o.status === 204 && o.headers.has("X-Remix-Redirect"))
    return {
      status: rl,
      data: {
        redirect: {
          redirect: o.headers.get("X-Remix-Redirect"),
          status: Number(o.headers.get("X-Remix-Status") || "302"),
          revalidate: o.headers.get("X-Remix-Revalidate") === "true",
          reload: o.headers.get("X-Remix-Reload-Document") === "true",
          replace: o.headers.get("X-Remix-Replace") === "true"
        }
      }
    };
  if (al.has(o.status)) {
    let i = {};
    return r && a.method !== "GET" && (i[r[0]] = { data: void 0 }), {
      status: o.status,
      data: { routes: i }
    };
  }
  oe(o.body, "No response body to decode");
  try {
    let i = await hl(o.body, window), l;
    if (a.method === "GET") {
      let s = i.value;
      wr in s ? l = { redirect: s[wr] } : l = { routes: s };
    } else {
      let s = i.value, u = r?.[0];
      oe(u, "No routeId found for single fetch call decoding"), "redirect" in s ? l = { redirect: s } : l = { routes: { [u]: s } };
    }
    return { status: o.status, data: l };
  } catch {
    throw new Error("Unable to decode turbo-stream response");
  }
}
function hl(e, t) {
  return Xi(e, {
    plugins: [
      (r, ...a) => {
        if (r === "SanitizedError") {
          let [n, o, i] = a, l = Error;
          n && n in t && typeof t[n] == "function" && (l = t[n]);
          let s = new l(o);
          return s.stack = i, { value: s };
        }
        if (r === "ErrorResponse") {
          let [n, o, i] = a;
          return {
            value: new De(o, i, n)
          };
        }
        if (r === "SingleFetchRedirect")
          return { value: { [wr]: a[0] } };
        if (r === "SingleFetchClassInstance")
          return { value: a[0] };
        if (r === "SingleFetchFallback")
          return { value: void 0 };
      }
    ]
  });
}
function vt(e, t) {
  if ("redirect" in e) {
    let {
      redirect: a,
      revalidate: n,
      reload: o,
      replace: i,
      status: l
    } = e.redirect;
    throw Sr(a, {
      status: l,
      headers: {
        // Three R's of redirecting (lol Veep)
        ...n ? { "X-Remix-Revalidate": "yes" } : null,
        ...o ? { "X-Remix-Reload-Document": "yes" } : null,
        ...i ? { "X-Remix-Replace": "yes" } : null
      }
    });
  }
  let r = e.routes[t];
  if (r == null)
    throw new _n(
      `No result found for routeId "${t}"`
    );
  if ("error" in r)
    throw r.error;
  if ("data" in r)
    return r.data;
  throw new Error(`Invalid response found for routeId "${t}"`);
}
function Ma() {
  let e, t, r = new Promise((a, n) => {
    e = async (o) => {
      a(o);
      try {
        await r;
      } catch {
      }
    }, t = async (o) => {
      n(o);
      try {
        await r;
      } catch {
      }
    };
  });
  return {
    promise: r,
    //@ts-ignore
    resolve: e,
    //@ts-ignore
    reject: t
  };
}
async function $n(e, t) {
  if (e.id in t)
    return t[e.id];
  try {
    let r = await import(
      /* @vite-ignore */
      /* webpackIgnore: true */
      e.module
    );
    return t[e.id] = r, r;
  } catch (r) {
    return console.error(
      `Error loading route module \`${e.module}\`, reloading page...`
    ), console.error(r), window.__reactRouterContext && window.__reactRouterContext.isSpaMode, window.location.reload(), new Promise(() => {
    });
  }
}
function ml(e, t, r) {
  let a = e.map((o) => {
    let i = t[o.route.id], l = r.routes[o.route.id];
    return [
      l && l.css ? l.css.map((s) => ({ rel: "stylesheet", href: s })) : [],
      i?.links?.() || []
    ];
  }).flat(2), n = zr(e, r);
  return An(a, n);
}
function Nn(e) {
  return e.css ? e.css.map((t) => ({ rel: "stylesheet", href: t })) : [];
}
async function pl(e) {
  if (!e.css) return;
  let t = Nn(e);
  await Promise.all(t.map(kn));
}
async function Fn(e, t) {
  if (!e.css && !t.links || !bl()) return;
  let r = [];
  if (e.css && r.push(...Nn(e)), t.links && r.push(...t.links()), r.length === 0) return;
  let a = [];
  for (let n of r)
    !Ur(n) && n.rel === "stylesheet" && a.push({
      ...n,
      rel: "preload",
      as: "style"
    });
  await Promise.all(a.map(kn));
}
async function kn(e) {
  return new Promise((t) => {
    if (e.media && !window.matchMedia(e.media).matches || document.querySelector(
      `link[rel="stylesheet"][href="${e.href}"]`
    ))
      return t();
    let r = document.createElement("link");
    Object.assign(r, e);
    function a() {
      document.head.contains(r) && document.head.removeChild(r);
    }
    r.onload = () => {
      a(), t();
    }, r.onerror = () => {
      a(), t();
    }, document.head.appendChild(r);
  });
}
function Ur(e) {
  return e != null && typeof e.page == "string";
}
function yl(e) {
  return e == null ? !1 : e.href == null ? e.rel === "preload" && typeof e.imageSrcSet == "string" && typeof e.imageSizes == "string" : typeof e.rel == "string" && typeof e.href == "string";
}
async function vl(e, t, r) {
  let a = await Promise.all(
    e.map(async (n) => {
      let o = t.routes[n.route.id];
      if (o) {
        let i = await $n(o, r);
        return i.links ? i.links() : [];
      }
      return [];
    })
  );
  return An(
    a.flat(1).filter(yl).filter((n) => n.rel === "stylesheet" || n.rel === "preload").map(
      (n) => n.rel === "stylesheet" ? { ...n, rel: "prefetch", as: "style" } : { ...n, rel: "prefetch" }
    )
  );
}
function Ta(e, t, r, a, n, o) {
  let i = (s, u) => r[u] ? s.route.id !== r[u].route.id : !0, l = (s, u) => (
    // param change, /users/123 -> /users/456
    r[u].pathname !== s.pathname || // splat param changed, which is not present in match.path
    // e.g. /files/images/avatar.jpg -> files/finances.xls
    r[u].route.path?.endsWith("*") && r[u].params["*"] !== s.params["*"]
  );
  return o === "assets" ? t.filter(
    (s, u) => i(s, u) || l(s, u)
  ) : o === "data" ? t.filter((s, u) => {
    let d = a.routes[s.route.id];
    if (!d || !d.hasLoader)
      return !1;
    if (i(s, u) || l(s, u))
      return !0;
    if (s.route.shouldRevalidate) {
      let f = s.route.shouldRevalidate({
        currentUrl: new URL(
          n.pathname + n.search + n.hash,
          window.origin
        ),
        currentParams: r[0]?.params || {},
        nextUrl: new URL(e, window.origin),
        nextParams: s.params,
        defaultShouldRevalidate: !0
      });
      if (typeof f == "boolean")
        return f;
    }
    return !0;
  }) : [];
}
function zr(e, t, { includeHydrateFallback: r } = {}) {
  return gl(
    e.map((a) => {
      let n = t.routes[a.route.id];
      if (!n) return [];
      let o = [n.module];
      return n.clientActionModule && (o = o.concat(n.clientActionModule)), n.clientLoaderModule && (o = o.concat(n.clientLoaderModule)), r && n.hydrateFallbackModule && (o = o.concat(n.hydrateFallbackModule)), n.imports && (o = o.concat(n.imports)), o;
    }).flat(1)
  );
}
function gl(e) {
  return [...new Set(e)];
}
function wl(e) {
  let t = {}, r = Object.keys(e).sort();
  for (let a of r)
    t[a] = e[a];
  return t;
}
function An(e, t) {
  let r = /* @__PURE__ */ new Set(), a = new Set(t);
  return e.reduce((n, o) => {
    if (t && !Ur(o) && o.as === "script" && o.href && a.has(o.href))
      return n;
    let l = JSON.stringify(wl(o));
    return r.has(l) || (r.add(l), n.push({ key: l, link: o })), n;
  }, []);
}
var Tt;
function bl() {
  if (Tt !== void 0)
    return Tt;
  let e = document.createElement("link");
  return Tt = e.relList.supports("preload"), e = null, Tt;
}
function El() {
  return /* @__PURE__ */ c.createElement(br, { title: "Loading...", renderScripts: !0 }, /* @__PURE__ */ c.createElement(
    "script",
    {
      dangerouslySetInnerHTML: {
        __html: `
              console.log(
                " Hey developer . You can provide a way better UX than this " +
                "when your app is loading JS modules and/or running \`clientLoader\` " +
                "functions. Check out https://reactrouter.com/start/framework/route-module#hydratefallback " +
                "for more information."
              );
            `
      }
    }
  ));
}
function Br(e) {
  let t = {};
  return Object.values(e).forEach((r) => {
    if (r) {
      let a = r.parentId || "";
      t[a] || (t[a] = []), t[a].push(r);
    }
  }), t;
}
function In(e, t, r) {
  let a = jn(t), n = t.HydrateFallback && (!r || e.id === "root") ? t.HydrateFallback : e.id === "root" ? El : void 0, o = t.ErrorBoundary ? t.ErrorBoundary : e.id === "root" ? () => /* @__PURE__ */ c.createElement(zn, { error: Ir() }) : void 0;
  return e.id === "root" && t.Layout ? {
    ...a ? {
      element: /* @__PURE__ */ c.createElement(t.Layout, null, /* @__PURE__ */ c.createElement(a, null))
    } : { Component: a },
    ...o ? {
      errorElement: /* @__PURE__ */ c.createElement(t.Layout, null, /* @__PURE__ */ c.createElement(o, null))
    } : { ErrorBoundary: o },
    ...n ? {
      hydrateFallbackElement: /* @__PURE__ */ c.createElement(t.Layout, null, /* @__PURE__ */ c.createElement(n, null))
    } : { HydrateFallback: n }
  } : { Component: a, ErrorBoundary: o, HydrateFallback: n };
}
function Rl(e, t, r, a, n = "", o = Br(e), i = Promise.resolve({ Component: () => null })) {
  return (o[n] || []).map((l) => {
    let s = t[l.id];
    oe(
      s,
      "No `routeModule` available to create server routes"
    );
    let u = {
      ...In(l, s, a),
      caseSensitive: l.caseSensitive,
      id: l.id,
      index: l.index,
      path: l.path,
      handle: s.handle,
      // For SPA Mode, all routes are lazy except root.  However we tell the
      // router root is also lazy here too since we don't need a full
      // implementation - we just need a `lazy` prop to tell the RR rendering
      // where to stop which is always at the root route in SPA mode
      lazy: a ? () => i : void 0,
      // For partial hydration rendering, we need to indicate when the route
      // has a loader/clientLoader, but it won't ever be called during the static
      // render, so just give it a no-op function so we can render down to the
      // proper fallback
      loader: l.hasLoader || l.hasClientLoader ? () => null : void 0
      // We don't need middleware/action/shouldRevalidate on these routes since
      // they're for a static render
    }, d = Rl(
      e,
      t,
      r,
      a,
      l.id,
      o,
      i
    );
    return d.length > 0 && (u.children = d), u;
  });
}
function Ts(e, t, r, a, n, o) {
  return Wr(
    t,
    r,
    a,
    n,
    o,
    "",
    Br(t),
    e
  );
}
function _t(e, t) {
  if (e === "loader" && !t.hasLoader || e === "action" && !t.hasAction) {
    let a = `You are trying to call ${e === "action" ? "serverAction()" : "serverLoader()"} on a route that does not have a server ${e} (routeId: "${t.id}")`;
    throw console.error(a), new De(400, "Bad Request", new Error(a), !0);
  }
}
function or(e, t) {
  let r = e === "clientAction" ? "a" : "an", a = `Route "${t}" does not have ${r} ${e}, but you are trying to submit to it. To fix this, please add ${r} \`${e}\` function to the route`;
  throw console.error(a), new De(405, "Method Not Allowed", new Error(a), !0);
}
function Wr(e, t, r, a, n, o = "", i = Br(e), l) {
  return (i[o] || []).map((s) => {
    let u = t[s.id];
    function d(R) {
      return oe(
        typeof R == "function",
        "No single fetch function available for route handler"
      ), R();
    }
    function f(R) {
      return s.hasLoader ? d(R) : Promise.resolve(null);
    }
    function h(R) {
      if (!s.hasAction)
        throw or("action", s.id);
      return d(R);
    }
    function m(R) {
      import(
        /* @vite-ignore */
        /* webpackIgnore: true */
        R
      );
    }
    function y(R) {
      R.clientActionModule && m(R.clientActionModule), R.clientLoaderModule && m(R.clientLoaderModule);
    }
    async function C(R) {
      let x = t[s.id], P = x ? Fn(s, x) : Promise.resolve();
      try {
        return R();
      } finally {
        await P;
      }
    }
    let g = {
      id: s.id,
      index: s.index,
      path: s.path
    };
    if (u) {
      Object.assign(g, {
        ...g,
        ...In(s, u, n),
        unstable_middleware: u.unstable_clientMiddleware,
        handle: u.handle,
        shouldRevalidate: _a(
          g.path,
          u,
          s,
          a,
          l
        )
      });
      let R = r && r.loaderData && s.id in r.loaderData, x = R ? r?.loaderData?.[s.id] : void 0, P = r && r.errors && s.id in r.errors, E = P ? r?.errors?.[s.id] : void 0, v = l == null && (u.clientLoader?.hydrate === !0 || !s.hasLoader);
      g.loader = async ({ request: _, params: D, context: T }, $) => {
        try {
          return await C(async () => (oe(
            u,
            "No `routeModule` available for critical-route loader"
          ), u.clientLoader ? u.clientLoader({
            request: _,
            params: D,
            context: T,
            async serverLoader() {
              if (_t("loader", s), v) {
                if (R)
                  return x;
                if (P)
                  throw E;
              }
              return f($);
            }
          }) : f($)));
        } finally {
          v = !1;
        }
      }, g.loader.hydrate = Pl(
        s.id,
        u.clientLoader,
        s.hasLoader,
        n
      ), g.action = ({ request: _, params: D, context: T }, $) => C(async () => {
        if (oe(
          u,
          "No `routeModule` available for critical-route action"
        ), !u.clientAction) {
          if (n)
            throw or("clientAction", s.id);
          return h($);
        }
        return u.clientAction({
          request: _,
          params: D,
          context: T,
          async serverAction() {
            return _t("action", s), h($);
          }
        });
      });
    } else {
      s.hasClientLoader || (g.loader = (P, E) => C(() => f(E))), s.hasClientAction || (g.action = (P, E) => C(() => {
        if (n)
          throw or("clientAction", s.id);
        return h(E);
      }));
      let R;
      async function x() {
        return R ? await R : (R = (async () => {
          (s.clientLoaderModule || s.clientActionModule) && await new Promise((E) => setTimeout(E, 0));
          let P = Cl(
            s,
            t
          );
          return y(s), await P;
        })(), await R);
      }
      g.lazy = {
        loader: s.hasClientLoader ? async () => {
          let { clientLoader: P } = s.clientLoaderModule ? await import(
            /* @vite-ignore */
            /* webpackIgnore: true */
            s.clientLoaderModule
          ) : await x();
          return oe(P, "No `clientLoader` export found"), (E, v) => P({
            ...E,
            async serverLoader() {
              return _t("loader", s), f(v);
            }
          });
        } : void 0,
        action: s.hasClientAction ? async () => {
          let P = s.clientActionModule ? import(
            /* @vite-ignore */
            /* webpackIgnore: true */
            s.clientActionModule
          ) : x();
          y(s);
          let { clientAction: E } = await P;
          return oe(E, "No `clientAction` export found"), (v, _) => E({
            ...v,
            async serverAction() {
              return _t("action", s), h(_);
            }
          });
        } : void 0,
        unstable_middleware: s.hasClientMiddleware ? async () => {
          let { unstable_clientMiddleware: P } = s.clientMiddlewareModule ? await import(
            /* @vite-ignore */
            /* webpackIgnore: true */
            s.clientMiddlewareModule
          ) : await x();
          return oe(
            P,
            "No `unstable_clientMiddleware` export found"
          ), P;
        } : void 0,
        shouldRevalidate: async () => {
          let P = await x();
          return _a(
            g.path,
            P,
            s,
            a,
            l
          );
        },
        handle: async () => (await x()).handle,
        // No need to wrap these in layout since the root route is never
        // loaded via route.lazy()
        Component: async () => (await x()).Component,
        ErrorBoundary: s.hasErrorBoundary ? async () => (await x()).ErrorBoundary : void 0
      };
    }
    let b = Wr(
      e,
      t,
      r,
      a,
      n,
      s.id,
      i,
      l
    );
    return b.length > 0 && (g.children = b), g;
  });
}
function _a(e, t, r, a, n) {
  if (n)
    return Sl(
      r.id,
      t.shouldRevalidate,
      n
    );
  if (!a && r.hasLoader && !r.hasClientLoader) {
    let o = e ? za(e)[1].map((l) => l.paramName) : [];
    const i = (l) => o.some((s) => l.currentParams[s] !== l.nextParams[s]);
    if (t.shouldRevalidate) {
      let l = t.shouldRevalidate;
      return (s) => l({
        ...s,
        defaultShouldRevalidate: i(s)
      });
    } else
      return (l) => i(l);
  }
  if (a && t.shouldRevalidate) {
    let o = t.shouldRevalidate;
    return (i) => o({ ...i, defaultShouldRevalidate: !0 });
  }
  return t.shouldRevalidate;
}
function Sl(e, t, r) {
  let a = !1;
  return (n) => a ? t ? t(n) : n.defaultShouldRevalidate : (a = !0, r.has(e));
}
async function Cl(e, t) {
  let r = $n(e, t), a = pl(e), n = await r;
  return await Promise.all([
    a,
    Fn(e, n)
  ]), {
    Component: jn(n),
    ErrorBoundary: n.ErrorBoundary,
    unstable_clientMiddleware: n.unstable_clientMiddleware,
    clientAction: n.clientAction,
    clientLoader: n.clientLoader,
    handle: n.handle,
    links: n.links,
    meta: n.meta,
    shouldRevalidate: n.shouldRevalidate
  };
}
function jn(e) {
  if (e.default == null) return;
  if (!(typeof e.default == "object" && Object.keys(e.default).length === 0))
    return e.default;
}
function Pl(e, t, r, a) {
  return a && e !== "root" || t != null && (t.hydrate === !0 || r !== !0);
}
var At = /* @__PURE__ */ new Set(), xl = 1e3, Ht = /* @__PURE__ */ new Set(), Ll = 7680;
function Yr(e, t) {
  return e.mode === "lazy" && t === !0;
}
function Dl({ sri: e, ...t }, r) {
  let a = new Set(r.state.matches.map((l) => l.route.id)), n = r.state.location.pathname.split("/").filter(Boolean), o = ["/"];
  for (n.pop(); n.length > 0; )
    o.push(`/${n.join("/")}`), n.pop();
  o.forEach((l) => {
    let s = Se(r.routes, l, r.basename);
    s && s.forEach((u) => a.add(u.route.id));
  });
  let i = [...a].reduce(
    (l, s) => Object.assign(l, { [s]: t.routes[s] }),
    {}
  );
  return {
    ...t,
    routes: i,
    sri: e ? !0 : void 0
  };
}
function _s(e, t, r, a, n, o) {
  if (Yr(a, r))
    return async ({ path: i, patch: l, signal: s, fetcherKey: u }) => {
      Ht.has(i) || await Hn(
        [i],
        u ? window.location.href : i,
        e,
        t,
        r,
        n,
        o,
        a.manifestPath,
        l,
        s
      );
    };
}
function Os(e, t, r, a, n, o) {
  c.useEffect(() => {
    if (!Yr(n, a) || // @ts-expect-error - TS doesn't know about this yet
    window.navigator?.connection?.saveData === !0)
      return;
    function i(d) {
      let f = d.tagName === "FORM" ? d.getAttribute("action") : d.getAttribute("href");
      if (!f)
        return;
      let h = d.tagName === "A" ? d.pathname : new URL(f, window.location.origin).pathname;
      Ht.has(h) || At.add(h);
    }
    async function l() {
      document.querySelectorAll("a[data-discover], form[data-discover]").forEach(i);
      let d = Array.from(At.keys()).filter((f) => Ht.has(f) ? (At.delete(f), !1) : !0);
      if (d.length !== 0)
        try {
          await Hn(
            d,
            null,
            t,
            r,
            a,
            o,
            e.basename,
            n.manifestPath,
            e.patchRoutes
          );
        } catch (f) {
          console.error("Failed to fetch manifest patches", f);
        }
    }
    let s = _l(l, 100);
    l();
    let u = new MutationObserver(() => s());
    return u.observe(document.documentElement, {
      subtree: !0,
      childList: !0,
      attributes: !0,
      attributeFilter: ["data-discover", "href", "action"]
    }), () => u.disconnect();
  }, [a, o, t, r, e, n]);
}
function Ml(e, t) {
  let r = e || "/__manifest";
  return t == null ? r : `${t}${r}`.replace(/\/+/g, "/");
}
var ir = "react-router-manifest-version";
async function Hn(e, t, r, a, n, o, i, l, s, u) {
  const d = new URLSearchParams();
  e.sort().forEach((g) => d.append("p", g)), d.set("version", r.version);
  let f = new URL(
    Ml(l, i),
    window.location.origin
  );
  if (f.search = d.toString(), f.toString().length > Ll) {
    At.clear();
    return;
  }
  let h;
  try {
    let g = await fetch(f, { signal: u });
    if (g.ok) {
      if (g.status === 204 && g.headers.has("X-Remix-Reload-Document")) {
        if (!t) {
          console.warn(
            "Detected a manifest version mismatch during eager route discovery. The next navigation/fetch to an undiscovered route will result in a new document navigation to sync up with the latest manifest."
          );
          return;
        }
        if (sessionStorage.getItem(ir) === r.version) {
          console.error(
            "Unable to discover routes due to manifest version mismatch."
          );
          return;
        }
        sessionStorage.setItem(ir, r.version), window.location.href = t, console.warn("Detected manifest version mismatch, reloading..."), await new Promise(() => {
        });
      } else if (g.status >= 400)
        throw new Error(await g.text());
    } else throw new Error(`${g.status} ${g.statusText}`);
    sessionStorage.removeItem(ir), h = await g.json();
  } catch (g) {
    if (u?.aborted) return;
    throw g;
  }
  let m = new Set(Object.keys(r.routes)), y = Object.values(h).reduce((g, b) => (b && !m.has(b.id) && (g[b.id] = b), g), {});
  Object.assign(r.routes, y), e.forEach((g) => Tl(g, Ht));
  let C = /* @__PURE__ */ new Set();
  Object.values(y).forEach((g) => {
    g && (!g.parentId || !y[g.parentId]) && C.add(g.parentId);
  }), C.forEach(
    (g) => s(
      g || null,
      Wr(y, a, null, n, o, g)
    )
  );
}
function Tl(e, t) {
  if (t.size >= xl) {
    let r = t.values().next().value;
    t.delete(r);
  }
  t.add(e);
}
function _l(e, t) {
  let r;
  return (...a) => {
    window.clearTimeout(r), r = window.setTimeout(() => e(...a), t);
  };
}
function Jr() {
  let e = c.useContext(_e);
  return oe(
    e,
    "You must render this element inside a <DataRouterContext.Provider> element"
  ), e;
}
function Vt() {
  let e = c.useContext(Ke);
  return oe(
    e,
    "You must render this element inside a <DataRouterStateContext.Provider> element"
  ), e;
}
var Kt = c.createContext(void 0);
Kt.displayName = "FrameworkContext";
function it() {
  let e = c.useContext(Kt);
  return oe(
    e,
    "You must render this element inside a <HydratedRouter> element"
  ), e;
}
function Ol(e, t) {
  let r = c.useContext(Kt), [a, n] = c.useState(!1), [o, i] = c.useState(!1), { onFocus: l, onBlur: s, onMouseEnter: u, onMouseLeave: d, onTouchStart: f } = t, h = c.useRef(null);
  c.useEffect(() => {
    if (e === "render" && i(!0), e === "viewport") {
      let C = (b) => {
        b.forEach((R) => {
          i(R.isIntersecting);
        });
      }, g = new IntersectionObserver(C, { threshold: 0.5 });
      return h.current && g.observe(h.current), () => {
        g.disconnect();
      };
    }
  }, [e]), c.useEffect(() => {
    if (a) {
      let C = setTimeout(() => {
        i(!0);
      }, 100);
      return () => {
        clearTimeout(C);
      };
    }
  }, [a]);
  let m = () => {
    n(!0);
  }, y = () => {
    n(!1), i(!1);
  };
  return r ? e !== "intent" ? [o, h, {}] : [
    o,
    h,
    {
      onFocus: ft(l, m),
      onBlur: ft(s, y),
      onMouseEnter: ft(u, m),
      onMouseLeave: ft(d, y),
      onTouchStart: ft(f, m)
    }
  ] : [!1, h, {}];
}
function ft(e, t) {
  return (r) => {
    e && e(r), r.defaultPrevented || t(r);
  };
}
function Vr(e, t, r) {
  if (r && !Ut)
    return [e[0]];
  if (t) {
    let a = e.findIndex((n) => t[n.route.id] !== void 0);
    return e.slice(0, a + 1);
  }
  return e;
}
var Oa = "data-react-router-critical-css";
function $s({ nonce: e }) {
  let { isSpaMode: t, manifest: r, routeModules: a, criticalCss: n } = it(), { errors: o, matches: i } = Vt(), l = Vr(i, o, t), s = c.useMemo(
    () => ml(l, a, r),
    [l, a, r]
  );
  return /* @__PURE__ */ c.createElement(c.Fragment, null, typeof n == "string" ? /* @__PURE__ */ c.createElement(
    "style",
    {
      [Oa]: "",
      dangerouslySetInnerHTML: { __html: n }
    }
  ) : null, typeof n == "object" ? /* @__PURE__ */ c.createElement(
    "link",
    {
      [Oa]: "",
      rel: "stylesheet",
      href: n.href,
      nonce: e
    }
  ) : null, s.map(
    ({ key: u, link: d }) => Ur(d) ? /* @__PURE__ */ c.createElement(Un, { key: u, nonce: e, ...d }) : /* @__PURE__ */ c.createElement("link", { key: u, nonce: e, ...d })
  ));
}
function Un({ page: e, ...t }) {
  let { router: r } = Jr(), a = c.useMemo(
    () => Se(r.routes, e, r.basename),
    [r.routes, e, r.basename]
  );
  return a ? /* @__PURE__ */ c.createElement(Nl, { page: e, matches: a, ...t }) : null;
}
function $l(e) {
  let { manifest: t, routeModules: r } = it(), [a, n] = c.useState([]);
  return c.useEffect(() => {
    let o = !1;
    return vl(e, t, r).then(
      (i) => {
        o || n(i);
      }
    ), () => {
      o = !0;
    };
  }, [e, t, r]), a;
}
function Nl({
  page: e,
  matches: t,
  ...r
}) {
  let a = pe(), { manifest: n, routeModules: o } = it(), { basename: i } = Jr(), { loaderData: l, matches: s } = Vt(), u = c.useMemo(
    () => Ta(
      e,
      t,
      s,
      n,
      a,
      "data"
    ),
    [e, t, s, n, a]
  ), d = c.useMemo(
    () => Ta(
      e,
      t,
      s,
      n,
      a,
      "assets"
    ),
    [e, t, s, n, a]
  ), f = c.useMemo(() => {
    if (e === a.pathname + a.search + a.hash)
      return [];
    let y = /* @__PURE__ */ new Set(), C = !1;
    if (t.forEach((b) => {
      let R = n.routes[b.route.id];
      !R || !R.hasLoader || (!u.some((x) => x.route.id === b.route.id) && b.route.id in l && o[b.route.id]?.shouldRevalidate || R.hasClientLoader ? C = !0 : y.add(b.route.id));
    }), y.size === 0)
      return [];
    let g = On(e, i, "data");
    return C && y.size > 0 && g.searchParams.set(
      "_routes",
      t.filter((b) => y.has(b.route.id)).map((b) => b.route.id).join(",")
    ), [g.pathname + g.search];
  }, [
    i,
    l,
    a,
    n,
    u,
    t,
    e,
    o
  ]), h = c.useMemo(
    () => zr(d, n),
    [d, n]
  ), m = $l(d);
  return /* @__PURE__ */ c.createElement(c.Fragment, null, f.map((y) => /* @__PURE__ */ c.createElement("link", { key: y, rel: "prefetch", as: "fetch", href: y, ...r })), h.map((y) => /* @__PURE__ */ c.createElement("link", { key: y, rel: "modulepreload", href: y, ...r })), m.map(({ key: y, link: C }) => (
    // these don't spread `linkProps` because they are full link descriptors
    // already with their own props
    /* @__PURE__ */ c.createElement("link", { key: y, nonce: r.nonce, ...C })
  )));
}
function Ns() {
  let { isSpaMode: e, routeModules: t } = it(), {
    errors: r,
    matches: a,
    loaderData: n
  } = Vt(), o = pe(), i = Vr(a, r, e), l = null;
  r && (l = r[i[i.length - 1].route.id]);
  let s = [], u = null, d = [];
  for (let f = 0; f < i.length; f++) {
    let h = i[f], m = h.route.id, y = n[m], C = h.params, g = t[m], b = [], R = {
      id: m,
      data: y,
      loaderData: y,
      meta: [],
      params: h.params,
      pathname: h.pathname,
      handle: h.route.handle,
      error: l
    };
    if (d[f] = R, g?.meta ? b = typeof g.meta == "function" ? g.meta({
      data: y,
      loaderData: y,
      params: C,
      location: o,
      matches: d,
      error: l
    }) : Array.isArray(g.meta) ? [...g.meta] : g.meta : u && (b = [...u]), b = b || [], !Array.isArray(b))
      throw new Error(
        "The route at " + h.route.path + ` returns an invalid value. All route meta functions must return an array of meta objects.

To reference the meta function API, see https://remix.run/route/meta`
      );
    R.meta = b, d[f] = R, s = [...b], u = s;
  }
  return /* @__PURE__ */ c.createElement(c.Fragment, null, s.flat().map((f) => {
    if (!f)
      return null;
    if ("tagName" in f) {
      let { tagName: h, ...m } = f;
      if (!Fl(h))
        return console.warn(
          `A meta object uses an invalid tagName: ${h}. Expected either 'link' or 'meta'`
        ), null;
      let y = h;
      return /* @__PURE__ */ c.createElement(y, { key: JSON.stringify(m), ...m });
    }
    if ("title" in f)
      return /* @__PURE__ */ c.createElement("title", { key: "title" }, String(f.title));
    if ("charset" in f && (f.charSet ?? (f.charSet = f.charset), delete f.charset), "charSet" in f && f.charSet != null)
      return typeof f.charSet == "string" ? /* @__PURE__ */ c.createElement("meta", { key: "charSet", charSet: f.charSet }) : null;
    if ("script:ld+json" in f)
      try {
        let h = JSON.stringify(f["script:ld+json"]);
        return /* @__PURE__ */ c.createElement(
          "script",
          {
            key: `script:ld+json:${h}`,
            type: "application/ld+json",
            dangerouslySetInnerHTML: { __html: h }
          }
        );
      } catch {
        return null;
      }
    return /* @__PURE__ */ c.createElement("meta", { key: JSON.stringify(f), ...f });
  }));
}
function Fl(e) {
  return typeof e == "string" && /^(meta|link)$/.test(e);
}
var Ut = !1;
function kl() {
  Ut = !0;
}
function Al(e) {
  let {
    manifest: t,
    serverHandoffString: r,
    isSpaMode: a,
    renderMeta: n,
    routeDiscovery: o,
    ssr: i
  } = it(), { router: l, static: s, staticContext: u } = Jr(), { matches: d } = Vt(), f = mi(), h = Yr(o, i);
  n && (n.didRenderScripts = !0);
  let m = Vr(d, null, a);
  c.useEffect(() => {
    kl();
  }, []);
  let y = c.useMemo(() => {
    if (f)
      return null;
    let R = u ? `window.__reactRouterContext = ${r};window.__reactRouterContext.stream = new ReadableStream({start(controller){window.__reactRouterContext.streamController = controller;}}).pipeThrough(new TextEncoderStream());` : " ", x = s ? `${t.hmr?.runtime ? `import ${JSON.stringify(t.hmr.runtime)};` : ""}${h ? "" : `import ${JSON.stringify(t.url)}`};
${m.map((P, E) => {
      let v = `route${E}`, _ = t.routes[P.route.id];
      oe(_, `Route ${P.route.id} not found in manifest`);
      let {
        clientActionModule: D,
        clientLoaderModule: T,
        clientMiddlewareModule: $,
        hydrateFallbackModule: U,
        module: K
      } = _, z = [
        ...D ? [
          {
            module: D,
            varName: `${v}_clientAction`
          }
        ] : [],
        ...T ? [
          {
            module: T,
            varName: `${v}_clientLoader`
          }
        ] : [],
        ...$ ? [
          {
            module: $,
            varName: `${v}_clientMiddleware`
          }
        ] : [],
        ...U ? [
          {
            module: U,
            varName: `${v}_HydrateFallback`
          }
        ] : [],
        { module: K, varName: `${v}_main` }
      ];
      if (z.length === 1)
        return `import * as ${v} from ${JSON.stringify(K)};`;
      let J = z.map((B) => `import * as ${B.varName} from "${B.module}";`).join(`
`), ue = `const ${v} = {${z.map((B) => `...${B.varName}`).join(",")}};`;
      return [J, ue].join(`
`);
    }).join(`
`)}
  ${h ? (
      // Inline a minimal manifest with the SSR matches
      `window.__reactRouterManifest = ${JSON.stringify(
        Dl(t, l),
        null,
        2
      )};`
    ) : ""}
  window.__reactRouterRouteModules = {${m.map((P, E) => `${JSON.stringify(P.route.id)}:route${E}`).join(",")}};

import(${JSON.stringify(t.entry.module)});` : " ";
    return /* @__PURE__ */ c.createElement(c.Fragment, null, /* @__PURE__ */ c.createElement(
      "script",
      {
        ...e,
        suppressHydrationWarning: !0,
        dangerouslySetInnerHTML: Da(R),
        type: void 0
      }
    ), /* @__PURE__ */ c.createElement(
      "script",
      {
        ...e,
        suppressHydrationWarning: !0,
        dangerouslySetInnerHTML: Da(x),
        type: "module",
        async: !0
      }
    ));
  }, []), C = Ut || f ? [] : Il(
    t.entry.imports.concat(
      zr(m, t, {
        includeHydrateFallback: !0
      })
    )
  ), g = typeof t.sri == "object" ? t.sri : {};
  return hr(
    !f,
    "The <Scripts /> element is a no-op when using RSC and can be safely removed."
  ), Ut || f ? null : /* @__PURE__ */ c.createElement(c.Fragment, null, typeof t.sri == "object" ? /* @__PURE__ */ c.createElement(
    "script",
    {
      "rr-importmap": "",
      type: "importmap",
      suppressHydrationWarning: !0,
      dangerouslySetInnerHTML: {
        __html: JSON.stringify({
          integrity: g
        })
      }
    }
  ) : null, h ? null : /* @__PURE__ */ c.createElement(
    "link",
    {
      rel: "modulepreload",
      href: t.url,
      crossOrigin: e.crossOrigin,
      integrity: g[t.url],
      suppressHydrationWarning: !0
    }
  ), /* @__PURE__ */ c.createElement(
    "link",
    {
      rel: "modulepreload",
      href: t.entry.module,
      crossOrigin: e.crossOrigin,
      integrity: g[t.entry.module],
      suppressHydrationWarning: !0
    }
  ), C.map((b) => /* @__PURE__ */ c.createElement(
    "link",
    {
      key: b,
      rel: "modulepreload",
      href: b,
      crossOrigin: e.crossOrigin,
      integrity: g[b],
      suppressHydrationWarning: !0
    }
  )), y);
}
function Il(e) {
  return [...new Set(e)];
}
function jl(...e) {
  return (t) => {
    e.forEach((r) => {
      typeof r == "function" ? r(t) : r != null && (r.current = t);
    });
  };
}
var Fs = class extends c.Component {
  constructor(e) {
    super(e), this.state = { error: e.error || null, location: e.location };
  }
  static getDerivedStateFromError(e) {
    return { error: e };
  }
  static getDerivedStateFromProps(e, t) {
    return t.location !== e.location ? { error: e.error || null, location: e.location } : { error: e.error || t.error, location: t.location };
  }
  render() {
    return this.state.error ? /* @__PURE__ */ c.createElement(
      zn,
      {
        error: this.state.error,
        isOutsideRemixApp: !0
      }
    ) : this.props.children;
  }
};
function zn({
  error: e,
  isOutsideRemixApp: t
}) {
  console.error(e);
  let r = /* @__PURE__ */ c.createElement(
    "script",
    {
      dangerouslySetInnerHTML: {
        __html: `
        console.log(
          " Hey developer . You can provide a way better UX than this when your app throws errors. Check out https://reactrouter.com/how-to/error-boundary for more information."
        );
      `
      }
    }
  );
  if (be(e))
    return /* @__PURE__ */ c.createElement(br, { title: "Unhandled Thrown Response!" }, /* @__PURE__ */ c.createElement("h1", { style: { fontSize: "24px" } }, e.status, " ", e.statusText), r);
  let a;
  if (e instanceof Error)
    a = e;
  else {
    let n = e == null ? "Unknown Error" : typeof e == "object" && "toString" in e ? e.toString() : JSON.stringify(e);
    a = new Error(n);
  }
  return /* @__PURE__ */ c.createElement(
    br,
    {
      title: "Application Error!",
      isOutsideRemixApp: t
    },
    /* @__PURE__ */ c.createElement("h1", { style: { fontSize: "24px" } }, "Application Error"),
    /* @__PURE__ */ c.createElement(
      "pre",
      {
        style: {
          padding: "2rem",
          background: "hsla(10, 50%, 50%, 0.1)",
          color: "red",
          overflow: "auto"
        }
      },
      a.stack
    ),
    r
  );
}
function br({
  title: e,
  renderScripts: t,
  isOutsideRemixApp: r,
  children: a
}) {
  let { routeModules: n } = it();
  return n.root?.Layout && !r ? a : /* @__PURE__ */ c.createElement("html", { lang: "en" }, /* @__PURE__ */ c.createElement("head", null, /* @__PURE__ */ c.createElement("meta", { charSet: "utf-8" }), /* @__PURE__ */ c.createElement(
    "meta",
    {
      name: "viewport",
      content: "width=device-width,initial-scale=1,viewport-fit=cover"
    }
  ), /* @__PURE__ */ c.createElement("title", null, e)), /* @__PURE__ */ c.createElement("body", null, /* @__PURE__ */ c.createElement("main", { style: { fontFamily: "system-ui, sans-serif", padding: "2rem" } }, a, t ? /* @__PURE__ */ c.createElement(Al, null) : null)));
}
var Bn = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
try {
  Bn && (window.__reactRouterVersion = // @ts-expect-error
  "7.8.2");
} catch {
}
function ks(e, t) {
  return xr({
    basename: t?.basename,
    unstable_getContext: t?.unstable_getContext,
    future: t?.future,
    history: Fa({ window: t?.window }),
    hydrationData: t?.hydrationData || Wn(),
    routes: e,
    mapRouteProperties: bt,
    hydrationRouteProperties: jr,
    dataStrategy: t?.dataStrategy,
    patchRoutesOnNavigation: t?.patchRoutesOnNavigation,
    window: t?.window
  }).initialize();
}
function As(e, t) {
  return xr({
    basename: t?.basename,
    unstable_getContext: t?.unstable_getContext,
    future: t?.future,
    history: ka({ window: t?.window }),
    hydrationData: t?.hydrationData || Wn(),
    routes: e,
    mapRouteProperties: bt,
    hydrationRouteProperties: jr,
    dataStrategy: t?.dataStrategy,
    patchRoutesOnNavigation: t?.patchRoutesOnNavigation,
    window: t?.window
  }).initialize();
}
function Wn() {
  let e = window?.__staticRouterHydrationData;
  return e && e.errors && (e = {
    ...e,
    errors: Hl(e.errors)
  }), e;
}
function Hl(e) {
  if (!e) return null;
  let t = Object.entries(e), r = {};
  for (let [a, n] of t)
    if (n && n.__type === "RouteErrorResponse")
      r[a] = new De(
        n.status,
        n.statusText,
        n.data,
        n.internal === !0
      );
    else if (n && n.__type === "Error") {
      if (n.__subType) {
        let o = window[n.__subType];
        if (typeof o == "function")
          try {
            let i = new o(n.message);
            i.stack = "", r[a] = i;
          } catch {
          }
      }
      if (r[a] == null) {
        let o = new Error(n.message);
        o.stack = "", r[a] = o;
      }
    } else
      r[a] = n;
  return r;
}
function Is({
  basename: e,
  children: t,
  window: r
}) {
  let a = c.useRef();
  a.current == null && (a.current = Fa({ window: r, v5Compat: !0 }));
  let n = a.current, [o, i] = c.useState({
    action: n.action,
    location: n.location
  }), l = c.useCallback(
    (s) => {
      c.startTransition(() => i(s));
    },
    [i]
  );
  return c.useLayoutEffect(() => n.listen(l), [n, l]), /* @__PURE__ */ c.createElement(
    Ge,
    {
      basename: e,
      children: t,
      location: o.location,
      navigationType: o.action,
      navigator: n
    }
  );
}
function js({ basename: e, children: t, window: r }) {
  let a = c.useRef();
  a.current == null && (a.current = ka({ window: r, v5Compat: !0 }));
  let n = a.current, [o, i] = c.useState({
    action: n.action,
    location: n.location
  }), l = c.useCallback(
    (s) => {
      c.startTransition(() => i(s));
    },
    [i]
  );
  return c.useLayoutEffect(() => n.listen(l), [n, l]), /* @__PURE__ */ c.createElement(
    Ge,
    {
      basename: e,
      children: t,
      location: o.location,
      navigationType: o.action,
      navigator: n
    }
  );
}
function Ul({
  basename: e,
  children: t,
  history: r
}) {
  let [a, n] = c.useState({
    action: r.action,
    location: r.location
  }), o = c.useCallback(
    (i) => {
      c.startTransition(() => n(i));
    },
    [n]
  );
  return c.useLayoutEffect(() => r.listen(o), [r, o]), /* @__PURE__ */ c.createElement(
    Ge,
    {
      basename: e,
      children: t,
      location: a.location,
      navigationType: a.action,
      navigator: r
    }
  );
}
Ul.displayName = "unstable_HistoryRouter";
var Yn = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, Jn = c.forwardRef(
  function({
    onClick: t,
    discover: r = "render",
    prefetch: a = "none",
    relative: n,
    reloadDocument: o,
    replace: i,
    state: l,
    target: s,
    to: u,
    preventScrollReset: d,
    viewTransition: f,
    ...h
  }, m) {
    let { basename: y } = c.useContext(he), C = typeof u == "string" && Yn.test(u), g, b = !1;
    if (typeof u == "string" && C && (g = u, Bn))
      try {
        let T = new URL(window.location.href), $ = u.startsWith("//") ? new URL(T.protocol + u) : new URL(u), U = se($.pathname, y);
        $.origin === T.origin && U != null ? u = U + $.search + $.hash : b = !0;
      } catch {
        V(
          !1,
          `<Link to="${u}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`
        );
      }
    let R = pi(u, { relative: n }), [x, P, E] = Ol(
      a,
      h
    ), v = Wl(u, {
      replace: i,
      state: l,
      target: s,
      preventScrollReset: d,
      relative: n,
      viewTransition: f
    });
    function _(T) {
      t && t(T), T.defaultPrevented || v(T);
    }
    let D = (
      // eslint-disable-next-line jsx-a11y/anchor-has-content
      /* @__PURE__ */ c.createElement(
        "a",
        {
          ...h,
          ...E,
          href: g || R,
          onClick: b || o ? t : _,
          ref: jl(m, P),
          target: s,
          "data-discover": !C && r === "render" ? "true" : void 0
        }
      )
    );
    return x && !C ? /* @__PURE__ */ c.createElement(c.Fragment, null, D, /* @__PURE__ */ c.createElement(Un, { page: R })) : D;
  }
);
Jn.displayName = "Link";
var zl = c.forwardRef(
  function({
    "aria-current": t = "page",
    caseSensitive: r = !1,
    className: a = "",
    end: n = !1,
    style: o,
    to: i,
    viewTransition: l,
    children: s,
    ...u
  }, d) {
    let f = gt(i, { relative: u.relative }), h = pe(), m = c.useContext(Ke), { navigator: y, basename: C } = c.useContext(he), g = m != null && // Conditional usage is OK here because the usage of a data router is static
    // eslint-disable-next-line react-hooks/rules-of-hooks
    Gl(f) && l === !0, b = y.encodeLocation ? y.encodeLocation(f).pathname : f.pathname, R = h.pathname, x = m && m.navigation && m.navigation.location ? m.navigation.location.pathname : null;
    r || (R = R.toLowerCase(), x = x ? x.toLowerCase() : null, b = b.toLowerCase()), x && C && (x = se(x, C) || x);
    const P = b !== "/" && b.endsWith("/") ? b.length - 1 : b.length;
    let E = R === b || !n && R.startsWith(b) && R.charAt(P) === "/", v = x != null && (x === b || !n && x.startsWith(b) && x.charAt(b.length) === "/"), _ = {
      isActive: E,
      isPending: v,
      isTransitioning: g
    }, D = E ? t : void 0, T;
    typeof a == "function" ? T = a(_) : T = [
      a,
      E ? "active" : null,
      v ? "pending" : null,
      g ? "transitioning" : null
    ].filter(Boolean).join(" ");
    let $ = typeof o == "function" ? o(_) : o;
    return /* @__PURE__ */ c.createElement(
      Jn,
      {
        ...u,
        "aria-current": D,
        className: T,
        ref: d,
        style: $,
        to: i,
        viewTransition: l
      },
      typeof s == "function" ? s(_) : s
    );
  }
);
zl.displayName = "NavLink";
var Vn = c.forwardRef(
  ({
    discover: e = "render",
    fetcherKey: t,
    navigate: r,
    reloadDocument: a,
    replace: n,
    state: o,
    method: i = Ft,
    action: l,
    onSubmit: s,
    relative: u,
    preventScrollReset: d,
    viewTransition: f,
    ...h
  }, m) => {
    let y = Xn(), C = Vl(l, { relative: u }), g = i.toLowerCase() === "get" ? "get" : "post", b = typeof l == "string" && Yn.test(l), R = (x) => {
      if (s && s(x), x.defaultPrevented) return;
      x.preventDefault();
      let P = x.nativeEvent.submitter, E = P?.getAttribute("formmethod") || i;
      y(P || x.currentTarget, {
        fetcherKey: t,
        method: E,
        navigate: r,
        replace: n,
        state: o,
        relative: u,
        preventScrollReset: d,
        viewTransition: f
      });
    };
    return /* @__PURE__ */ c.createElement(
      "form",
      {
        ref: m,
        method: g,
        action: C,
        onSubmit: a ? s : R,
        ...h,
        "data-discover": !b && e === "render" ? "true" : void 0
      }
    );
  }
);
Vn.displayName = "Form";
function Bl({
  getKey: e,
  storageKey: t,
  ...r
}) {
  let a = c.useContext(Kt), { basename: n } = c.useContext(he), o = pe(), i = Fr();
  Kl({ getKey: e, storageKey: t });
  let l = c.useMemo(
    () => {
      if (!a || !e) return null;
      let u = Rr(
        o,
        i,
        n,
        e
      );
      return u !== o.key ? u : null;
    },
    // Nah, we only need this the first time for the SSR render
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  if (!a || a.isSpaMode)
    return null;
  let s = ((u, d) => {
    if (!window.history.state || !window.history.state.key) {
      let f = Math.random().toString(32).slice(2);
      window.history.replaceState({ key: f }, "");
    }
    try {
      let h = JSON.parse(sessionStorage.getItem(u) || "{}")[d || window.history.state.key];
      typeof h == "number" && window.scrollTo(0, h);
    } catch (f) {
      console.error(f), sessionStorage.removeItem(u);
    }
  }).toString();
  return /* @__PURE__ */ c.createElement(
    "script",
    {
      ...r,
      suppressHydrationWarning: !0,
      dangerouslySetInnerHTML: {
        __html: `(${s})(${JSON.stringify(
          t || Er
        )}, ${JSON.stringify(l)})`
      }
    }
  );
}
Bl.displayName = "ScrollRestoration";
function Kn(e) {
  return `${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function Xt(e) {
  let t = c.useContext(_e);
  return I(t, Kn(e)), t;
}
function Kr(e) {
  let t = c.useContext(Ke);
  return I(t, Kn(e)), t;
}
function Wl(e, {
  target: t,
  replace: r,
  state: a,
  preventScrollReset: n,
  relative: o,
  viewTransition: i
} = {}) {
  let l = Tr(), s = pe(), u = gt(e, { relative: o });
  return c.useCallback(
    (d) => {
      if (Hi(d, t)) {
        d.preventDefault();
        let f = r !== void 0 ? r : fe(s) === fe(u);
        l(e, {
          replace: f,
          state: a,
          preventScrollReset: n,
          relative: o,
          viewTransition: i
        });
      }
    },
    [
      s,
      l,
      u,
      r,
      a,
      t,
      e,
      n,
      o,
      i
    ]
  );
}
function Hs(e) {
  V(
    typeof URLSearchParams < "u",
    "You cannot use the `useSearchParams` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params."
  );
  let t = c.useRef(mr(e)), r = c.useRef(!1), a = pe(), n = c.useMemo(
    () => (
      // Only merge in the defaults if we haven't yet called setSearchParams.
      // Once we call that we want those to take precedence, otherwise you can't
      // remove a param with setSearchParams({}) if it has an initial value
      Ui(
        a.search,
        r.current ? null : t.current
      )
    ),
    [a.search]
  ), o = Tr(), i = c.useCallback(
    (l, s) => {
      const u = mr(
        typeof l == "function" ? l(new URLSearchParams(n)) : l
      );
      r.current = !0, o("?" + u, s);
    },
    [o, n]
  );
  return [n, i];
}
var Yl = 0, Jl = () => `__${String(++Yl)}__`;
function Xn() {
  let { router: e } = Xt(
    "useSubmit"
    /* UseSubmit */
  ), { basename: t } = c.useContext(he), r = Ci();
  return c.useCallback(
    async (a, n = {}) => {
      let { action: o, method: i, encType: l, formData: s, body: u } = Wi(
        a,
        t
      );
      if (n.navigate === !1) {
        let d = n.fetcherKey || Jl();
        await e.fetch(d, r, n.action || o, {
          preventScrollReset: n.preventScrollReset,
          formData: s,
          body: u,
          formMethod: n.method || i,
          formEncType: n.encType || l,
          flushSync: n.flushSync
        });
      } else
        await e.navigate(n.action || o, {
          preventScrollReset: n.preventScrollReset,
          formData: s,
          body: u,
          formMethod: n.method || i,
          formEncType: n.encType || l,
          replace: n.replace,
          state: n.state,
          fromRouteId: r,
          flushSync: n.flushSync,
          viewTransition: n.viewTransition
        });
    },
    [e, t, r]
  );
}
function Vl(e, { relative: t } = {}) {
  let { basename: r } = c.useContext(he), a = c.useContext(me);
  I(a, "useFormAction must be used inside a RouteContext");
  let [n] = a.matches.slice(-1), o = { ...gt(e || ".", { relative: t }) }, i = pe();
  if (e == null) {
    o.search = i.search;
    let l = new URLSearchParams(o.search), s = l.getAll("index");
    if (s.some((d) => d === "")) {
      l.delete("index"), s.filter((f) => f).forEach((f) => l.append("index", f));
      let d = l.toString();
      o.search = d ? `?${d}` : "";
    }
  }
  return (!e || e === ".") && n.route.index && (o.search = o.search ? o.search.replace(/^\?/, "?index&") : "?index"), r !== "/" && (o.pathname = o.pathname === "/" ? r : Le([r, o.pathname])), fe(o);
}
function Us({
  key: e
} = {}) {
  let { router: t } = Xt(
    "useFetcher"
    /* UseFetcher */
  ), r = Kr(
    "useFetcher"
    /* UseFetcher */
  ), a = c.useContext(Yt), n = c.useContext(me), o = n.matches[n.matches.length - 1]?.route.id;
  I(a, "useFetcher must be used inside a FetchersContext"), I(n, "useFetcher must be used inside a RouteContext"), I(
    o != null,
    'useFetcher can only be used on routes that contain a unique "id"'
  );
  let i = c.useId(), [l, s] = c.useState(e || i);
  e && e !== l && s(e), c.useEffect(() => (t.getFetcher(l), () => t.deleteFetcher(l)), [t, l]);
  let u = c.useCallback(
    async (g, b) => {
      I(o, "No routeId available for fetcher.load()"), await t.fetch(l, o, g, b);
    },
    [l, o, t]
  ), d = Xn(), f = c.useCallback(
    async (g, b) => {
      await d(g, {
        ...b,
        navigate: !1,
        fetcherKey: l
      });
    },
    [l, d]
  ), h = c.useMemo(() => {
    let g = c.forwardRef(
      (b, R) => /* @__PURE__ */ c.createElement(Vn, { ...b, navigate: !1, fetcherKey: l, ref: R })
    );
    return g.displayName = "fetcher.Form", g;
  }, [l]), m = r.fetchers.get(l) || Cr, y = a.get(l);
  return c.useMemo(
    () => ({
      Form: h,
      submit: f,
      load: u,
      ...m,
      data: y
    }),
    [h, f, u, m, y]
  );
}
function zs() {
  let e = Kr(
    "useFetchers"
    /* UseFetchers */
  );
  return Array.from(e.fetchers.entries()).map(([t, r]) => ({
    ...r,
    key: t
  }));
}
var Er = "react-router-scroll-positions", Ot = {};
function Rr(e, t, r, a) {
  let n = null;
  return a && (r !== "/" ? n = a(
    {
      ...e,
      pathname: se(e.pathname, r) || e.pathname
    },
    t
  ) : n = a(e, t)), n == null && (n = e.key), n;
}
function Kl({
  getKey: e,
  storageKey: t
} = {}) {
  let { router: r } = Xt(
    "useScrollRestoration"
    /* UseScrollRestoration */
  ), { restoreScrollPosition: a, preventScrollReset: n } = Kr(
    "useScrollRestoration"
    /* UseScrollRestoration */
  ), { basename: o } = c.useContext(he), i = pe(), l = Fr(), s = Pi();
  c.useEffect(() => (window.history.scrollRestoration = "manual", () => {
    window.history.scrollRestoration = "auto";
  }), []), Xl(
    c.useCallback(() => {
      if (s.state === "idle") {
        let u = Rr(i, l, o, e);
        Ot[u] = window.scrollY;
      }
      try {
        sessionStorage.setItem(
          t || Er,
          JSON.stringify(Ot)
        );
      } catch (u) {
        V(
          !1,
          `Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (${u}).`
        );
      }
      window.history.scrollRestoration = "auto";
    }, [s.state, e, o, i, l, t])
  ), typeof document < "u" && (c.useLayoutEffect(() => {
    try {
      let u = sessionStorage.getItem(
        t || Er
      );
      u && (Ot = JSON.parse(u));
    } catch {
    }
  }, [t]), c.useLayoutEffect(() => {
    let u = r?.enableScrollRestoration(
      Ot,
      () => window.scrollY,
      e ? (d, f) => Rr(d, f, o, e) : void 0
    );
    return () => u && u();
  }, [r, o, e]), c.useLayoutEffect(() => {
    if (a !== !1) {
      if (typeof a == "number") {
        window.scrollTo(0, a);
        return;
      }
      try {
        if (i.hash) {
          let u = document.getElementById(
            decodeURIComponent(i.hash.slice(1))
          );
          if (u) {
            u.scrollIntoView();
            return;
          }
        }
      } catch {
        V(
          !1,
          `"${i.hash.slice(
            1
          )}" is not a decodable element ID. The view will not scroll to it.`
        );
      }
      n !== !0 && window.scrollTo(0, 0);
    }
  }, [i, a, n]));
}
function Bs(e, t) {
  let { capture: r } = t || {};
  c.useEffect(() => {
    let a = r != null ? { capture: r } : void 0;
    return window.addEventListener("beforeunload", e, a), () => {
      window.removeEventListener("beforeunload", e, a);
    };
  }, [e, r]);
}
function Xl(e, t) {
  let { capture: r } = {};
  c.useEffect(() => {
    let a = r != null ? { capture: r } : void 0;
    return window.addEventListener("pagehide", e, a), () => {
      window.removeEventListener("pagehide", e, a);
    };
  }, [e, r]);
}
function Ws({
  when: e,
  message: t
}) {
  let r = Di(e);
  c.useEffect(() => {
    r.state === "blocked" && (window.confirm(t) ? setTimeout(r.proceed, 0) : r.reset());
  }, [r, t]), c.useEffect(() => {
    r.state === "blocked" && !e && r.reset();
  }, [r, e]);
}
function Gl(e, { relative: t } = {}) {
  let r = c.useContext(Wt);
  I(
    r != null,
    "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?"
  );
  let { basename: a } = Xt(
    "useViewTransitionState"
    /* useViewTransitionState */
  ), n = gt(e, { relative: t });
  if (!r.isTransitioning)
    return !1;
  let o = se(r.currentLocation.pathname, a) || r.currentLocation.pathname, i = se(r.nextLocation.pathname, a) || r.nextLocation.pathname;
  return mt(n.pathname, i) != null || mt(n.pathname, o) != null;
}
function Ys({
  basename: e,
  children: t,
  location: r = "/"
}) {
  typeof r == "string" && (r = Ee(r));
  let a = "POP", n = {
    pathname: r.pathname || "/",
    search: r.search || "",
    hash: r.hash || "",
    state: r.state != null ? r.state : null,
    key: r.key || "default"
  }, o = Gn();
  return /* @__PURE__ */ c.createElement(
    Ge,
    {
      basename: e,
      children: t,
      location: n,
      navigationType: a,
      navigator: o,
      static: !0
    }
  );
}
function Js({
  context: e,
  router: t,
  hydrate: r = !0,
  nonce: a
}) {
  I(
    t && e,
    "You must provide `router` and `context` to <StaticRouterProvider>"
  );
  let n = {
    router: t,
    navigator: Gn(),
    static: !0,
    staticContext: e,
    basename: e.basename || "/"
  }, o = /* @__PURE__ */ new Map(), i = "";
  if (r !== !1) {
    let s = {
      loaderData: e.loaderData,
      actionData: e.actionData,
      errors: Zl(e.errors)
    };
    i = `window.__staticRouterHydrationData = JSON.parse(${rs(JSON.stringify(JSON.stringify(s)))});`;
  }
  let { state: l } = n.router;
  return /* @__PURE__ */ c.createElement(c.Fragment, null, /* @__PURE__ */ c.createElement(_e.Provider, { value: n }, /* @__PURE__ */ c.createElement(Ke.Provider, { value: l }, /* @__PURE__ */ c.createElement(Yt.Provider, { value: o }, /* @__PURE__ */ c.createElement(Wt.Provider, { value: { isTransitioning: !1 } }, /* @__PURE__ */ c.createElement(
    Ge,
    {
      basename: n.basename,
      location: l.location,
      navigationType: l.historyAction,
      navigator: n.navigator,
      static: n.static
    },
    /* @__PURE__ */ c.createElement(
      Ql,
      {
        routes: t.routes,
        future: t.future,
        state: l
      }
    )
  ))))), i ? /* @__PURE__ */ c.createElement(
    "script",
    {
      suppressHydrationWarning: !0,
      nonce: a,
      dangerouslySetInnerHTML: { __html: i }
    }
  ) : null);
}
function Ql({
  routes: e,
  future: t,
  state: r
}) {
  return Or(e, void 0, r, void 0, t);
}
function Zl(e) {
  if (!e) return null;
  let t = Object.entries(e), r = {};
  for (let [a, n] of t)
    be(n) ? r[a] = { ...n, __type: "RouteErrorResponse" } : n instanceof Error ? r[a] = {
      message: n.message,
      __type: "Error",
      // If this is a subclass (i.e., ReferenceError), send up the type so we
      // can re-create the same type during hydration.
      ...n.name !== "Error" ? {
        __subType: n.name
      } : {}
    } : r[a] = n;
  return r;
}
function Gn() {
  return {
    createHref: Qn,
    encodeLocation: Zn,
    push(e) {
      throw new Error(
        `You cannot use navigator.push() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(e)})\` somewhere in your app.`
      );
    },
    replace(e) {
      throw new Error(
        `You cannot use navigator.replace() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(e)}, { replace: true })\` somewhere in your app.`
      );
    },
    go(e) {
      throw new Error(
        `You cannot use navigator.go() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${e})\` somewhere in your app.`
      );
    },
    back() {
      throw new Error(
        "You cannot use navigator.back() on the server because it is a stateless environment."
      );
    },
    forward() {
      throw new Error(
        "You cannot use navigator.forward() on the server because it is a stateless environment."
      );
    }
  };
}
function Vs(e, t) {
  return Xo(e, {
    ...t,
    mapRouteProperties: bt
  });
}
function Ks(e, t, r = {}) {
  let a = {}, n = Ve(
    e,
    bt,
    void 0,
    a
  ), o = t.matches.map((l) => {
    let s = a[l.route.id] || l.route;
    return {
      ...l,
      route: s
    };
  }), i = (l) => `You cannot use router.${l}() on the server because it is a stateless environment`;
  return {
    get basename() {
      return t.basename;
    },
    get future() {
      return {
        unstable_middleware: !1,
        ...r?.future
      };
    },
    get state() {
      return {
        historyAction: "POP",
        location: t.location,
        matches: o,
        loaderData: t.loaderData,
        actionData: t.actionData,
        errors: t.errors,
        initialized: !0,
        navigation: Nt,
        restoreScrollPosition: null,
        preventScrollReset: !1,
        revalidation: "idle",
        fetchers: /* @__PURE__ */ new Map(),
        blockers: /* @__PURE__ */ new Map()
      };
    },
    get routes() {
      return n;
    },
    get window() {
    },
    initialize() {
      throw i("initialize");
    },
    subscribe() {
      throw i("subscribe");
    },
    enableScrollRestoration() {
      throw i("enableScrollRestoration");
    },
    navigate() {
      throw i("navigate");
    },
    fetch() {
      throw i("fetch");
    },
    revalidate() {
      throw i("revalidate");
    },
    createHref: Qn,
    encodeLocation: Zn,
    getFetcher() {
      return Cr;
    },
    deleteFetcher() {
      throw i("deleteFetcher");
    },
    dispose() {
      throw i("dispose");
    },
    getBlocker() {
      return Ye;
    },
    deleteBlocker() {
      throw i("deleteBlocker");
    },
    patchRoutes() {
      throw i("patchRoutes");
    },
    _internalFetchControllers: /* @__PURE__ */ new Map(),
    _internalSetRoutes() {
      throw i("_internalSetRoutes");
    },
    _internalSetStateDoNotUseOrYouWillBreakYourApp() {
      throw i("_internalSetStateDoNotUseOrYouWillBreakYourApp");
    }
  };
}
function Qn(e) {
  return typeof e == "string" ? e : fe(e);
}
function Zn(e) {
  let t = typeof e == "string" ? e : fe(e);
  t = t.replace(/ $/, "%20");
  let r = ql.test(t) ? new URL(t) : new URL(t, "http://localhost");
  return {
    pathname: r.pathname,
    search: r.search,
    hash: r.hash
  };
}
var ql = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, es = {
  "&": "\\u0026",
  ">": "\\u003e",
  "<": "\\u003c",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
}, ts = /[&><\u2028\u2029]/g;
function rs(e) {
  return e.replace(ts, (t) => es[t]);
}
export {
  dl as $,
  ne as A,
  Go as B,
  Ls as C,
  Ps as D,
  De as E,
  Kt as F,
  Ss as G,
  I as H,
  xr as I,
  Fa as J,
  or as K,
  Jn as L,
  hl as M,
  ys as N,
  vs as O,
  wr as P,
  os as Q,
  Fs as R,
  Js as S,
  is as T,
  li as U,
  al as V,
  Ds as W,
  as as X,
  ol as Y,
  Je as Z,
  On as _,
  Ir as a,
  Wl as a$,
  Zi as a0,
  le as a1,
  ws as a2,
  Is as a3,
  Vn as a4,
  js as a5,
  Ye as a6,
  Cr as a7,
  Nt as a8,
  $s as a9,
  bt as aA,
  Os as aB,
  Kl as aC,
  ks as aD,
  As as aE,
  fe as aF,
  jt as aG,
  bs as aH,
  mr as aI,
  Vs as aJ,
  Bo as aK,
  ns as aL,
  Ee as aM,
  Es as aN,
  Ao as aO,
  Ul as aP,
  Ws as aQ,
  Ar as aR,
  fs as aS,
  xi as aT,
  Bs as aU,
  Di as aV,
  Us as aW,
  zs as aX,
  Vl as aY,
  pi as aZ,
  Xe as a_,
  ps as aa,
  Ns as ab,
  zl as ac,
  wo as ad,
  Un as ae,
  $i as af,
  Ge as ag,
  gs as ah,
  Al as ai,
  Bl as aj,
  Ys as ak,
  _e as al,
  Ke as am,
  Yt as an,
  ot as ao,
  he as ap,
  me as aq,
  Wt as ar,
  Rs as as,
  xs as at,
  Cs as au,
  Wr as av,
  Ts as aw,
  _s as ax,
  Ms as ay,
  jr as az,
  Tr as b,
  kr as b0,
  Fr as b1,
  Pi as b2,
  ls as b3,
  vi as b4,
  us as b5,
  gt as b6,
  cs as b7,
  ds as b8,
  gi as b9,
  Xn as ba,
  Gl as bb,
  pe as c,
  ss as d,
  Hs as e,
  Rl as f,
  Ks as g,
  nl as h,
  be as i,
  Se as j,
  et as k,
  se as l,
  mt as m,
  Ml as n,
  Sa as o,
  Ve as p,
  hs as q,
  Sr as r,
  Pl as s,
  ms as t,
  _r as u,
  kl as v,
  hi as w,
  rl as x,
  hr as y,
  Xo as z
};
//# sourceMappingURL=chunk-PVWAREVJ-BO6B-RAk.js.map
