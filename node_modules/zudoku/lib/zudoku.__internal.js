import { a as Fe, H as qe } from "./index.esm-BnYHxCYC.js";
import { j as a } from "./jsx-runtime-DywqP_6a.js";
import { S as Me, q as Qe, Q as _t, n as O, r as fe, v as pe, i as T, w as yt, x as wt, y as bt, z as zt, A as me, B as ge, D as xt, h as ve, E as _e, F as kt, G as Zt, g as $t, H as Le, f as jt, d as X, o as Pt, j as Ot } from "./ZudokuContext-BcqSiygJ.js";
import { M as St } from "./mutation-De-1gXxl.js";
import * as A from "react";
import { StrictMode as Be, useEffect as ee, useRef as Ke, useState as Et, Suspense as It } from "react";
import { t as Tt, S as Dt, c as We, b2 as At, O as Nt } from "./chunk-PVWAREVJ-BO6B-RAk.js";
import * as Ct from "react-dom";
import { a as Rt, u as Ut, P as Ft, H as qt } from "./index-CVfG8Pb4.js";
import { B as He, R as Mt } from "./RouteGuard-dji1UEYe.js";
import { CircleFadingArrowUpIcon as Qt, LoaderCircleIcon as Lt, ExternalLink as Bt, PanelLeftIcon as Kt } from "lucide-react";
import { Button as Wt } from "./ui/Button.js";
import { c as S } from "./cn-dYga0KKN.js";
import { a as N, A as Ht, s as Vt, N as ye, f as Jt, T as Gt, H as Yt, E as Xt } from "./ErrorAlert-xpVkFS_n.js";
import { d as E, b as en, c as tn } from "./Drawer-DM9wJUC6.js";
import { VisuallyHidden as nn } from "@radix-ui/react-visually-hidden";
import { S as rn } from "./Spinner-Cf6E803I.js";
import { C as on } from "./CategoryHeading-BGCNu3VK.js";
import { N as sn, R as an } from "./RouterError-D1I15Qyy.js";
var cn = class extends Me {
  constructor(e = {}) {
    super(), this.config = e, this.#e = /* @__PURE__ */ new Map();
  }
  #e;
  build(e, t, n) {
    const r = t.queryKey, o = t.queryHash ?? Qe(r, t);
    let s = this.get(o);
    return s || (s = new _t({
      client: e,
      queryKey: r,
      queryHash: o,
      options: e.defaultQueryOptions(t),
      state: n,
      defaultOptions: e.getQueryDefaults(r)
    }), this.add(s)), s;
  }
  add(e) {
    this.#e.has(e.queryHash) || (this.#e.set(e.queryHash, e), this.notify({
      type: "added",
      query: e
    }));
  }
  remove(e) {
    const t = this.#e.get(e.queryHash);
    t && (e.destroy(), t === e && this.#e.delete(e.queryHash), this.notify({ type: "removed", query: e }));
  }
  clear() {
    O.batch(() => {
      this.getAll().forEach((e) => {
        this.remove(e);
      });
    });
  }
  get(e) {
    return this.#e.get(e);
  }
  getAll() {
    return [...this.#e.values()];
  }
  find(e) {
    const t = { exact: !0, ...e };
    return this.getAll().find(
      (n) => fe(t, n)
    );
  }
  findAll(e = {}) {
    const t = this.getAll();
    return Object.keys(e).length > 0 ? t.filter((n) => fe(e, n)) : t;
  }
  notify(e) {
    O.batch(() => {
      this.listeners.forEach((t) => {
        t(e);
      });
    });
  }
  onFocus() {
    O.batch(() => {
      this.getAll().forEach((e) => {
        e.onFocus();
      });
    });
  }
  onOnline() {
    O.batch(() => {
      this.getAll().forEach((e) => {
        e.onOnline();
      });
    });
  }
}, un = class extends Me {
  constructor(e = {}) {
    super(), this.config = e, this.#e = /* @__PURE__ */ new Set(), this.#t = /* @__PURE__ */ new Map(), this.#n = 0;
  }
  #e;
  #t;
  #n;
  build(e, t, n) {
    const r = new St({
      mutationCache: this,
      mutationId: ++this.#n,
      options: e.defaultMutationOptions(t),
      state: n
    });
    return this.add(r), r;
  }
  add(e) {
    this.#e.add(e);
    const t = W(e);
    if (typeof t == "string") {
      const n = this.#t.get(t);
      n ? n.push(e) : this.#t.set(t, [e]);
    }
    this.notify({ type: "added", mutation: e });
  }
  remove(e) {
    if (this.#e.delete(e)) {
      const t = W(e);
      if (typeof t == "string") {
        const n = this.#t.get(t);
        if (n)
          if (n.length > 1) {
            const r = n.indexOf(e);
            r !== -1 && n.splice(r, 1);
          } else n[0] === e && this.#t.delete(t);
      }
    }
    this.notify({ type: "removed", mutation: e });
  }
  canRun(e) {
    const t = W(e);
    if (typeof t == "string") {
      const r = this.#t.get(t)?.find(
        (o) => o.state.status === "pending"
      );
      return !r || r === e;
    } else
      return !0;
  }
  runNext(e) {
    const t = W(e);
    return typeof t == "string" ? this.#t.get(t)?.find((r) => r !== e && r.state.isPaused)?.continue() ?? Promise.resolve() : Promise.resolve();
  }
  clear() {
    O.batch(() => {
      this.#e.forEach((e) => {
        this.notify({ type: "removed", mutation: e });
      }), this.#e.clear(), this.#t.clear();
    });
  }
  getAll() {
    return Array.from(this.#e);
  }
  find(e) {
    const t = { exact: !0, ...e };
    return this.getAll().find(
      (n) => pe(t, n)
    );
  }
  findAll(e = {}) {
    return this.getAll().filter((t) => pe(e, t));
  }
  notify(e) {
    O.batch(() => {
      this.listeners.forEach((t) => {
        t(e);
      });
    });
  }
  resumePausedMutations() {
    const e = this.getAll().filter((t) => t.state.isPaused);
    return O.batch(
      () => Promise.all(
        e.map((t) => t.continue().catch(T))
      )
    );
  }
};
function W(e) {
  return e.options.scope?.id;
}
function we(e) {
  return {
    onFetch: (t, n) => {
      const r = t.options, o = t.fetchOptions?.meta?.fetchMore?.direction, s = t.state.data?.pages || [], i = t.state.data?.pageParams || [];
      let u = { pages: [], pageParams: [] }, f = 0;
      const d = async () => {
        let g = !1;
        const h = (v) => {
          Object.defineProperty(v, "signal", {
            enumerable: !0,
            get: () => (t.signal.aborted ? g = !0 : t.signal.addEventListener("abort", () => {
              g = !0;
            }), t.signal)
          });
        }, p = yt(t.options, t.fetchOptions), m = async (v, z, P) => {
          if (g)
            return Promise.reject();
          if (z == null && v.pages.length)
            return Promise.resolve(v);
          const j = (() => {
            const D = {
              client: t.client,
              queryKey: t.queryKey,
              pageParam: z,
              direction: P ? "backward" : "forward",
              meta: t.options.meta
            };
            return h(D), D;
          })(), b = await p(j), { maxPages: k } = t.options, q = P ? wt : bt;
          return {
            pages: q(v.pages, b, k),
            pageParams: q(v.pageParams, z, k)
          };
        };
        if (o && s.length) {
          const v = o === "backward", z = v ? ln : be, P = {
            pages: s,
            pageParams: i
          }, $ = z(r, P);
          u = await m(P, $, v);
        } else {
          const v = e ?? s.length;
          do {
            const z = f === 0 ? i[0] ?? r.initialPageParam : be(r, u);
            if (f > 0 && z == null)
              break;
            u = await m(u, z), f++;
          } while (f < v);
        }
        return u;
      };
      t.options.persister ? t.fetchFn = () => t.options.persister?.(
        d,
        {
          client: t.client,
          queryKey: t.queryKey,
          meta: t.options.meta,
          signal: t.signal
        },
        n
      ) : t.fetchFn = d;
    }
  };
}
function be(e, { pages: t, pageParams: n }) {
  const r = t.length - 1;
  return t.length > 0 ? e.getNextPageParam(
    t[r],
    t,
    n[r],
    n
  ) : void 0;
}
function ln(e, { pages: t, pageParams: n }) {
  return t.length > 0 ? e.getPreviousPageParam?.(t[0], t, n[0], n) : void 0;
}
var dn = class {
  #e;
  #t;
  #n;
  #o;
  #s;
  #r;
  #i;
  #a;
  constructor(e = {}) {
    this.#e = e.queryCache || new cn(), this.#t = e.mutationCache || new un(), this.#n = e.defaultOptions || {}, this.#o = /* @__PURE__ */ new Map(), this.#s = /* @__PURE__ */ new Map(), this.#r = 0;
  }
  mount() {
    this.#r++, this.#r === 1 && (this.#i = zt.subscribe(async (e) => {
      e && (await this.resumePausedMutations(), this.#e.onFocus());
    }), this.#a = me.subscribe(async (e) => {
      e && (await this.resumePausedMutations(), this.#e.onOnline());
    }));
  }
  unmount() {
    this.#r--, this.#r === 0 && (this.#i?.(), this.#i = void 0, this.#a?.(), this.#a = void 0);
  }
  isFetching(e) {
    return this.#e.findAll({ ...e, fetchStatus: "fetching" }).length;
  }
  isMutating(e) {
    return this.#t.findAll({ ...e, status: "pending" }).length;
  }
  /**
   * Imperative (non-reactive) way to retrieve data for a QueryKey.
   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.
   *
   * Hint: Do not use this function inside a component, because it won't receive updates.
   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.
   */
  getQueryData(e) {
    const t = this.defaultQueryOptions({ queryKey: e });
    return this.#e.get(t.queryHash)?.state.data;
  }
  ensureQueryData(e) {
    const t = this.defaultQueryOptions(e), n = this.#e.build(this, t), r = n.state.data;
    return r === void 0 ? this.fetchQuery(e) : (e.revalidateIfStale && n.isStaleByTime(ge(t.staleTime, n)) && this.prefetchQuery(t), Promise.resolve(r));
  }
  getQueriesData(e) {
    return this.#e.findAll(e).map(({ queryKey: t, state: n }) => {
      const r = n.data;
      return [t, r];
    });
  }
  setQueryData(e, t, n) {
    const r = this.defaultQueryOptions({ queryKey: e }), s = this.#e.get(
      r.queryHash
    )?.state.data, i = xt(t, s);
    if (i !== void 0)
      return this.#e.build(this, r).setData(i, { ...n, manual: !0 });
  }
  setQueriesData(e, t, n) {
    return O.batch(
      () => this.#e.findAll(e).map(({ queryKey: r }) => [
        r,
        this.setQueryData(r, t, n)
      ])
    );
  }
  getQueryState(e) {
    const t = this.defaultQueryOptions({ queryKey: e });
    return this.#e.get(
      t.queryHash
    )?.state;
  }
  removeQueries(e) {
    const t = this.#e;
    O.batch(() => {
      t.findAll(e).forEach((n) => {
        t.remove(n);
      });
    });
  }
  resetQueries(e, t) {
    const n = this.#e;
    return O.batch(() => (n.findAll(e).forEach((r) => {
      r.reset();
    }), this.refetchQueries(
      {
        type: "active",
        ...e
      },
      t
    )));
  }
  cancelQueries(e, t = {}) {
    const n = { revert: !0, ...t }, r = O.batch(
      () => this.#e.findAll(e).map((o) => o.cancel(n))
    );
    return Promise.all(r).then(T).catch(T);
  }
  invalidateQueries(e, t = {}) {
    return O.batch(() => (this.#e.findAll(e).forEach((n) => {
      n.invalidate();
    }), e?.refetchType === "none" ? Promise.resolve() : this.refetchQueries(
      {
        ...e,
        type: e?.refetchType ?? e?.type ?? "active"
      },
      t
    )));
  }
  refetchQueries(e, t = {}) {
    const n = {
      ...t,
      cancelRefetch: t.cancelRefetch ?? !0
    }, r = O.batch(
      () => this.#e.findAll(e).filter((o) => !o.isDisabled() && !o.isStatic()).map((o) => {
        let s = o.fetch(void 0, n);
        return n.throwOnError || (s = s.catch(T)), o.state.fetchStatus === "paused" ? Promise.resolve() : s;
      })
    );
    return Promise.all(r).then(T);
  }
  fetchQuery(e) {
    const t = this.defaultQueryOptions(e);
    t.retry === void 0 && (t.retry = !1);
    const n = this.#e.build(this, t);
    return n.isStaleByTime(
      ge(t.staleTime, n)
    ) ? n.fetch(t) : Promise.resolve(n.state.data);
  }
  prefetchQuery(e) {
    return this.fetchQuery(e).then(T).catch(T);
  }
  fetchInfiniteQuery(e) {
    return e.behavior = we(e.pages), this.fetchQuery(e);
  }
  prefetchInfiniteQuery(e) {
    return this.fetchInfiniteQuery(e).then(T).catch(T);
  }
  ensureInfiniteQueryData(e) {
    return e.behavior = we(e.pages), this.ensureQueryData(e);
  }
  resumePausedMutations() {
    return me.isOnline() ? this.#t.resumePausedMutations() : Promise.resolve();
  }
  getQueryCache() {
    return this.#e;
  }
  getMutationCache() {
    return this.#t;
  }
  getDefaultOptions() {
    return this.#n;
  }
  setDefaultOptions(e) {
    this.#n = e;
  }
  setQueryDefaults(e, t) {
    this.#o.set(ve(e), {
      queryKey: e,
      defaultOptions: t
    });
  }
  getQueryDefaults(e) {
    const t = [...this.#o.values()], n = {};
    return t.forEach((r) => {
      _e(e, r.queryKey) && Object.assign(n, r.defaultOptions);
    }), n;
  }
  setMutationDefaults(e, t) {
    this.#s.set(ve(e), {
      mutationKey: e,
      defaultOptions: t
    });
  }
  getMutationDefaults(e) {
    const t = [...this.#s.values()], n = {};
    return t.forEach((r) => {
      _e(e, r.mutationKey) && Object.assign(n, r.defaultOptions);
    }), n;
  }
  defaultQueryOptions(e) {
    if (e._defaulted)
      return e;
    const t = {
      ...this.#n.queries,
      ...this.getQueryDefaults(e.queryKey),
      ...e,
      _defaulted: !0
    };
    return t.queryHash || (t.queryHash = Qe(
      t.queryKey,
      t
    )), t.refetchOnReconnect === void 0 && (t.refetchOnReconnect = t.networkMode !== "always"), t.throwOnError === void 0 && (t.throwOnError = !!t.suspense), !t.networkMode && t.persister && (t.networkMode = "offlineFirst"), t.queryFn === kt && (t.enabled = !1), t;
  }
  defaultMutationOptions(e) {
    return e?._defaulted ? e : {
      ...this.#n.mutations,
      ...e?.mutationKey && this.getMutationDefaults(e.mutationKey),
      ...e,
      _defaulted: !0
    };
  }
  clear() {
    this.#e.clear(), this.#t.clear();
  }
};
function hn(e) {
  return e;
}
function ze(e, t, n) {
  if (typeof t != "object" || t === null)
    return;
  const r = e.getMutationCache(), o = e.getQueryCache(), s = n?.defaultOptions?.deserializeData ?? e.getDefaultOptions().hydrate?.deserializeData ?? hn, i = t.mutations || [], u = t.queries || [];
  i.forEach(({ state: f, ...d }) => {
    r.build(
      e,
      {
        ...e.getDefaultOptions().hydrate?.mutations,
        ...n?.defaultOptions?.mutations,
        ...d
      },
      f
    );
  }), u.forEach(
    ({ queryKey: f, state: d, queryHash: g, meta: h, promise: p, dehydratedAt: m }) => {
      const v = p ? Zt(p) : void 0, z = d.data === void 0 ? v?.data : d.data, P = z === void 0 ? z : s(z);
      let $ = o.get(g);
      const j = $?.state.status === "pending", b = $?.state.fetchStatus === "fetching";
      if ($) {
        const k = v && // We only need this undefined check to handle older dehydration
        // payloads that might not have dehydratedAt
        m !== void 0 && m > $.state.dataUpdatedAt;
        if (d.dataUpdatedAt > $.state.dataUpdatedAt || k) {
          const { fetchStatus: q, ...D } = d;
          $.setState({
            ...D,
            data: P
          });
        }
      } else
        $ = o.build(
          e,
          {
            ...e.getDefaultOptions().hydrate?.queries,
            ...n?.defaultOptions?.queries,
            queryKey: f,
            queryHash: g,
            meta: h
          },
          // Reset fetch status to idle to avoid
          // query being stuck in fetching state upon hydration
          {
            ...d,
            data: P,
            fetchStatus: "idle",
            status: P !== void 0 ? "success" : d.status
          }
        );
      p && !j && !b && // Only hydrate if dehydration is newer than any existing data,
      // this is always true for new queries
      (m === void 0 || m > $.state.dataUpdatedAt) && $.fetch(void 0, {
        // RSC transformed promises are not thenable
        initialPromise: Promise.resolve(p).then(s)
      });
    }
  );
}
var fn = ({
  children: e,
  options: t = {},
  state: n,
  queryClient: r
}) => {
  const o = $t(r), s = A.useRef(t);
  s.current = t;
  const i = A.useMemo(() => {
    if (n) {
      if (typeof n != "object")
        return;
      const u = o.getQueryCache(), f = n.queries || [], d = [], g = [];
      for (const h of f) {
        const p = u.get(h.queryHash);
        p ? (h.state.dataUpdatedAt > p.state.dataUpdatedAt || h.promise && p.state.status !== "pending" && p.state.fetchStatus !== "fetching" && h.dehydratedAt !== void 0 && h.dehydratedAt > p.state.dataUpdatedAt) && g.push(h) : d.push(h);
      }
      if (d.length > 0 && ze(o, { queries: d }, s.current), g.length > 0)
        return g;
    }
  }, [o, n]);
  return A.useEffect(() => {
    i && ze(o, { queries: i }, s.current);
  }, [o, i]), e;
};
/**
 * react-router v7.8.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function pn(e) {
  return /* @__PURE__ */ A.createElement(Tt, { flushSync: Ct.flushSync, ...e });
}
const mn = new dn({
  defaultOptions: {
    queries: {
      staleTime: 1e3 * 60 * 5
    }
  }
}), gn = ({
  router: e,
  hydrate: t = !1
}) => /* @__PURE__ */ a.jsx(Be, { children: /* @__PURE__ */ a.jsx(Le, { client: mn, children: /* @__PURE__ */ a.jsx(fn, { state: t ? window.DATA : void 0, children: /* @__PURE__ */ a.jsx(He, { value: !1, children: /* @__PURE__ */ a.jsx(Fe, { children: /* @__PURE__ */ a.jsx(Rt.Provider, { value: { stagger: !t }, children: /* @__PURE__ */ a.jsx(pn, { router: e }) }) }) }) }) }) }), vn = ({
  router: e,
  context: t,
  queryClient: n,
  helmetContext: r,
  bypassProtection: o = !1
}) => /* @__PURE__ */ a.jsx(Be, { children: /* @__PURE__ */ a.jsx(Le, { client: n, children: /* @__PURE__ */ a.jsx(Fe, { context: r, children: /* @__PURE__ */ a.jsx(He, { value: o, children: /* @__PURE__ */ a.jsx(Dt, { router: e, context: t }) }) }) }) });
function c(e, t, n) {
  function r(u, f) {
    var d;
    Object.defineProperty(u, "_zod", {
      value: u._zod ?? {},
      enumerable: !1
    }), (d = u._zod).traits ?? (d.traits = /* @__PURE__ */ new Set()), u._zod.traits.add(e), t(u, f);
    for (const g in i.prototype)
      g in u || Object.defineProperty(u, g, { value: i.prototype[g].bind(u) });
    u._zod.constr = i, u._zod.def = f;
  }
  const o = n?.Parent ?? Object;
  class s extends o {
  }
  Object.defineProperty(s, "name", { value: e });
  function i(u) {
    var f;
    const d = n?.Parent ? new s() : this;
    r(d, u), (f = d._zod).deferred ?? (f.deferred = []);
    for (const g of d._zod.deferred)
      g();
    return d;
  }
  return Object.defineProperty(i, "init", { value: r }), Object.defineProperty(i, Symbol.hasInstance, {
    value: (u) => n?.Parent && u instanceof n.Parent ? !0 : u?._zod?.traits?.has(e)
  }), Object.defineProperty(i, "name", { value: e }), i;
}
class L extends Error {
  constructor() {
    super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
  }
}
const Ve = {};
function C(e) {
  return Ve;
}
function _n(e) {
  const t = Object.values(e).filter((r) => typeof r == "number");
  return Object.entries(e).filter(([r, o]) => t.indexOf(+r) === -1).map(([r, o]) => o);
}
function oe(e, t) {
  return typeof t == "bigint" ? t.toString() : t;
}
function Je(e) {
  return {
    get value() {
      {
        const t = e();
        return Object.defineProperty(this, "value", { value: t }), t;
      }
    }
  };
}
function ue(e) {
  return e == null;
}
function le(e) {
  const t = e.startsWith("^") ? 1 : 0, n = e.endsWith("$") ? e.length - 1 : e.length;
  return e.slice(t, n);
}
function _(e, t, n) {
  Object.defineProperty(e, t, {
    get() {
      {
        const r = n();
        return e[t] = r, r;
      }
    },
    set(r) {
      Object.defineProperty(e, t, {
        value: r
        // configurable: true,
      });
    },
    configurable: !0
  });
}
function U(e, t, n) {
  Object.defineProperty(e, t, {
    value: n,
    writable: !0,
    enumerable: !0,
    configurable: !0
  });
}
function M(...e) {
  const t = {};
  for (const n of e) {
    const r = Object.getOwnPropertyDescriptors(n);
    Object.assign(t, r);
  }
  return Object.defineProperties({}, t);
}
function xe(e) {
  return JSON.stringify(e);
}
const Ge = "captureStackTrace" in Error ? Error.captureStackTrace : (...e) => {
};
function se(e) {
  return typeof e == "object" && e !== null && !Array.isArray(e);
}
const yn = Je(() => {
  if (typeof navigator < "u" && navigator?.userAgent?.includes("Cloudflare"))
    return !1;
  try {
    const e = Function;
    return new e(""), !0;
  } catch {
    return !1;
  }
});
function ie(e) {
  if (se(e) === !1)
    return !1;
  const t = e.constructor;
  if (t === void 0)
    return !0;
  const n = t.prototype;
  return !(se(n) === !1 || Object.prototype.hasOwnProperty.call(n, "isPrototypeOf") === !1);
}
const wn = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
function te(e) {
  return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function F(e, t, n) {
  const r = new e._zod.constr(t ?? e._zod.def);
  return (!t || n?.parent) && (r._zod.parent = e), r;
}
function l(e) {
  const t = e;
  if (!t)
    return {};
  if (typeof t == "string")
    return { error: () => t };
  if (t?.message !== void 0) {
    if (t?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    t.error = t.message;
  }
  return delete t.message, typeof t.error == "string" ? { ...t, error: () => t.error } : t;
}
function bn(e) {
  return Object.keys(e).filter((t) => e[t]._zod.optin === "optional" && e[t]._zod.optout === "optional");
}
function zn(e, t) {
  const n = e._zod.def, r = M(e._zod.def, {
    get shape() {
      const o = {};
      for (const s in t) {
        if (!(s in n.shape))
          throw new Error(`Unrecognized key: "${s}"`);
        t[s] && (o[s] = n.shape[s]);
      }
      return U(this, "shape", o), o;
    },
    checks: []
  });
  return F(e, r);
}
function xn(e, t) {
  const n = e._zod.def, r = M(e._zod.def, {
    get shape() {
      const o = { ...e._zod.def.shape };
      for (const s in t) {
        if (!(s in n.shape))
          throw new Error(`Unrecognized key: "${s}"`);
        t[s] && delete o[s];
      }
      return U(this, "shape", o), o;
    },
    checks: []
  });
  return F(e, r);
}
function kn(e, t) {
  if (!ie(t))
    throw new Error("Invalid input to extend: expected a plain object");
  const n = M(e._zod.def, {
    get shape() {
      const r = { ...e._zod.def.shape, ...t };
      return U(this, "shape", r), r;
    },
    checks: []
  });
  return F(e, n);
}
function Zn(e, t) {
  const n = M(e._zod.def, {
    get shape() {
      const r = { ...e._zod.def.shape, ...t._zod.def.shape };
      return U(this, "shape", r), r;
    },
    get catchall() {
      return t._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return F(e, n);
}
function $n(e, t, n) {
  const r = M(t._zod.def, {
    get shape() {
      const o = t._zod.def.shape, s = { ...o };
      if (n)
        for (const i in n) {
          if (!(i in o))
            throw new Error(`Unrecognized key: "${i}"`);
          n[i] && (s[i] = e ? new e({
            type: "optional",
            innerType: o[i]
          }) : o[i]);
        }
      else
        for (const i in o)
          s[i] = e ? new e({
            type: "optional",
            innerType: o[i]
          }) : o[i];
      return U(this, "shape", s), s;
    },
    checks: []
  });
  return F(t, r);
}
function jn(e, t, n) {
  const r = M(t._zod.def, {
    get shape() {
      const o = t._zod.def.shape, s = { ...o };
      if (n)
        for (const i in n) {
          if (!(i in s))
            throw new Error(`Unrecognized key: "${i}"`);
          n[i] && (s[i] = new e({
            type: "nonoptional",
            innerType: o[i]
          }));
        }
      else
        for (const i in o)
          s[i] = new e({
            type: "nonoptional",
            innerType: o[i]
          });
      return U(this, "shape", s), s;
    },
    checks: []
  });
  return F(t, r);
}
function Q(e, t = 0) {
  for (let n = t; n < e.issues.length; n++)
    if (e.issues[n]?.continue !== !0)
      return !0;
  return !1;
}
function Ye(e, t) {
  return t.map((n) => {
    var r;
    return (r = n).path ?? (r.path = []), n.path.unshift(e), n;
  });
}
function H(e) {
  return typeof e == "string" ? e : e?.message;
}
function R(e, t, n) {
  const r = { ...e, path: e.path ?? [] };
  if (!e.message) {
    const o = H(e.inst?._zod.def?.error?.(e)) ?? H(t?.error?.(e)) ?? H(n.customError?.(e)) ?? H(n.localeError?.(e)) ?? "Invalid input";
    r.message = o;
  }
  return delete r.inst, delete r.continue, t?.reportInput || delete r.input, r;
}
function de(e) {
  return Array.isArray(e) ? "array" : typeof e == "string" ? "string" : "unknown";
}
function B(...e) {
  const [t, n, r] = e;
  return typeof t == "string" ? {
    message: t,
    code: "custom",
    input: n,
    inst: r
  } : { ...t };
}
const Xe = (e, t) => {
  e.name = "$ZodError", Object.defineProperty(e, "_zod", {
    value: e._zod,
    enumerable: !1
  }), Object.defineProperty(e, "issues", {
    value: t,
    enumerable: !1
  }), e.message = JSON.stringify(t, oe, 2), Object.defineProperty(e, "toString", {
    value: () => e.message,
    enumerable: !1
  });
}, et = c("$ZodError", Xe), tt = c("$ZodError", Xe, { Parent: Error });
function Pn(e, t = (n) => n.message) {
  const n = {}, r = [];
  for (const o of e.issues)
    o.path.length > 0 ? (n[o.path[0]] = n[o.path[0]] || [], n[o.path[0]].push(t(o))) : r.push(t(o));
  return { formErrors: r, fieldErrors: n };
}
function On(e, t) {
  const n = t || function(s) {
    return s.message;
  }, r = { _errors: [] }, o = (s) => {
    for (const i of s.issues)
      if (i.code === "invalid_union" && i.errors.length)
        i.errors.map((u) => o({ issues: u }));
      else if (i.code === "invalid_key")
        o({ issues: i.issues });
      else if (i.code === "invalid_element")
        o({ issues: i.issues });
      else if (i.path.length === 0)
        r._errors.push(n(i));
      else {
        let u = r, f = 0;
        for (; f < i.path.length; ) {
          const d = i.path[f];
          f === i.path.length - 1 ? (u[d] = u[d] || { _errors: [] }, u[d]._errors.push(n(i))) : u[d] = u[d] || { _errors: [] }, u = u[d], f++;
        }
      }
  };
  return o(e), r;
}
const Sn = (e) => (t, n, r, o) => {
  const s = r ? Object.assign(r, { async: !1 }) : { async: !1 }, i = t._zod.run({ value: n, issues: [] }, s);
  if (i instanceof Promise)
    throw new L();
  if (i.issues.length) {
    const u = new (o?.Err ?? e)(i.issues.map((f) => R(f, s, C())));
    throw Ge(u, o?.callee), u;
  }
  return i.value;
}, En = (e) => async (t, n, r, o) => {
  const s = r ? Object.assign(r, { async: !0 }) : { async: !0 };
  let i = t._zod.run({ value: n, issues: [] }, s);
  if (i instanceof Promise && (i = await i), i.issues.length) {
    const u = new (o?.Err ?? e)(i.issues.map((f) => R(f, s, C())));
    throw Ge(u, o?.callee), u;
  }
  return i.value;
}, nt = (e) => (t, n, r) => {
  const o = r ? { ...r, async: !1 } : { async: !1 }, s = t._zod.run({ value: n, issues: [] }, o);
  if (s instanceof Promise)
    throw new L();
  return s.issues.length ? {
    success: !1,
    error: new (e ?? et)(s.issues.map((i) => R(i, o, C())))
  } : { success: !0, data: s.value };
}, In = /* @__PURE__ */ nt(tt), rt = (e) => async (t, n, r) => {
  const o = r ? Object.assign(r, { async: !0 }) : { async: !0 };
  let s = t._zod.run({ value: n, issues: [] }, o);
  return s instanceof Promise && (s = await s), s.issues.length ? {
    success: !1,
    error: new e(s.issues.map((i) => R(i, o, C())))
  } : { success: !0, data: s.value };
}, Tn = /* @__PURE__ */ rt(tt), Dn = /^[cC][^\s-]{8,}$/, An = /^[0-9a-z]+$/, Nn = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/, Cn = /^[0-9a-vA-V]{20}$/, Rn = /^[A-Za-z0-9]{27}$/, Un = /^[a-zA-Z0-9_-]{21}$/, Fn = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/, qn = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/, ke = (e) => e ? new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${e}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`) : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/, Mn = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/, Qn = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function Ln() {
  return new RegExp(Qn, "u");
}
const Bn = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, Kn = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/, Wn = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/, Hn = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, Vn = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/, ot = /^[A-Za-z0-9_-]*$/, Jn = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/, Gn = /^\+(?:[0-9]){6,14}[0-9]$/, st = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))", Yn = /* @__PURE__ */ new RegExp(`^${st}$`);
function it(e) {
  const t = "(?:[01]\\d|2[0-3]):[0-5]\\d";
  return typeof e.precision == "number" ? e.precision === -1 ? `${t}` : e.precision === 0 ? `${t}:[0-5]\\d` : `${t}:[0-5]\\d\\.\\d{${e.precision}}` : `${t}(?::[0-5]\\d(?:\\.\\d+)?)?`;
}
function Xn(e) {
  return new RegExp(`^${it(e)}$`);
}
function er(e) {
  const t = it({ precision: e.precision }), n = ["Z"];
  e.local && n.push(""), e.offset && n.push("([+-]\\d{2}:\\d{2})");
  const r = `${t}(?:${n.join("|")})`;
  return new RegExp(`^${st}T(?:${r})$`);
}
const tr = (e) => {
  const t = e ? `[\\s\\S]{${e?.minimum ?? 0},${e?.maximum ?? ""}}` : "[\\s\\S]*";
  return new RegExp(`^${t}$`);
}, nr = /^[^A-Z]*$/, rr = /^[^a-z]*$/, I = /* @__PURE__ */ c("$ZodCheck", (e, t) => {
  var n;
  e._zod ?? (e._zod = {}), e._zod.def = t, (n = e._zod).onattach ?? (n.onattach = []);
}), or = /* @__PURE__ */ c("$ZodCheckMaxLength", (e, t) => {
  var n;
  I.init(e, t), (n = e._zod.def).when ?? (n.when = (r) => {
    const o = r.value;
    return !ue(o) && o.length !== void 0;
  }), e._zod.onattach.push((r) => {
    const o = r._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    t.maximum < o && (r._zod.bag.maximum = t.maximum);
  }), e._zod.check = (r) => {
    const o = r.value;
    if (o.length <= t.maximum)
      return;
    const i = de(o);
    r.issues.push({
      origin: i,
      code: "too_big",
      maximum: t.maximum,
      inclusive: !0,
      input: o,
      inst: e,
      continue: !t.abort
    });
  };
}), sr = /* @__PURE__ */ c("$ZodCheckMinLength", (e, t) => {
  var n;
  I.init(e, t), (n = e._zod.def).when ?? (n.when = (r) => {
    const o = r.value;
    return !ue(o) && o.length !== void 0;
  }), e._zod.onattach.push((r) => {
    const o = r._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    t.minimum > o && (r._zod.bag.minimum = t.minimum);
  }), e._zod.check = (r) => {
    const o = r.value;
    if (o.length >= t.minimum)
      return;
    const i = de(o);
    r.issues.push({
      origin: i,
      code: "too_small",
      minimum: t.minimum,
      inclusive: !0,
      input: o,
      inst: e,
      continue: !t.abort
    });
  };
}), ir = /* @__PURE__ */ c("$ZodCheckLengthEquals", (e, t) => {
  var n;
  I.init(e, t), (n = e._zod.def).when ?? (n.when = (r) => {
    const o = r.value;
    return !ue(o) && o.length !== void 0;
  }), e._zod.onattach.push((r) => {
    const o = r._zod.bag;
    o.minimum = t.length, o.maximum = t.length, o.length = t.length;
  }), e._zod.check = (r) => {
    const o = r.value, s = o.length;
    if (s === t.length)
      return;
    const i = de(o), u = s > t.length;
    r.issues.push({
      origin: i,
      ...u ? { code: "too_big", maximum: t.length } : { code: "too_small", minimum: t.length },
      inclusive: !0,
      exact: !0,
      input: r.value,
      inst: e,
      continue: !t.abort
    });
  };
}), ne = /* @__PURE__ */ c("$ZodCheckStringFormat", (e, t) => {
  var n, r;
  I.init(e, t), e._zod.onattach.push((o) => {
    const s = o._zod.bag;
    s.format = t.format, t.pattern && (s.patterns ?? (s.patterns = /* @__PURE__ */ new Set()), s.patterns.add(t.pattern));
  }), t.pattern ? (n = e._zod).check ?? (n.check = (o) => {
    t.pattern.lastIndex = 0, !t.pattern.test(o.value) && o.issues.push({
      origin: "string",
      code: "invalid_format",
      format: t.format,
      input: o.value,
      ...t.pattern ? { pattern: t.pattern.toString() } : {},
      inst: e,
      continue: !t.abort
    });
  }) : (r = e._zod).check ?? (r.check = () => {
  });
}), ar = /* @__PURE__ */ c("$ZodCheckRegex", (e, t) => {
  ne.init(e, t), e._zod.check = (n) => {
    t.pattern.lastIndex = 0, !t.pattern.test(n.value) && n.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: n.value,
      pattern: t.pattern.toString(),
      inst: e,
      continue: !t.abort
    });
  };
}), cr = /* @__PURE__ */ c("$ZodCheckLowerCase", (e, t) => {
  t.pattern ?? (t.pattern = nr), ne.init(e, t);
}), ur = /* @__PURE__ */ c("$ZodCheckUpperCase", (e, t) => {
  t.pattern ?? (t.pattern = rr), ne.init(e, t);
}), lr = /* @__PURE__ */ c("$ZodCheckIncludes", (e, t) => {
  I.init(e, t);
  const n = te(t.includes), r = new RegExp(typeof t.position == "number" ? `^.{${t.position}}${n}` : n);
  t.pattern = r, e._zod.onattach.push((o) => {
    const s = o._zod.bag;
    s.patterns ?? (s.patterns = /* @__PURE__ */ new Set()), s.patterns.add(r);
  }), e._zod.check = (o) => {
    o.value.includes(t.includes, t.position) || o.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: t.includes,
      input: o.value,
      inst: e,
      continue: !t.abort
    });
  };
}), dr = /* @__PURE__ */ c("$ZodCheckStartsWith", (e, t) => {
  I.init(e, t);
  const n = new RegExp(`^${te(t.prefix)}.*`);
  t.pattern ?? (t.pattern = n), e._zod.onattach.push((r) => {
    const o = r._zod.bag;
    o.patterns ?? (o.patterns = /* @__PURE__ */ new Set()), o.patterns.add(n);
  }), e._zod.check = (r) => {
    r.value.startsWith(t.prefix) || r.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: t.prefix,
      input: r.value,
      inst: e,
      continue: !t.abort
    });
  };
}), hr = /* @__PURE__ */ c("$ZodCheckEndsWith", (e, t) => {
  I.init(e, t);
  const n = new RegExp(`.*${te(t.suffix)}$`);
  t.pattern ?? (t.pattern = n), e._zod.onattach.push((r) => {
    const o = r._zod.bag;
    o.patterns ?? (o.patterns = /* @__PURE__ */ new Set()), o.patterns.add(n);
  }), e._zod.check = (r) => {
    r.value.endsWith(t.suffix) || r.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: t.suffix,
      input: r.value,
      inst: e,
      continue: !t.abort
    });
  };
}), fr = /* @__PURE__ */ c("$ZodCheckOverwrite", (e, t) => {
  I.init(e, t), e._zod.check = (n) => {
    n.value = t.tx(n.value);
  };
});
class pr {
  constructor(t = []) {
    this.content = [], this.indent = 0, this && (this.args = t);
  }
  indented(t) {
    this.indent += 1, t(this), this.indent -= 1;
  }
  write(t) {
    if (typeof t == "function") {
      t(this, { execution: "sync" }), t(this, { execution: "async" });
      return;
    }
    const r = t.split(`
`).filter((i) => i), o = Math.min(...r.map((i) => i.length - i.trimStart().length)), s = r.map((i) => i.slice(o)).map((i) => " ".repeat(this.indent * 2) + i);
    for (const i of s)
      this.content.push(i);
  }
  compile() {
    const t = Function, n = this?.args, o = [...(this?.content ?? [""]).map((s) => `  ${s}`)];
    return new t(...n, o.join(`
`));
  }
}
const mr = {
  major: 4,
  minor: 0,
  patch: 10
}, x = /* @__PURE__ */ c("$ZodType", (e, t) => {
  var n;
  e ?? (e = {}), e._zod.def = t, e._zod.bag = e._zod.bag || {}, e._zod.version = mr;
  const r = [...e._zod.def.checks ?? []];
  e._zod.traits.has("$ZodCheck") && r.unshift(e);
  for (const o of r)
    for (const s of o._zod.onattach)
      s(e);
  if (r.length === 0)
    (n = e._zod).deferred ?? (n.deferred = []), e._zod.deferred?.push(() => {
      e._zod.run = e._zod.parse;
    });
  else {
    const o = (s, i, u) => {
      let f = Q(s), d;
      for (const g of i) {
        if (g._zod.def.when) {
          if (!g._zod.def.when(s))
            continue;
        } else if (f)
          continue;
        const h = s.issues.length, p = g._zod.check(s);
        if (p instanceof Promise && u?.async === !1)
          throw new L();
        if (d || p instanceof Promise)
          d = (d ?? Promise.resolve()).then(async () => {
            await p, s.issues.length !== h && (f || (f = Q(s, h)));
          });
        else {
          if (s.issues.length === h)
            continue;
          f || (f = Q(s, h));
        }
      }
      return d ? d.then(() => s) : s;
    };
    e._zod.run = (s, i) => {
      const u = e._zod.parse(s, i);
      if (u instanceof Promise) {
        if (i.async === !1)
          throw new L();
        return u.then((f) => o(f, r, i));
      }
      return o(u, r, i);
    };
  }
  e["~standard"] = {
    validate: (o) => {
      try {
        const s = In(e, o);
        return s.success ? { value: s.data } : { issues: s.error?.issues };
      } catch {
        return Tn(e, o).then((i) => i.success ? { value: i.data } : { issues: i.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  };
}), he = /* @__PURE__ */ c("$ZodString", (e, t) => {
  x.init(e, t), e._zod.pattern = [...e?._zod.bag?.patterns ?? []].pop() ?? tr(e._zod.bag), e._zod.parse = (n, r) => {
    if (t.coerce)
      try {
        n.value = String(n.value);
      } catch {
      }
    return typeof n.value == "string" || n.issues.push({
      expected: "string",
      code: "invalid_type",
      input: n.value,
      inst: e
    }), n;
  };
}), y = /* @__PURE__ */ c("$ZodStringFormat", (e, t) => {
  ne.init(e, t), he.init(e, t);
}), gr = /* @__PURE__ */ c("$ZodGUID", (e, t) => {
  t.pattern ?? (t.pattern = qn), y.init(e, t);
}), vr = /* @__PURE__ */ c("$ZodUUID", (e, t) => {
  if (t.version) {
    const r = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    }[t.version];
    if (r === void 0)
      throw new Error(`Invalid UUID version: "${t.version}"`);
    t.pattern ?? (t.pattern = ke(r));
  } else
    t.pattern ?? (t.pattern = ke());
  y.init(e, t);
}), _r = /* @__PURE__ */ c("$ZodEmail", (e, t) => {
  t.pattern ?? (t.pattern = Mn), y.init(e, t);
}), yr = /* @__PURE__ */ c("$ZodURL", (e, t) => {
  y.init(e, t), e._zod.check = (n) => {
    try {
      const r = n.value.trim(), o = new URL(r);
      t.hostname && (t.hostname.lastIndex = 0, t.hostname.test(o.hostname) || n.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid hostname",
        pattern: Jn.source,
        input: n.value,
        inst: e,
        continue: !t.abort
      })), t.protocol && (t.protocol.lastIndex = 0, t.protocol.test(o.protocol.endsWith(":") ? o.protocol.slice(0, -1) : o.protocol) || n.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid protocol",
        pattern: t.protocol.source,
        input: n.value,
        inst: e,
        continue: !t.abort
      })), t.normalize ? n.value = o.href : n.value = r;
      return;
    } catch {
      n.issues.push({
        code: "invalid_format",
        format: "url",
        input: n.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
}), wr = /* @__PURE__ */ c("$ZodEmoji", (e, t) => {
  t.pattern ?? (t.pattern = Ln()), y.init(e, t);
}), br = /* @__PURE__ */ c("$ZodNanoID", (e, t) => {
  t.pattern ?? (t.pattern = Un), y.init(e, t);
}), zr = /* @__PURE__ */ c("$ZodCUID", (e, t) => {
  t.pattern ?? (t.pattern = Dn), y.init(e, t);
}), xr = /* @__PURE__ */ c("$ZodCUID2", (e, t) => {
  t.pattern ?? (t.pattern = An), y.init(e, t);
}), kr = /* @__PURE__ */ c("$ZodULID", (e, t) => {
  t.pattern ?? (t.pattern = Nn), y.init(e, t);
}), Zr = /* @__PURE__ */ c("$ZodXID", (e, t) => {
  t.pattern ?? (t.pattern = Cn), y.init(e, t);
}), $r = /* @__PURE__ */ c("$ZodKSUID", (e, t) => {
  t.pattern ?? (t.pattern = Rn), y.init(e, t);
}), jr = /* @__PURE__ */ c("$ZodISODateTime", (e, t) => {
  t.pattern ?? (t.pattern = er(t)), y.init(e, t);
}), Pr = /* @__PURE__ */ c("$ZodISODate", (e, t) => {
  t.pattern ?? (t.pattern = Yn), y.init(e, t);
}), Or = /* @__PURE__ */ c("$ZodISOTime", (e, t) => {
  t.pattern ?? (t.pattern = Xn(t)), y.init(e, t);
}), Sr = /* @__PURE__ */ c("$ZodISODuration", (e, t) => {
  t.pattern ?? (t.pattern = Fn), y.init(e, t);
}), Er = /* @__PURE__ */ c("$ZodIPv4", (e, t) => {
  t.pattern ?? (t.pattern = Bn), y.init(e, t), e._zod.onattach.push((n) => {
    const r = n._zod.bag;
    r.format = "ipv4";
  });
}), Ir = /* @__PURE__ */ c("$ZodIPv6", (e, t) => {
  t.pattern ?? (t.pattern = Kn), y.init(e, t), e._zod.onattach.push((n) => {
    const r = n._zod.bag;
    r.format = "ipv6";
  }), e._zod.check = (n) => {
    try {
      new URL(`http://[${n.value}]`);
    } catch {
      n.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: n.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
}), Tr = /* @__PURE__ */ c("$ZodCIDRv4", (e, t) => {
  t.pattern ?? (t.pattern = Wn), y.init(e, t);
}), Dr = /* @__PURE__ */ c("$ZodCIDRv6", (e, t) => {
  t.pattern ?? (t.pattern = Hn), y.init(e, t), e._zod.check = (n) => {
    const [r, o] = n.value.split("/");
    try {
      if (!o)
        throw new Error();
      const s = Number(o);
      if (`${s}` !== o)
        throw new Error();
      if (s < 0 || s > 128)
        throw new Error();
      new URL(`http://[${r}]`);
    } catch {
      n.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: n.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
});
function at(e) {
  if (e === "")
    return !0;
  if (e.length % 4 !== 0)
    return !1;
  try {
    return atob(e), !0;
  } catch {
    return !1;
  }
}
const Ar = /* @__PURE__ */ c("$ZodBase64", (e, t) => {
  t.pattern ?? (t.pattern = Vn), y.init(e, t), e._zod.onattach.push((n) => {
    n._zod.bag.contentEncoding = "base64";
  }), e._zod.check = (n) => {
    at(n.value) || n.issues.push({
      code: "invalid_format",
      format: "base64",
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
});
function Nr(e) {
  if (!ot.test(e))
    return !1;
  const t = e.replace(/[-_]/g, (r) => r === "-" ? "+" : "/"), n = t.padEnd(Math.ceil(t.length / 4) * 4, "=");
  return at(n);
}
const Cr = /* @__PURE__ */ c("$ZodBase64URL", (e, t) => {
  t.pattern ?? (t.pattern = ot), y.init(e, t), e._zod.onattach.push((n) => {
    n._zod.bag.contentEncoding = "base64url";
  }), e._zod.check = (n) => {
    Nr(n.value) || n.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Rr = /* @__PURE__ */ c("$ZodE164", (e, t) => {
  t.pattern ?? (t.pattern = Gn), y.init(e, t);
});
function Ur(e, t = null) {
  try {
    const n = e.split(".");
    if (n.length !== 3)
      return !1;
    const [r] = n;
    if (!r)
      return !1;
    const o = JSON.parse(atob(r));
    return !("typ" in o && o?.typ !== "JWT" || !o.alg || t && (!("alg" in o) || o.alg !== t));
  } catch {
    return !1;
  }
}
const Fr = /* @__PURE__ */ c("$ZodJWT", (e, t) => {
  y.init(e, t), e._zod.check = (n) => {
    Ur(n.value, t.alg) || n.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), qr = /* @__PURE__ */ c("$ZodUnknown", (e, t) => {
  x.init(e, t), e._zod.parse = (n) => n;
}), Mr = /* @__PURE__ */ c("$ZodNever", (e, t) => {
  x.init(e, t), e._zod.parse = (n, r) => (n.issues.push({
    expected: "never",
    code: "invalid_type",
    input: n.value,
    inst: e
  }), n);
});
function Ze(e, t, n) {
  e.issues.length && t.issues.push(...Ye(n, e.issues)), t.value[n] = e.value;
}
const Qr = /* @__PURE__ */ c("$ZodArray", (e, t) => {
  x.init(e, t), e._zod.parse = (n, r) => {
    const o = n.value;
    if (!Array.isArray(o))
      return n.issues.push({
        expected: "array",
        code: "invalid_type",
        input: o,
        inst: e
      }), n;
    n.value = Array(o.length);
    const s = [];
    for (let i = 0; i < o.length; i++) {
      const u = o[i], f = t.element._zod.run({
        value: u,
        issues: []
      }, r);
      f instanceof Promise ? s.push(f.then((d) => Ze(d, n, i))) : Ze(f, n, i);
    }
    return s.length ? Promise.all(s).then(() => n) : n;
  };
});
function V(e, t, n, r) {
  e.issues.length && t.issues.push(...Ye(n, e.issues)), e.value === void 0 ? n in r && (t.value[n] = void 0) : t.value[n] = e.value;
}
const Lr = /* @__PURE__ */ c("$ZodObject", (e, t) => {
  x.init(e, t);
  const n = Je(() => {
    const h = Object.keys(t.shape);
    for (const m of h)
      if (!(t.shape[m] instanceof x))
        throw new Error(`Invalid element at key "${m}": expected a Zod schema`);
    const p = bn(t.shape);
    return {
      shape: t.shape,
      keys: h,
      keySet: new Set(h),
      numKeys: h.length,
      optionalKeys: new Set(p)
    };
  });
  _(e._zod, "propValues", () => {
    const h = t.shape, p = {};
    for (const m in h) {
      const v = h[m]._zod;
      if (v.values) {
        p[m] ?? (p[m] = /* @__PURE__ */ new Set());
        for (const z of v.values)
          p[m].add(z);
      }
    }
    return p;
  });
  const r = (h) => {
    const p = new pr(["shape", "payload", "ctx"]), m = n.value, v = (j) => {
      const b = xe(j);
      return `shape[${b}]._zod.run({ value: input[${b}], issues: [] }, ctx)`;
    };
    p.write("const input = payload.value;");
    const z = /* @__PURE__ */ Object.create(null);
    let P = 0;
    for (const j of m.keys)
      z[j] = `key_${P++}`;
    p.write("const newResult = {}");
    for (const j of m.keys) {
      const b = z[j], k = xe(j);
      p.write(`const ${b} = ${v(j)};`), p.write(`
        if (${b}.issues.length) {
          payload.issues = payload.issues.concat(${b}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        if (${b}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${b}.value;
        }
      `);
    }
    p.write("payload.value = newResult;"), p.write("return payload;");
    const $ = p.compile();
    return (j, b) => $(h, j, b);
  };
  let o;
  const s = se, i = !Ve.jitless, f = i && yn.value, d = t.catchall;
  let g;
  e._zod.parse = (h, p) => {
    g ?? (g = n.value);
    const m = h.value;
    if (!s(m))
      return h.issues.push({
        expected: "object",
        code: "invalid_type",
        input: m,
        inst: e
      }), h;
    const v = [];
    if (i && f && p?.async === !1 && p.jitless !== !0)
      o || (o = r(t.shape)), h = o(h, p);
    else {
      h.value = {};
      const b = g.shape;
      for (const k of g.keys) {
        const D = b[k]._zod.run({ value: m[k], issues: [] }, p);
        D instanceof Promise ? v.push(D.then((vt) => V(vt, h, k, m))) : V(D, h, k, m);
      }
    }
    if (!d)
      return v.length ? Promise.all(v).then(() => h) : h;
    const z = [], P = g.keySet, $ = d._zod, j = $.def.type;
    for (const b of Object.keys(m)) {
      if (P.has(b))
        continue;
      if (j === "never") {
        z.push(b);
        continue;
      }
      const k = $.run({ value: m[b], issues: [] }, p);
      k instanceof Promise ? v.push(k.then((q) => V(q, h, b, m))) : V(k, h, b, m);
    }
    return z.length && h.issues.push({
      code: "unrecognized_keys",
      keys: z,
      input: m,
      inst: e
    }), v.length ? Promise.all(v).then(() => h) : h;
  };
});
function $e(e, t, n, r) {
  for (const s of e)
    if (s.issues.length === 0)
      return t.value = s.value, t;
  const o = e.filter((s) => !Q(s));
  return o.length === 1 ? (t.value = o[0].value, o[0]) : (t.issues.push({
    code: "invalid_union",
    input: t.value,
    inst: n,
    errors: e.map((s) => s.issues.map((i) => R(i, r, C())))
  }), t);
}
const Br = /* @__PURE__ */ c("$ZodUnion", (e, t) => {
  x.init(e, t), _(e._zod, "optin", () => t.options.some((n) => n._zod.optin === "optional") ? "optional" : void 0), _(e._zod, "optout", () => t.options.some((n) => n._zod.optout === "optional") ? "optional" : void 0), _(e._zod, "values", () => {
    if (t.options.every((n) => n._zod.values))
      return new Set(t.options.flatMap((n) => Array.from(n._zod.values)));
  }), _(e._zod, "pattern", () => {
    if (t.options.every((n) => n._zod.pattern)) {
      const n = t.options.map((r) => r._zod.pattern);
      return new RegExp(`^(${n.map((r) => le(r.source)).join("|")})$`);
    }
  }), e._zod.parse = (n, r) => {
    let o = !1;
    const s = [];
    for (const i of t.options) {
      const u = i._zod.run({
        value: n.value,
        issues: []
      }, r);
      if (u instanceof Promise)
        s.push(u), o = !0;
      else {
        if (u.issues.length === 0)
          return u;
        s.push(u);
      }
    }
    return o ? Promise.all(s).then((i) => $e(i, n, e, r)) : $e(s, n, e, r);
  };
}), Kr = /* @__PURE__ */ c("$ZodIntersection", (e, t) => {
  x.init(e, t), e._zod.parse = (n, r) => {
    const o = n.value, s = t.left._zod.run({ value: o, issues: [] }, r), i = t.right._zod.run({ value: o, issues: [] }, r);
    return s instanceof Promise || i instanceof Promise ? Promise.all([s, i]).then(([f, d]) => je(n, f, d)) : je(n, s, i);
  };
});
function ae(e, t) {
  if (e === t)
    return { valid: !0, data: e };
  if (e instanceof Date && t instanceof Date && +e == +t)
    return { valid: !0, data: e };
  if (ie(e) && ie(t)) {
    const n = Object.keys(t), r = Object.keys(e).filter((s) => n.indexOf(s) !== -1), o = { ...e, ...t };
    for (const s of r) {
      const i = ae(e[s], t[s]);
      if (!i.valid)
        return {
          valid: !1,
          mergeErrorPath: [s, ...i.mergeErrorPath]
        };
      o[s] = i.data;
    }
    return { valid: !0, data: o };
  }
  if (Array.isArray(e) && Array.isArray(t)) {
    if (e.length !== t.length)
      return { valid: !1, mergeErrorPath: [] };
    const n = [];
    for (let r = 0; r < e.length; r++) {
      const o = e[r], s = t[r], i = ae(o, s);
      if (!i.valid)
        return {
          valid: !1,
          mergeErrorPath: [r, ...i.mergeErrorPath]
        };
      n.push(i.data);
    }
    return { valid: !0, data: n };
  }
  return { valid: !1, mergeErrorPath: [] };
}
function je(e, t, n) {
  if (t.issues.length && e.issues.push(...t.issues), n.issues.length && e.issues.push(...n.issues), Q(e))
    return e;
  const r = ae(t.value, n.value);
  if (!r.valid)
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(r.mergeErrorPath)}`);
  return e.value = r.data, e;
}
const Wr = /* @__PURE__ */ c("$ZodEnum", (e, t) => {
  x.init(e, t);
  const n = _n(t.entries), r = new Set(n);
  e._zod.values = r, e._zod.pattern = new RegExp(`^(${n.filter((o) => wn.has(typeof o)).map((o) => typeof o == "string" ? te(o) : o.toString()).join("|")})$`), e._zod.parse = (o, s) => {
    const i = o.value;
    return r.has(i) || o.issues.push({
      code: "invalid_value",
      values: n,
      input: i,
      inst: e
    }), o;
  };
}), Hr = /* @__PURE__ */ c("$ZodTransform", (e, t) => {
  x.init(e, t), e._zod.parse = (n, r) => {
    const o = t.transform(n.value, n);
    if (r.async)
      return (o instanceof Promise ? o : Promise.resolve(o)).then((i) => (n.value = i, n));
    if (o instanceof Promise)
      throw new L();
    return n.value = o, n;
  };
}), Vr = /* @__PURE__ */ c("$ZodOptional", (e, t) => {
  x.init(e, t), e._zod.optin = "optional", e._zod.optout = "optional", _(e._zod, "values", () => t.innerType._zod.values ? /* @__PURE__ */ new Set([...t.innerType._zod.values, void 0]) : void 0), _(e._zod, "pattern", () => {
    const n = t.innerType._zod.pattern;
    return n ? new RegExp(`^(${le(n.source)})?$`) : void 0;
  }), e._zod.parse = (n, r) => t.innerType._zod.optin === "optional" ? t.innerType._zod.run(n, r) : n.value === void 0 ? n : t.innerType._zod.run(n, r);
}), Jr = /* @__PURE__ */ c("$ZodNullable", (e, t) => {
  x.init(e, t), _(e._zod, "optin", () => t.innerType._zod.optin), _(e._zod, "optout", () => t.innerType._zod.optout), _(e._zod, "pattern", () => {
    const n = t.innerType._zod.pattern;
    return n ? new RegExp(`^(${le(n.source)}|null)$`) : void 0;
  }), _(e._zod, "values", () => t.innerType._zod.values ? /* @__PURE__ */ new Set([...t.innerType._zod.values, null]) : void 0), e._zod.parse = (n, r) => n.value === null ? n : t.innerType._zod.run(n, r);
}), Gr = /* @__PURE__ */ c("$ZodDefault", (e, t) => {
  x.init(e, t), e._zod.optin = "optional", _(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, r) => {
    if (n.value === void 0)
      return n.value = t.defaultValue, n;
    const o = t.innerType._zod.run(n, r);
    return o instanceof Promise ? o.then((s) => Pe(s, t)) : Pe(o, t);
  };
});
function Pe(e, t) {
  return e.value === void 0 && (e.value = t.defaultValue), e;
}
const Yr = /* @__PURE__ */ c("$ZodPrefault", (e, t) => {
  x.init(e, t), e._zod.optin = "optional", _(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, r) => (n.value === void 0 && (n.value = t.defaultValue), t.innerType._zod.run(n, r));
}), Xr = /* @__PURE__ */ c("$ZodNonOptional", (e, t) => {
  x.init(e, t), _(e._zod, "values", () => {
    const n = t.innerType._zod.values;
    return n ? new Set([...n].filter((r) => r !== void 0)) : void 0;
  }), e._zod.parse = (n, r) => {
    const o = t.innerType._zod.run(n, r);
    return o instanceof Promise ? o.then((s) => Oe(s, e)) : Oe(o, e);
  };
});
function Oe(e, t) {
  return !e.issues.length && e.value === void 0 && e.issues.push({
    code: "invalid_type",
    expected: "nonoptional",
    input: e.value,
    inst: t
  }), e;
}
const eo = /* @__PURE__ */ c("$ZodCatch", (e, t) => {
  x.init(e, t), _(e._zod, "optin", () => t.innerType._zod.optin), _(e._zod, "optout", () => t.innerType._zod.optout), _(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (n, r) => {
    const o = t.innerType._zod.run(n, r);
    return o instanceof Promise ? o.then((s) => (n.value = s.value, s.issues.length && (n.value = t.catchValue({
      ...n,
      error: {
        issues: s.issues.map((i) => R(i, r, C()))
      },
      input: n.value
    }), n.issues = []), n)) : (n.value = o.value, o.issues.length && (n.value = t.catchValue({
      ...n,
      error: {
        issues: o.issues.map((s) => R(s, r, C()))
      },
      input: n.value
    }), n.issues = []), n);
  };
}), to = /* @__PURE__ */ c("$ZodPipe", (e, t) => {
  x.init(e, t), _(e._zod, "values", () => t.in._zod.values), _(e._zod, "optin", () => t.in._zod.optin), _(e._zod, "optout", () => t.out._zod.optout), _(e._zod, "propValues", () => t.in._zod.propValues), e._zod.parse = (n, r) => {
    const o = t.in._zod.run(n, r);
    return o instanceof Promise ? o.then((s) => Se(s, t, r)) : Se(o, t, r);
  };
});
function Se(e, t, n) {
  return e.issues.length ? e : t.out._zod.run({ value: e.value, issues: e.issues }, n);
}
const no = /* @__PURE__ */ c("$ZodReadonly", (e, t) => {
  x.init(e, t), _(e._zod, "propValues", () => t.innerType._zod.propValues), _(e._zod, "values", () => t.innerType._zod.values), _(e._zod, "optin", () => t.innerType._zod.optin), _(e._zod, "optout", () => t.innerType._zod.optout), e._zod.parse = (n, r) => {
    const o = t.innerType._zod.run(n, r);
    return o instanceof Promise ? o.then(Ee) : Ee(o);
  };
});
function Ee(e) {
  return e.value = Object.freeze(e.value), e;
}
const ro = /* @__PURE__ */ c("$ZodCustom", (e, t) => {
  I.init(e, t), x.init(e, t), e._zod.parse = (n, r) => n, e._zod.check = (n) => {
    const r = n.value, o = t.fn(r);
    if (o instanceof Promise)
      return o.then((s) => Ie(s, n, r, e));
    Ie(o, n, r, e);
  };
});
function Ie(e, t, n, r) {
  if (!e) {
    const o = {
      code: "custom",
      input: n,
      inst: r,
      // incorporates params.error into issue reporting
      path: [...r._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !r._zod.def.abort
      // params: inst._zod.def.params,
    };
    r._zod.def.params && (o.params = r._zod.def.params), t.issues.push(B(o));
  }
}
class oo {
  constructor() {
    this._map = /* @__PURE__ */ new Map(), this._idmap = /* @__PURE__ */ new Map();
  }
  add(t, ...n) {
    const r = n[0];
    if (this._map.set(t, r), r && typeof r == "object" && "id" in r) {
      if (this._idmap.has(r.id))
        throw new Error(`ID ${r.id} already exists in the registry`);
      this._idmap.set(r.id, t);
    }
    return this;
  }
  clear() {
    return this._map = /* @__PURE__ */ new Map(), this._idmap = /* @__PURE__ */ new Map(), this;
  }
  remove(t) {
    const n = this._map.get(t);
    return n && typeof n == "object" && "id" in n && this._idmap.delete(n.id), this._map.delete(t), this;
  }
  get(t) {
    const n = t._zod.parent;
    if (n) {
      const r = { ...this.get(n) ?? {} };
      delete r.id;
      const o = { ...r, ...this._map.get(t) };
      return Object.keys(o).length ? o : void 0;
    }
    return this._map.get(t);
  }
  has(t) {
    return this._map.has(t);
  }
}
function so() {
  return new oo();
}
const J = /* @__PURE__ */ so();
function io(e, t) {
  return new e({
    type: "string",
    ...l(t)
  });
}
function ao(e, t) {
  return new e({
    type: "string",
    format: "email",
    check: "string_format",
    abort: !1,
    ...l(t)
  });
}
function Te(e, t) {
  return new e({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: !1,
    ...l(t)
  });
}
function co(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    ...l(t)
  });
}
function uo(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v4",
    ...l(t)
  });
}
function lo(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v6",
    ...l(t)
  });
}
function ho(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v7",
    ...l(t)
  });
}
function fo(e, t) {
  return new e({
    type: "string",
    format: "url",
    check: "string_format",
    abort: !1,
    ...l(t)
  });
}
function po(e, t) {
  return new e({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: !1,
    ...l(t)
  });
}
function mo(e, t) {
  return new e({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: !1,
    ...l(t)
  });
}
function go(e, t) {
  return new e({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: !1,
    ...l(t)
  });
}
function vo(e, t) {
  return new e({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: !1,
    ...l(t)
  });
}
function _o(e, t) {
  return new e({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: !1,
    ...l(t)
  });
}
function yo(e, t) {
  return new e({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: !1,
    ...l(t)
  });
}
function wo(e, t) {
  return new e({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: !1,
    ...l(t)
  });
}
function bo(e, t) {
  return new e({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: !1,
    ...l(t)
  });
}
function zo(e, t) {
  return new e({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: !1,
    ...l(t)
  });
}
function xo(e, t) {
  return new e({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: !1,
    ...l(t)
  });
}
function ko(e, t) {
  return new e({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: !1,
    ...l(t)
  });
}
function Zo(e, t) {
  return new e({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: !1,
    ...l(t)
  });
}
function $o(e, t) {
  return new e({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: !1,
    ...l(t)
  });
}
function jo(e, t) {
  return new e({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: !1,
    ...l(t)
  });
}
function Po(e, t) {
  return new e({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: !1,
    ...l(t)
  });
}
function Oo(e, t) {
  return new e({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: !1,
    local: !1,
    precision: null,
    ...l(t)
  });
}
function So(e, t) {
  return new e({
    type: "string",
    format: "date",
    check: "string_format",
    ...l(t)
  });
}
function Eo(e, t) {
  return new e({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...l(t)
  });
}
function Io(e, t) {
  return new e({
    type: "string",
    format: "duration",
    check: "string_format",
    ...l(t)
  });
}
function To(e) {
  return new e({
    type: "unknown"
  });
}
function Do(e, t) {
  return new e({
    type: "never",
    ...l(t)
  });
}
function ct(e, t) {
  return new or({
    check: "max_length",
    ...l(t),
    maximum: e
  });
}
function Y(e, t) {
  return new sr({
    check: "min_length",
    ...l(t),
    minimum: e
  });
}
function ut(e, t) {
  return new ir({
    check: "length_equals",
    ...l(t),
    length: e
  });
}
function Ao(e, t) {
  return new ar({
    check: "string_format",
    format: "regex",
    ...l(t),
    pattern: e
  });
}
function No(e) {
  return new cr({
    check: "string_format",
    format: "lowercase",
    ...l(e)
  });
}
function Co(e) {
  return new ur({
    check: "string_format",
    format: "uppercase",
    ...l(e)
  });
}
function Ro(e, t) {
  return new lr({
    check: "string_format",
    format: "includes",
    ...l(t),
    includes: e
  });
}
function Uo(e, t) {
  return new dr({
    check: "string_format",
    format: "starts_with",
    ...l(t),
    prefix: e
  });
}
function Fo(e, t) {
  return new hr({
    check: "string_format",
    format: "ends_with",
    ...l(t),
    suffix: e
  });
}
function K(e) {
  return new fr({
    check: "overwrite",
    tx: e
  });
}
function qo(e) {
  return K((t) => t.normalize(e));
}
function Mo() {
  return K((e) => e.trim());
}
function Qo() {
  return K((e) => e.toLowerCase());
}
function Lo() {
  return K((e) => e.toUpperCase());
}
function Bo(e, t, n) {
  return new e({
    type: "array",
    element: t,
    // get element() {
    //   return element;
    // },
    ...l(n)
  });
}
function Ko(e, t, n) {
  return new e({
    type: "custom",
    check: "custom",
    fn: t,
    ...l(n)
  });
}
const Wo = /* @__PURE__ */ c("ZodISODateTime", (e, t) => {
  jr.init(e, t), w.init(e, t);
});
function Ho(e) {
  return Oo(Wo, e);
}
const Vo = /* @__PURE__ */ c("ZodISODate", (e, t) => {
  Pr.init(e, t), w.init(e, t);
});
function Jo(e) {
  return So(Vo, e);
}
const Go = /* @__PURE__ */ c("ZodISOTime", (e, t) => {
  Or.init(e, t), w.init(e, t);
});
function Yo(e) {
  return Eo(Go, e);
}
const Xo = /* @__PURE__ */ c("ZodISODuration", (e, t) => {
  Sr.init(e, t), w.init(e, t);
});
function es(e) {
  return Io(Xo, e);
}
const ts = (e, t) => {
  et.init(e, t), e.name = "ZodError", Object.defineProperties(e, {
    format: {
      value: (n) => On(e, n)
      // enumerable: false,
    },
    flatten: {
      value: (n) => Pn(e, n)
      // enumerable: false,
    },
    addIssue: {
      value: (n) => {
        e.issues.push(n), e.message = JSON.stringify(e.issues, oe, 2);
      }
      // enumerable: false,
    },
    addIssues: {
      value: (n) => {
        e.issues.push(...n), e.message = JSON.stringify(e.issues, oe, 2);
      }
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return e.issues.length === 0;
      }
      // enumerable: false,
    }
  });
}, re = c("ZodError", ts, {
  Parent: Error
}), ns = /* @__PURE__ */ Sn(re), rs = /* @__PURE__ */ En(re), os = /* @__PURE__ */ nt(re), ss = /* @__PURE__ */ rt(re), Z = /* @__PURE__ */ c("ZodType", (e, t) => (x.init(e, t), e.def = t, Object.defineProperty(e, "_def", { value: t }), e.check = (...n) => e.clone(
  {
    ...t,
    checks: [
      ...t.checks ?? [],
      ...n.map((r) => typeof r == "function" ? { _zod: { check: r, def: { check: "custom" }, onattach: [] } } : r)
    ]
  }
  // { parent: true }
), e.clone = (n, r) => F(e, n, r), e.brand = () => e, e.register = (n, r) => (n.add(e, r), e), e.parse = (n, r) => ns(e, n, r, { callee: e.parse }), e.safeParse = (n, r) => os(e, n, r), e.parseAsync = async (n, r) => rs(e, n, r, { callee: e.parseAsync }), e.safeParseAsync = async (n, r) => ss(e, n, r), e.spa = e.safeParseAsync, e.refine = (n, r) => e.check(Js(n, r)), e.superRefine = (n) => e.check(Gs(n)), e.overwrite = (n) => e.check(K(n)), e.optional = () => Ce(e), e.nullable = () => Re(e), e.nullish = () => Ce(Re(e)), e.nonoptional = (n) => Ms(e, n), e.array = () => Ps(e), e.or = (n) => Is([e, n]), e.and = (n) => Ds(e, n), e.transform = (n) => Ue(e, Ns(n)), e.default = (n) => Us(e, n), e.prefault = (n) => qs(e, n), e.catch = (n) => Ls(e, n), e.pipe = (n) => Ue(e, n), e.readonly = () => Ws(e), e.describe = (n) => {
  const r = e.clone();
  return J.add(r, { description: n }), r;
}, Object.defineProperty(e, "description", {
  get() {
    return J.get(e)?.description;
  },
  configurable: !0
}), e.meta = (...n) => {
  if (n.length === 0)
    return J.get(e);
  const r = e.clone();
  return J.add(r, n[0]), r;
}, e.isOptional = () => e.safeParse(void 0).success, e.isNullable = () => e.safeParse(null).success, e)), lt = /* @__PURE__ */ c("_ZodString", (e, t) => {
  he.init(e, t), Z.init(e, t);
  const n = e._zod.bag;
  e.format = n.format ?? null, e.minLength = n.minimum ?? null, e.maxLength = n.maximum ?? null, e.regex = (...r) => e.check(Ao(...r)), e.includes = (...r) => e.check(Ro(...r)), e.startsWith = (...r) => e.check(Uo(...r)), e.endsWith = (...r) => e.check(Fo(...r)), e.min = (...r) => e.check(Y(...r)), e.max = (...r) => e.check(ct(...r)), e.length = (...r) => e.check(ut(...r)), e.nonempty = (...r) => e.check(Y(1, ...r)), e.lowercase = (r) => e.check(No(r)), e.uppercase = (r) => e.check(Co(r)), e.trim = () => e.check(Mo()), e.normalize = (...r) => e.check(qo(...r)), e.toLowerCase = () => e.check(Qo()), e.toUpperCase = () => e.check(Lo());
}), is = /* @__PURE__ */ c("ZodString", (e, t) => {
  he.init(e, t), lt.init(e, t), e.email = (n) => e.check(ao(as, n)), e.url = (n) => e.check(fo(cs, n)), e.jwt = (n) => e.check(Po(xs, n)), e.emoji = (n) => e.check(po(us, n)), e.guid = (n) => e.check(Te(Ae, n)), e.uuid = (n) => e.check(co(G, n)), e.uuidv4 = (n) => e.check(uo(G, n)), e.uuidv6 = (n) => e.check(lo(G, n)), e.uuidv7 = (n) => e.check(ho(G, n)), e.nanoid = (n) => e.check(mo(ls, n)), e.guid = (n) => e.check(Te(Ae, n)), e.cuid = (n) => e.check(go(ds, n)), e.cuid2 = (n) => e.check(vo(hs, n)), e.ulid = (n) => e.check(_o(fs, n)), e.base64 = (n) => e.check(Zo(ws, n)), e.base64url = (n) => e.check($o(bs, n)), e.xid = (n) => e.check(yo(ps, n)), e.ksuid = (n) => e.check(wo(ms, n)), e.ipv4 = (n) => e.check(bo(gs, n)), e.ipv6 = (n) => e.check(zo(vs, n)), e.cidrv4 = (n) => e.check(xo(_s, n)), e.cidrv6 = (n) => e.check(ko(ys, n)), e.e164 = (n) => e.check(jo(zs, n)), e.datetime = (n) => e.check(Ho(n)), e.date = (n) => e.check(Jo(n)), e.time = (n) => e.check(Yo(n)), e.duration = (n) => e.check(es(n));
});
function De(e) {
  return io(is, e);
}
const w = /* @__PURE__ */ c("ZodStringFormat", (e, t) => {
  y.init(e, t), lt.init(e, t);
}), as = /* @__PURE__ */ c("ZodEmail", (e, t) => {
  _r.init(e, t), w.init(e, t);
}), Ae = /* @__PURE__ */ c("ZodGUID", (e, t) => {
  gr.init(e, t), w.init(e, t);
}), G = /* @__PURE__ */ c("ZodUUID", (e, t) => {
  vr.init(e, t), w.init(e, t);
}), cs = /* @__PURE__ */ c("ZodURL", (e, t) => {
  yr.init(e, t), w.init(e, t);
}), us = /* @__PURE__ */ c("ZodEmoji", (e, t) => {
  wr.init(e, t), w.init(e, t);
}), ls = /* @__PURE__ */ c("ZodNanoID", (e, t) => {
  br.init(e, t), w.init(e, t);
}), ds = /* @__PURE__ */ c("ZodCUID", (e, t) => {
  zr.init(e, t), w.init(e, t);
}), hs = /* @__PURE__ */ c("ZodCUID2", (e, t) => {
  xr.init(e, t), w.init(e, t);
}), fs = /* @__PURE__ */ c("ZodULID", (e, t) => {
  kr.init(e, t), w.init(e, t);
}), ps = /* @__PURE__ */ c("ZodXID", (e, t) => {
  Zr.init(e, t), w.init(e, t);
}), ms = /* @__PURE__ */ c("ZodKSUID", (e, t) => {
  $r.init(e, t), w.init(e, t);
}), gs = /* @__PURE__ */ c("ZodIPv4", (e, t) => {
  Er.init(e, t), w.init(e, t);
}), vs = /* @__PURE__ */ c("ZodIPv6", (e, t) => {
  Ir.init(e, t), w.init(e, t);
}), _s = /* @__PURE__ */ c("ZodCIDRv4", (e, t) => {
  Tr.init(e, t), w.init(e, t);
}), ys = /* @__PURE__ */ c("ZodCIDRv6", (e, t) => {
  Dr.init(e, t), w.init(e, t);
}), ws = /* @__PURE__ */ c("ZodBase64", (e, t) => {
  Ar.init(e, t), w.init(e, t);
}), bs = /* @__PURE__ */ c("ZodBase64URL", (e, t) => {
  Cr.init(e, t), w.init(e, t);
}), zs = /* @__PURE__ */ c("ZodE164", (e, t) => {
  Rr.init(e, t), w.init(e, t);
}), xs = /* @__PURE__ */ c("ZodJWT", (e, t) => {
  Fr.init(e, t), w.init(e, t);
}), ks = /* @__PURE__ */ c("ZodUnknown", (e, t) => {
  qr.init(e, t), Z.init(e, t);
});
function Ne() {
  return To(ks);
}
const Zs = /* @__PURE__ */ c("ZodNever", (e, t) => {
  Mr.init(e, t), Z.init(e, t);
});
function $s(e) {
  return Do(Zs, e);
}
const js = /* @__PURE__ */ c("ZodArray", (e, t) => {
  Qr.init(e, t), Z.init(e, t), e.element = t.element, e.min = (n, r) => e.check(Y(n, r)), e.nonempty = (n) => e.check(Y(1, n)), e.max = (n, r) => e.check(ct(n, r)), e.length = (n, r) => e.check(ut(n, r)), e.unwrap = () => e.element;
});
function Ps(e, t) {
  return Bo(js, e, t);
}
const Os = /* @__PURE__ */ c("ZodObject", (e, t) => {
  Lr.init(e, t), Z.init(e, t), _(e, "shape", () => t.shape), e.keyof = () => dt(Object.keys(e._zod.def.shape)), e.catchall = (n) => e.clone({ ...e._zod.def, catchall: n }), e.passthrough = () => e.clone({ ...e._zod.def, catchall: Ne() }), e.loose = () => e.clone({ ...e._zod.def, catchall: Ne() }), e.strict = () => e.clone({ ...e._zod.def, catchall: $s() }), e.strip = () => e.clone({ ...e._zod.def, catchall: void 0 }), e.extend = (n) => kn(e, n), e.merge = (n) => Zn(e, n), e.pick = (n) => zn(e, n), e.omit = (n) => xn(e, n), e.partial = (...n) => $n(ht, e, n[0]), e.required = (...n) => jn(ft, e, n[0]);
});
function Ss(e, t) {
  const n = {
    type: "object",
    get shape() {
      return U(this, "shape", { ...e }), this.shape;
    },
    ...l(t)
  };
  return new Os(n);
}
const Es = /* @__PURE__ */ c("ZodUnion", (e, t) => {
  Br.init(e, t), Z.init(e, t), e.options = t.options;
});
function Is(e, t) {
  return new Es({
    type: "union",
    options: e,
    ...l(t)
  });
}
const Ts = /* @__PURE__ */ c("ZodIntersection", (e, t) => {
  Kr.init(e, t), Z.init(e, t);
});
function Ds(e, t) {
  return new Ts({
    type: "intersection",
    left: e,
    right: t
  });
}
const ce = /* @__PURE__ */ c("ZodEnum", (e, t) => {
  Wr.init(e, t), Z.init(e, t), e.enum = t.entries, e.options = Object.values(t.entries);
  const n = new Set(Object.keys(t.entries));
  e.extract = (r, o) => {
    const s = {};
    for (const i of r)
      if (n.has(i))
        s[i] = t.entries[i];
      else
        throw new Error(`Key ${i} not found in enum`);
    return new ce({
      ...t,
      checks: [],
      ...l(o),
      entries: s
    });
  }, e.exclude = (r, o) => {
    const s = { ...t.entries };
    for (const i of r)
      if (n.has(i))
        delete s[i];
      else
        throw new Error(`Key ${i} not found in enum`);
    return new ce({
      ...t,
      checks: [],
      ...l(o),
      entries: s
    });
  };
});
function dt(e, t) {
  const n = Array.isArray(e) ? Object.fromEntries(e.map((r) => [r, r])) : e;
  return new ce({
    type: "enum",
    entries: n,
    ...l(t)
  });
}
const As = /* @__PURE__ */ c("ZodTransform", (e, t) => {
  Hr.init(e, t), Z.init(e, t), e._zod.parse = (n, r) => {
    n.addIssue = (s) => {
      if (typeof s == "string")
        n.issues.push(B(s, n.value, t));
      else {
        const i = s;
        i.fatal && (i.continue = !1), i.code ?? (i.code = "custom"), i.input ?? (i.input = n.value), i.inst ?? (i.inst = e), n.issues.push(B(i));
      }
    };
    const o = t.transform(n.value, n);
    return o instanceof Promise ? o.then((s) => (n.value = s, n)) : (n.value = o, n);
  };
});
function Ns(e) {
  return new As({
    type: "transform",
    transform: e
  });
}
const ht = /* @__PURE__ */ c("ZodOptional", (e, t) => {
  Vr.init(e, t), Z.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function Ce(e) {
  return new ht({
    type: "optional",
    innerType: e
  });
}
const Cs = /* @__PURE__ */ c("ZodNullable", (e, t) => {
  Jr.init(e, t), Z.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function Re(e) {
  return new Cs({
    type: "nullable",
    innerType: e
  });
}
const Rs = /* @__PURE__ */ c("ZodDefault", (e, t) => {
  Gr.init(e, t), Z.init(e, t), e.unwrap = () => e._zod.def.innerType, e.removeDefault = e.unwrap;
});
function Us(e, t) {
  return new Rs({
    type: "default",
    innerType: e,
    get defaultValue() {
      return typeof t == "function" ? t() : t;
    }
  });
}
const Fs = /* @__PURE__ */ c("ZodPrefault", (e, t) => {
  Yr.init(e, t), Z.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function qs(e, t) {
  return new Fs({
    type: "prefault",
    innerType: e,
    get defaultValue() {
      return typeof t == "function" ? t() : t;
    }
  });
}
const ft = /* @__PURE__ */ c("ZodNonOptional", (e, t) => {
  Xr.init(e, t), Z.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function Ms(e, t) {
  return new ft({
    type: "nonoptional",
    innerType: e,
    ...l(t)
  });
}
const Qs = /* @__PURE__ */ c("ZodCatch", (e, t) => {
  eo.init(e, t), Z.init(e, t), e.unwrap = () => e._zod.def.innerType, e.removeCatch = e.unwrap;
});
function Ls(e, t) {
  return new Qs({
    type: "catch",
    innerType: e,
    catchValue: typeof t == "function" ? t : () => t
  });
}
const Bs = /* @__PURE__ */ c("ZodPipe", (e, t) => {
  to.init(e, t), Z.init(e, t), e.in = t.in, e.out = t.out;
});
function Ue(e, t) {
  return new Bs({
    type: "pipe",
    in: e,
    out: t
    // ...util.normalizeParams(params),
  });
}
const Ks = /* @__PURE__ */ c("ZodReadonly", (e, t) => {
  no.init(e, t), Z.init(e, t), e.unwrap = () => e._zod.def.innerType;
});
function Ws(e) {
  return new Ks({
    type: "readonly",
    innerType: e
  });
}
const Hs = /* @__PURE__ */ c("ZodCustom", (e, t) => {
  ro.init(e, t), Z.init(e, t);
});
function Vs(e) {
  const t = new I({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  return t._zod.check = e, t;
}
function Js(e, t = {}) {
  return Ko(Hs, e, t);
}
function Gs(e) {
  const t = Vs((n) => (n.addIssue = (r) => {
    if (typeof r == "string")
      n.issues.push(B(r, n.value, t._zod.def));
    else {
      const o = r;
      o.fatal && (o.continue = !1), o.code ?? (o.code = "custom"), o.input ?? (o.input = n.value), o.inst ?? (o.inst = t), o.continue ?? (o.continue = !t._zod.def.abort), n.issues.push(B(o));
    }
  }, e(n.value, n)));
  return t;
}
const Ys = Ss({
  buildId: De(),
  timestamp: De(),
  status: dt(["in-progress", "success", "failed"])
}), Xs = ({
  buildId: e,
  environmentType: t,
  endpoint: n = "/__zuplo/docs"
}) => {
  const r = jt({
    queryKey: ["zuplo-build-check", e, n],
    refetchInterval: 3e3,
    enabled: e !== void 0 && t === "WORKING_COPY",
    retry: !1,
    queryFn: () => fetch(n, { signal: AbortSignal.timeout(2e3) }).then((s) => {
      if (!s.ok) throw new Error("Failed to fetch build status");
      return s.json();
    }).then((s) => Ys.parse(s))
  });
  if (ee(() => {
    r.data?.status === "success" && r.data.buildId && (document.cookie = `zuplo-build=${r.data.buildId}; path=/; max-age=300; secure; SameSite=None`);
  }, [r.data]), r.isError || !r.data || r.data.buildId === e)
    return null;
  const o = r.data.status === "success";
  return /* @__PURE__ */ a.jsxs("div", { className: "fixed flex flex-col gap-3 p-4 rounded-xl w-96 border z-20 bg-background left-0 right-0 top-4 mx-auto shadow-lg", children: [
    o ? /* @__PURE__ */ a.jsxs("div", { className: "flex flex-row items-center gap-2", children: [
      /* @__PURE__ */ a.jsx(Qt, { size: 16 }),
      /* @__PURE__ */ a.jsx("span", { className: "text-sm", children: "New version available" })
    ] }) : /* @__PURE__ */ a.jsxs("div", { className: "flex flex-row items-center gap-2", children: [
      /* @__PURE__ */ a.jsx(Lt, { size: 16, className: "animate-spin" }),
      /* @__PURE__ */ a.jsx("span", { className: "text-sm", children: "Building new version..." })
    ] }),
    /* @__PURE__ */ a.jsx("span", { className: "text-xs", children: o ? "To see the new version, reload the page now." : "A new version of the developer portal will be available soon." }),
    o && /* @__PURE__ */ a.jsx(
      Wt,
      {
        variant: "outline",
        size: "sm",
        className: "w-full",
        onClick: () => {
          window.location.reload();
        },
        children: "Reload"
      }
    )
  ] });
}, ei = () => {
  const e = We(), t = Ke(e.pathname);
  ee(() => {
    const n = t.current !== e.pathname, r = e.hash !== "";
    n && !r && window.scrollTo(0, 0), t.current = e.pathname;
  }, [e.pathname, e.hash]);
}, ti = ({
  icon: e
}) => typeof e == "string" ? /* @__PURE__ */ a.jsx(
  "img",
  {
    src: `https://cdn.simpleicons.org/${e}/000000/ffffff`,
    className: "size-5",
    alt: e
  }
) : e, ni = (e) => /^https?:/.test(e), ri = () => {
  const { site: e } = Ut(), t = e?.footer;
  return t ? /* @__PURE__ */ a.jsx("footer", { className: "border-t bg-background", children: /* @__PURE__ */ a.jsxs("div", { className: "mx-auto max-w-screen-2xl px-4 lg:px-8 py-8 pt-20", children: [
    /* @__PURE__ */ a.jsxs(
      "div",
      {
        className: S("flex flex-row gap-8", {
          "justify-center": !t.position || t.position === "center",
          "justify-start": t.position === "start",
          "justify-end": t.position === "end"
        }),
        children: [
          /* @__PURE__ */ a.jsx(N.Target, { name: "footer-before" }),
          t.columns && /* @__PURE__ */ a.jsx(
            "div",
            {
              className: "w-full md:max-w-screen-md grid grid-cols-[1fr_1fr] gap-8 md:grid-cols-[repeat(var(--columns),minmax(0,1fr))]",
              style: { "--columns": t.columns.length },
              children: t.columns.map((n) => /* @__PURE__ */ a.jsxs(
                "div",
                {
                  className: S({
                    "justify-self-center": !n.position || n.position === "center",
                    "justify-self-start": n.position === "start",
                    "justify-self-end": n.position === "end"
                  }),
                  children: [
                    /* @__PURE__ */ a.jsx("span", { className: "text-sm font-semibold", children: n.title }),
                    /* @__PURE__ */ a.jsx("ul", { className: "mt-4 space-y-2", children: n.links.map((r) => {
                      const o = "flex flex-row gap-1 items-center text-sm text-muted-foreground hover:text-accent-foreground";
                      return /* @__PURE__ */ a.jsx("li", { children: ni(r.href) ? /* @__PURE__ */ a.jsxs(
                        "a",
                        {
                          href: r.href,
                          target: "_blank",
                          rel: "noopener noreferrer",
                          className: o,
                          children: [
                            /* @__PURE__ */ a.jsx("span", { children: r.label }),
                            /* @__PURE__ */ a.jsx(Bt, { size: 12 })
                          ]
                        }
                      ) : /* @__PURE__ */ a.jsx(Ht, { to: r.href, className: o, children: /* @__PURE__ */ a.jsx("span", { children: r.label }) }) }, r.href + r.label);
                    }) })
                  ]
                },
                n.title
              ))
            }
          ),
          /* @__PURE__ */ a.jsx(N.Target, { name: "footer-after" })
        ]
      }
    ),
    /* @__PURE__ */ a.jsxs(
      "div",
      {
        className: S(
          "flex items-center justify-between",
          t.columns && "border-t mt-8 pt-8"
        ),
        children: [
          t.logo && /* @__PURE__ */ a.jsxs(a.Fragment, { children: [
            /* @__PURE__ */ a.jsx(
              "img",
              {
                src: t.logo.src.light,
                alt: t.logo.alt,
                className: "w-8 dark:hidden",
                style: { width: t.logo.width }
              }
            ),
            /* @__PURE__ */ a.jsx(
              "img",
              {
                src: t.logo.src.dark,
                alt: t.logo.alt,
                className: "w-8 hidden dark:block",
                style: { width: t.logo.width }
              }
            )
          ] }),
          t.copyright && /* @__PURE__ */ a.jsx("p", { className: "text-sm text-muted-foreground", children: t.copyright }),
          /* @__PURE__ */ a.jsx("div", { className: "flex items-center gap-2", children: t.social?.map((n) => /* @__PURE__ */ a.jsxs(
            "a",
            {
              href: n.href,
              target: "_blank",
              rel: "noopener noreferrer",
              className: "w-auto gap-2 flex text-muted-foreground hover:text-accent-foreground",
              children: [
                /* @__PURE__ */ a.jsx(ti, { icon: n.icon }),
                n.label
              ]
            },
            n.href
          )) })
        ]
      }
    )
  ] }) }) : null;
}, pt = ({
  shouldScaleBackground: e = !0,
  ...t
}) => /* @__PURE__ */ a.jsx(
  E.Root,
  {
    shouldScaleBackground: e,
    ...t
  }
);
pt.displayName = "Drawer";
const oi = E.Trigger, si = E.Portal, mt = A.forwardRef(({ className: e, ...t }, n) => /* @__PURE__ */ a.jsx(
  E.Overlay,
  {
    ref: n,
    className: S("fixed inset-0 z-50 bg-black/80", e),
    ...t
  }
));
mt.displayName = E.Overlay.displayName;
const ii = A.forwardRef(
  ({ className: e, children: t, hideBar: n = !0, ...r }, o) => /* @__PURE__ */ a.jsxs(si, { children: [
    /* @__PURE__ */ a.jsx(mt, {}),
    /* @__PURE__ */ a.jsxs(
      E.Content,
      {
        ref: o,
        className: S(
          "fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background",
          e
        ),
        ...r,
        children: [
          !n && /* @__PURE__ */ a.jsx("div", { className: "mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" }),
          t
        ]
      }
    )
  ] })
);
ii.displayName = "DrawerContent";
const ai = A.forwardRef(({ className: e, ...t }, n) => /* @__PURE__ */ a.jsx(
  E.Title,
  {
    ref: n,
    className: S(
      "text-lg font-semibold leading-none tracking-tight",
      e
    ),
    ...t
  }
));
ai.displayName = E.Title.displayName;
const ci = A.forwardRef(({ className: e, ...t }, n) => /* @__PURE__ */ a.jsx(
  E.Description,
  {
    ref: n,
    className: S("text-sm text-muted-foreground", e),
    ...t
  }
));
ci.displayName = E.Description.displayName;
const gt = ({
  children: e,
  className: t
}) => {
  const { options: n } = X(), r = Ke(null);
  return ee(() => {
    const o = r.current?.querySelector('[aria-current="page"]');
    Vt(o ?? null);
  }, []), /* @__PURE__ */ a.jsxs(
    "div",
    {
      className: "grid sticky top-(--header-height) lg:h-[calc(100vh-var(--header-height))] grid-rows-[1fr_min-content] border-r",
      "data-pagefind-ignore": "all",
      children: [
        /* @__PURE__ */ a.jsx(
          "nav",
          {
            ref: r,
            className: S(
              "hidden max-w-[calc(var(--side-nav-width)+var(--padding-nav-item))] lg:flex scrollbar flex-col overflow-y-auto shrink-0 text-sm pe-3 ps-4 lg:ps-8",
              "-mx-(--padding-nav-item) pb-[8vh] pt-(--padding-content-top) scroll-pt-2 gap-1",
              // Revert the padding/margin on the first child
              "-mt-2.5",
              t
            ),
            style: {
              maskImage: "linear-gradient(180deg, transparent 1%, rgba(0, 0, 0, 1) 20px, rgba(0, 0, 0, 1) 90%, transparent 99%)"
            },
            children: e
          }
        ),
        /* @__PURE__ */ a.jsx("div", { className: "bg-background border-t p-2 mx-5  gap-2 items-center mt-2 drop-shadow-[0_-3px_1px_rgba(0,0,0,0.015)] hidden lg:[&:has(>_:nth-child(1):last-child)]:flex", children: n.site?.showPoweredBy !== !1 && /* @__PURE__ */ a.jsx(Ft, {}) })
      ]
    }
  );
};
gt.displayName = "NavigationWrapper";
const ui = ({
  onRequestClose: e,
  navigation: t
}) => /* @__PURE__ */ a.jsxs(a.Fragment, { children: [
  /* @__PURE__ */ a.jsxs(gt, { children: [
    /* @__PURE__ */ a.jsx(N.Target, { name: "navigation-before" }),
    t.map((n) => /* @__PURE__ */ a.jsx(
      ye,
      {
        item: n
      },
      n.type + (n.label ?? "") + ("path" in n ? n.path : "") + ("file" in n ? n.file : "") + ("to" in n ? n.to : "")
    )),
    /* @__PURE__ */ a.jsx(N.Target, { name: "navigation-after" })
  ] }),
  /* @__PURE__ */ a.jsx(
    en,
    {
      className: "lg:hidden h-[100dvh] start-0 w-[320px] rounded-none",
      "aria-describedby": void 0,
      children: /* @__PURE__ */ a.jsxs("div", { className: "p-4 overflow-y-auto overscroll-none", children: [
        /* @__PURE__ */ a.jsx(nn, { children: /* @__PURE__ */ a.jsx(tn, { children: "Navigation" }) }),
        t.map((n) => /* @__PURE__ */ a.jsx(
          ye,
          {
            item: n,
            onRequestClose: e
          },
          n.label
        ))
      ] })
    }
  )
] }), li = ({ children: e }) => {
  const [t, n] = Et(!1), { navigation: r } = Pt(), o = r.length > 0, s = At().state === "loading", { options: i } = X();
  return /* @__PURE__ */ a.jsxs(
    pt,
    {
      direction: i.site?.dir === "rtl" ? "right" : "left",
      open: t,
      onOpenChange: (u) => n(u),
      children: [
        o && /* @__PURE__ */ a.jsx(
          ui,
          {
            onRequestClose: () => n(!1),
            navigation: r
          }
        ),
        o && /* @__PURE__ */ a.jsx("div", { className: "lg:hidden -mx-4 px-4 py-2 sticky bg-background/80 backdrop-blur-xs z-10 top-0 start-0 end-0 border-b", children: /* @__PURE__ */ a.jsxs(oi, { className: "flex items-center gap-2 px-4", children: [
          /* @__PURE__ */ a.jsx(Kt, { size: 16, strokeWidth: 1.5 }),
          /* @__PURE__ */ a.jsx("span", { className: "text-sm", children: "Menu" })
        ] }) }),
        /* @__PURE__ */ a.jsxs(
          "main",
          {
            "data-pagefind-body": !0,
            className: S(
              "px-4 lg:pe-8 lg:px-8",
              !o && "col-span-full",
              s && "animate-pulse"
            ),
            children: [
              /* @__PURE__ */ a.jsx(N.Target, { name: "content-before" }),
              e,
              /* @__PURE__ */ a.jsx(N.Target, { name: "content-after" })
            ]
          }
        )
      ]
    }
  );
}, di = () => /* @__PURE__ */ a.jsx("main", { className: "col-span-full row-span-full grid place-items-center", children: /* @__PURE__ */ a.jsx(rn, {}) }), hi = ({ children: e }) => {
  const { authentication: t } = X();
  return Jt(), ei(), ee(() => {
    t?.onPageLoad?.();
  }, [t]), /* @__PURE__ */ a.jsxs(a.Fragment, { children: [
    /* @__PURE__ */ a.jsx(N.Target, { name: "layout-before-head" }),
    /* @__PURE__ */ a.jsx(qt, {}),
    /* @__PURE__ */ a.jsx(N.Target, { name: "layout-after-head" }),
    /* @__PURE__ */ a.jsx(
      "div",
      {
        className: S(
          "grid max-w-screen-2xl w-full lg:mx-auto",
          "[&:has(>:only-child)]:grid-rows-1 grid-rows-[0_min-content_1fr] lg:grid-rows-[min-content_1fr]",
          "grid-cols-1 lg:grid-cols-[var(--side-nav-width)_1fr]"
        ),
        children: /* @__PURE__ */ a.jsx(It, { fallback: /* @__PURE__ */ a.jsx(di, {}), children: /* @__PURE__ */ a.jsx(li, { children: e ?? /* @__PURE__ */ a.jsx(Nt, {}) }) })
      }
    ),
    /* @__PURE__ */ a.jsx(ri, {})
  ] });
}, fi = ({ children: e }) => {
  const { meta: t, options: n } = X(), r = We();
  return /* @__PURE__ */ a.jsxs(a.Fragment, { children: [
    /* @__PURE__ */ a.jsxs(qe, { titleTemplate: t?.title, defaultTitle: t?.defaultTitle, children: [
      n.canonicalUrlOrigin && /* @__PURE__ */ a.jsx(
        "link",
        {
          rel: "canonical",
          href: Ot(
            n.canonicalUrlOrigin,
            n.basePath,
            r.pathname
          )
        }
      ),
      t?.description && /* @__PURE__ */ a.jsx("meta", { name: "description", content: t.description }),
      t?.favicon && /* @__PURE__ */ a.jsx("link", { rel: "icon", href: t.favicon }),
      t?.generator && /* @__PURE__ */ a.jsx("meta", { name: "generator", content: t.generator }),
      t?.applicationName && /* @__PURE__ */ a.jsx("meta", { name: "application-name", content: t.applicationName }),
      t?.referrer && /* @__PURE__ */ a.jsx("meta", { name: "referrer", content: t.referrer }),
      t?.keywords && t.keywords.length > 0 && /* @__PURE__ */ a.jsx("meta", { name: "keywords", content: t.keywords.join(", ") }),
      t?.authors?.map((o) => /* @__PURE__ */ a.jsx("meta", { name: "author", content: o }, o)),
      t?.creator && /* @__PURE__ */ a.jsx("meta", { name: "creator", content: t.creator }),
      t?.publisher && /* @__PURE__ */ a.jsx("meta", { name: "publisher", content: t.publisher })
    ] }),
    e
  ] });
}, pi = ({
  title: e = "An error occurred",
  message: t,
  category: n
}) => /* @__PURE__ */ a.jsxs(Gt, { className: "h-full pt-(--padding-content-top)", children: [
  n && /* @__PURE__ */ a.jsx(on, { children: n }),
  e && /* @__PURE__ */ a.jsx(Yt, { level: 1, className: "flex gap-3.5 items-center", children: e }),
  /* @__PURE__ */ a.jsx("p", { children: t })
] }), mi = (e) => {
  switch (e) {
    case 400:
      return {
        title: "Bad Request",
        message: "The request could not be understood by the server due to malformed syntax."
      };
    case 403:
      return {
        title: "Forbidden",
        message: "You don't have permission to access this resource."
      };
    case 404:
      return {
        title: "Not Found",
        message: "The requested resource could not be found."
      };
    case 405:
      return {
        title: "Method Not Allowed",
        message: "The request method is not supported for the requested resource."
      };
    case 414:
      return {
        title: "Request URI Too Large",
        message: "The request URI is too large."
      };
    case 416:
      return {
        title: "Range Not Satisfiable",
        message: "The server cannot satisfy the request range."
      };
    case 500:
      return {
        title: "Internal Server Error",
        message: "An unexpected error occurred while processing your request."
      };
    case 501:
      return {
        title: "Not Implemented",
        message: "The server does not support the functionality required to fulfill the request."
      };
    case 502:
      return {
        title: "Bad Gateway",
        message: "The server received an invalid response from the upstream server."
      };
    case 503:
      return {
        title: "Service Unavailable",
        message: "The server is temporarily unable to handle the request."
      };
    case 504:
      return {
        title: "Gateway Timeout",
        message: "The server did not receive a timely response from the upstream server."
      };
    default:
      return {
        title: "An error occurred",
        message: "Something went wrong while processing your request."
      };
  }
}, gi = ({ statusCode: e, message: t }) => {
  if (e === 404)
    return /* @__PURE__ */ a.jsx(sn, {});
  const n = mi(e);
  return /* @__PURE__ */ a.jsx(
    pi,
    {
      title: n.title,
      message: t ?? n.message,
      category: e
    }
  );
};
function vi({ error: e }) {
  return /* @__PURE__ */ a.jsx(Xt, { error: e });
}
const Ai = hi, Ni = an, Ci = vi, Ri = gn, Ui = vn, Fi = Mt, qi = qe, Mi = gi, Qi = Xs, Li = fi;
export {
  Ri as Bootstrap,
  Ui as BootstrapStatic,
  Qi as BuildCheck,
  qi as Head,
  Ai as Layout,
  Li as Meta,
  Fi as RouteGuard,
  Ni as RouterError,
  Ci as ServerError,
  Mi as StatusPage
};
//# sourceMappingURL=zudoku.__internal.js.map
