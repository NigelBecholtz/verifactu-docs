import * as v from "react";
import { createContext as vt, useContext as mt } from "react";
import { j as bt } from "./jsx-runtime-DywqP_6a.js";
import { c as A, m as J } from "./chunk-PVWAREVJ-BO6B-RAk.js";
import { c as gt } from "./index-DI5SPFK9.js";
var z = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = this.subscribe.bind(this);
  }
  subscribe(t) {
    return this.listeners.add(t), this.onSubscribe(), () => {
      this.listeners.delete(t), this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}, w = typeof window > "u" || "Deno" in globalThis;
function C() {
}
function ie(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function Q(t) {
  return typeof t == "number" && t >= 0 && t !== 1 / 0;
}
function st(t, e) {
  return Math.max(t + (e || 0) - Date.now(), 0);
}
function I(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function y(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function ne(t, e) {
  const {
    type: s = "all",
    exact: r,
    fetchStatus: i,
    predicate: o,
    queryKey: a,
    stale: n
  } = t;
  if (a) {
    if (r) {
      if (e.queryHash !== Rt(a, e.options))
        return !1;
    } else if (!B(e.queryKey, a))
      return !1;
  }
  if (s !== "all") {
    const u = e.isActive();
    if (s === "active" && !u || s === "inactive" && u)
      return !1;
  }
  return !(typeof n == "boolean" && e.isStale() !== n || i && i !== e.state.fetchStatus || o && !o(e));
}
function ae(t, e) {
  const { exact: s, status: r, predicate: i, mutationKey: o } = t;
  if (o) {
    if (!e.options.mutationKey)
      return !1;
    if (s) {
      if (U(e.options.mutationKey) !== U(o))
        return !1;
    } else if (!B(e.options.mutationKey, o))
      return !1;
  }
  return !(r && e.state.status !== r || i && !i(e));
}
function Rt(t, e) {
  return (e?.queryKeyHashFn || U)(t);
}
function U(t) {
  return JSON.stringify(
    t,
    (e, s) => N(s) ? Object.keys(s).sort().reduce((r, i) => (r[i] = s[i], r), {}) : s
  );
}
function B(t, e) {
  return t === e ? !0 : typeof t != typeof e ? !1 : t && e && typeof t == "object" && typeof e == "object" ? Object.keys(e).every((s) => B(t[s], e[s])) : !1;
}
function j(t, e) {
  if (t === e)
    return t;
  const s = W(t) && W(e);
  if (s || N(t) && N(e)) {
    const r = s ? t : Object.keys(t), i = r.length, o = s ? e : Object.keys(e), a = o.length, n = s ? [] : {}, u = new Set(r);
    let h = 0;
    for (let c = 0; c < a; c++) {
      const d = s ? c : o[c];
      (!s && u.has(d) || s) && t[d] === void 0 && e[d] === void 0 ? (n[d] = void 0, h++) : (n[d] = j(t[d], e[d]), n[d] === t[d] && t[d] !== void 0 && h++);
    }
    return i === a && h === i ? t : n;
  }
  return e;
}
function M(t, e) {
  if (!e || Object.keys(t).length !== Object.keys(e).length)
    return !1;
  for (const s in t)
    if (t[s] !== e[s])
      return !1;
  return !0;
}
function W(t) {
  return Array.isArray(t) && t.length === Object.keys(t).length;
}
function N(t) {
  if (!Y(t))
    return !1;
  const e = t.constructor;
  if (e === void 0)
    return !0;
  const s = e.prototype;
  return !(!Y(s) || !s.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(t) !== Object.prototype);
}
function Y(t) {
  return Object.prototype.toString.call(t) === "[object Object]";
}
function St(t) {
  return new Promise((e) => {
    setTimeout(e, t);
  });
}
function L(t, e, s) {
  if (typeof s.structuralSharing == "function")
    return s.structuralSharing(t, e);
  if (s.structuralSharing !== !1) {
    if (process.env.NODE_ENV !== "production")
      try {
        return j(t, e);
      } catch (r) {
        throw console.error(
          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${s.queryHash}]: ${r}`
        ), r;
      }
    return j(t, e);
  }
  return e;
}
function oe(t) {
  return t;
}
function ue(t, e, s = 0) {
  const r = [...t, e];
  return s && r.length > s ? r.slice(1) : r;
}
function ce(t, e, s = 0) {
  const r = [e, ...t];
  return s && r.length > s ? r.slice(0, -1) : r;
}
var k = Symbol();
function wt(t, e) {
  return process.env.NODE_ENV !== "production" && t.queryFn === k && console.error(
    `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${t.queryHash}'`
  ), !t.queryFn && e?.initialPromise ? () => e.initialPromise : !t.queryFn || t.queryFn === k ? () => Promise.reject(new Error(`Missing queryFn: '${t.queryHash}'`)) : t.queryFn;
}
function Ct(t, e) {
  return typeof t == "function" ? t(...e) : !!t;
}
var Ot = class extends z {
  #e;
  #t;
  #s;
  constructor() {
    super(), this.#s = (t) => {
      if (!w && window.addEventListener) {
        const e = () => t();
        return window.addEventListener("visibilitychange", e, !1), () => {
          window.removeEventListener("visibilitychange", e);
        };
      }
    };
  }
  onSubscribe() {
    this.#t || this.setEventListener(this.#s);
  }
  onUnsubscribe() {
    this.hasListeners() || (this.#t?.(), this.#t = void 0);
  }
  setEventListener(t) {
    this.#s = t, this.#t?.(), this.#t = t((e) => {
      typeof e == "boolean" ? this.setFocused(e) : this.onFocus();
    });
  }
  setFocused(t) {
    this.#e !== t && (this.#e = t, this.onFocus());
  }
  onFocus() {
    const t = this.isFocused();
    this.listeners.forEach((e) => {
      e(t);
    });
  }
  isFocused() {
    return typeof this.#e == "boolean" ? this.#e : globalThis.document?.visibilityState !== "hidden";
  }
}, rt = new Ot(), Ft = class extends z {
  #e = !0;
  #t;
  #s;
  constructor() {
    super(), this.#s = (t) => {
      if (!w && window.addEventListener) {
        const e = () => t(!0), s = () => t(!1);
        return window.addEventListener("online", e, !1), window.addEventListener("offline", s, !1), () => {
          window.removeEventListener("online", e), window.removeEventListener("offline", s);
        };
      }
    };
  }
  onSubscribe() {
    this.#t || this.setEventListener(this.#s);
  }
  onUnsubscribe() {
    this.hasListeners() || (this.#t?.(), this.#t = void 0);
  }
  setEventListener(t) {
    this.#s = t, this.#t?.(), this.#t = t(this.setOnline.bind(this));
  }
  setOnline(t) {
    this.#e !== t && (this.#e = t, this.listeners.forEach((s) => {
      s(t);
    }));
  }
  isOnline() {
    return this.#e;
  }
}, it = new Ft();
function _() {
  let t, e;
  const s = new Promise((i, o) => {
    t = i, e = o;
  });
  s.status = "pending", s.catch(() => {
  });
  function r(i) {
    Object.assign(s, i), delete s.resolve, delete s.reject;
  }
  return s.resolve = (i) => {
    r({
      status: "fulfilled",
      value: i
    }), t(i);
  }, s.reject = (i) => {
    r({
      status: "rejected",
      reason: i
    }), e(i);
  }, s;
}
function he(t) {
  let e;
  if (t.then((s) => (e = s, s), C)?.catch(C), e !== void 0)
    return { data: e };
}
function Et(t) {
  return Math.min(1e3 * 2 ** t, 3e4);
}
function nt(t) {
  return (t ?? "online") === "online" ? it.isOnline() : !0;
}
var at = class extends Error {
  constructor(t) {
    super("CancelledError"), this.revert = t?.revert, this.silent = t?.silent;
  }
};
function It(t) {
  let e = !1, s = 0, r;
  const i = _(), o = () => i.status !== "pending", a = (f) => {
    o() || (l(new at(f)), t.abort?.());
  }, n = () => {
    e = !0;
  }, u = () => {
    e = !1;
  }, h = () => rt.isFocused() && (t.networkMode === "always" || it.isOnline()) && t.canRun(), c = () => nt(t.networkMode) && t.canRun(), d = (f) => {
    o() || (r?.(), i.resolve(f));
  }, l = (f) => {
    o() || (r?.(), i.reject(f));
  }, P = () => new Promise((f) => {
    r = (F) => {
      (o() || h()) && f(F);
    }, t.onPause?.();
  }).then(() => {
    r = void 0, o() || t.onContinue?.();
  }), O = () => {
    if (o())
      return;
    let f;
    const F = s === 0 ? t.initialPromise : void 0;
    try {
      f = F ?? t.fn();
    } catch (m) {
      f = Promise.reject(m);
    }
    Promise.resolve(f).then(d).catch((m) => {
      if (o())
        return;
      const g = t.retry ?? (w ? 0 : 3), S = t.retryDelay ?? Et, x = typeof S == "function" ? S(s, m) : S, T = g === !0 || typeof g == "number" && s < g || typeof g == "function" && g(s, m);
      if (e || !T) {
        l(m);
        return;
      }
      s++, t.onFail?.(s, m), St(x).then(() => h() ? void 0 : P()).then(() => {
        e ? l(m) : O();
      });
    });
  };
  return {
    promise: i,
    status: () => i.status,
    cancel: a,
    continue: () => (r?.(), i),
    cancelRetry: n,
    continueRetry: u,
    canStart: c,
    start: () => (c() ? O() : P().then(O), i)
  };
}
var Pt = (t) => setTimeout(t, 0);
function xt() {
  let t = [], e = 0, s = (n) => {
    n();
  }, r = (n) => {
    n();
  }, i = Pt;
  const o = (n) => {
    e ? t.push(n) : i(() => {
      s(n);
    });
  }, a = () => {
    const n = t;
    t = [], n.length && i(() => {
      r(() => {
        n.forEach((u) => {
          s(u);
        });
      });
    });
  };
  return {
    batch: (n) => {
      let u;
      e++;
      try {
        u = n();
      } finally {
        e--, e || a();
      }
      return u;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (n) => (...u) => {
      o(() => {
        n(...u);
      });
    },
    schedule: o,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (n) => {
      s = n;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (n) => {
      r = n;
    },
    setScheduler: (n) => {
      i = n;
    }
  };
}
var V = xt(), Tt = class {
  #e;
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(), Q(this.gcTime) && (this.#e = setTimeout(() => {
      this.optionalRemove();
    }, this.gcTime));
  }
  updateGcTime(t) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      t ?? (w ? 1 / 0 : 300 * 1e3)
    );
  }
  clearGcTimeout() {
    this.#e && (clearTimeout(this.#e), this.#e = void 0);
  }
}, le = class extends Tt {
  #e;
  #t;
  #s;
  #i;
  #r;
  #o;
  #a;
  constructor(t) {
    super(), this.#a = !1, this.#o = t.defaultOptions, this.setOptions(t.options), this.observers = [], this.#i = t.client, this.#s = this.#i.getQueryCache(), this.queryKey = t.queryKey, this.queryHash = t.queryHash, this.#e = Dt(this.options), this.state = t.state ?? this.#e, this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    return this.#r?.promise;
  }
  setOptions(t) {
    this.options = { ...this.#o, ...t }, this.updateGcTime(this.options.gcTime);
  }
  optionalRemove() {
    !this.observers.length && this.state.fetchStatus === "idle" && this.#s.remove(this);
  }
  setData(t, e) {
    const s = L(this.state.data, t, this.options);
    return this.#n({
      data: s,
      type: "success",
      dataUpdatedAt: e?.updatedAt,
      manual: e?.manual
    }), s;
  }
  setState(t, e) {
    this.#n({ type: "setState", state: t, setStateOptions: e });
  }
  cancel(t) {
    const e = this.#r?.promise;
    return this.#r?.cancel(t), e ? e.then(C).catch(C) : Promise.resolve();
  }
  destroy() {
    super.destroy(), this.cancel({ silent: !0 });
  }
  reset() {
    this.destroy(), this.setState(this.#e);
  }
  isActive() {
    return this.observers.some(
      (t) => y(t.options.enabled, this) !== !1
    );
  }
  isDisabled() {
    return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === k || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStatic() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (t) => I(t.options.staleTime, this) === "static"
    ) : !1;
  }
  isStale() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (t) => t.getCurrentResult().isStale
    ) : this.state.data === void 0 || this.state.isInvalidated;
  }
  isStaleByTime(t = 0) {
    return this.state.data === void 0 ? !0 : t === "static" ? !1 : this.state.isInvalidated ? !0 : !st(this.state.dataUpdatedAt, t);
  }
  onFocus() {
    this.observers.find((e) => e.shouldFetchOnWindowFocus())?.refetch({ cancelRefetch: !1 }), this.#r?.continue();
  }
  onOnline() {
    this.observers.find((e) => e.shouldFetchOnReconnect())?.refetch({ cancelRefetch: !1 }), this.#r?.continue();
  }
  addObserver(t) {
    this.observers.includes(t) || (this.observers.push(t), this.clearGcTimeout(), this.#s.notify({ type: "observerAdded", query: this, observer: t }));
  }
  removeObserver(t) {
    this.observers.includes(t) && (this.observers = this.observers.filter((e) => e !== t), this.observers.length || (this.#r && (this.#a ? this.#r.cancel({ revert: !0 }) : this.#r.cancelRetry()), this.scheduleGc()), this.#s.notify({ type: "observerRemoved", query: this, observer: t }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated || this.#n({ type: "invalidate" });
  }
  async fetch(t, e) {
    if (this.state.fetchStatus !== "idle" && // If the promise in the retyer is already rejected, we have to definitely
    // re-start the fetch; there is a chance that the query is still in a
    // pending state when that happens
    this.#r?.status() !== "rejected") {
      if (this.state.data !== void 0 && e?.cancelRefetch)
        this.cancel({ silent: !0 });
      else if (this.#r)
        return this.#r.continueRetry(), this.#r.promise;
    }
    if (t && this.setOptions(t), !this.options.queryFn) {
      const n = this.observers.find((u) => u.options.queryFn);
      n && this.setOptions(n.options);
    }
    process.env.NODE_ENV !== "production" && (Array.isArray(this.options.queryKey) || console.error(
      "As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']"
    ));
    const s = new AbortController(), r = (n) => {
      Object.defineProperty(n, "signal", {
        enumerable: !0,
        get: () => (this.#a = !0, s.signal)
      });
    }, i = () => {
      const n = wt(this.options, e), h = (() => {
        const c = {
          client: this.#i,
          queryKey: this.queryKey,
          meta: this.meta
        };
        return r(c), c;
      })();
      return this.#a = !1, this.options.persister ? this.options.persister(
        n,
        h,
        this
      ) : n(h);
    }, a = (() => {
      const n = {
        fetchOptions: e,
        options: this.options,
        queryKey: this.queryKey,
        client: this.#i,
        state: this.state,
        fetchFn: i
      };
      return r(n), n;
    })();
    this.options.behavior?.onFetch(a, this), this.#t = this.state, (this.state.fetchStatus === "idle" || this.state.fetchMeta !== a.fetchOptions?.meta) && this.#n({ type: "fetch", meta: a.fetchOptions?.meta }), this.#r = It({
      initialPromise: e?.initialPromise,
      fn: a.fetchFn,
      abort: s.abort.bind(s),
      onFail: (n, u) => {
        this.#n({ type: "failed", failureCount: n, error: u });
      },
      onPause: () => {
        this.#n({ type: "pause" });
      },
      onContinue: () => {
        this.#n({ type: "continue" });
      },
      retry: a.options.retry,
      retryDelay: a.options.retryDelay,
      networkMode: a.options.networkMode,
      canRun: () => !0
    });
    try {
      const n = await this.#r.start();
      if (n === void 0)
        throw process.env.NODE_ENV !== "production" && console.error(
          `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`
        ), new Error(`${this.queryHash} data is undefined`);
      return this.setData(n), this.#s.config.onSuccess?.(n, this), this.#s.config.onSettled?.(
        n,
        this.state.error,
        this
      ), n;
    } catch (n) {
      if (n instanceof at) {
        if (n.silent)
          return this.#r.promise;
        if (n.revert) {
          if (this.setState({
            ...this.#t,
            fetchStatus: "idle"
          }), this.state.data === void 0)
            throw n;
          return this.state.data;
        }
      }
      throw this.#n({
        type: "error",
        error: n
      }), this.#s.config.onError?.(
        n,
        this
      ), this.#s.config.onSettled?.(
        this.state.data,
        n,
        this
      ), n;
    } finally {
      this.scheduleGc();
    }
  }
  #n(t) {
    const e = (s) => {
      switch (t.type) {
        case "failed":
          return {
            ...s,
            fetchFailureCount: t.failureCount,
            fetchFailureReason: t.error
          };
        case "pause":
          return {
            ...s,
            fetchStatus: "paused"
          };
        case "continue":
          return {
            ...s,
            fetchStatus: "fetching"
          };
        case "fetch":
          return {
            ...s,
            ...ot(s.data, this.options),
            fetchMeta: t.meta ?? null
          };
        case "success":
          const r = {
            ...s,
            data: t.data,
            dataUpdateCount: s.dataUpdateCount + 1,
            dataUpdatedAt: t.dataUpdatedAt ?? Date.now(),
            error: null,
            isInvalidated: !1,
            status: "success",
            ...!t.manual && {
              fetchStatus: "idle",
              fetchFailureCount: 0,
              fetchFailureReason: null
            }
          };
          return this.#t = t.manual ? r : void 0, r;
        case "error":
          const i = t.error;
          return {
            ...s,
            error: i,
            errorUpdateCount: s.errorUpdateCount + 1,
            errorUpdatedAt: Date.now(),
            fetchFailureCount: s.fetchFailureCount + 1,
            fetchFailureReason: i,
            fetchStatus: "idle",
            status: "error"
          };
        case "invalidate":
          return {
            ...s,
            isInvalidated: !0
          };
        case "setState":
          return {
            ...s,
            ...t.state
          };
      }
    };
    this.state = e(this.state), V.batch(() => {
      this.observers.forEach((s) => {
        s.onQueryUpdate();
      }), this.#s.notify({ query: this, type: "updated", action: t });
    });
  }
};
function ot(t, e) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: nt(e.networkMode) ? "fetching" : "paused",
    ...t === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function Dt(t) {
  const e = typeof t.initialData == "function" ? t.initialData() : t.initialData, s = e !== void 0, r = s ? typeof t.initialDataUpdatedAt == "function" ? t.initialDataUpdatedAt() : t.initialDataUpdatedAt : 0;
  return {
    data: e,
    dataUpdateCount: 0,
    dataUpdatedAt: s ? r ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: s ? "success" : "pending",
    fetchStatus: "idle"
  };
}
var ut = class extends z {
  constructor(t, e) {
    super(), this.options = e, this.#e = t, this.#n = null, this.#a = _(), this.bindMethods(), this.setOptions(e);
  }
  #e;
  #t = void 0;
  #s = void 0;
  #i = void 0;
  #r;
  #o;
  #a;
  #n;
  #y;
  #f;
  // This property keeps track of the last query with defined data.
  // It will be used to pass the previous data and query to the placeholder function between renders.
  #d;
  #c;
  #h;
  #u;
  #p = /* @__PURE__ */ new Set();
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    this.listeners.size === 1 && (this.#t.addObserver(this), X(this.#t, this.options) ? this.#l() : this.updateResult(), this.#g());
  }
  onUnsubscribe() {
    this.hasListeners() || this.destroy();
  }
  shouldFetchOnReconnect() {
    return K(
      this.#t,
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return K(
      this.#t,
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set(), this.#R(), this.#S(), this.#t.removeObserver(this);
  }
  setOptions(t) {
    const e = this.options, s = this.#t;
    if (this.options = this.#e.defaultQueryOptions(t), this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof y(this.options.enabled, this.#t) != "boolean")
      throw new Error(
        "Expected enabled to be a boolean or a callback that returns a boolean"
      );
    this.#w(), this.#t.setOptions(this.options), e._defaulted && !M(this.options, e) && this.#e.getQueryCache().notify({
      type: "observerOptionsUpdated",
      query: this.#t,
      observer: this
    });
    const r = this.hasListeners();
    r && tt(
      this.#t,
      s,
      this.options,
      e
    ) && this.#l(), this.updateResult(), r && (this.#t !== s || y(this.options.enabled, this.#t) !== y(e.enabled, this.#t) || I(this.options.staleTime, this.#t) !== I(e.staleTime, this.#t)) && this.#v();
    const i = this.#m();
    r && (this.#t !== s || y(this.options.enabled, this.#t) !== y(e.enabled, this.#t) || i !== this.#u) && this.#b(i);
  }
  getOptimisticResult(t) {
    const e = this.#e.getQueryCache().build(this.#e, t), s = this.createResult(e, t);
    return kt(this, s) && (this.#i = s, this.#o = this.options, this.#r = this.#t.state), s;
  }
  getCurrentResult() {
    return this.#i;
  }
  trackResult(t, e) {
    return new Proxy(t, {
      get: (s, r) => (this.trackProp(r), e?.(r), r === "promise" && !this.options.experimental_prefetchInRender && this.#a.status === "pending" && this.#a.reject(
        new Error(
          "experimental_prefetchInRender feature flag is not enabled"
        )
      ), Reflect.get(s, r))
    });
  }
  trackProp(t) {
    this.#p.add(t);
  }
  getCurrentQuery() {
    return this.#t;
  }
  refetch({ ...t } = {}) {
    return this.fetch({
      ...t
    });
  }
  fetchOptimistic(t) {
    const e = this.#e.defaultQueryOptions(t), s = this.#e.getQueryCache().build(this.#e, e);
    return s.fetch().then(() => this.createResult(s, e));
  }
  fetch(t) {
    return this.#l({
      ...t,
      cancelRefetch: t.cancelRefetch ?? !0
    }).then(() => (this.updateResult(), this.#i));
  }
  #l(t) {
    this.#w();
    let e = this.#t.fetch(
      this.options,
      t
    );
    return t?.throwOnError || (e = e.catch(C)), e;
  }
  #v() {
    this.#R();
    const t = I(
      this.options.staleTime,
      this.#t
    );
    if (w || this.#i.isStale || !Q(t))
      return;
    const s = st(this.#i.dataUpdatedAt, t) + 1;
    this.#c = setTimeout(() => {
      this.#i.isStale || this.updateResult();
    }, s);
  }
  #m() {
    return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(this.#t) : this.options.refetchInterval) ?? !1;
  }
  #b(t) {
    this.#S(), this.#u = t, !(w || y(this.options.enabled, this.#t) === !1 || !Q(this.#u) || this.#u === 0) && (this.#h = setInterval(() => {
      (this.options.refetchIntervalInBackground || rt.isFocused()) && this.#l();
    }, this.#u));
  }
  #g() {
    this.#v(), this.#b(this.#m());
  }
  #R() {
    this.#c && (clearTimeout(this.#c), this.#c = void 0);
  }
  #S() {
    this.#h && (clearInterval(this.#h), this.#h = void 0);
  }
  createResult(t, e) {
    const s = this.#t, r = this.options, i = this.#i, o = this.#r, a = this.#o, u = t !== s ? t.state : this.#s, { state: h } = t;
    let c = { ...h }, d = !1, l;
    if (e._optimisticResults) {
      const p = this.hasListeners(), D = !p && X(t, e), E = p && tt(t, s, e, r);
      (D || E) && (c = {
        ...c,
        ...ot(h.data, t.options)
      }), e._optimisticResults === "isRestoring" && (c.fetchStatus = "idle");
    }
    let { error: P, errorUpdatedAt: O, status: f } = c;
    l = c.data;
    let F = !1;
    if (e.placeholderData !== void 0 && l === void 0 && f === "pending") {
      let p;
      i?.isPlaceholderData && e.placeholderData === a?.placeholderData ? (p = i.data, F = !0) : p = typeof e.placeholderData == "function" ? e.placeholderData(
        this.#d?.state.data,
        this.#d
      ) : e.placeholderData, p !== void 0 && (f = "success", l = L(
        i?.data,
        p,
        e
      ), d = !0);
    }
    if (e.select && l !== void 0 && !F)
      if (i && l === o?.data && e.select === this.#y)
        l = this.#f;
      else
        try {
          this.#y = e.select, l = e.select(l), l = L(i?.data, l, e), this.#f = l, this.#n = null;
        } catch (p) {
          this.#n = p;
        }
    this.#n && (P = this.#n, l = this.#f, O = Date.now(), f = "error");
    const m = c.fetchStatus === "fetching", g = f === "pending", S = f === "error", x = g && m, T = l !== void 0, b = {
      status: f,
      fetchStatus: c.fetchStatus,
      isPending: g,
      isSuccess: f === "success",
      isError: S,
      isInitialLoading: x,
      isLoading: x,
      data: l,
      dataUpdatedAt: c.dataUpdatedAt,
      error: P,
      errorUpdatedAt: O,
      failureCount: c.fetchFailureCount,
      failureReason: c.fetchFailureReason,
      errorUpdateCount: c.errorUpdateCount,
      isFetched: c.dataUpdateCount > 0 || c.errorUpdateCount > 0,
      isFetchedAfterMount: c.dataUpdateCount > u.dataUpdateCount || c.errorUpdateCount > u.errorUpdateCount,
      isFetching: m,
      isRefetching: m && !g,
      isLoadingError: S && !T,
      isPaused: c.fetchStatus === "paused",
      isPlaceholderData: d,
      isRefetchError: S && T,
      isStale: G(t, e),
      refetch: this.refetch,
      promise: this.#a,
      isEnabled: y(e.enabled, t) !== !1
    };
    if (this.options.experimental_prefetchInRender) {
      const p = (q) => {
        b.status === "error" ? q.reject(b.error) : b.data !== void 0 && q.resolve(b.data);
      }, D = () => {
        const q = this.#a = b.promise = _();
        p(q);
      }, E = this.#a;
      switch (E.status) {
        case "pending":
          t.queryHash === s.queryHash && p(E);
          break;
        case "fulfilled":
          (b.status === "error" || b.data !== E.value) && D();
          break;
        case "rejected":
          (b.status !== "error" || b.error !== E.reason) && D();
          break;
      }
    }
    return b;
  }
  updateResult() {
    const t = this.#i, e = this.createResult(this.#t, this.options);
    if (this.#r = this.#t.state, this.#o = this.options, this.#r.data !== void 0 && (this.#d = this.#t), M(e, t))
      return;
    this.#i = e;
    const s = () => {
      if (!t)
        return !0;
      const { notifyOnChangeProps: r } = this.options, i = typeof r == "function" ? r() : r;
      if (i === "all" || !i && !this.#p.size)
        return !0;
      const o = new Set(
        i ?? this.#p
      );
      return this.options.throwOnError && o.add("error"), Object.keys(this.#i).some((a) => {
        const n = a;
        return this.#i[n] !== t[n] && o.has(n);
      });
    };
    this.#C({ listeners: s() });
  }
  #w() {
    const t = this.#e.getQueryCache().build(this.#e, this.options);
    if (t === this.#t)
      return;
    const e = this.#t;
    this.#t = t, this.#s = t.state, this.hasListeners() && (e?.removeObserver(this), t.addObserver(this));
  }
  onQueryUpdate() {
    this.updateResult(), this.hasListeners() && this.#g();
  }
  #C(t) {
    V.batch(() => {
      t.listeners && this.listeners.forEach((e) => {
        e(this.#i);
      }), this.#e.getQueryCache().notify({
        query: this.#t,
        type: "observerResultsUpdated"
      });
    });
  }
};
function qt(t, e) {
  return y(e.enabled, t) !== !1 && t.state.data === void 0 && !(t.state.status === "error" && e.retryOnMount === !1);
}
function X(t, e) {
  return qt(t, e) || t.state.data !== void 0 && K(t, e, e.refetchOnMount);
}
function K(t, e, s) {
  if (y(e.enabled, t) !== !1 && I(e.staleTime, t) !== "static") {
    const r = typeof s == "function" ? s(t) : s;
    return r === "always" || r !== !1 && G(t, e);
  }
  return !1;
}
function tt(t, e, s, r) {
  return (t !== e || y(r.enabled, t) === !1) && (!s.suspense || t.state.status !== "error") && G(t, s);
}
function G(t, e) {
  return y(e.enabled, t) !== !1 && t.isStaleByTime(I(e.staleTime, t));
}
function kt(t, e) {
  return !M(t.getCurrentResult(), e);
}
var ct = v.createContext(
  void 0
), ht = (t) => {
  const e = v.useContext(ct);
  if (t)
    return t;
  if (!e)
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  return e;
}, fe = ({
  client: t,
  children: e
}) => (v.useEffect(() => (t.mount(), () => {
  t.unmount();
}), [t]), /* @__PURE__ */ bt.jsx(ct.Provider, { value: t, children: e })), lt = v.createContext(!1), At = () => v.useContext(lt);
lt.Provider;
function Qt() {
  let t = !1;
  return {
    clearReset: () => {
      t = !1;
    },
    reset: () => {
      t = !0;
    },
    isReset: () => t
  };
}
var Ut = v.createContext(Qt()), jt = () => v.useContext(Ut), Mt = (t, e) => {
  (t.suspense || t.throwOnError || t.experimental_prefetchInRender) && (e.isReset() || (t.retryOnMount = !1));
}, Nt = (t) => {
  v.useEffect(() => {
    t.clearReset();
  }, [t]);
}, Lt = ({
  result: t,
  errorResetBoundary: e,
  throwOnError: s,
  query: r,
  suspense: i
}) => t.isError && !e.isReset() && !t.isFetching && r && (i && t.data === void 0 || Ct(s, [t.error, r])), _t = (t, e) => e.state.data === void 0, Kt = (t) => {
  if (t.suspense) {
    const e = (r) => r === "static" ? r : Math.max(r ?? 1e3, 1e3), s = t.staleTime;
    t.staleTime = typeof s == "function" ? (...r) => e(s(...r)) : e(s), typeof t.gcTime == "number" && (t.gcTime = Math.max(t.gcTime, 1e3));
  }
}, Ht = (t, e) => t.isLoading && t.isFetching && !e, zt = (t, e) => t?.suspense && e.isPending, et = (t, e, s) => e.fetchOptimistic(t).catch(() => {
  s.clearReset();
});
function ft(t, e, s) {
  if (process.env.NODE_ENV !== "production" && (typeof t != "object" || Array.isArray(t)))
    throw new Error(
      'Bad argument type. Starting with v5, only the "Object" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object'
    );
  const r = At(), i = jt(), o = ht(s), a = o.defaultQueryOptions(t);
  o.getDefaultOptions().queries?._experimental_beforeQuery?.(
    a
  ), process.env.NODE_ENV !== "production" && (a.queryFn || console.error(
    `[${a.queryHash}]: No queryFn was passed as an option, and no default queryFn was found. The queryFn parameter is only optional when using a default queryFn. More info here: https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function`
  )), a._optimisticResults = r ? "isRestoring" : "optimistic", Kt(a), Mt(a, i), Nt(i);
  const n = !o.getQueryCache().get(a.queryHash), [u] = v.useState(
    () => new e(
      o,
      a
    )
  ), h = u.getOptimisticResult(a), c = !r && t.subscribed !== !1;
  if (v.useSyncExternalStore(
    v.useCallback(
      (d) => {
        const l = c ? u.subscribe(V.batchCalls(d)) : C;
        return u.updateResult(), l;
      },
      [u, c]
    ),
    () => u.getCurrentResult(),
    () => u.getCurrentResult()
  ), v.useEffect(() => {
    u.setOptions(a);
  }, [a, u]), zt(a, h))
    throw et(a, u, i);
  if (Lt({
    result: h,
    errorResetBoundary: i,
    throwOnError: a.throwOnError,
    query: o.getQueryCache().get(a.queryHash),
    suspense: a.suspense
  }))
    throw h.error;
  return o.getDefaultOptions().queries?._experimental_afterQuery?.(
    a,
    h
  ), a.experimental_prefetchInRender && !w && Ht(h, r) && (n ? (
    // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted
    et(a, u, i)
  ) : (
    // subscribe to the "cache promise" so that we can finalize the currentThenable once data comes in
    o.getQueryCache().get(a.queryHash)?.promise
  ))?.catch(C).finally(() => {
    u.updateResult();
  }), a.notifyOnChangeProps ? h : u.trackResult(h);
}
function Bt(t, e) {
  return ft(t, ut, e);
}
function Vt(t, e) {
  return process.env.NODE_ENV !== "production" && t.queryFn === k && console.error("skipToken is not allowed for useSuspenseQuery"), ft(
    {
      ...t,
      enabled: !0,
      suspense: !0,
      throwOnError: _t,
      placeholderData: void 0
    },
    ut,
    e
  );
}
const Gt = /^(\w+:\/\/[^/?]+)?([^?]*)(\?.*)?$/, $t = (t) => t.filter(
  (e) => e != null && e !== !1 && (typeof e == "string" || typeof e == "number")
).map((e) => `${e}`).filter((e) => e), Zt = (t) => {
  const e = t.join("/"), [, s = "", r = ""] = e.match(Gt) ?? [];
  return {
    prefix: s,
    pathname: r.split("/").filter((i) => i !== "")
  };
}, Jt = (t) => {
  const { prefix: e, pathname: s } = t;
  let r = e;
  return s.length > 0 ? (r ? r += "/" : r = "/", r += s.join("/")) : r || (r = "/"), r;
}, R = (...t) => {
  const e = $t(t), s = Zt(e);
  return Jt(s);
}, dt = Object.freeze({
  API_IDENTITIES: ["api-identities"]
}), de = () => {
  const t = ht();
  return {
    invalidateCache: async (e) => {
      await t.invalidateQueries({ queryKey: dt[e] });
    }
  };
}, pe = "no-dehydrate", $ = (t, e) => {
  for (const s of t) {
    const r = Z(s, e);
    if (r !== void 0) return r;
  }
}, Z = (t, e, s = []) => {
  const r = e(t, s);
  if (r !== void 0) return r;
  if (t.type === "category")
    for (const i of t.items) {
      const o = Z(i, e, [
        ...s,
        t
      ]);
      if (o !== void 0) return o;
    }
}, ye = () => {
  const t = A(), { navigation: e } = yt();
  return $(e, (s) => {
    if (s.type === "doc" && R(s.path) === t.pathname)
      return s;
  });
}, ve = (t) => {
  const e = A();
  return Z(t, (s) => {
    switch (s.type) {
      case "category":
        return s.link && R(s.link.path) === e.pathname ? !0 : void 0;
      case "custom-page":
      case "doc":
        return R(s.path) === e.pathname ? !0 : void 0;
      default:
        return;
    }
  });
}, me = () => {
  const t = A().pathname, { navigation: e } = yt();
  let s, r, i = !1;
  return $(e, (o) => {
    const a = o.type === "doc" ? R(o.path) : o.type === "category" && o.link ? R(o.link.path) : void 0;
    if (a) {
      if (i)
        return r = { label: o.label, id: a }, !0;
      t === a ? i = !0 : s = { label: o.label, id: a };
    }
  }), { prev: s, next: r };
}, be = gt(
  "relative flex items-center gap-2 px-(--padding-nav-item) my-0.5 py-1.5 rounded-lg hover:bg-accent tabular-nums",
  {
    variants: {
      isActive: {
        true: "bg-accent font-medium",
        false: "text-foreground/80"
      },
      isMuted: {
        true: "text-foreground/30",
        false: ""
      },
      isPending: {
        true: "bg-accent animate-pulse",
        false: ""
      }
    },
    defaultVariants: {
      isActive: !1
    }
  }
), ge = (t, e) => (s) => typeof s.display == "function" ? s.display({ context: e, auth: t }) : s.display === "hide" || !s.label ? !1 : s.display === "auth" && t.isAuthenticated || s.display === "anon" && !t.isAuthenticated || !s.display || s.display === "always", Wt = vt(
  void 0
), pt = () => {
  const t = mt(Wt);
  if (!t)
    throw new Error("useZudoku must be used within a ZudokuProvider.");
  return t;
}, Re = () => {
  const { getApiIdentities: t } = pt();
  return Bt({
    queryFn: t,
    queryKey: dt.API_IDENTITIES
  });
}, H = (t) => {
  switch (t.type) {
    case "doc":
      return R(t.path);
    case "category":
      return t.link ? R(t.link.path) : void 0;
    case "link":
      return t.to;
    case "custom-page":
      return R(t.path);
    default:
      return;
  }
}, Yt = (t) => {
  const e = /* @__PURE__ */ new Set(), s = (r) => {
    for (const i of r) {
      const o = H(i)?.split("?").at(0)?.split("#").at(0);
      o && e.add(o), i.type === "category" && s(i.items);
    }
  };
  return s(t), [...e];
}, yt = () => {
  const { getPluginNavigation: t, navigation: e } = pt(), s = A(), r = $(e, (a, n) => {
    if (H(a) === s.pathname)
      return n.at(0) ?? a;
  }), { data: i } = Vt({
    queryFn: () => t(s.pathname),
    queryKey: ["plugin-navigation", s.pathname]
  });
  let o = r;
  if (!r && i.length > 0) {
    const a = Yt(i);
    o = e.flatMap((n) => {
      const u = H(n);
      return u ? [{ item: n, path: u }] : [];
    }).sort((n, u) => u.path.length - n.path.length).find(({ path: n }) => a.some(
      (u) => J({ path: n, end: !1 }, u) ?? J({ path: u, end: !1 }, n)
    ))?.item;
  }
  return {
    navigation: [
      ...r?.type === "category" ? r.items : [],
      ...i
    ],
    topNavItem: o
  };
};
export {
  it as A,
  I as B,
  dt as C,
  ie as D,
  B as E,
  k as F,
  he as G,
  fe as H,
  Re as I,
  ve as J,
  be as K,
  pe as N,
  le as Q,
  Tt as R,
  z as S,
  Wt as Z,
  me as a,
  Vt as b,
  It as c,
  pt as d,
  de as e,
  Bt as f,
  ht as g,
  U as h,
  C as i,
  R as j,
  Ct as k,
  oe as l,
  ge as m,
  V as n,
  yt as o,
  Z as p,
  Rt as q,
  ne as r,
  M as s,
  $ as t,
  ye as u,
  ae as v,
  wt as w,
  ce as x,
  ue as y,
  rt as z
};
//# sourceMappingURL=ZudokuContext-BcqSiygJ.js.map
