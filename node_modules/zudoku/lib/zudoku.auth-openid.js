import { j as D } from "./jsx-runtime-DywqP_6a.js";
import { g as Le } from "./invariant-Bm-FVUQE.js";
import { E as Ue } from "./index-CVfG8Pb4.js";
import { C as xe } from "./ClientOnly-E7hGysn1.js";
import { j as Ce } from "./ZudokuContext-BcqSiygJ.js";
import { C as Ie, O as re, A as R } from "./errors-ouIp07AW.js";
import { C as je, O as Oe } from "./OAuthErrorPage-DCjFngGS.js";
import { u as S } from "./hook-BkLXq8pm.js";
var J = { exports: {} }, De = J.exports, oe;
function Je() {
  return oe || (oe = 1, function(t) {
    (function(e, n) {
      t.exports ? t.exports = n() : e.log = n();
    })(De, function() {
      var e = function() {
      }, n = "undefined", o = typeof window !== n && typeof window.navigator !== n && /Trident\/|MSIE /.test(window.navigator.userAgent), s = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
      ], r = {}, i = null;
      function u(l, m) {
        var c = l[m];
        if (typeof c.bind == "function")
          return c.bind(l);
        try {
          return Function.prototype.bind.call(c, l);
        } catch {
          return function() {
            return Function.prototype.apply.apply(c, [l, arguments]);
          };
        }
      }
      function d() {
        console.log && (console.log.apply ? console.log.apply(console, arguments) : Function.prototype.apply.apply(console.log, [console, arguments])), console.trace && console.trace();
      }
      function y(l) {
        return l === "debug" && (l = "log"), typeof console === n ? !1 : l === "trace" && o ? d : console[l] !== void 0 ? u(console, l) : console.log !== void 0 ? u(console, "log") : e;
      }
      function p() {
        for (var l = this.getLevel(), m = 0; m < s.length; m++) {
          var c = s[m];
          this[c] = m < l ? e : this.methodFactory(c, l, this.name);
        }
        if (this.log = this.debug, typeof console === n && l < this.levels.SILENT)
          return "No console available for logging";
      }
      function k(l) {
        return function() {
          typeof console !== n && (p.call(this), this[l].apply(this, arguments));
        };
      }
      function b(l, m, c) {
        return y(l) || k.apply(this, arguments);
      }
      function h(l, m) {
        var c = this, j, H, L, _ = "loglevel";
        typeof l == "string" ? _ += ":" + l : typeof l == "symbol" && (_ = void 0);
        function Ee(f) {
          var g = (s[f] || "silent").toUpperCase();
          if (!(typeof window === n || !_)) {
            try {
              window.localStorage[_] = g;
              return;
            } catch {
            }
            try {
              window.document.cookie = encodeURIComponent(_) + "=" + g + ";";
            } catch {
            }
          }
        }
        function ee() {
          var f;
          if (!(typeof window === n || !_)) {
            try {
              f = window.localStorage[_];
            } catch {
            }
            if (typeof f === n)
              try {
                var g = window.document.cookie, O = encodeURIComponent(_), ne = g.indexOf(O + "=");
                ne !== -1 && (f = /^([^;]+)/.exec(
                  g.slice(ne + O.length + 1)
                )[1]);
              } catch {
              }
            return c.levels[f] === void 0 && (f = void 0), f;
          }
        }
        function Re() {
          if (!(typeof window === n || !_)) {
            try {
              window.localStorage.removeItem(_);
            } catch {
            }
            try {
              window.document.cookie = encodeURIComponent(_) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
            } catch {
            }
          }
        }
        function U(f) {
          var g = f;
          if (typeof g == "string" && c.levels[g.toUpperCase()] !== void 0 && (g = c.levels[g.toUpperCase()]), typeof g == "number" && g >= 0 && g <= c.levels.SILENT)
            return g;
          throw new TypeError("log.setLevel() called with invalid level: " + f);
        }
        c.name = l, c.levels = {
          TRACE: 0,
          DEBUG: 1,
          INFO: 2,
          WARN: 3,
          ERROR: 4,
          SILENT: 5
        }, c.methodFactory = m || b, c.getLevel = function() {
          return L ?? H ?? j;
        }, c.setLevel = function(f, g) {
          return L = U(f), g !== !1 && Ee(L), p.call(c);
        }, c.setDefaultLevel = function(f) {
          H = U(f), ee() || c.setLevel(f, !1);
        }, c.resetLevel = function() {
          L = null, Re(), p.call(c);
        }, c.enableAll = function(f) {
          c.setLevel(c.levels.TRACE, f);
        }, c.disableAll = function(f) {
          c.setLevel(c.levels.SILENT, f);
        }, c.rebuild = function() {
          if (i !== c && (j = U(i.getLevel())), p.call(c), i === c)
            for (var f in r)
              r[f].rebuild();
        }, j = U(
          i ? i.getLevel() : "WARN"
        );
        var te = ee();
        te != null && (L = U(te)), p.call(c);
      }
      i = new h(), i.getLogger = function(m) {
        if (typeof m != "symbol" && typeof m != "string" || m === "")
          throw new TypeError("You must supply a name when creating a logger.");
        var c = r[m];
        return c || (c = r[m] = new h(
          m,
          i.methodFactory
        )), c;
      };
      var P = typeof window !== n ? window.log : void 0;
      return i.noConflict = function() {
        return typeof window !== n && window.log === i && (window.log = P), i;
      }, i.getLoggers = function() {
        return r;
      }, i.default = i, i;
    });
  }(J)), J.exports;
}
var ze = Je();
const ie = /* @__PURE__ */ Le(ze);
let B;
(typeof navigator > "u" || !navigator.userAgent?.startsWith?.("Mozilla/5.0 ")) && (B = "oauth4webapi/v2.17.0");
function V(t, e) {
  if (t == null)
    return !1;
  try {
    return t instanceof e || Object.getPrototypeOf(t)[Symbol.toStringTag] === e.prototype[Symbol.toStringTag];
  } catch {
    return !1;
  }
}
const N = Symbol(), Ne = Symbol(), G = Symbol(), We = Symbol(), Ke = Symbol(), He = Symbol(), $e = new TextEncoder(), Fe = new TextDecoder();
function E(t) {
  return typeof t == "string" ? $e.encode(t) : Fe.decode(t);
}
const se = 32768;
function Me(t) {
  t instanceof ArrayBuffer && (t = new Uint8Array(t));
  const e = [];
  for (let n = 0; n < t.byteLength; n += se)
    e.push(String.fromCharCode.apply(null, t.subarray(n, n + se)));
  return btoa(e.join("")).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function Be(t) {
  try {
    const e = atob(t.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "")), n = new Uint8Array(e.length);
    for (let o = 0; o < e.length; o++)
      n[o] = e.charCodeAt(o);
    return n;
  } catch (e) {
    throw new a("The input to be decoded is not correctly encoded.", { cause: e });
  }
}
function A(t) {
  return typeof t == "string" ? Be(t) : Me(t);
}
class qe {
  constructor(e) {
    this.cache = /* @__PURE__ */ new Map(), this._cache = /* @__PURE__ */ new Map(), this.maxSize = e;
  }
  get(e) {
    let n = this.cache.get(e);
    if (n)
      return n;
    if (n = this._cache.get(e))
      return this.update(e, n), n;
  }
  has(e) {
    return this.cache.has(e) || this._cache.has(e);
  }
  set(e, n) {
    return this.cache.has(e) ? this.cache.set(e, n) : this.update(e, n), this;
  }
  delete(e) {
    return this.cache.has(e) ? this.cache.delete(e) : this._cache.has(e) ? this._cache.delete(e) : !1;
  }
  update(e, n) {
    this.cache.set(e, n), this.cache.size >= this.maxSize && (this._cache = this.cache, this.cache = /* @__PURE__ */ new Map());
  }
}
class v extends Error {
  constructor(e) {
    super(e ?? "operation not supported"), this.name = this.constructor.name, Error.captureStackTrace?.(this, this.constructor);
  }
}
class Ve extends Error {
  constructor(e, n) {
    super(e, n), this.name = this.constructor.name, Error.captureStackTrace?.(this, this.constructor);
  }
}
const a = Ve, we = new qe(100);
function me(t) {
  return t instanceof CryptoKey;
}
function Ge(t) {
  return me(t) && t.type === "private";
}
function Ye(t) {
  return me(t) && t.type === "public";
}
function Y(t) {
  try {
    const e = t.headers.get("dpop-nonce");
    e && we.set(new URL(t.url).origin, e);
  } catch {
  }
  return t;
}
function x(t) {
  return !(t === null || typeof t != "object" || Array.isArray(t));
}
function W(t) {
  V(t, Headers) && (t = Object.fromEntries(t.entries()));
  const e = new Headers(t);
  if (B && !e.has("user-agent") && e.set("user-agent", B), e.has("authorization"))
    throw new TypeError('"options.headers" must not include the "authorization" header name');
  if (e.has("dpop"))
    throw new TypeError('"options.headers" must not include the "dpop" header name');
  return e;
}
function Ze(t) {
  if (typeof t == "function" && (t = t()), !(t instanceof AbortSignal))
    throw new TypeError('"options.signal" must return or be an instance of AbortSignal');
  return t;
}
async function Qe(t, e) {
  if (!(t instanceof URL))
    throw new TypeError('"issuerIdentifier" must be an instance of URL');
  if (t.protocol !== "https:" && t.protocol !== "http:")
    throw new TypeError('"issuer.protocol" must be "https:" or "http:"');
  const n = new URL(t.href);
  switch (e?.algorithm) {
    case void 0:
    case "oidc":
      n.pathname = `${n.pathname}/.well-known/openid-configuration`.replace("//", "/");
      break;
    case "oauth2":
      n.pathname === "/" ? n.pathname = ".well-known/oauth-authorization-server" : n.pathname = `.well-known/oauth-authorization-server/${n.pathname}`.replace("//", "/");
      break;
    default:
      throw new TypeError('"options.algorithm" must be "oidc" (default), or "oauth2"');
  }
  const o = W(e?.headers);
  return o.set("accept", "application/json"), (e?.[G] || fetch)(n.href, {
    headers: Object.fromEntries(o.entries()),
    method: "GET",
    redirect: "manual",
    signal: null
  }).then(Y);
}
function w(t) {
  return typeof t == "string" && t.length !== 0;
}
async function Xe(t, e) {
  if (!(t instanceof URL))
    throw new TypeError('"expectedIssuer" must be an instance of URL');
  if (!V(e, Response))
    throw new TypeError('"response" must be an instance of Response');
  if (e.status !== 200)
    throw new a('"response" is not a conform Authorization Server Metadata response');
  X(e);
  let n;
  try {
    n = await e.json();
  } catch (o) {
    throw new a('failed to parse "response" body as JSON', { cause: o });
  }
  if (!x(n))
    throw new a('"response" body must be a top level object');
  if (!w(n.issuer))
    throw new a('"response" body "issuer" property must be a non-empty string');
  if (new URL(n.issuer).href !== t.href)
    throw new a('"response" body "issuer" does not match "expectedIssuer"');
  return n;
}
function Z() {
  return A(crypto.getRandomValues(new Uint8Array(32)));
}
function et() {
  return Z();
}
function tt() {
  return Z();
}
async function nt(t) {
  if (!w(t))
    throw new TypeError('"codeVerifier" must be a non-empty string');
  return A(await crypto.subtle.digest("SHA-256", E(t)));
}
function ae(t) {
  return encodeURIComponent(t).replace(/%20/g, "+");
}
function rt(t, e) {
  const n = ae(t), o = ae(e);
  return `Basic ${btoa(`${n}:${o}`)}`;
}
function ot(t) {
  switch (t.algorithm.hash.name) {
    case "SHA-256":
      return "PS256";
    case "SHA-384":
      return "PS384";
    case "SHA-512":
      return "PS512";
    default:
      throw new v("unsupported RsaHashedKeyAlgorithm hash name");
  }
}
function it(t) {
  switch (t.algorithm.hash.name) {
    case "SHA-256":
      return "RS256";
    case "SHA-384":
      return "RS384";
    case "SHA-512":
      return "RS512";
    default:
      throw new v("unsupported RsaHashedKeyAlgorithm hash name");
  }
}
function st(t) {
  switch (t.algorithm.namedCurve) {
    case "P-256":
      return "ES256";
    case "P-384":
      return "ES384";
    case "P-521":
      return "ES512";
    default:
      throw new v("unsupported EcKeyAlgorithm namedCurve");
  }
}
function at(t) {
  switch (t.algorithm.name) {
    case "RSA-PSS":
      return ot(t);
    case "RSASSA-PKCS1-v1_5":
      return it(t);
    case "ECDSA":
      return st(t);
    case "Ed25519":
    case "Ed448":
      return "EdDSA";
    default:
      throw new v("unsupported CryptoKey algorithm name");
  }
}
function K(t) {
  const e = t?.[N];
  return typeof e == "number" && Number.isFinite(e) ? e : 0;
}
function ge(t) {
  const e = t?.[Ne];
  return typeof e == "number" && Number.isFinite(e) && Math.sign(e) !== -1 ? e : 30;
}
function Q() {
  return Math.floor(Date.now() / 1e3);
}
function C(t) {
  if (typeof t != "object" || t === null)
    throw new TypeError('"as" must be an object');
  if (!w(t.issuer))
    throw new TypeError('"as.issuer" property must be a non-empty string');
  return !0;
}
function I(t) {
  if (typeof t != "object" || t === null)
    throw new TypeError('"client" must be an object');
  if (!w(t.client_id))
    throw new TypeError('"client.client_id" property must be a non-empty string');
  return !0;
}
function ce(t) {
  if (!w(t))
    throw new TypeError('"client.client_secret" property must be a non-empty string');
  return t;
}
function ue(t, e) {
  if (e !== void 0)
    throw new TypeError(`"client.client_secret" property must not be provided when ${t} client authentication method is used.`);
}
async function ct(t, e, n, o, s) {
  switch (n.delete("client_secret"), n.delete("client_assertion_type"), n.delete("client_assertion"), e.token_endpoint_auth_method) {
    case void 0:
    case "client_secret_basic": {
      o.set("authorization", rt(e.client_id, ce(e.client_secret)));
      break;
    }
    case "client_secret_post": {
      n.set("client_id", e.client_id), n.set("client_secret", ce(e.client_secret));
      break;
    }
    case "private_key_jwt":
      throw ue("private_key_jwt", e.client_secret), new TypeError('"options.clientPrivateKey" must be provided when "client.token_endpoint_auth_method" is "private_key_jwt"');
    case "tls_client_auth":
    case "self_signed_tls_client_auth":
    case "none": {
      ue(e.token_endpoint_auth_method, e.client_secret), e.token_endpoint_auth_method, n.set("client_id", e.client_id);
      break;
    }
    default:
      throw new v("unsupported client token_endpoint_auth_method");
  }
}
async function ut(t, e, n) {
  if (!n.usages.includes("sign"))
    throw new TypeError('CryptoKey instances used for signing assertions must include "sign" in their "usages"');
  const o = `${A(E(JSON.stringify(t)))}.${A(E(JSON.stringify(e)))}`, s = A(await crypto.subtle.sign(Ae(n), n, E(o)));
  return `${o}.${s}`;
}
async function lt(t, e, n, o, s, r) {
  const { privateKey: i, publicKey: u, nonce: d = we.get(n.origin) } = e;
  if (!Ge(i))
    throw new TypeError('"DPoP.privateKey" must be a private CryptoKey');
  if (!Ye(u))
    throw new TypeError('"DPoP.publicKey" must be a public CryptoKey');
  if (d !== void 0 && !w(d))
    throw new TypeError('"DPoP.nonce" must be a non-empty string or undefined');
  if (!u.extractable)
    throw new TypeError('"DPoP.publicKey.extractable" must be true');
  const y = Q() + s, p = {
    alg: at(i),
    typ: "dpop+jwt",
    jwk: await ft(u)
  }, k = {
    iat: y,
    jti: Z(),
    htm: o,
    nonce: d,
    htu: `${n.origin}${n.pathname}`,
    ath: r ? A(await crypto.subtle.digest("SHA-256", E(r))) : void 0
  };
  e[We]?.(p, k), t.set("dpop", await ut(p, k, i));
}
let z;
async function dt(t) {
  const { kty: e, e: n, n: o, x: s, y: r, crv: i } = await crypto.subtle.exportKey("jwk", t), u = { kty: e, e: n, n: o, x: s, y: r, crv: i };
  return z.set(t, u), u;
}
async function ft(t) {
  return z || (z = /* @__PURE__ */ new WeakMap()), z.get(t) || dt(t);
}
function le(t, e, n) {
  if (typeof t != "string")
    throw n ? new TypeError(`"as.mtls_endpoint_aliases.${e}" must be a string`) : new TypeError(`"as.${e}" must be a string`);
  return new URL(t);
}
function ye(t, e, n = !1) {
  return n && t.mtls_endpoint_aliases && e in t.mtls_endpoint_aliases ? le(t.mtls_endpoint_aliases[e], e, n) : le(t[e], e, n);
}
function be(t, e) {
  return !!(t.use_mtls_endpoint_aliases || e?.[He]);
}
function q(t) {
  const e = t;
  return typeof e != "object" || Array.isArray(e) || e === null ? !1 : e.error !== void 0;
}
async function ht(t, e, n, o, s, r) {
  if (!w(t))
    throw new TypeError('"accessToken" must be a non-empty string');
  if (!(n instanceof URL))
    throw new TypeError('"url" must be an instance of URL');
  return o = W(o), r?.DPoP === void 0 ? o.set("authorization", `Bearer ${t}`) : (await lt(o, r.DPoP, n, e.toUpperCase(), K({ [N]: r?.[N] }), t), o.set("authorization", `DPoP ${t}`)), (r?.[G] || fetch)(n.href, {
    body: s,
    headers: Object.fromEntries(o.entries()),
    method: e,
    redirect: "manual",
    signal: r?.signal ? Ze(r.signal) : null
  }).then(Y);
}
async function pt(t, e, n, o) {
  C(t), I(e);
  const s = ye(t, "userinfo_endpoint", be(e, o)), r = W(o?.headers);
  return e.userinfo_signed_response_alg ? r.set("accept", "application/jwt") : (r.set("accept", "application/json"), r.append("accept", "application/jwt")), ht(n, "GET", s, r, null, {
    ...o,
    [N]: K(e)
  });
}
async function wt(t, e, n, o, s, r, i) {
  return await ct(t, e, s, r), r.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"), (i?.[G] || fetch)(o.href, {
    body: s,
    headers: Object.fromEntries(r.entries()),
    method: n,
    redirect: "manual",
    signal: null
  }).then(Y);
}
async function _e(t, e, n, o, s) {
  const r = ye(t, "token_endpoint", be(e, s));
  o.set("grant_type", n);
  const i = W(s?.headers);
  return i.set("accept", "application/json"), wt(t, e, "POST", r, o, i, s);
}
async function de(t, e, n, o) {
  if (C(t), I(e), !w(n))
    throw new TypeError('"refreshToken" must be a non-empty string');
  const s = new URLSearchParams(o?.additionalParameters);
  return s.set("refresh_token", n), _e(t, e, "refresh_token", s, o);
}
const ve = /* @__PURE__ */ new WeakMap();
function mt(t) {
  if (!t.id_token)
    return;
  const e = ve.get(t);
  if (!e)
    throw new TypeError('"ref" was already garbage collected or did not resolve from the proper sources');
  return e[0];
}
async function Se(t, e, n, o = !1, s = !1) {
  if (C(t), I(e), !V(n, Response))
    throw new TypeError('"response" must be an instance of Response');
  if (n.status !== 200) {
    let i;
    if (i = await kt(n))
      return i;
    throw new a('"response" is not a conform Token Endpoint response');
  }
  X(n);
  let r;
  try {
    r = await n.json();
  } catch (i) {
    throw new a('failed to parse "response" body as JSON', { cause: i });
  }
  if (!x(r))
    throw new a('"response" body must be a top level object');
  if (!w(r.access_token))
    throw new a('"response" body "access_token" property must be a non-empty string');
  if (!w(r.token_type))
    throw new a('"response" body "token_type" property must be a non-empty string');
  if (r.token_type = r.token_type.toLowerCase(), r.token_type !== "dpop" && r.token_type !== "bearer")
    throw new v("unsupported `token_type` value");
  if (r.expires_in !== void 0 && (typeof r.expires_in != "number" || r.expires_in <= 0))
    throw new a('"response" body "expires_in" property must be a positive number');
  if (!s && r.refresh_token !== void 0 && !w(r.refresh_token))
    throw new a('"response" body "refresh_token" property must be a non-empty string');
  if (r.scope !== void 0 && typeof r.scope != "string")
    throw new a('"response" body "scope" property must be a string');
  if (!o) {
    if (r.id_token !== void 0 && !w(r.id_token))
      throw new a('"response" body "id_token" property must be a non-empty string');
    if (r.id_token) {
      const { claims: i, jwt: u } = await Pt(r.id_token, Lt.bind(void 0, e.id_token_signed_response_alg, t.id_token_signing_alg_values_supported), ke, K(e), ge(e), e[Ke]).then(St.bind(void 0, ["aud", "exp", "iat", "iss", "sub"])).then(yt.bind(void 0, t.issuer)).then(gt.bind(void 0, e.client_id));
      if (Array.isArray(i.aud) && i.aud.length !== 1) {
        if (i.azp === void 0)
          throw new a('ID Token "aud" (audience) claim includes additional untrusted audiences');
        if (i.azp !== e.client_id)
          throw new a('unexpected ID Token "azp" (authorized party) claim value');
      }
      if (i.auth_time !== void 0 && (!Number.isFinite(i.auth_time) || Math.sign(i.auth_time) !== 1))
        throw new a('ID Token "auth_time" (authentication time) must be a positive number');
      ve.set(r, [i, u]);
    }
  }
  return r;
}
async function fe(t, e, n) {
  return Se(t, e, n);
}
function gt(t, e) {
  if (Array.isArray(e.claims.aud)) {
    if (!e.claims.aud.includes(t))
      throw new a('unexpected JWT "aud" (audience) claim value');
  } else if (e.claims.aud !== t)
    throw new a('unexpected JWT "aud" (audience) claim value');
  return e;
}
function yt(t, e) {
  if (e.claims.iss !== t)
    throw new a('unexpected JWT "iss" (issuer) claim value');
  return e;
}
const Te = /* @__PURE__ */ new WeakSet();
function bt(t) {
  return Te.add(t), t;
}
async function _t(t, e, n, o, s, r) {
  if (C(t), I(e), !Te.has(n))
    throw new TypeError('"callbackParameters" must be an instance of URLSearchParams obtained from "validateAuthResponse()", or "validateJwtAuthResponse()');
  if (!w(o))
    throw new TypeError('"redirectUri" must be a non-empty string');
  if (!w(s))
    throw new TypeError('"codeVerifier" must be a non-empty string');
  const i = T(n, "code");
  if (!i)
    throw new a('no authorization code in "callbackParameters"');
  const u = new URLSearchParams(r?.additionalParameters);
  return u.set("redirect_uri", o), u.set("code_verifier", s), u.set("code", i), _e(t, e, "authorization_code", u, r);
}
const vt = {
  aud: "audience",
  c_hash: "code hash",
  client_id: "client id",
  exp: "expiration time",
  iat: "issued at",
  iss: "issuer",
  jti: "jwt id",
  nonce: "nonce",
  s_hash: "state hash",
  sub: "subject",
  ath: "access token hash",
  htm: "http method",
  htu: "http uri",
  cnf: "confirmation"
};
function St(t, e) {
  for (const n of t)
    if (e.claims[n] === void 0)
      throw new a(`JWT "${n}" (${vt[n]}) claim missing`);
  return e;
}
const Tt = Symbol(), $ = Symbol();
async function At(t, e, n, o, s) {
  const r = await Se(t, e, n);
  if (q(r))
    return r;
  if (!w(r.id_token))
    throw new a('"response" body "id_token" property must be a non-empty string');
  s ?? (s = e.default_max_age ?? $);
  const i = mt(r);
  if ((e.require_auth_time || s !== $) && i.auth_time === void 0)
    throw new a('ID Token "auth_time" (authentication time) claim missing');
  if (s !== $) {
    if (typeof s != "number" || s < 0)
      throw new TypeError('"maxAge" must be a non-negative number');
    const u = Q() + K(e), d = ge(e);
    if (i.auth_time + s < u - d)
      throw new a("too much time has elapsed since the last End-User authentication");
  }
  switch (o) {
    case void 0:
    case Tt:
      if (i.nonce !== void 0)
        throw new a('unexpected ID Token "nonce" claim value');
      break;
    default:
      if (!w(o))
        throw new TypeError('"expectedNonce" must be a non-empty string');
      if (i.nonce === void 0)
        throw new a('ID Token "nonce" claim missing');
      if (i.nonce !== o)
        throw new a('unexpected ID Token "nonce" claim value');
  }
  return r;
}
function X(t) {
  if (t.bodyUsed)
    throw new TypeError('"response" body has been used already');
}
async function kt(t) {
  if (t.status > 399 && t.status < 500) {
    X(t);
    try {
      const e = await t.json();
      if (x(e) && typeof e.error == "string" && e.error.length)
        return e.error_description !== void 0 && typeof e.error_description != "string" && delete e.error_description, e.error_uri !== void 0 && typeof e.error_uri != "string" && delete e.error_uri, e.algs !== void 0 && typeof e.algs != "string" && delete e.algs, e.scope !== void 0 && typeof e.scope != "string" && delete e.scope, e;
    } catch {
    }
  }
}
function he(t) {
  if (typeof t.modulusLength != "number" || t.modulusLength < 2048)
    throw new a(`${t.name} modulusLength must be at least 2048 bits`);
}
function Et(t) {
  switch (t) {
    case "P-256":
      return "SHA-256";
    case "P-384":
      return "SHA-384";
    case "P-521":
      return "SHA-512";
    default:
      throw new v();
  }
}
function Ae(t) {
  switch (t.algorithm.name) {
    case "ECDSA":
      return {
        name: t.algorithm.name,
        hash: Et(t.algorithm.namedCurve)
      };
    case "RSA-PSS":
      switch (he(t.algorithm), t.algorithm.hash.name) {
        case "SHA-256":
        case "SHA-384":
        case "SHA-512":
          return {
            name: t.algorithm.name,
            saltLength: parseInt(t.algorithm.hash.name.slice(-3), 10) >> 3
          };
        default:
          throw new v();
      }
    case "RSASSA-PKCS1-v1_5":
      return he(t.algorithm), t.algorithm.name;
    case "Ed448":
    case "Ed25519":
      return t.algorithm.name;
  }
  throw new v();
}
const ke = Symbol();
async function Rt(t, e, n, o) {
  const s = `${t}.${e}`;
  if (!await crypto.subtle.verify(Ae(n), n, o, E(s)))
    throw new a("JWT signature verification failed");
}
async function Pt(t, e, n, o, s, r) {
  let { 0: i, 1: u, 2: d, length: y } = t.split(".");
  if (y === 5)
    if (r !== void 0)
      t = await r(t), { 0: i, 1: u, 2: d, length: y } = t.split(".");
    else
      throw new v("JWE structure JWTs are not supported");
  if (y !== 3)
    throw new a("Invalid JWT");
  let p;
  try {
    p = JSON.parse(E(A(i)));
  } catch (l) {
    throw new a("failed to parse JWT Header body as base64url encoded JSON", { cause: l });
  }
  if (!x(p))
    throw new a("JWT Header must be a top level object");
  if (e(p), p.crit !== void 0)
    throw new a('unexpected JWT "crit" header parameter');
  const k = A(d);
  let b;
  n !== ke && (b = await n(p), await Rt(i, u, b, k));
  let h;
  try {
    h = JSON.parse(E(A(u)));
  } catch (l) {
    throw new a("failed to parse JWT Payload body as base64url encoded JSON", { cause: l });
  }
  if (!x(h))
    throw new a("JWT Payload must be a top level object");
  const P = Q() + o;
  if (h.exp !== void 0) {
    if (typeof h.exp != "number")
      throw new a('unexpected JWT "exp" (expiration time) claim type');
    if (h.exp <= P - s)
      throw new a('unexpected JWT "exp" (expiration time) claim value, timestamp is <= now()');
  }
  if (h.iat !== void 0 && typeof h.iat != "number")
    throw new a('unexpected JWT "iat" (issued at) claim type');
  if (h.iss !== void 0 && typeof h.iss != "string")
    throw new a('unexpected JWT "iss" (issuer) claim type');
  if (h.nbf !== void 0) {
    if (typeof h.nbf != "number")
      throw new a('unexpected JWT "nbf" (not before) claim type');
    if (h.nbf > P + s)
      throw new a('unexpected JWT "nbf" (not before) claim value, timestamp is > now()');
  }
  if (h.aud !== void 0 && typeof h.aud != "string" && !Array.isArray(h.aud))
    throw new a('unexpected JWT "aud" (audience) claim type');
  return { header: p, claims: h, signature: k, key: b, jwt: t };
}
function Lt(t, e, n) {
  if (t !== void 0) {
    if (n.alg !== t)
      throw new a('unexpected JWT "alg" header parameter');
    return;
  }
  if (Array.isArray(e)) {
    if (!e.includes(n.alg))
      throw new a('unexpected JWT "alg" header parameter');
    return;
  }
  if (n.alg !== "RS256")
    throw new a('unexpected JWT "alg" header parameter');
}
function T(t, e) {
  const { 0: n, length: o } = t.getAll(e);
  if (o > 1)
    throw new a(`"${e}" parameter must be provided only once`);
  return n;
}
const Ut = Symbol(), xt = Symbol();
function Ct(t, e, n, o) {
  if (C(t), I(e), n instanceof URL && (n = n.searchParams), !(n instanceof URLSearchParams))
    throw new TypeError('"parameters" must be an instance of URLSearchParams, or URL');
  if (T(n, "response"))
    throw new a('"parameters" contains a JARM response, use validateJwtAuthResponse() instead of validateAuthResponse()');
  const s = T(n, "iss"), r = T(n, "state");
  if (!s && t.authorization_response_iss_parameter_supported)
    throw new a('response parameter "iss" (issuer) missing');
  if (s && s !== t.issuer)
    throw new a('unexpected "iss" (issuer) response parameter value');
  switch (o) {
    case void 0:
    case xt:
      if (r !== void 0)
        throw new a('unexpected "state" response parameter encountered');
      break;
    case Ut:
      break;
    default:
      if (!w(o))
        throw new a('"expectedState" must be a non-empty string');
      if (r === void 0)
        throw new a('response parameter "state" missing');
      if (r !== o)
        throw new a('unexpected "state" response parameter value');
  }
  const i = T(n, "error");
  if (i)
    return {
      error: i,
      error_description: T(n, "error_description"),
      error_uri: T(n, "error_uri")
    };
  const u = T(n, "id_token"), d = T(n, "token");
  if (u !== void 0 || d !== void 0)
    throw new v("implicit and hybrid flows are not supported");
  return bt(new URLSearchParams(n));
}
const F = "code-verifier", M = "oauth-state", pe = "/oauth/callback";
class It extends Ie {
  client;
  issuer;
  authorizationServer;
  callbackUrlPath;
  onAuthorizationUrl;
  redirectToAfterSignUp;
  redirectToAfterSignIn;
  redirectToAfterSignOut;
  audience;
  scopes;
  constructor({
    issuer: e,
    audience: n,
    clientId: o,
    redirectToAfterSignUp: s,
    redirectToAfterSignIn: r,
    redirectToAfterSignOut: i = "/",
    basePath: u,
    scopes: d
  }) {
    super(), this.client = {
      client_id: o,
      token_endpoint_auth_method: "none"
    }, this.audience = n, this.issuer = e, this.callbackUrlPath = Ce(u, pe), this.scopes = d ?? ["openid", "profile", "email"], this.redirectToAfterSignUp = s, this.redirectToAfterSignIn = r, this.redirectToAfterSignOut = i;
  }
  async getAuthServer() {
    if (!this.authorizationServer) {
      const e = new URL(this.issuer), n = await Qe(e);
      this.authorizationServer = await Xe(
        e,
        n
      );
    }
    return this.authorizationServer;
  }
  /**
   * Sets the tokens from various OAuth responses
   * @param response
   */
  setTokensFromResponse(e) {
    if (q(e))
      throw ie.error("Bad Token Response", e), new re("Bad Token Response", e);
    if (!e.expires_in)
      throw new R("No expires_in in response");
    const n = {
      accessToken: e.access_token,
      refreshToken: e.refresh_token,
      idToken: e.id_token,
      expiresOn: new Date(Date.now() + e.expires_in * 1e3),
      tokenType: e.token_type
    };
    S.setState({
      providerData: n
    });
  }
  async signUp({
    redirectTo: e,
    replace: n = !1
  } = {}) {
    return this.authorize({
      redirectTo: this.redirectToAfterSignUp ?? e ?? "/",
      replace: n,
      isSignUp: !0
    });
  }
  async signIn({
    redirectTo: e,
    replace: n = !1
  } = {}) {
    return this.authorize({
      redirectTo: this.redirectToAfterSignIn ?? e ?? "/",
      replace: n
    });
  }
  async authorize({
    redirectTo: e,
    isSignUp: n = !1,
    replace: o = !1
  }) {
    const s = "S256", r = await this.getAuthServer();
    if (!r.authorization_endpoint)
      throw new R("No authorization endpoint");
    const i = et(), u = await nt(i);
    sessionStorage.setItem(F, i);
    const d = new URL(
      r.authorization_endpoint
    );
    sessionStorage.setItem("redirect-to", e);
    const y = new URL(window.location.origin);
    y.pathname = this.callbackUrlPath, y.search = "", d.searchParams.set("client_id", this.client.client_id), d.searchParams.set("redirect_uri", y.toString()), d.searchParams.set("response_type", "code"), d.searchParams.set("scope", this.scopes.join(" ")), d.searchParams.set("code_challenge", u), d.searchParams.set(
      "code_challenge_method",
      s
    ), this.audience && d.searchParams.set("audience", this.audience), this.onAuthorizationUrl?.(d, {
      isSignIn: !n,
      isSignUp: n
    });
    const p = tt();
    sessionStorage.setItem(M, p), d.searchParams.set("state", p), o ? location.replace(d.href) : location.href = d.href;
  }
  async getAccessToken() {
    const e = await this.getAuthServer(), { providerData: n } = S.getState();
    if (!n)
      throw new R("User is not authenticated");
    const o = n;
    if (new Date(o.expiresOn) < /* @__PURE__ */ new Date()) {
      if (!o.refreshToken)
        return S.setState({
          isAuthenticated: !1,
          isPending: !1,
          profile: null,
          providerData: null
        }), "";
      const s = await de(
        e,
        this.client,
        o.refreshToken
      ), r = await fe(
        e,
        this.client,
        s
      );
      if (!r.access_token)
        throw new R("No access token in response");
      return this.setTokensFromResponse(r), r.access_token.toString();
    } else
      return o.accessToken;
  }
  signRequest = async (e) => {
    const n = await this.getAccessToken();
    return e.headers.set("Authorization", `Bearer ${n}`), e;
  };
  signOut = async () => {
    S.setState({
      isAuthenticated: !1,
      isPending: !1,
      profile: void 0,
      providerData: void 0
    });
    const e = await this.getAuthServer(), n = new URL(
      window.location.origin + this.redirectToAfterSignOut
    );
    n.pathname = this.callbackUrlPath;
    let o;
    e.end_session_endpoint ? (o = new URL(e.end_session_endpoint), o.searchParams.set(
      "post_logout_redirect_uri",
      n.toString()
    )) : o = n;
  };
  onPageLoad = async () => {
    const { providerData: e } = S.getState();
    if (!e) {
      S.setState({ isPending: !1 });
      return;
    }
    const n = e;
    if (new Date(n.expiresOn) < /* @__PURE__ */ new Date()) {
      if (!n.refreshToken) {
        S.setState({
          isAuthenticated: !1,
          isPending: !1,
          profile: null,
          providerData: null
        });
        return;
      }
      try {
        const o = await this.getAuthServer(), s = await de(
          o,
          this.client,
          n.refreshToken
        ), r = await fe(
          o,
          this.client,
          s
        );
        if (!r.access_token)
          throw new R("No access token in response");
        this.setTokensFromResponse(r);
      } catch {
        S.setState({
          isAuthenticated: !1,
          isPending: !1,
          profile: null,
          providerData: null
        });
        return;
      }
    }
    S.setState({ isPending: !1 });
  };
  handleCallback = async () => {
    const e = new URL(window.location.href), n = e.searchParams.get("state"), o = sessionStorage.getItem(M);
    if (sessionStorage.removeItem(M), n !== o)
      throw new R("Invalid state parameter");
    const s = sessionStorage.getItem(F);
    if (sessionStorage.removeItem(F), !s)
      throw new R("No code verifier found in state.");
    const r = await this.getAuthServer(), i = Ct(
      r,
      this.client,
      e.searchParams,
      n ?? void 0
    );
    if (q(i))
      throw ie.error("Error validating OAuth response", i), new re(
        "Error validating OAuth response",
        i
      );
    const u = new URL(e);
    u.pathname = this.callbackUrlPath, u.search = "";
    const d = await _t(
      r,
      this.client,
      i,
      u.toString(),
      s
    ), y = await At(
      r,
      this.client,
      d
    );
    this.setTokensFromResponse(y);
    const p = await this.getAccessToken(), b = await (await pt(
      r,
      this.client,
      p
    )).json(), h = {
      sub: b.sub,
      email: b.email,
      name: b.name,
      emailVerified: b.email_verified ?? !1,
      pictureUrl: b.picture
    };
    S.setState({
      isAuthenticated: !0,
      isPending: !1,
      profile: h
    });
    const P = sessionStorage.getItem("redirect-to") ?? "/";
    return sessionStorage.removeItem("redirect-to"), P;
  };
  getRoutes() {
    return [
      ...super.getRoutes(),
      {
        path: pe,
        element: /* @__PURE__ */ D.jsx(xe, { children: /* @__PURE__ */ D.jsx(
          Ue,
          {
            fallbackRender: ({ error: e }) => /* @__PURE__ */ D.jsx(Oe, { error: e }),
            children: /* @__PURE__ */ D.jsx(je, { handleCallback: this.handleCallback })
          }
        ) })
      }
    ];
  }
}
const Ht = (t) => new It(t);
export {
  pe as OPENID_CALLBACK_PATH,
  It as OpenIDAuthenticationProvider,
  Ht as default
};
//# sourceMappingURL=zudoku.auth-openid.js.map
