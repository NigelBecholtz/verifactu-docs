{"version":3,"file":"zudoku.auth-openid.js","sources":["../../../node_modules/.pnpm/loglevel@1.9.2/node_modules/loglevel/lib/loglevel.js","../../../node_modules/.pnpm/oauth4webapi@2.17.0/node_modules/oauth4webapi/build/index.js","../src/lib/authentication/providers/openid.tsx"],"sourcesContent":["/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (root, definition) {\n    \"use strict\";\n    if (typeof define === 'function' && define.amd) {\n        define(definition);\n    } else if (typeof module === 'object' && module.exports) {\n        module.exports = definition();\n    } else {\n        root.log = definition();\n    }\n}(this, function () {\n    \"use strict\";\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function() {};\n    var undefinedType = \"undefined\";\n    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (\n        /Trident\\/|MSIE /.test(window.navigator.userAgent)\n    );\n\n    var logMethods = [\n        \"trace\",\n        \"debug\",\n        \"info\",\n        \"warn\",\n        \"error\"\n    ];\n\n    var _loggersByName = {};\n    var defaultLogger = null;\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n        var method = obj[methodName];\n        if (typeof method.bind === 'function') {\n            return method.bind(obj);\n        } else {\n            try {\n                return Function.prototype.bind.call(method, obj);\n            } catch (e) {\n                // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                return function() {\n                    return Function.prototype.apply.apply(method, [obj, arguments]);\n                };\n            }\n        }\n    }\n\n    // Trace() doesn't print the message in IE, so for that case we need to wrap it\n    function traceForIE() {\n        if (console.log) {\n            if (console.log.apply) {\n                console.log.apply(console, arguments);\n            } else {\n                // In old IE, native console methods themselves don't have apply().\n                Function.prototype.apply.apply(console.log, [console, arguments]);\n            }\n        }\n        if (console.trace) console.trace();\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n        if (methodName === 'debug') {\n            methodName = 'log';\n        }\n\n        if (typeof console === undefinedType) {\n            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n        } else if (methodName === 'trace' && isIE) {\n            return traceForIE;\n        } else if (console[methodName] !== undefined) {\n            return bindMethod(console, methodName);\n        } else if (console.log !== undefined) {\n            return bindMethod(console, 'log');\n        } else {\n            return noop;\n        }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods() {\n        /*jshint validthis:true */\n        var level = this.getLevel();\n\n        // Replace the actual methods.\n        for (var i = 0; i < logMethods.length; i++) {\n            var methodName = logMethods[i];\n            this[methodName] = (i < level) ?\n                noop :\n                this.methodFactory(methodName, level, this.name);\n        }\n\n        // Define log.log as an alias for log.debug\n        this.log = this.debug;\n\n        // Return any important warnings.\n        if (typeof console === undefinedType && level < this.levels.SILENT) {\n            return \"No console available for logging\";\n        }\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName) {\n        return function () {\n            if (typeof console !== undefinedType) {\n                replaceLoggingMethods.call(this);\n                this[methodName].apply(this, arguments);\n            }\n        };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, _level, _loggerName) {\n        /*jshint validthis:true */\n        return realMethod(methodName) ||\n               enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n\n    function Logger(name, factory) {\n      // Private instance variables.\n      var self = this;\n      /**\n       * The level inherited from a parent logger (or a global default). We\n       * cache this here rather than delegating to the parent so that it stays\n       * in sync with the actual logging methods that we have installed (the\n       * parent could change levels but we might not have rebuilt the loggers\n       * in this child yet).\n       * @type {number}\n       */\n      var inheritedLevel;\n      /**\n       * The default level for this logger, if any. If set, this overrides\n       * `inheritedLevel`.\n       * @type {number|null}\n       */\n      var defaultLevel;\n      /**\n       * A user-specific level for this logger. If set, this overrides\n       * `defaultLevel`.\n       * @type {number|null}\n       */\n      var userLevel;\n\n      var storageKey = \"loglevel\";\n      if (typeof name === \"string\") {\n        storageKey += \":\" + name;\n      } else if (typeof name === \"symbol\") {\n        storageKey = undefined;\n      }\n\n      function persistLevelIfPossible(levelNum) {\n          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage[storageKey] = levelName;\n              return;\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n          } catch (ignore) {}\n      }\n\n      function getPersistedLevel() {\n          var storedLevel;\n\n          if (typeof window === undefinedType || !storageKey) return;\n\n          try {\n              storedLevel = window.localStorage[storageKey];\n          } catch (ignore) {}\n\n          // Fallback to cookies if local storage gives us nothing\n          if (typeof storedLevel === undefinedType) {\n              try {\n                  var cookie = window.document.cookie;\n                  var cookieName = encodeURIComponent(storageKey);\n                  var location = cookie.indexOf(cookieName + \"=\");\n                  if (location !== -1) {\n                      storedLevel = /^([^;]+)/.exec(\n                          cookie.slice(location + cookieName.length + 1)\n                      )[1];\n                  }\n              } catch (ignore) {}\n          }\n\n          // If the stored level is not valid, treat it as if nothing was stored.\n          if (self.levels[storedLevel] === undefined) {\n              storedLevel = undefined;\n          }\n\n          return storedLevel;\n      }\n\n      function clearPersistedLevel() {\n          if (typeof window === undefinedType || !storageKey) return;\n\n          // Use localStorage if available\n          try {\n              window.localStorage.removeItem(storageKey);\n          } catch (ignore) {}\n\n          // Use session cookie as fallback\n          try {\n              window.document.cookie =\n                encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n          } catch (ignore) {}\n      }\n\n      function normalizeLevel(input) {\n          var level = input;\n          if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n              level = self.levels[level.toUpperCase()];\n          }\n          if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n              return level;\n          } else {\n              throw new TypeError(\"log.setLevel() called with invalid level: \" + input);\n          }\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n\n      self.levels = { \"TRACE\": 0, \"DEBUG\": 1, \"INFO\": 2, \"WARN\": 3,\n          \"ERROR\": 4, \"SILENT\": 5};\n\n      self.methodFactory = factory || defaultMethodFactory;\n\n      self.getLevel = function () {\n          if (userLevel != null) {\n            return userLevel;\n          } else if (defaultLevel != null) {\n            return defaultLevel;\n          } else {\n            return inheritedLevel;\n          }\n      };\n\n      self.setLevel = function (level, persist) {\n          userLevel = normalizeLevel(level);\n          if (persist !== false) {  // defaults to true\n              persistLevelIfPossible(userLevel);\n          }\n\n          // NOTE: in v2, this should call rebuild(), which updates children.\n          return replaceLoggingMethods.call(self);\n      };\n\n      self.setDefaultLevel = function (level) {\n          defaultLevel = normalizeLevel(level);\n          if (!getPersistedLevel()) {\n              self.setLevel(level, false);\n          }\n      };\n\n      self.resetLevel = function () {\n          userLevel = null;\n          clearPersistedLevel();\n          replaceLoggingMethods.call(self);\n      };\n\n      self.enableAll = function(persist) {\n          self.setLevel(self.levels.TRACE, persist);\n      };\n\n      self.disableAll = function(persist) {\n          self.setLevel(self.levels.SILENT, persist);\n      };\n\n      self.rebuild = function () {\n          if (defaultLogger !== self) {\n              inheritedLevel = normalizeLevel(defaultLogger.getLevel());\n          }\n          replaceLoggingMethods.call(self);\n\n          if (defaultLogger === self) {\n              for (var childName in _loggersByName) {\n                _loggersByName[childName].rebuild();\n              }\n          }\n      };\n\n      // Initialize all the internal levels.\n      inheritedLevel = normalizeLevel(\n          defaultLogger ? defaultLogger.getLevel() : \"WARN\"\n      );\n      var initialLevel = getPersistedLevel();\n      if (initialLevel != null) {\n          userLevel = normalizeLevel(initialLevel);\n      }\n      replaceLoggingMethods.call(self);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    defaultLogger = new Logger();\n\n    defaultLogger.getLogger = function getLogger(name) {\n        if ((typeof name !== \"symbol\" && typeof name !== \"string\") || name === \"\") {\n            throw new TypeError(\"You must supply a name when creating a logger.\");\n        }\n\n        var logger = _loggersByName[name];\n        if (!logger) {\n            logger = _loggersByName[name] = new Logger(\n                name,\n                defaultLogger.methodFactory\n            );\n        }\n        return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = (typeof window !== undefinedType) ? window.log : undefined;\n    defaultLogger.noConflict = function() {\n        if (typeof window !== undefinedType &&\n               window.log === defaultLogger) {\n            window.log = _log;\n        }\n\n        return defaultLogger;\n    };\n\n    defaultLogger.getLoggers = function getLoggers() {\n        return _loggersByName;\n    };\n\n    // ES6 default export, for compatibility\n    defaultLogger['default'] = defaultLogger;\n\n    return defaultLogger;\n}));\n","let USER_AGENT;\nif (typeof navigator === 'undefined' || !navigator.userAgent?.startsWith?.('Mozilla/5.0 ')) {\n    const NAME = 'oauth4webapi';\n    const VERSION = 'v2.17.0';\n    USER_AGENT = `${NAME}/${VERSION}`;\n}\nfunction looseInstanceOf(input, expected) {\n    if (input == null) {\n        return false;\n    }\n    try {\n        return (input instanceof expected ||\n            Object.getPrototypeOf(input)[Symbol.toStringTag] === expected.prototype[Symbol.toStringTag]);\n    }\n    catch {\n        return false;\n    }\n}\nexport const clockSkew = Symbol();\nexport const clockTolerance = Symbol();\nexport const customFetch = Symbol();\nexport const modifyAssertion = Symbol();\nexport const jweDecrypt = Symbol();\nexport const jwksCache = Symbol();\nexport const useMtlsAlias = Symbol();\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\nfunction buf(input) {\n    if (typeof input === 'string') {\n        return encoder.encode(input);\n    }\n    return decoder.decode(input);\n}\nconst CHUNK_SIZE = 0x8000;\nfunction encodeBase64Url(input) {\n    if (input instanceof ArrayBuffer) {\n        input = new Uint8Array(input);\n    }\n    const arr = [];\n    for (let i = 0; i < input.byteLength; i += CHUNK_SIZE) {\n        arr.push(String.fromCharCode.apply(null, input.subarray(i, i + CHUNK_SIZE)));\n    }\n    return btoa(arr.join('')).replace(/=/g, '').replace(/\\+/g, '-').replace(/\\//g, '_');\n}\nfunction decodeBase64Url(input) {\n    try {\n        const binary = atob(input.replace(/-/g, '+').replace(/_/g, '/').replace(/\\s/g, ''));\n        const bytes = new Uint8Array(binary.length);\n        for (let i = 0; i < binary.length; i++) {\n            bytes[i] = binary.charCodeAt(i);\n        }\n        return bytes;\n    }\n    catch (cause) {\n        throw new OPE('The input to be decoded is not correctly encoded.', { cause });\n    }\n}\nfunction b64u(input) {\n    if (typeof input === 'string') {\n        return decodeBase64Url(input);\n    }\n    return encodeBase64Url(input);\n}\nclass LRU {\n    constructor(maxSize) {\n        this.cache = new Map();\n        this._cache = new Map();\n        this.maxSize = maxSize;\n    }\n    get(key) {\n        let v = this.cache.get(key);\n        if (v) {\n            return v;\n        }\n        if ((v = this._cache.get(key))) {\n            this.update(key, v);\n            return v;\n        }\n        return undefined;\n    }\n    has(key) {\n        return this.cache.has(key) || this._cache.has(key);\n    }\n    set(key, value) {\n        if (this.cache.has(key)) {\n            this.cache.set(key, value);\n        }\n        else {\n            this.update(key, value);\n        }\n        return this;\n    }\n    delete(key) {\n        if (this.cache.has(key)) {\n            return this.cache.delete(key);\n        }\n        if (this._cache.has(key)) {\n            return this._cache.delete(key);\n        }\n        return false;\n    }\n    update(key, value) {\n        this.cache.set(key, value);\n        if (this.cache.size >= this.maxSize) {\n            this._cache = this.cache;\n            this.cache = new Map();\n        }\n    }\n}\nexport class UnsupportedOperationError extends Error {\n    constructor(message) {\n        super(message ?? 'operation not supported');\n        this.name = this.constructor.name;\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nexport class OperationProcessingError extends Error {\n    constructor(message, options) {\n        super(message, options);\n        this.name = this.constructor.name;\n        Error.captureStackTrace?.(this, this.constructor);\n    }\n}\nconst OPE = OperationProcessingError;\nconst dpopNonces = new LRU(100);\nfunction isCryptoKey(key) {\n    return key instanceof CryptoKey;\n}\nfunction isPrivateKey(key) {\n    return isCryptoKey(key) && key.type === 'private';\n}\nfunction isPublicKey(key) {\n    return isCryptoKey(key) && key.type === 'public';\n}\nconst SUPPORTED_JWS_ALGS = [\n    'PS256',\n    'ES256',\n    'RS256',\n    'PS384',\n    'ES384',\n    'RS384',\n    'PS512',\n    'ES512',\n    'RS512',\n    'EdDSA',\n];\nfunction processDpopNonce(response) {\n    try {\n        const nonce = response.headers.get('dpop-nonce');\n        if (nonce) {\n            dpopNonces.set(new URL(response.url).origin, nonce);\n        }\n    }\n    catch { }\n    return response;\n}\nfunction normalizeTyp(value) {\n    return value.toLowerCase().replace(/^application\\//, '');\n}\nfunction isJsonObject(input) {\n    if (input === null || typeof input !== 'object' || Array.isArray(input)) {\n        return false;\n    }\n    return true;\n}\nfunction prepareHeaders(input) {\n    if (looseInstanceOf(input, Headers)) {\n        input = Object.fromEntries(input.entries());\n    }\n    const headers = new Headers(input);\n    if (USER_AGENT && !headers.has('user-agent')) {\n        headers.set('user-agent', USER_AGENT);\n    }\n    if (headers.has('authorization')) {\n        throw new TypeError('\"options.headers\" must not include the \"authorization\" header name');\n    }\n    if (headers.has('dpop')) {\n        throw new TypeError('\"options.headers\" must not include the \"dpop\" header name');\n    }\n    return headers;\n}\nfunction signal(value) {\n    if (typeof value === 'function') {\n        value = value();\n    }\n    if (!(value instanceof AbortSignal)) {\n        throw new TypeError('\"options.signal\" must return or be an instance of AbortSignal');\n    }\n    return value;\n}\nexport async function discoveryRequest(issuerIdentifier, options) {\n    if (!(issuerIdentifier instanceof URL)) {\n        throw new TypeError('\"issuerIdentifier\" must be an instance of URL');\n    }\n    if (issuerIdentifier.protocol !== 'https:' && issuerIdentifier.protocol !== 'http:') {\n        throw new TypeError('\"issuer.protocol\" must be \"https:\" or \"http:\"');\n    }\n    const url = new URL(issuerIdentifier.href);\n    switch (options?.algorithm) {\n        case undefined:\n        case 'oidc':\n            url.pathname = `${url.pathname}/.well-known/openid-configuration`.replace('//', '/');\n            break;\n        case 'oauth2':\n            if (url.pathname === '/') {\n                url.pathname = '.well-known/oauth-authorization-server';\n            }\n            else {\n                url.pathname = `.well-known/oauth-authorization-server/${url.pathname}`.replace('//', '/');\n            }\n            break;\n        default:\n            throw new TypeError('\"options.algorithm\" must be \"oidc\" (default), or \"oauth2\"');\n    }\n    const headers = prepareHeaders(options?.headers);\n    headers.set('accept', 'application/json');\n    return (options?.[customFetch] || fetch)(url.href, {\n        headers: Object.fromEntries(headers.entries()),\n        method: 'GET',\n        redirect: 'manual',\n        signal: options?.signal ? signal(options.signal) : null,\n    }).then(processDpopNonce);\n}\nfunction validateString(input) {\n    return typeof input === 'string' && input.length !== 0;\n}\nexport async function processDiscoveryResponse(expectedIssuerIdentifier, response) {\n    if (!(expectedIssuerIdentifier instanceof URL)) {\n        throw new TypeError('\"expectedIssuer\" must be an instance of URL');\n    }\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        throw new OPE('\"response\" is not a conform Authorization Server Metadata response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    }\n    catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', { cause });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.issuer)) {\n        throw new OPE('\"response\" body \"issuer\" property must be a non-empty string');\n    }\n    if (new URL(json.issuer).href !== expectedIssuerIdentifier.href) {\n        throw new OPE('\"response\" body \"issuer\" does not match \"expectedIssuer\"');\n    }\n    return json;\n}\nfunction randomBytes() {\n    return b64u(crypto.getRandomValues(new Uint8Array(32)));\n}\nexport function generateRandomCodeVerifier() {\n    return randomBytes();\n}\nexport function generateRandomState() {\n    return randomBytes();\n}\nexport function generateRandomNonce() {\n    return randomBytes();\n}\nexport async function calculatePKCECodeChallenge(codeVerifier) {\n    if (!validateString(codeVerifier)) {\n        throw new TypeError('\"codeVerifier\" must be a non-empty string');\n    }\n    return b64u(await crypto.subtle.digest('SHA-256', buf(codeVerifier)));\n}\nfunction getKeyAndKid(input) {\n    if (input instanceof CryptoKey) {\n        return { key: input };\n    }\n    if (!(input?.key instanceof CryptoKey)) {\n        return {};\n    }\n    if (input.kid !== undefined && !validateString(input.kid)) {\n        throw new TypeError('\"kid\" must be a non-empty string');\n    }\n    return {\n        key: input.key,\n        kid: input.kid,\n        modifyAssertion: input[modifyAssertion],\n    };\n}\nfunction formUrlEncode(token) {\n    return encodeURIComponent(token).replace(/%20/g, '+');\n}\nfunction clientSecretBasic(clientId, clientSecret) {\n    const username = formUrlEncode(clientId);\n    const password = formUrlEncode(clientSecret);\n    const credentials = btoa(`${username}:${password}`);\n    return `Basic ${credentials}`;\n}\nfunction psAlg(key) {\n    switch (key.algorithm.hash.name) {\n        case 'SHA-256':\n            return 'PS256';\n        case 'SHA-384':\n            return 'PS384';\n        case 'SHA-512':\n            return 'PS512';\n        default:\n            throw new UnsupportedOperationError('unsupported RsaHashedKeyAlgorithm hash name');\n    }\n}\nfunction rsAlg(key) {\n    switch (key.algorithm.hash.name) {\n        case 'SHA-256':\n            return 'RS256';\n        case 'SHA-384':\n            return 'RS384';\n        case 'SHA-512':\n            return 'RS512';\n        default:\n            throw new UnsupportedOperationError('unsupported RsaHashedKeyAlgorithm hash name');\n    }\n}\nfunction esAlg(key) {\n    switch (key.algorithm.namedCurve) {\n        case 'P-256':\n            return 'ES256';\n        case 'P-384':\n            return 'ES384';\n        case 'P-521':\n            return 'ES512';\n        default:\n            throw new UnsupportedOperationError('unsupported EcKeyAlgorithm namedCurve');\n    }\n}\nfunction keyToJws(key) {\n    switch (key.algorithm.name) {\n        case 'RSA-PSS':\n            return psAlg(key);\n        case 'RSASSA-PKCS1-v1_5':\n            return rsAlg(key);\n        case 'ECDSA':\n            return esAlg(key);\n        case 'Ed25519':\n        case 'Ed448':\n            return 'EdDSA';\n        default:\n            throw new UnsupportedOperationError('unsupported CryptoKey algorithm name');\n    }\n}\nfunction getClockSkew(client) {\n    const skew = client?.[clockSkew];\n    return typeof skew === 'number' && Number.isFinite(skew) ? skew : 0;\n}\nfunction getClockTolerance(client) {\n    const tolerance = client?.[clockTolerance];\n    return typeof tolerance === 'number' && Number.isFinite(tolerance) && Math.sign(tolerance) !== -1\n        ? tolerance\n        : 30;\n}\nfunction epochTime() {\n    return Math.floor(Date.now() / 1000);\n}\nfunction clientAssertion(as, client) {\n    const now = epochTime() + getClockSkew(client);\n    return {\n        jti: randomBytes(),\n        aud: [as.issuer, as.token_endpoint],\n        exp: now + 60,\n        iat: now,\n        nbf: now,\n        iss: client.client_id,\n        sub: client.client_id,\n    };\n}\nasync function privateKeyJwt(as, client, key, kid, modifyAssertion) {\n    const header = { alg: keyToJws(key), kid };\n    const payload = clientAssertion(as, client);\n    modifyAssertion?.(header, payload);\n    return jwt(header, payload, key);\n}\nfunction assertAs(as) {\n    if (typeof as !== 'object' || as === null) {\n        throw new TypeError('\"as\" must be an object');\n    }\n    if (!validateString(as.issuer)) {\n        throw new TypeError('\"as.issuer\" property must be a non-empty string');\n    }\n    return true;\n}\nfunction assertClient(client) {\n    if (typeof client !== 'object' || client === null) {\n        throw new TypeError('\"client\" must be an object');\n    }\n    if (!validateString(client.client_id)) {\n        throw new TypeError('\"client.client_id\" property must be a non-empty string');\n    }\n    return true;\n}\nfunction assertClientSecret(clientSecret) {\n    if (!validateString(clientSecret)) {\n        throw new TypeError('\"client.client_secret\" property must be a non-empty string');\n    }\n    return clientSecret;\n}\nfunction assertNoClientPrivateKey(clientAuthMethod, clientPrivateKey) {\n    if (clientPrivateKey !== undefined) {\n        throw new TypeError(`\"options.clientPrivateKey\" property must not be provided when ${clientAuthMethod} client authentication method is used.`);\n    }\n}\nfunction assertNoClientSecret(clientAuthMethod, clientSecret) {\n    if (clientSecret !== undefined) {\n        throw new TypeError(`\"client.client_secret\" property must not be provided when ${clientAuthMethod} client authentication method is used.`);\n    }\n}\nasync function clientAuthentication(as, client, body, headers, clientPrivateKey) {\n    body.delete('client_secret');\n    body.delete('client_assertion_type');\n    body.delete('client_assertion');\n    switch (client.token_endpoint_auth_method) {\n        case undefined:\n        case 'client_secret_basic': {\n            assertNoClientPrivateKey('client_secret_basic', clientPrivateKey);\n            headers.set('authorization', clientSecretBasic(client.client_id, assertClientSecret(client.client_secret)));\n            break;\n        }\n        case 'client_secret_post': {\n            assertNoClientPrivateKey('client_secret_post', clientPrivateKey);\n            body.set('client_id', client.client_id);\n            body.set('client_secret', assertClientSecret(client.client_secret));\n            break;\n        }\n        case 'private_key_jwt': {\n            assertNoClientSecret('private_key_jwt', client.client_secret);\n            if (clientPrivateKey === undefined) {\n                throw new TypeError('\"options.clientPrivateKey\" must be provided when \"client.token_endpoint_auth_method\" is \"private_key_jwt\"');\n            }\n            const { key, kid, modifyAssertion } = getKeyAndKid(clientPrivateKey);\n            if (!isPrivateKey(key)) {\n                throw new TypeError('\"options.clientPrivateKey.key\" must be a private CryptoKey');\n            }\n            body.set('client_id', client.client_id);\n            body.set('client_assertion_type', 'urn:ietf:params:oauth:client-assertion-type:jwt-bearer');\n            body.set('client_assertion', await privateKeyJwt(as, client, key, kid, modifyAssertion));\n            break;\n        }\n        case 'tls_client_auth':\n        case 'self_signed_tls_client_auth':\n        case 'none': {\n            assertNoClientSecret(client.token_endpoint_auth_method, client.client_secret);\n            assertNoClientPrivateKey(client.token_endpoint_auth_method, clientPrivateKey);\n            body.set('client_id', client.client_id);\n            break;\n        }\n        default:\n            throw new UnsupportedOperationError('unsupported client token_endpoint_auth_method');\n    }\n}\nasync function jwt(header, payload, key) {\n    if (!key.usages.includes('sign')) {\n        throw new TypeError('CryptoKey instances used for signing assertions must include \"sign\" in their \"usages\"');\n    }\n    const input = `${b64u(buf(JSON.stringify(header)))}.${b64u(buf(JSON.stringify(payload)))}`;\n    const signature = b64u(await crypto.subtle.sign(keyToSubtle(key), key, buf(input)));\n    return `${input}.${signature}`;\n}\nexport async function issueRequestObject(as, client, parameters, privateKey) {\n    assertAs(as);\n    assertClient(client);\n    parameters = new URLSearchParams(parameters);\n    const { key, kid, modifyAssertion } = getKeyAndKid(privateKey);\n    if (!isPrivateKey(key)) {\n        throw new TypeError('\"privateKey.key\" must be a private CryptoKey');\n    }\n    parameters.set('client_id', client.client_id);\n    const now = epochTime() + getClockSkew(client);\n    const claims = {\n        ...Object.fromEntries(parameters.entries()),\n        jti: randomBytes(),\n        aud: as.issuer,\n        exp: now + 60,\n        iat: now,\n        nbf: now,\n        iss: client.client_id,\n    };\n    let resource;\n    if (parameters.has('resource') &&\n        (resource = parameters.getAll('resource')) &&\n        resource.length > 1) {\n        claims.resource = resource;\n    }\n    {\n        let value = parameters.get('max_age');\n        if (value !== null) {\n            claims.max_age = parseInt(value, 10);\n            if (!Number.isFinite(claims.max_age)) {\n                throw new OPE('\"max_age\" parameter must be a number');\n            }\n        }\n    }\n    {\n        let value = parameters.get('claims');\n        if (value !== null) {\n            try {\n                claims.claims = JSON.parse(value);\n            }\n            catch (cause) {\n                throw new OPE('failed to parse the \"claims\" parameter as JSON', { cause });\n            }\n            if (!isJsonObject(claims.claims)) {\n                throw new OPE('\"claims\" parameter must be a JSON with a top level object');\n            }\n        }\n    }\n    {\n        let value = parameters.get('authorization_details');\n        if (value !== null) {\n            try {\n                claims.authorization_details = JSON.parse(value);\n            }\n            catch (cause) {\n                throw new OPE('failed to parse the \"authorization_details\" parameter as JSON', { cause });\n            }\n            if (!Array.isArray(claims.authorization_details)) {\n                throw new OPE('\"authorization_details\" parameter must be a JSON with a top level array');\n            }\n        }\n    }\n    const header = {\n        alg: keyToJws(key),\n        typ: 'oauth-authz-req+jwt',\n        kid,\n    };\n    modifyAssertion?.(header, claims);\n    return jwt(header, claims, key);\n}\nasync function dpopProofJwt(headers, options, url, htm, clockSkew, accessToken) {\n    const { privateKey, publicKey, nonce = dpopNonces.get(url.origin) } = options;\n    if (!isPrivateKey(privateKey)) {\n        throw new TypeError('\"DPoP.privateKey\" must be a private CryptoKey');\n    }\n    if (!isPublicKey(publicKey)) {\n        throw new TypeError('\"DPoP.publicKey\" must be a public CryptoKey');\n    }\n    if (nonce !== undefined && !validateString(nonce)) {\n        throw new TypeError('\"DPoP.nonce\" must be a non-empty string or undefined');\n    }\n    if (!publicKey.extractable) {\n        throw new TypeError('\"DPoP.publicKey.extractable\" must be true');\n    }\n    const now = epochTime() + clockSkew;\n    const header = {\n        alg: keyToJws(privateKey),\n        typ: 'dpop+jwt',\n        jwk: await publicJwk(publicKey),\n    };\n    const payload = {\n        iat: now,\n        jti: randomBytes(),\n        htm,\n        nonce,\n        htu: `${url.origin}${url.pathname}`,\n        ath: accessToken ? b64u(await crypto.subtle.digest('SHA-256', buf(accessToken))) : undefined,\n    };\n    options[modifyAssertion]?.(header, payload);\n    headers.set('dpop', await jwt(header, payload, privateKey));\n}\nlet jwkCache;\nasync function getSetPublicJwkCache(key) {\n    const { kty, e, n, x, y, crv } = await crypto.subtle.exportKey('jwk', key);\n    const jwk = { kty, e, n, x, y, crv };\n    jwkCache.set(key, jwk);\n    return jwk;\n}\nasync function publicJwk(key) {\n    jwkCache || (jwkCache = new WeakMap());\n    return jwkCache.get(key) || getSetPublicJwkCache(key);\n}\nfunction validateEndpoint(value, endpoint, useMtlsAlias) {\n    if (typeof value !== 'string') {\n        if (useMtlsAlias) {\n            throw new TypeError(`\"as.mtls_endpoint_aliases.${endpoint}\" must be a string`);\n        }\n        throw new TypeError(`\"as.${endpoint}\" must be a string`);\n    }\n    return new URL(value);\n}\nfunction resolveEndpoint(as, endpoint, useMtlsAlias = false) {\n    if (useMtlsAlias && as.mtls_endpoint_aliases && endpoint in as.mtls_endpoint_aliases) {\n        return validateEndpoint(as.mtls_endpoint_aliases[endpoint], endpoint, useMtlsAlias);\n    }\n    return validateEndpoint(as[endpoint], endpoint, useMtlsAlias);\n}\nfunction alias(client, options) {\n    if (client.use_mtls_endpoint_aliases || options?.[useMtlsAlias]) {\n        return true;\n    }\n    return false;\n}\nexport async function pushedAuthorizationRequest(as, client, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    const url = resolveEndpoint(as, 'pushed_authorization_request_endpoint', alias(client, options));\n    const body = new URLSearchParams(parameters);\n    body.set('client_id', client.client_id);\n    const headers = prepareHeaders(options?.headers);\n    headers.set('accept', 'application/json');\n    if (options?.DPoP !== undefined) {\n        await dpopProofJwt(headers, options.DPoP, url, 'POST', getClockSkew(client));\n    }\n    return authenticatedRequest(as, client, 'POST', url, body, headers, options);\n}\nexport function isOAuth2Error(input) {\n    const value = input;\n    if (typeof value !== 'object' || Array.isArray(value) || value === null) {\n        return false;\n    }\n    return value.error !== undefined;\n}\nfunction unquote(value) {\n    if (value.length >= 2 && value[0] === '\"' && value[value.length - 1] === '\"') {\n        return value.slice(1, -1);\n    }\n    return value;\n}\nconst SPLIT_REGEXP = /((?:,|, )?[0-9a-zA-Z!#$%&'*+-.^_`|~]+=)/;\nconst SCHEMES_REGEXP = /(?:^|, ?)([0-9a-zA-Z!#$%&'*+\\-.^_`|~]+)(?=$|[ ,])/g;\nfunction wwwAuth(scheme, params) {\n    const arr = params.split(SPLIT_REGEXP).slice(1);\n    if (!arr.length) {\n        return { scheme: scheme.toLowerCase(), parameters: {} };\n    }\n    arr[arr.length - 1] = arr[arr.length - 1].replace(/,$/, '');\n    const parameters = {};\n    for (let i = 1; i < arr.length; i += 2) {\n        const idx = i;\n        if (arr[idx][0] === '\"') {\n            while (arr[idx].slice(-1) !== '\"' && ++i < arr.length) {\n                arr[idx] += arr[i];\n            }\n        }\n        const key = arr[idx - 1].replace(/^(?:, ?)|=$/g, '').toLowerCase();\n        parameters[key] = unquote(arr[idx]);\n    }\n    return {\n        scheme: scheme.toLowerCase(),\n        parameters,\n    };\n}\nexport function parseWwwAuthenticateChallenges(response) {\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    const header = response.headers.get('www-authenticate');\n    if (header === null) {\n        return undefined;\n    }\n    const result = [];\n    for (const { 1: scheme, index } of header.matchAll(SCHEMES_REGEXP)) {\n        result.push([scheme, index]);\n    }\n    if (!result.length) {\n        return undefined;\n    }\n    const challenges = result.map(([scheme, indexOf], i, others) => {\n        const next = others[i + 1];\n        let parameters;\n        if (next) {\n            parameters = header.slice(indexOf, next[1]);\n        }\n        else {\n            parameters = header.slice(indexOf);\n        }\n        return wwwAuth(scheme, parameters);\n    });\n    return challenges;\n}\nexport async function processPushedAuthorizationResponse(as, client, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 201) {\n        let err;\n        if ((err = await handleOAuthBodyError(response))) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Pushed Authorization Request Endpoint response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    }\n    catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', { cause });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.request_uri)) {\n        throw new OPE('\"response\" body \"request_uri\" property must be a non-empty string');\n    }\n    if (typeof json.expires_in !== 'number' || json.expires_in <= 0) {\n        throw new OPE('\"response\" body \"expires_in\" property must be a positive number');\n    }\n    return json;\n}\nexport async function protectedResourceRequest(accessToken, method, url, headers, body, options) {\n    if (!validateString(accessToken)) {\n        throw new TypeError('\"accessToken\" must be a non-empty string');\n    }\n    if (!(url instanceof URL)) {\n        throw new TypeError('\"url\" must be an instance of URL');\n    }\n    headers = prepareHeaders(headers);\n    if (options?.DPoP === undefined) {\n        headers.set('authorization', `Bearer ${accessToken}`);\n    }\n    else {\n        await dpopProofJwt(headers, options.DPoP, url, method.toUpperCase(), getClockSkew({ [clockSkew]: options?.[clockSkew] }), accessToken);\n        headers.set('authorization', `DPoP ${accessToken}`);\n    }\n    return (options?.[customFetch] || fetch)(url.href, {\n        body,\n        headers: Object.fromEntries(headers.entries()),\n        method,\n        redirect: 'manual',\n        signal: options?.signal ? signal(options.signal) : null,\n    }).then(processDpopNonce);\n}\nexport async function userInfoRequest(as, client, accessToken, options) {\n    assertAs(as);\n    assertClient(client);\n    const url = resolveEndpoint(as, 'userinfo_endpoint', alias(client, options));\n    const headers = prepareHeaders(options?.headers);\n    if (client.userinfo_signed_response_alg) {\n        headers.set('accept', 'application/jwt');\n    }\n    else {\n        headers.set('accept', 'application/json');\n        headers.append('accept', 'application/jwt');\n    }\n    return protectedResourceRequest(accessToken, 'GET', url, headers, null, {\n        ...options,\n        [clockSkew]: getClockSkew(client),\n    });\n}\nlet jwksMap;\nfunction setJwksCache(as, jwks, uat, cache) {\n    jwksMap || (jwksMap = new WeakMap());\n    jwksMap.set(as, {\n        jwks,\n        uat,\n        get age() {\n            return epochTime() - this.uat;\n        },\n    });\n    if (cache) {\n        Object.assign(cache, { jwks: structuredClone(jwks), uat });\n    }\n}\nfunction isFreshJwksCache(input) {\n    if (typeof input !== 'object' || input === null) {\n        return false;\n    }\n    if (!('uat' in input) || typeof input.uat !== 'number' || epochTime() - input.uat >= 300) {\n        return false;\n    }\n    if (!('jwks' in input) ||\n        !isJsonObject(input.jwks) ||\n        !Array.isArray(input.jwks.keys) ||\n        !Array.prototype.every.call(input.jwks.keys, isJsonObject)) {\n        return false;\n    }\n    return true;\n}\nfunction clearJwksCache(as, cache) {\n    jwksMap?.delete(as);\n    delete cache?.jwks;\n    delete cache?.uat;\n}\nasync function getPublicSigKeyFromIssuerJwksUri(as, options, header) {\n    const { alg, kid } = header;\n    checkSupportedJwsAlg(alg);\n    if (!jwksMap?.has(as) && isFreshJwksCache(options?.[jwksCache])) {\n        setJwksCache(as, options?.[jwksCache].jwks, options?.[jwksCache].uat);\n    }\n    let jwks;\n    let age;\n    if (jwksMap?.has(as)) {\n        ;\n        ({ jwks, age } = jwksMap.get(as));\n        if (age >= 300) {\n            clearJwksCache(as, options?.[jwksCache]);\n            return getPublicSigKeyFromIssuerJwksUri(as, options, header);\n        }\n    }\n    else {\n        jwks = await jwksRequest(as, options).then(processJwksResponse);\n        age = 0;\n        setJwksCache(as, jwks, epochTime(), options?.[jwksCache]);\n    }\n    let kty;\n    switch (alg.slice(0, 2)) {\n        case 'RS':\n        case 'PS':\n            kty = 'RSA';\n            break;\n        case 'ES':\n            kty = 'EC';\n            break;\n        case 'Ed':\n            kty = 'OKP';\n            break;\n        default:\n            throw new UnsupportedOperationError();\n    }\n    const candidates = jwks.keys.filter((jwk) => {\n        if (jwk.kty !== kty) {\n            return false;\n        }\n        if (kid !== undefined && kid !== jwk.kid) {\n            return false;\n        }\n        if (jwk.alg !== undefined && alg !== jwk.alg) {\n            return false;\n        }\n        if (jwk.use !== undefined && jwk.use !== 'sig') {\n            return false;\n        }\n        if (jwk.key_ops?.includes('verify') === false) {\n            return false;\n        }\n        switch (true) {\n            case alg === 'ES256' && jwk.crv !== 'P-256':\n            case alg === 'ES384' && jwk.crv !== 'P-384':\n            case alg === 'ES512' && jwk.crv !== 'P-521':\n            case alg === 'EdDSA' && !(jwk.crv === 'Ed25519' || jwk.crv === 'Ed448'):\n                return false;\n        }\n        return true;\n    });\n    const { 0: jwk, length } = candidates;\n    if (!length) {\n        if (age >= 60) {\n            clearJwksCache(as, options?.[jwksCache]);\n            return getPublicSigKeyFromIssuerJwksUri(as, options, header);\n        }\n        throw new OPE('error when selecting a JWT verification key, no applicable keys found');\n    }\n    if (length !== 1) {\n        throw new OPE('error when selecting a JWT verification key, multiple applicable keys found, a \"kid\" JWT Header Parameter is required');\n    }\n    const key = await importJwk(alg, jwk);\n    if (key.type !== 'public') {\n        throw new OPE('jwks_uri must only contain public keys');\n    }\n    return key;\n}\nexport const skipSubjectCheck = Symbol();\nfunction getContentType(response) {\n    return response.headers.get('content-type')?.split(';')[0];\n}\nexport async function processUserInfoResponse(as, client, expectedSubject, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        throw new OPE('\"response\" is not a conform UserInfo Endpoint response');\n    }\n    let json;\n    if (getContentType(response) === 'application/jwt') {\n        assertReadableResponse(response);\n        const { claims, jwt } = await validateJwt(await response.text(), checkSigningAlgorithm.bind(undefined, client.userinfo_signed_response_alg, as.userinfo_signing_alg_values_supported), noSignatureCheck, getClockSkew(client), getClockTolerance(client), client[jweDecrypt])\n            .then(validateOptionalAudience.bind(undefined, client.client_id))\n            .then(validateOptionalIssuer.bind(undefined, as.issuer));\n        jwtResponseBodies.set(response, jwt);\n        json = claims;\n    }\n    else {\n        if (client.userinfo_signed_response_alg) {\n            throw new OPE('JWT UserInfo Response expected');\n        }\n        assertReadableResponse(response);\n        try {\n            json = await response.json();\n        }\n        catch (cause) {\n            throw new OPE('failed to parse \"response\" body as JSON', { cause });\n        }\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.sub)) {\n        throw new OPE('\"response\" body \"sub\" property must be a non-empty string');\n    }\n    switch (expectedSubject) {\n        case skipSubjectCheck:\n            break;\n        default:\n            if (!validateString(expectedSubject)) {\n                throw new OPE('\"expectedSubject\" must be a non-empty string');\n            }\n            if (json.sub !== expectedSubject) {\n                throw new OPE('unexpected \"response\" body \"sub\" value');\n            }\n    }\n    return json;\n}\nasync function authenticatedRequest(as, client, method, url, body, headers, options) {\n    await clientAuthentication(as, client, body, headers, options?.clientPrivateKey);\n    headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n    return (options?.[customFetch] || fetch)(url.href, {\n        body,\n        headers: Object.fromEntries(headers.entries()),\n        method,\n        redirect: 'manual',\n        signal: options?.signal ? signal(options.signal) : null,\n    }).then(processDpopNonce);\n}\nasync function tokenEndpointRequest(as, client, grantType, parameters, options) {\n    const url = resolveEndpoint(as, 'token_endpoint', alias(client, options));\n    parameters.set('grant_type', grantType);\n    const headers = prepareHeaders(options?.headers);\n    headers.set('accept', 'application/json');\n    if (options?.DPoP !== undefined) {\n        await dpopProofJwt(headers, options.DPoP, url, 'POST', getClockSkew(client));\n    }\n    return authenticatedRequest(as, client, 'POST', url, parameters, headers, options);\n}\nexport async function refreshTokenGrantRequest(as, client, refreshToken, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!validateString(refreshToken)) {\n        throw new TypeError('\"refreshToken\" must be a non-empty string');\n    }\n    const parameters = new URLSearchParams(options?.additionalParameters);\n    parameters.set('refresh_token', refreshToken);\n    return tokenEndpointRequest(as, client, 'refresh_token', parameters, options);\n}\nconst idTokenClaims = new WeakMap();\nconst jwtResponseBodies = new WeakMap();\nexport function getValidatedIdTokenClaims(ref) {\n    if (!ref.id_token) {\n        return undefined;\n    }\n    const claims = idTokenClaims.get(ref);\n    if (!claims) {\n        throw new TypeError('\"ref\" was already garbage collected or did not resolve from the proper sources');\n    }\n    return claims[0];\n}\nexport async function validateIdTokenSignature(as, ref, options) {\n    assertAs(as);\n    if (!idTokenClaims.has(ref)) {\n        throw new OPE('\"ref\" does not contain an ID Token to verify the signature of');\n    }\n    const { 0: protectedHeader, 1: payload, 2: encodedSignature, } = idTokenClaims.get(ref)[1].split('.');\n    const header = JSON.parse(buf(b64u(protectedHeader)));\n    if (header.alg.startsWith('HS')) {\n        throw new UnsupportedOperationError();\n    }\n    let key;\n    key = await getPublicSigKeyFromIssuerJwksUri(as, options, header);\n    await validateJwsSignature(protectedHeader, payload, key, b64u(encodedSignature));\n}\nasync function validateJwtResponseSignature(as, ref, options) {\n    assertAs(as);\n    if (!jwtResponseBodies.has(ref)) {\n        throw new OPE('\"ref\" does not contain a processed JWT Response to verify the signature of');\n    }\n    const { 0: protectedHeader, 1: payload, 2: encodedSignature, } = jwtResponseBodies.get(ref).split('.');\n    const header = JSON.parse(buf(b64u(protectedHeader)));\n    if (header.alg.startsWith('HS')) {\n        throw new UnsupportedOperationError();\n    }\n    let key;\n    key = await getPublicSigKeyFromIssuerJwksUri(as, options, header);\n    await validateJwsSignature(protectedHeader, payload, key, b64u(encodedSignature));\n}\nexport function validateJwtUserInfoSignature(as, ref, options) {\n    return validateJwtResponseSignature(as, ref, options);\n}\nexport function validateJwtIntrospectionSignature(as, ref, options) {\n    return validateJwtResponseSignature(as, ref, options);\n}\nasync function processGenericAccessTokenResponse(as, client, response, ignoreIdToken = false, ignoreRefreshToken = false) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        let err;\n        if ((err = await handleOAuthBodyError(response))) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Token Endpoint response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    }\n    catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', { cause });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.access_token)) {\n        throw new OPE('\"response\" body \"access_token\" property must be a non-empty string');\n    }\n    if (!validateString(json.token_type)) {\n        throw new OPE('\"response\" body \"token_type\" property must be a non-empty string');\n    }\n    json.token_type = json.token_type.toLowerCase();\n    if (json.token_type !== 'dpop' && json.token_type !== 'bearer') {\n        throw new UnsupportedOperationError('unsupported `token_type` value');\n    }\n    if (json.expires_in !== undefined &&\n        (typeof json.expires_in !== 'number' || json.expires_in <= 0)) {\n        throw new OPE('\"response\" body \"expires_in\" property must be a positive number');\n    }\n    if (!ignoreRefreshToken &&\n        json.refresh_token !== undefined &&\n        !validateString(json.refresh_token)) {\n        throw new OPE('\"response\" body \"refresh_token\" property must be a non-empty string');\n    }\n    if (json.scope !== undefined && typeof json.scope !== 'string') {\n        throw new OPE('\"response\" body \"scope\" property must be a string');\n    }\n    if (!ignoreIdToken) {\n        if (json.id_token !== undefined && !validateString(json.id_token)) {\n            throw new OPE('\"response\" body \"id_token\" property must be a non-empty string');\n        }\n        if (json.id_token) {\n            const { claims, jwt } = await validateJwt(json.id_token, checkSigningAlgorithm.bind(undefined, client.id_token_signed_response_alg, as.id_token_signing_alg_values_supported), noSignatureCheck, getClockSkew(client), getClockTolerance(client), client[jweDecrypt])\n                .then(validatePresence.bind(undefined, ['aud', 'exp', 'iat', 'iss', 'sub']))\n                .then(validateIssuer.bind(undefined, as.issuer))\n                .then(validateAudience.bind(undefined, client.client_id));\n            if (Array.isArray(claims.aud) && claims.aud.length !== 1) {\n                if (claims.azp === undefined) {\n                    throw new OPE('ID Token \"aud\" (audience) claim includes additional untrusted audiences');\n                }\n                if (claims.azp !== client.client_id) {\n                    throw new OPE('unexpected ID Token \"azp\" (authorized party) claim value');\n                }\n            }\n            if (claims.auth_time !== undefined &&\n                (!Number.isFinite(claims.auth_time) || Math.sign(claims.auth_time) !== 1)) {\n                throw new OPE('ID Token \"auth_time\" (authentication time) must be a positive number');\n            }\n            idTokenClaims.set(json, [claims, jwt]);\n        }\n    }\n    return json;\n}\nexport async function processRefreshTokenResponse(as, client, response) {\n    return processGenericAccessTokenResponse(as, client, response);\n}\nfunction validateOptionalAudience(expected, result) {\n    if (result.claims.aud !== undefined) {\n        return validateAudience(expected, result);\n    }\n    return result;\n}\nfunction validateAudience(expected, result) {\n    if (Array.isArray(result.claims.aud)) {\n        if (!result.claims.aud.includes(expected)) {\n            throw new OPE('unexpected JWT \"aud\" (audience) claim value');\n        }\n    }\n    else if (result.claims.aud !== expected) {\n        throw new OPE('unexpected JWT \"aud\" (audience) claim value');\n    }\n    return result;\n}\nfunction validateOptionalIssuer(expected, result) {\n    if (result.claims.iss !== undefined) {\n        return validateIssuer(expected, result);\n    }\n    return result;\n}\nfunction validateIssuer(expected, result) {\n    if (result.claims.iss !== expected) {\n        throw new OPE('unexpected JWT \"iss\" (issuer) claim value');\n    }\n    return result;\n}\nconst branded = new WeakSet();\nfunction brand(searchParams) {\n    branded.add(searchParams);\n    return searchParams;\n}\nexport async function authorizationCodeGrantRequest(as, client, callbackParameters, redirectUri, codeVerifier, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!branded.has(callbackParameters)) {\n        throw new TypeError('\"callbackParameters\" must be an instance of URLSearchParams obtained from \"validateAuthResponse()\", or \"validateJwtAuthResponse()');\n    }\n    if (!validateString(redirectUri)) {\n        throw new TypeError('\"redirectUri\" must be a non-empty string');\n    }\n    if (!validateString(codeVerifier)) {\n        throw new TypeError('\"codeVerifier\" must be a non-empty string');\n    }\n    const code = getURLSearchParameter(callbackParameters, 'code');\n    if (!code) {\n        throw new OPE('no authorization code in \"callbackParameters\"');\n    }\n    const parameters = new URLSearchParams(options?.additionalParameters);\n    parameters.set('redirect_uri', redirectUri);\n    parameters.set('code_verifier', codeVerifier);\n    parameters.set('code', code);\n    return tokenEndpointRequest(as, client, 'authorization_code', parameters, options);\n}\nconst jwtClaimNames = {\n    aud: 'audience',\n    c_hash: 'code hash',\n    client_id: 'client id',\n    exp: 'expiration time',\n    iat: 'issued at',\n    iss: 'issuer',\n    jti: 'jwt id',\n    nonce: 'nonce',\n    s_hash: 'state hash',\n    sub: 'subject',\n    ath: 'access token hash',\n    htm: 'http method',\n    htu: 'http uri',\n    cnf: 'confirmation',\n};\nfunction validatePresence(required, result) {\n    for (const claim of required) {\n        if (result.claims[claim] === undefined) {\n            throw new OPE(`JWT \"${claim}\" (${jwtClaimNames[claim]}) claim missing`);\n        }\n    }\n    return result;\n}\nexport const expectNoNonce = Symbol();\nexport const skipAuthTimeCheck = Symbol();\nexport async function processAuthorizationCodeOpenIDResponse(as, client, response, expectedNonce, maxAge) {\n    const result = await processGenericAccessTokenResponse(as, client, response);\n    if (isOAuth2Error(result)) {\n        return result;\n    }\n    if (!validateString(result.id_token)) {\n        throw new OPE('\"response\" body \"id_token\" property must be a non-empty string');\n    }\n    maxAge ?? (maxAge = client.default_max_age ?? skipAuthTimeCheck);\n    const claims = getValidatedIdTokenClaims(result);\n    if ((client.require_auth_time || maxAge !== skipAuthTimeCheck) &&\n        claims.auth_time === undefined) {\n        throw new OPE('ID Token \"auth_time\" (authentication time) claim missing');\n    }\n    if (maxAge !== skipAuthTimeCheck) {\n        if (typeof maxAge !== 'number' || maxAge < 0) {\n            throw new TypeError('\"maxAge\" must be a non-negative number');\n        }\n        const now = epochTime() + getClockSkew(client);\n        const tolerance = getClockTolerance(client);\n        if (claims.auth_time + maxAge < now - tolerance) {\n            throw new OPE('too much time has elapsed since the last End-User authentication');\n        }\n    }\n    switch (expectedNonce) {\n        case undefined:\n        case expectNoNonce:\n            if (claims.nonce !== undefined) {\n                throw new OPE('unexpected ID Token \"nonce\" claim value');\n            }\n            break;\n        default:\n            if (!validateString(expectedNonce)) {\n                throw new TypeError('\"expectedNonce\" must be a non-empty string');\n            }\n            if (claims.nonce === undefined) {\n                throw new OPE('ID Token \"nonce\" claim missing');\n            }\n            if (claims.nonce !== expectedNonce) {\n                throw new OPE('unexpected ID Token \"nonce\" claim value');\n            }\n    }\n    return result;\n}\nexport async function processAuthorizationCodeOAuth2Response(as, client, response) {\n    const result = await processGenericAccessTokenResponse(as, client, response, true);\n    if (isOAuth2Error(result)) {\n        return result;\n    }\n    if (result.id_token !== undefined) {\n        if (typeof result.id_token === 'string' && result.id_token.length) {\n            throw new OPE('Unexpected ID Token returned, use processAuthorizationCodeOpenIDResponse() for OpenID Connect callback processing');\n        }\n        delete result.id_token;\n    }\n    return result;\n}\nfunction checkJwtType(expected, result) {\n    if (typeof result.header.typ !== 'string' || normalizeTyp(result.header.typ) !== expected) {\n        throw new OPE('unexpected JWT \"typ\" header parameter value');\n    }\n    return result;\n}\nexport async function clientCredentialsGrantRequest(as, client, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    return tokenEndpointRequest(as, client, 'client_credentials', new URLSearchParams(parameters), options);\n}\nexport async function genericTokenEndpointRequest(as, client, grantType, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!validateString(grantType)) {\n        throw new TypeError('\"grantType\" must be a non-empty string');\n    }\n    return tokenEndpointRequest(as, client, grantType, new URLSearchParams(parameters), options);\n}\nexport async function processClientCredentialsResponse(as, client, response) {\n    const result = await processGenericAccessTokenResponse(as, client, response, true, true);\n    if (isOAuth2Error(result)) {\n        return result;\n    }\n    return result;\n}\nexport async function revocationRequest(as, client, token, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!validateString(token)) {\n        throw new TypeError('\"token\" must be a non-empty string');\n    }\n    const url = resolveEndpoint(as, 'revocation_endpoint', alias(client, options));\n    const body = new URLSearchParams(options?.additionalParameters);\n    body.set('token', token);\n    const headers = prepareHeaders(options?.headers);\n    headers.delete('accept');\n    return authenticatedRequest(as, client, 'POST', url, body, headers, options);\n}\nexport async function processRevocationResponse(response) {\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        let err;\n        if ((err = await handleOAuthBodyError(response))) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Revocation Endpoint response');\n    }\n    return undefined;\n}\nfunction assertReadableResponse(response) {\n    if (response.bodyUsed) {\n        throw new TypeError('\"response\" body has been used already');\n    }\n}\nexport async function introspectionRequest(as, client, token, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!validateString(token)) {\n        throw new TypeError('\"token\" must be a non-empty string');\n    }\n    const url = resolveEndpoint(as, 'introspection_endpoint', alias(client, options));\n    const body = new URLSearchParams(options?.additionalParameters);\n    body.set('token', token);\n    const headers = prepareHeaders(options?.headers);\n    if (options?.requestJwtResponse ?? client.introspection_signed_response_alg) {\n        headers.set('accept', 'application/token-introspection+jwt');\n    }\n    else {\n        headers.set('accept', 'application/json');\n    }\n    return authenticatedRequest(as, client, 'POST', url, body, headers, options);\n}\nexport async function processIntrospectionResponse(as, client, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        let err;\n        if ((err = await handleOAuthBodyError(response))) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Introspection Endpoint response');\n    }\n    let json;\n    if (getContentType(response) === 'application/token-introspection+jwt') {\n        assertReadableResponse(response);\n        const { claims, jwt } = await validateJwt(await response.text(), checkSigningAlgorithm.bind(undefined, client.introspection_signed_response_alg, as.introspection_signing_alg_values_supported), noSignatureCheck, getClockSkew(client), getClockTolerance(client), client[jweDecrypt])\n            .then(checkJwtType.bind(undefined, 'token-introspection+jwt'))\n            .then(validatePresence.bind(undefined, ['aud', 'iat', 'iss']))\n            .then(validateIssuer.bind(undefined, as.issuer))\n            .then(validateAudience.bind(undefined, client.client_id));\n        jwtResponseBodies.set(response, jwt);\n        json = claims.token_introspection;\n        if (!isJsonObject(json)) {\n            throw new OPE('JWT \"token_introspection\" claim must be a JSON object');\n        }\n    }\n    else {\n        assertReadableResponse(response);\n        try {\n            json = await response.json();\n        }\n        catch (cause) {\n            throw new OPE('failed to parse \"response\" body as JSON', { cause });\n        }\n        if (!isJsonObject(json)) {\n            throw new OPE('\"response\" body must be a top level object');\n        }\n    }\n    if (typeof json.active !== 'boolean') {\n        throw new OPE('\"response\" body \"active\" property must be a boolean');\n    }\n    return json;\n}\nasync function jwksRequest(as, options) {\n    assertAs(as);\n    const url = resolveEndpoint(as, 'jwks_uri');\n    const headers = prepareHeaders(options?.headers);\n    headers.set('accept', 'application/json');\n    headers.append('accept', 'application/jwk-set+json');\n    return (options?.[customFetch] || fetch)(url.href, {\n        headers: Object.fromEntries(headers.entries()),\n        method: 'GET',\n        redirect: 'manual',\n        signal: options?.signal ? signal(options.signal) : null,\n    }).then(processDpopNonce);\n}\nasync function processJwksResponse(response) {\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        throw new OPE('\"response\" is not a conform JSON Web Key Set response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    }\n    catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', { cause });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!Array.isArray(json.keys)) {\n        throw new OPE('\"response\" body \"keys\" property must be an array');\n    }\n    if (!Array.prototype.every.call(json.keys, isJsonObject)) {\n        throw new OPE('\"response\" body \"keys\" property members must be JWK formatted objects');\n    }\n    return json;\n}\nasync function handleOAuthBodyError(response) {\n    if (response.status > 399 && response.status < 500) {\n        assertReadableResponse(response);\n        try {\n            const json = await response.json();\n            if (isJsonObject(json) && typeof json.error === 'string' && json.error.length) {\n                if (json.error_description !== undefined && typeof json.error_description !== 'string') {\n                    delete json.error_description;\n                }\n                if (json.error_uri !== undefined && typeof json.error_uri !== 'string') {\n                    delete json.error_uri;\n                }\n                if (json.algs !== undefined && typeof json.algs !== 'string') {\n                    delete json.algs;\n                }\n                if (json.scope !== undefined && typeof json.scope !== 'string') {\n                    delete json.scope;\n                }\n                return json;\n            }\n        }\n        catch { }\n    }\n    return undefined;\n}\nfunction checkSupportedJwsAlg(alg) {\n    if (!SUPPORTED_JWS_ALGS.includes(alg)) {\n        throw new UnsupportedOperationError('unsupported JWS \"alg\" identifier');\n    }\n    return alg;\n}\nfunction checkRsaKeyAlgorithm(algorithm) {\n    if (typeof algorithm.modulusLength !== 'number' || algorithm.modulusLength < 2048) {\n        throw new OPE(`${algorithm.name} modulusLength must be at least 2048 bits`);\n    }\n}\nfunction ecdsaHashName(namedCurve) {\n    switch (namedCurve) {\n        case 'P-256':\n            return 'SHA-256';\n        case 'P-384':\n            return 'SHA-384';\n        case 'P-521':\n            return 'SHA-512';\n        default:\n            throw new UnsupportedOperationError();\n    }\n}\nfunction keyToSubtle(key) {\n    switch (key.algorithm.name) {\n        case 'ECDSA':\n            return {\n                name: key.algorithm.name,\n                hash: ecdsaHashName(key.algorithm.namedCurve),\n            };\n        case 'RSA-PSS': {\n            checkRsaKeyAlgorithm(key.algorithm);\n            switch (key.algorithm.hash.name) {\n                case 'SHA-256':\n                case 'SHA-384':\n                case 'SHA-512':\n                    return {\n                        name: key.algorithm.name,\n                        saltLength: parseInt(key.algorithm.hash.name.slice(-3), 10) >> 3,\n                    };\n                default:\n                    throw new UnsupportedOperationError();\n            }\n        }\n        case 'RSASSA-PKCS1-v1_5':\n            checkRsaKeyAlgorithm(key.algorithm);\n            return key.algorithm.name;\n        case 'Ed448':\n        case 'Ed25519':\n            return key.algorithm.name;\n    }\n    throw new UnsupportedOperationError();\n}\nconst noSignatureCheck = Symbol();\nasync function validateJwsSignature(protectedHeader, payload, key, signature) {\n    const input = `${protectedHeader}.${payload}`;\n    const verified = await crypto.subtle.verify(keyToSubtle(key), key, signature, buf(input));\n    if (!verified) {\n        throw new OPE('JWT signature verification failed');\n    }\n}\nasync function validateJwt(jws, checkAlg, getKey, clockSkew, clockTolerance, decryptJwt) {\n    let { 0: protectedHeader, 1: payload, 2: encodedSignature, length } = jws.split('.');\n    if (length === 5) {\n        if (decryptJwt !== undefined) {\n            jws = await decryptJwt(jws);\n            ({ 0: protectedHeader, 1: payload, 2: encodedSignature, length } = jws.split('.'));\n        }\n        else {\n            throw new UnsupportedOperationError('JWE structure JWTs are not supported');\n        }\n    }\n    if (length !== 3) {\n        throw new OPE('Invalid JWT');\n    }\n    let header;\n    try {\n        header = JSON.parse(buf(b64u(protectedHeader)));\n    }\n    catch (cause) {\n        throw new OPE('failed to parse JWT Header body as base64url encoded JSON', { cause });\n    }\n    if (!isJsonObject(header)) {\n        throw new OPE('JWT Header must be a top level object');\n    }\n    checkAlg(header);\n    if (header.crit !== undefined) {\n        throw new OPE('unexpected JWT \"crit\" header parameter');\n    }\n    const signature = b64u(encodedSignature);\n    let key;\n    if (getKey !== noSignatureCheck) {\n        key = await getKey(header);\n        await validateJwsSignature(protectedHeader, payload, key, signature);\n    }\n    let claims;\n    try {\n        claims = JSON.parse(buf(b64u(payload)));\n    }\n    catch (cause) {\n        throw new OPE('failed to parse JWT Payload body as base64url encoded JSON', { cause });\n    }\n    if (!isJsonObject(claims)) {\n        throw new OPE('JWT Payload must be a top level object');\n    }\n    const now = epochTime() + clockSkew;\n    if (claims.exp !== undefined) {\n        if (typeof claims.exp !== 'number') {\n            throw new OPE('unexpected JWT \"exp\" (expiration time) claim type');\n        }\n        if (claims.exp <= now - clockTolerance) {\n            throw new OPE('unexpected JWT \"exp\" (expiration time) claim value, timestamp is <= now()');\n        }\n    }\n    if (claims.iat !== undefined) {\n        if (typeof claims.iat !== 'number') {\n            throw new OPE('unexpected JWT \"iat\" (issued at) claim type');\n        }\n    }\n    if (claims.iss !== undefined) {\n        if (typeof claims.iss !== 'string') {\n            throw new OPE('unexpected JWT \"iss\" (issuer) claim type');\n        }\n    }\n    if (claims.nbf !== undefined) {\n        if (typeof claims.nbf !== 'number') {\n            throw new OPE('unexpected JWT \"nbf\" (not before) claim type');\n        }\n        if (claims.nbf > now + clockTolerance) {\n            throw new OPE('unexpected JWT \"nbf\" (not before) claim value, timestamp is > now()');\n        }\n    }\n    if (claims.aud !== undefined) {\n        if (typeof claims.aud !== 'string' && !Array.isArray(claims.aud)) {\n            throw new OPE('unexpected JWT \"aud\" (audience) claim type');\n        }\n    }\n    return { header, claims, signature, key, jwt: jws };\n}\nexport async function validateJwtAuthResponse(as, client, parameters, expectedState, options) {\n    assertAs(as);\n    assertClient(client);\n    if (parameters instanceof URL) {\n        parameters = parameters.searchParams;\n    }\n    if (!(parameters instanceof URLSearchParams)) {\n        throw new TypeError('\"parameters\" must be an instance of URLSearchParams, or URL');\n    }\n    const response = getURLSearchParameter(parameters, 'response');\n    if (!response) {\n        throw new OPE('\"parameters\" does not contain a JARM response');\n    }\n    const { claims } = await validateJwt(response, checkSigningAlgorithm.bind(undefined, client.authorization_signed_response_alg, as.authorization_signing_alg_values_supported), getPublicSigKeyFromIssuerJwksUri.bind(undefined, as, options), getClockSkew(client), getClockTolerance(client), client[jweDecrypt])\n        .then(validatePresence.bind(undefined, ['aud', 'exp', 'iss']))\n        .then(validateIssuer.bind(undefined, as.issuer))\n        .then(validateAudience.bind(undefined, client.client_id));\n    const result = new URLSearchParams();\n    for (const [key, value] of Object.entries(claims)) {\n        if (typeof value === 'string' && key !== 'aud') {\n            result.set(key, value);\n        }\n    }\n    return validateAuthResponse(as, client, result, expectedState);\n}\nasync function idTokenHash(alg, data, key) {\n    let algorithm;\n    switch (alg) {\n        case 'RS256':\n        case 'PS256':\n        case 'ES256':\n            algorithm = 'SHA-256';\n            break;\n        case 'RS384':\n        case 'PS384':\n        case 'ES384':\n            algorithm = 'SHA-384';\n            break;\n        case 'RS512':\n        case 'PS512':\n        case 'ES512':\n            algorithm = 'SHA-512';\n            break;\n        case 'EdDSA':\n            if (key.algorithm.name === 'Ed25519') {\n                algorithm = 'SHA-512';\n                break;\n            }\n            throw new UnsupportedOperationError();\n        default:\n            throw new UnsupportedOperationError();\n    }\n    const digest = await crypto.subtle.digest(algorithm, buf(data));\n    return b64u(digest.slice(0, digest.byteLength / 2));\n}\nasync function idTokenHashMatches(data, actual, alg, key) {\n    const expected = await idTokenHash(alg, data, key);\n    return actual === expected;\n}\nexport async function validateDetachedSignatureResponse(as, client, parameters, expectedNonce, expectedState, maxAge, options) {\n    assertAs(as);\n    assertClient(client);\n    if (parameters instanceof URL) {\n        if (!parameters.hash.length) {\n            throw new TypeError('\"parameters\" as an instance of URL must contain a hash (fragment) with the Authorization Response parameters');\n        }\n        parameters = new URLSearchParams(parameters.hash.slice(1));\n    }\n    if (!(parameters instanceof URLSearchParams)) {\n        throw new TypeError('\"parameters\" must be an instance of URLSearchParams');\n    }\n    parameters = new URLSearchParams(parameters);\n    const id_token = getURLSearchParameter(parameters, 'id_token');\n    parameters.delete('id_token');\n    switch (expectedState) {\n        case undefined:\n        case expectNoState:\n            break;\n        default:\n            if (!validateString(expectedState)) {\n                throw new TypeError('\"expectedState\" must be a non-empty string');\n            }\n    }\n    const result = validateAuthResponse({\n        ...as,\n        authorization_response_iss_parameter_supported: false,\n    }, client, parameters, expectedState);\n    if (isOAuth2Error(result)) {\n        return result;\n    }\n    if (!id_token) {\n        throw new OPE('\"parameters\" does not contain an ID Token');\n    }\n    const code = getURLSearchParameter(parameters, 'code');\n    if (!code) {\n        throw new OPE('\"parameters\" does not contain an Authorization Code');\n    }\n    const requiredClaims = [\n        'aud',\n        'exp',\n        'iat',\n        'iss',\n        'sub',\n        'nonce',\n        'c_hash',\n    ];\n    if (typeof expectedState === 'string') {\n        requiredClaims.push('s_hash');\n    }\n    const { claims, header, key } = await validateJwt(id_token, checkSigningAlgorithm.bind(undefined, client.id_token_signed_response_alg, as.id_token_signing_alg_values_supported), getPublicSigKeyFromIssuerJwksUri.bind(undefined, as, options), getClockSkew(client), getClockTolerance(client), client[jweDecrypt])\n        .then(validatePresence.bind(undefined, requiredClaims))\n        .then(validateIssuer.bind(undefined, as.issuer))\n        .then(validateAudience.bind(undefined, client.client_id));\n    const clockSkew = getClockSkew(client);\n    const now = epochTime() + clockSkew;\n    if (claims.iat < now - 3600) {\n        throw new OPE('unexpected JWT \"iat\" (issued at) claim value, it is too far in the past');\n    }\n    if (typeof claims.c_hash !== 'string' ||\n        (await idTokenHashMatches(code, claims.c_hash, header.alg, key)) !== true) {\n        throw new OPE('invalid ID Token \"c_hash\" (code hash) claim value');\n    }\n    if (claims.s_hash !== undefined && typeof expectedState !== 'string') {\n        throw new OPE('could not verify ID Token \"s_hash\" (state hash) claim value');\n    }\n    if (typeof expectedState === 'string' &&\n        (typeof claims.s_hash !== 'string' ||\n            (await idTokenHashMatches(expectedState, claims.s_hash, header.alg, key)) !== true)) {\n        throw new OPE('invalid ID Token \"s_hash\" (state hash) claim value');\n    }\n    if (claims.auth_time !== undefined &&\n        (!Number.isFinite(claims.auth_time) || Math.sign(claims.auth_time) !== 1)) {\n        throw new OPE('ID Token \"auth_time\" (authentication time) must be a positive number');\n    }\n    maxAge ?? (maxAge = client.default_max_age ?? skipAuthTimeCheck);\n    if ((client.require_auth_time || maxAge !== skipAuthTimeCheck) &&\n        claims.auth_time === undefined) {\n        throw new OPE('ID Token \"auth_time\" (authentication time) claim missing');\n    }\n    if (maxAge !== skipAuthTimeCheck) {\n        if (typeof maxAge !== 'number' || maxAge < 0) {\n            throw new TypeError('\"maxAge\" must be a non-negative number');\n        }\n        const now = epochTime() + getClockSkew(client);\n        const tolerance = getClockTolerance(client);\n        if (claims.auth_time + maxAge < now - tolerance) {\n            throw new OPE('too much time has elapsed since the last End-User authentication');\n        }\n    }\n    if (!validateString(expectedNonce)) {\n        throw new TypeError('\"expectedNonce\" must be a non-empty string');\n    }\n    if (claims.nonce !== expectedNonce) {\n        throw new OPE('unexpected ID Token \"nonce\" claim value');\n    }\n    if (Array.isArray(claims.aud) && claims.aud.length !== 1) {\n        if (claims.azp === undefined) {\n            throw new OPE('ID Token \"aud\" (audience) claim includes additional untrusted audiences');\n        }\n        if (claims.azp !== client.client_id) {\n            throw new OPE('unexpected ID Token \"azp\" (authorized party) claim value');\n        }\n    }\n    return result;\n}\nfunction checkSigningAlgorithm(client, issuer, header) {\n    if (client !== undefined) {\n        if (header.alg !== client) {\n            throw new OPE('unexpected JWT \"alg\" header parameter');\n        }\n        return;\n    }\n    if (Array.isArray(issuer)) {\n        if (!issuer.includes(header.alg)) {\n            throw new OPE('unexpected JWT \"alg\" header parameter');\n        }\n        return;\n    }\n    if (header.alg !== 'RS256') {\n        throw new OPE('unexpected JWT \"alg\" header parameter');\n    }\n}\nfunction getURLSearchParameter(parameters, name) {\n    const { 0: value, length } = parameters.getAll(name);\n    if (length > 1) {\n        throw new OPE(`\"${name}\" parameter must be provided only once`);\n    }\n    return value;\n}\nexport const skipStateCheck = Symbol();\nexport const expectNoState = Symbol();\nexport function validateAuthResponse(as, client, parameters, expectedState) {\n    assertAs(as);\n    assertClient(client);\n    if (parameters instanceof URL) {\n        parameters = parameters.searchParams;\n    }\n    if (!(parameters instanceof URLSearchParams)) {\n        throw new TypeError('\"parameters\" must be an instance of URLSearchParams, or URL');\n    }\n    if (getURLSearchParameter(parameters, 'response')) {\n        throw new OPE('\"parameters\" contains a JARM response, use validateJwtAuthResponse() instead of validateAuthResponse()');\n    }\n    const iss = getURLSearchParameter(parameters, 'iss');\n    const state = getURLSearchParameter(parameters, 'state');\n    if (!iss && as.authorization_response_iss_parameter_supported) {\n        throw new OPE('response parameter \"iss\" (issuer) missing');\n    }\n    if (iss && iss !== as.issuer) {\n        throw new OPE('unexpected \"iss\" (issuer) response parameter value');\n    }\n    switch (expectedState) {\n        case undefined:\n        case expectNoState:\n            if (state !== undefined) {\n                throw new OPE('unexpected \"state\" response parameter encountered');\n            }\n            break;\n        case skipStateCheck:\n            break;\n        default:\n            if (!validateString(expectedState)) {\n                throw new OPE('\"expectedState\" must be a non-empty string');\n            }\n            if (state === undefined) {\n                throw new OPE('response parameter \"state\" missing');\n            }\n            if (state !== expectedState) {\n                throw new OPE('unexpected \"state\" response parameter value');\n            }\n    }\n    const error = getURLSearchParameter(parameters, 'error');\n    if (error) {\n        return {\n            error,\n            error_description: getURLSearchParameter(parameters, 'error_description'),\n            error_uri: getURLSearchParameter(parameters, 'error_uri'),\n        };\n    }\n    const id_token = getURLSearchParameter(parameters, 'id_token');\n    const token = getURLSearchParameter(parameters, 'token');\n    if (id_token !== undefined || token !== undefined) {\n        throw new UnsupportedOperationError('implicit and hybrid flows are not supported');\n    }\n    return brand(new URLSearchParams(parameters));\n}\nfunction algToSubtle(alg, crv) {\n    switch (alg) {\n        case 'PS256':\n        case 'PS384':\n        case 'PS512':\n            return { name: 'RSA-PSS', hash: `SHA-${alg.slice(-3)}` };\n        case 'RS256':\n        case 'RS384':\n        case 'RS512':\n            return { name: 'RSASSA-PKCS1-v1_5', hash: `SHA-${alg.slice(-3)}` };\n        case 'ES256':\n        case 'ES384':\n            return { name: 'ECDSA', namedCurve: `P-${alg.slice(-3)}` };\n        case 'ES512':\n            return { name: 'ECDSA', namedCurve: 'P-521' };\n        case 'EdDSA': {\n            switch (crv) {\n                case 'Ed25519':\n                case 'Ed448':\n                    return crv;\n                default:\n                    throw new UnsupportedOperationError();\n            }\n        }\n        default:\n            throw new UnsupportedOperationError();\n    }\n}\nasync function importJwk(alg, jwk) {\n    const { ext, key_ops, use, ...key } = jwk;\n    return crypto.subtle.importKey('jwk', key, algToSubtle(alg, jwk.crv), true, ['verify']);\n}\nexport async function deviceAuthorizationRequest(as, client, parameters, options) {\n    assertAs(as);\n    assertClient(client);\n    const url = resolveEndpoint(as, 'device_authorization_endpoint', alias(client, options));\n    const body = new URLSearchParams(parameters);\n    body.set('client_id', client.client_id);\n    const headers = prepareHeaders(options?.headers);\n    headers.set('accept', 'application/json');\n    return authenticatedRequest(as, client, 'POST', url, body, headers, options);\n}\nexport async function processDeviceAuthorizationResponse(as, client, response) {\n    assertAs(as);\n    assertClient(client);\n    if (!looseInstanceOf(response, Response)) {\n        throw new TypeError('\"response\" must be an instance of Response');\n    }\n    if (response.status !== 200) {\n        let err;\n        if ((err = await handleOAuthBodyError(response))) {\n            return err;\n        }\n        throw new OPE('\"response\" is not a conform Device Authorization Endpoint response');\n    }\n    assertReadableResponse(response);\n    let json;\n    try {\n        json = await response.json();\n    }\n    catch (cause) {\n        throw new OPE('failed to parse \"response\" body as JSON', { cause });\n    }\n    if (!isJsonObject(json)) {\n        throw new OPE('\"response\" body must be a top level object');\n    }\n    if (!validateString(json.device_code)) {\n        throw new OPE('\"response\" body \"device_code\" property must be a non-empty string');\n    }\n    if (!validateString(json.user_code)) {\n        throw new OPE('\"response\" body \"user_code\" property must be a non-empty string');\n    }\n    if (!validateString(json.verification_uri)) {\n        throw new OPE('\"response\" body \"verification_uri\" property must be a non-empty string');\n    }\n    if (typeof json.expires_in !== 'number' || json.expires_in <= 0) {\n        throw new OPE('\"response\" body \"expires_in\" property must be a positive number');\n    }\n    if (json.verification_uri_complete !== undefined &&\n        !validateString(json.verification_uri_complete)) {\n        throw new OPE('\"response\" body \"verification_uri_complete\" property must be a non-empty string');\n    }\n    if (json.interval !== undefined && (typeof json.interval !== 'number' || json.interval <= 0)) {\n        throw new OPE('\"response\" body \"interval\" property must be a positive number');\n    }\n    return json;\n}\nexport async function deviceCodeGrantRequest(as, client, deviceCode, options) {\n    assertAs(as);\n    assertClient(client);\n    if (!validateString(deviceCode)) {\n        throw new TypeError('\"deviceCode\" must be a non-empty string');\n    }\n    const parameters = new URLSearchParams(options?.additionalParameters);\n    parameters.set('device_code', deviceCode);\n    return tokenEndpointRequest(as, client, 'urn:ietf:params:oauth:grant-type:device_code', parameters, options);\n}\nexport async function processDeviceCodeResponse(as, client, response) {\n    return processGenericAccessTokenResponse(as, client, response);\n}\nexport async function generateKeyPair(alg, options) {\n    if (!validateString(alg)) {\n        throw new TypeError('\"alg\" must be a non-empty string');\n    }\n    const algorithm = algToSubtle(alg, alg === 'EdDSA' ? (options?.crv ?? 'Ed25519') : undefined);\n    if (alg.startsWith('PS') || alg.startsWith('RS')) {\n        Object.assign(algorithm, {\n            modulusLength: options?.modulusLength ?? 2048,\n            publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n        });\n    }\n    return crypto.subtle.generateKey(algorithm, options?.extractable ?? false, [\n        'sign',\n        'verify',\n    ]);\n}\nfunction normalizeHtu(htu) {\n    const url = new URL(htu);\n    url.search = '';\n    url.hash = '';\n    return url.href;\n}\nasync function validateDPoP(as, request, accessToken, accessTokenClaims, options) {\n    const header = request.headers.get('dpop');\n    if (header === null) {\n        throw new OPE('operation indicated DPoP use but the request has no DPoP HTTP Header');\n    }\n    if (request.headers.get('authorization')?.toLowerCase().startsWith('dpop ') === false) {\n        throw new OPE(`operation indicated DPoP use but the request's Authorization HTTP Header scheme is not DPoP`);\n    }\n    if (typeof accessTokenClaims.cnf?.jkt !== 'string') {\n        throw new OPE('operation indicated DPoP use but the JWT Access Token has no jkt confirmation claim');\n    }\n    const clockSkew = getClockSkew(options);\n    const proof = await validateJwt(header, checkSigningAlgorithm.bind(undefined, undefined, as?.dpop_signing_alg_values_supported || SUPPORTED_JWS_ALGS), async ({ jwk, alg }) => {\n        if (!jwk) {\n            throw new OPE('DPoP Proof is missing the jwk header parameter');\n        }\n        const key = await importJwk(alg, jwk);\n        if (key.type !== 'public') {\n            throw new OPE('DPoP Proof jwk header parameter must contain a public key');\n        }\n        return key;\n    }, clockSkew, getClockTolerance(options), undefined)\n        .then(checkJwtType.bind(undefined, 'dpop+jwt'))\n        .then(validatePresence.bind(undefined, ['iat', 'jti', 'ath', 'htm', 'htu']));\n    const now = epochTime() + clockSkew;\n    const diff = Math.abs(now - proof.claims.iat);\n    if (diff > 300) {\n        throw new OPE('DPoP Proof iat is not recent enough');\n    }\n    if (proof.claims.htm !== request.method) {\n        throw new OPE('DPoP Proof htm mismatch');\n    }\n    if (typeof proof.claims.htu !== 'string' ||\n        normalizeHtu(proof.claims.htu) !== normalizeHtu(request.url)) {\n        throw new OPE('DPoP Proof htu mismatch');\n    }\n    {\n        const expected = b64u(await crypto.subtle.digest('SHA-256', encoder.encode(accessToken)));\n        if (proof.claims.ath !== expected) {\n            throw new OPE('DPoP Proof ath mismatch');\n        }\n    }\n    {\n        let components;\n        switch (proof.header.jwk.kty) {\n            case 'EC':\n                components = {\n                    crv: proof.header.jwk.crv,\n                    kty: proof.header.jwk.kty,\n                    x: proof.header.jwk.x,\n                    y: proof.header.jwk.y,\n                };\n                break;\n            case 'OKP':\n                components = {\n                    crv: proof.header.jwk.crv,\n                    kty: proof.header.jwk.kty,\n                    x: proof.header.jwk.x,\n                };\n                break;\n            case 'RSA':\n                components = {\n                    e: proof.header.jwk.e,\n                    kty: proof.header.jwk.kty,\n                    n: proof.header.jwk.n,\n                };\n                break;\n            default:\n                throw new UnsupportedOperationError();\n        }\n        const expected = b64u(await crypto.subtle.digest('SHA-256', encoder.encode(JSON.stringify(components))));\n        if (accessTokenClaims.cnf.jkt !== expected) {\n            throw new OPE('JWT Access Token confirmation mismatch');\n        }\n    }\n}\nexport async function validateJwtAccessToken(as, request, expectedAudience, options) {\n    assertAs(as);\n    if (!looseInstanceOf(request, Request)) {\n        throw new TypeError('\"request\" must be an instance of Request');\n    }\n    if (!validateString(expectedAudience)) {\n        throw new OPE('\"expectedAudience\" must be a non-empty string');\n    }\n    const authorization = request.headers.get('authorization');\n    if (authorization === null) {\n        throw new OPE('\"request\" is missing an Authorization HTTP Header');\n    }\n    let { 0: scheme, 1: accessToken, length } = authorization.split(' ');\n    scheme = scheme.toLowerCase();\n    switch (scheme) {\n        case 'dpop':\n        case 'bearer':\n            break;\n        default:\n            throw new UnsupportedOperationError('unsupported Authorization HTTP Header scheme');\n    }\n    if (length !== 2) {\n        throw new OPE('invalid Authorization HTTP Header format');\n    }\n    const requiredClaims = [\n        'iss',\n        'exp',\n        'aud',\n        'sub',\n        'iat',\n        'jti',\n        'client_id',\n    ];\n    if (options?.requireDPoP || scheme === 'dpop' || request.headers.has('dpop')) {\n        requiredClaims.push('cnf');\n    }\n    const { claims } = await validateJwt(accessToken, checkSigningAlgorithm.bind(undefined, undefined, SUPPORTED_JWS_ALGS), getPublicSigKeyFromIssuerJwksUri.bind(undefined, as, options), getClockSkew(options), getClockTolerance(options), undefined)\n        .then(checkJwtType.bind(undefined, 'at+jwt'))\n        .then(validatePresence.bind(undefined, requiredClaims))\n        .then(validateIssuer.bind(undefined, as.issuer))\n        .then(validateAudience.bind(undefined, expectedAudience));\n    for (const claim of ['client_id', 'jti', 'sub']) {\n        if (typeof claims[claim] !== 'string') {\n            throw new OPE(`unexpected JWT \"${claim}\" claim type`);\n        }\n    }\n    if ('cnf' in claims) {\n        if (!isJsonObject(claims.cnf)) {\n            throw new OPE('unexpected JWT \"cnf\" (confirmation) claim value');\n        }\n        const { 0: cnf, length } = Object.keys(claims.cnf);\n        if (length) {\n            if (length !== 1) {\n                throw new UnsupportedOperationError('multiple confirmation claims are not supported');\n            }\n            if (cnf !== 'jkt') {\n                throw new UnsupportedOperationError('unsupported JWT Confirmation method');\n            }\n        }\n    }\n    if (options?.requireDPoP ||\n        scheme === 'dpop' ||\n        claims.cnf?.jkt !== undefined ||\n        request.headers.has('dpop')) {\n        await validateDPoP(as, request, accessToken, claims, options);\n    }\n    return claims;\n}\nexport const experimentalCustomFetch = customFetch;\nexport const experimental_customFetch = customFetch;\nexport const experimentalUseMtlsAlias = useMtlsAlias;\nexport const experimental_useMtlsAlias = useMtlsAlias;\nexport const experimental_validateDetachedSignatureResponse = (...args) => validateDetachedSignatureResponse(...args);\nexport const experimental_validateJwtAccessToken = (...args) => validateJwtAccessToken(...args);\nexport const validateJwtUserinfoSignature = (...args) => validateJwtUserInfoSignature(...args);\nexport const experimental_jwksCache = jwksCache;\n","import logger from \"loglevel\";\nimport * as oauth from \"oauth4webapi\";\nimport { ErrorBoundary } from \"react-error-boundary\";\nimport type { OpenIDAuthenticationConfig } from \"../../../config/config.js\";\nimport { ClientOnly } from \"../../components/ClientOnly.js\";\nimport { joinUrl } from \"../../util/joinUrl.js\";\nimport { CoreAuthenticationPlugin } from \"../AuthenticationPlugin.js\";\nimport type {\n  AuthenticationPlugin,\n  AuthenticationProviderInitializer,\n} from \"../authentication.js\";\nimport { CallbackHandler } from \"../components/CallbackHandler.js\";\nimport { OAuthErrorPage } from \"../components/OAuthErrorPage.js\";\nimport { AuthorizationError, OAuthAuthorizationError } from \"../errors.js\";\nimport { type UserProfile, useAuthState } from \"../state.js\";\n\nconst CODE_VERIFIER_KEY = \"code-verifier\";\nconst STATE_KEY = \"oauth-state\";\n\nexport interface OpenIdProviderData {\n  accessToken: string;\n  idToken?: string;\n  refreshToken?: string;\n  expiresOn: Date;\n  tokenType: string;\n}\n\nexport const OPENID_CALLBACK_PATH = \"/oauth/callback\";\n\nexport class OpenIDAuthenticationProvider\n  extends CoreAuthenticationPlugin\n  implements AuthenticationPlugin\n{\n  protected client: oauth.Client;\n  protected issuer: string;\n  protected authorizationServer: oauth.AuthorizationServer | undefined;\n\n  protected callbackUrlPath: string;\n\n  protected onAuthorizationUrl?: (\n    authorizationUrl: URL,\n    options: { isSignIn: boolean; isSignUp: boolean },\n  ) => void;\n\n  protected readonly redirectToAfterSignUp: string | undefined;\n  protected readonly redirectToAfterSignIn: string | undefined;\n  protected readonly redirectToAfterSignOut: string;\n  private readonly audience?: string;\n  private readonly scopes: string[];\n\n  constructor({\n    issuer,\n    audience,\n    clientId,\n    redirectToAfterSignUp,\n    redirectToAfterSignIn,\n    redirectToAfterSignOut = \"/\",\n    basePath,\n    scopes,\n  }: OpenIDAuthenticationConfig) {\n    super();\n    this.client = {\n      client_id: clientId,\n      token_endpoint_auth_method: \"none\",\n    };\n    this.audience = audience;\n    this.issuer = issuer;\n    // This is the callback URL for the OAuth provider. So it needs the base path.\n    this.callbackUrlPath = joinUrl(basePath, OPENID_CALLBACK_PATH);\n    this.scopes = scopes ?? [\"openid\", \"profile\", \"email\"];\n\n    this.redirectToAfterSignUp = redirectToAfterSignUp;\n    this.redirectToAfterSignIn = redirectToAfterSignIn;\n    this.redirectToAfterSignOut = redirectToAfterSignOut;\n  }\n\n  protected async getAuthServer() {\n    if (!this.authorizationServer) {\n      const issuerUrl = new URL(this.issuer);\n      const response = await oauth.discoveryRequest(issuerUrl);\n      this.authorizationServer = await oauth.processDiscoveryResponse(\n        issuerUrl,\n        response,\n      );\n    }\n    return this.authorizationServer;\n  }\n\n  /**\n   * Sets the tokens from various OAuth responses\n   * @param response\n   */\n  protected setTokensFromResponse(\n    response: oauth.TokenEndpointResponse | oauth.OAuth2Error,\n  ) {\n    if (oauth.isOAuth2Error(response)) {\n      logger.error(\"Bad Token Response\", response);\n      throw new OAuthAuthorizationError(\"Bad Token Response\", response);\n    }\n\n    if (!response.expires_in) {\n      throw new AuthorizationError(\"No expires_in in response\");\n    }\n\n    const tokens: OpenIdProviderData = {\n      accessToken: response.access_token,\n      refreshToken: response.refresh_token,\n      idToken: response.id_token,\n      expiresOn: new Date(Date.now() + response.expires_in * 1000),\n      tokenType: response.token_type,\n    };\n\n    useAuthState.setState({\n      providerData: tokens,\n    });\n  }\n\n  async signUp({\n    redirectTo,\n    replace = false,\n  }: {\n    redirectTo?: string;\n    replace?: boolean;\n  } = {}) {\n    return this.authorize({\n      redirectTo: this.redirectToAfterSignUp ?? redirectTo ?? \"/\",\n      replace,\n      isSignUp: true,\n    });\n  }\n\n  async signIn({\n    redirectTo,\n    replace = false,\n  }: {\n    redirectTo?: string;\n    replace?: boolean;\n  } = {}) {\n    return this.authorize({\n      redirectTo: this.redirectToAfterSignIn ?? redirectTo ?? \"/\",\n      replace,\n    });\n  }\n\n  private async authorize({\n    redirectTo,\n    isSignUp = false,\n    replace = false,\n  }: {\n    redirectTo: string;\n    isSignUp?: boolean;\n    replace?: boolean;\n  }): Promise<void> {\n    const code_challenge_method = \"S256\";\n    const authorizationServer = await this.getAuthServer();\n\n    if (!authorizationServer.authorization_endpoint) {\n      throw new AuthorizationError(\"No authorization endpoint\");\n    }\n\n    /**\n     * The following MUST be generated for every redirect to the authorization_endpoint. You must store\n     * the codeVerifier and nonce in the end-user session such that it can be recovered as the user\n     * gets redirected from the authorization server back to your application.\n     */\n    const codeVerifier = oauth.generateRandomCodeVerifier();\n    const codeChallenge = await oauth.calculatePKCECodeChallenge(codeVerifier);\n\n    sessionStorage.setItem(CODE_VERIFIER_KEY, codeVerifier);\n\n    // redirect user to as.authorization_endpoint\n    const authorizationUrl = new URL(\n      authorizationServer.authorization_endpoint,\n    );\n\n    sessionStorage.setItem(\"redirect-to\", redirectTo);\n\n    const redirectUrl = new URL(window.location.origin);\n    redirectUrl.pathname = this.callbackUrlPath;\n    redirectUrl.search = \"\";\n\n    authorizationUrl.searchParams.set(\"client_id\", this.client.client_id);\n    authorizationUrl.searchParams.set(\"redirect_uri\", redirectUrl.toString());\n    authorizationUrl.searchParams.set(\"response_type\", \"code\");\n    authorizationUrl.searchParams.set(\"scope\", this.scopes.join(\" \"));\n    authorizationUrl.searchParams.set(\"code_challenge\", codeChallenge);\n    authorizationUrl.searchParams.set(\n      \"code_challenge_method\",\n      code_challenge_method,\n    );\n    if (this.audience) {\n      authorizationUrl.searchParams.set(\"audience\", this.audience);\n    }\n\n    this.onAuthorizationUrl?.(authorizationUrl, {\n      isSignIn: !isSignUp,\n      isSignUp,\n    });\n\n    /**\n     * The state parameter is used to prevent CSRF attacks and should be used in all authorization requests.\n     * It is independent of PKCE and should be used regardless of PKCE support.\n     */\n    const state = oauth.generateRandomState();\n    sessionStorage.setItem(STATE_KEY, state);\n    authorizationUrl.searchParams.set(\"state\", state);\n\n    if (replace) {\n      location.replace(authorizationUrl.href);\n    } else {\n      location.href = authorizationUrl.href;\n    }\n  }\n\n  async getAccessToken(): Promise<string> {\n    const as = await this.getAuthServer();\n    const { providerData } = useAuthState.getState();\n    if (!providerData) {\n      throw new AuthorizationError(\"User is not authenticated\");\n    }\n    const tokenState = providerData as OpenIdProviderData;\n\n    if (new Date(tokenState.expiresOn) < new Date()) {\n      if (!tokenState.refreshToken) {\n        useAuthState.setState({\n          isAuthenticated: false,\n          isPending: false,\n          profile: null,\n          providerData: null,\n        });\n        return \"\";\n      }\n\n      const request = await oauth.refreshTokenGrantRequest(\n        as,\n        this.client,\n        tokenState.refreshToken,\n      );\n      const response = await oauth.processRefreshTokenResponse(\n        as,\n        this.client,\n        request,\n      );\n\n      if (!response.access_token) {\n        throw new AuthorizationError(\"No access token in response\");\n      }\n\n      this.setTokensFromResponse(response);\n\n      return response.access_token.toString();\n    } else {\n      return tokenState.accessToken;\n    }\n  }\n\n  signRequest = async (request: Request): Promise<Request> => {\n    const accessToken = await this.getAccessToken();\n    request.headers.set(\"Authorization\", `Bearer ${accessToken}`);\n    return request;\n  };\n\n  signOut = async () => {\n    useAuthState.setState({\n      isAuthenticated: false,\n      isPending: false,\n      profile: undefined,\n      providerData: undefined,\n    });\n\n    const as = await this.getAuthServer();\n\n    const redirectUrl = new URL(\n      window.location.origin + this.redirectToAfterSignOut,\n    );\n    redirectUrl.pathname = this.callbackUrlPath;\n\n    let logoutUrl: URL;\n    // The endSessionEndpoint is set, the IdP supports some form of logout,\n    // so we use the IdP logout. Otherwise, just redirect the user to home\n    if (as.end_session_endpoint) {\n      logoutUrl = new URL(as.end_session_endpoint);\n      // TODO: get id_token and set hint\n      // const { id_token } = session;\n      // if (id_token) {\n      //   logoutUrl.searchParams.set(\"id_token_hint\", id_token);\n      // }\n      logoutUrl.searchParams.set(\n        \"post_logout_redirect_uri\",\n        redirectUrl.toString(),\n      );\n    } else {\n      logoutUrl = redirectUrl;\n    }\n  };\n\n  onPageLoad = async () => {\n    const { providerData } = useAuthState.getState();\n\n    if (!providerData) {\n      useAuthState.setState({ isPending: false });\n      return;\n    }\n\n    const tokenState = providerData as OpenIdProviderData;\n\n    if (new Date(tokenState.expiresOn) < new Date()) {\n      if (!tokenState.refreshToken) {\n        useAuthState.setState({\n          isAuthenticated: false,\n          isPending: false,\n          profile: null,\n          providerData: null,\n        });\n        return;\n      }\n\n      try {\n        const as = await this.getAuthServer();\n        const request = await oauth.refreshTokenGrantRequest(\n          as,\n          this.client,\n          tokenState.refreshToken,\n        );\n        const response = await oauth.processRefreshTokenResponse(\n          as,\n          this.client,\n          request,\n        );\n\n        if (!response.access_token) {\n          throw new AuthorizationError(\"No access token in response\");\n        }\n\n        this.setTokensFromResponse(response);\n      } catch {\n        useAuthState.setState({\n          isAuthenticated: false,\n          isPending: false,\n          profile: null,\n          providerData: null,\n        });\n        return;\n      }\n    }\n\n    useAuthState.setState({ isPending: false });\n  };\n\n  handleCallback = async () => {\n    const url = new URL(window.location.href);\n    const state = url.searchParams.get(\"state\");\n    const storedState = sessionStorage.getItem(STATE_KEY);\n    sessionStorage.removeItem(STATE_KEY);\n\n    if (state !== storedState) {\n      throw new AuthorizationError(\"Invalid state parameter\");\n    }\n\n    // one eternity later, the user lands back on the redirect_uri\n    // Authorization Code Grant Request & Response\n    const codeVerifier = sessionStorage.getItem(CODE_VERIFIER_KEY);\n    sessionStorage.removeItem(CODE_VERIFIER_KEY);\n    if (!codeVerifier) {\n      throw new AuthorizationError(\"No code verifier found in state.\");\n    }\n\n    const authServer = await this.getAuthServer();\n\n    const params = oauth.validateAuthResponse(\n      authServer,\n      this.client,\n      url.searchParams,\n      state ?? undefined,\n    );\n    if (oauth.isOAuth2Error(params)) {\n      logger.error(\"Error validating OAuth response\", params);\n      throw new OAuthAuthorizationError(\n        \"Error validating OAuth response\",\n        params,\n      );\n    }\n\n    const redirectUrl = new URL(url);\n    redirectUrl.pathname = this.callbackUrlPath;\n    redirectUrl.search = \"\";\n\n    const response = await oauth.authorizationCodeGrantRequest(\n      authServer,\n      this.client,\n      params,\n      redirectUrl.toString(),\n      codeVerifier,\n    );\n\n    // TODO: do we need to do these\n    // const challenges = oauth.parseWwwAuthenticateChallenges(response);\n    // if (challenges) {\n    //   for (const challenge of challenges) {\n    //     console.error(\"WWW-Authenticate Challenge\", challenge);\n    //   }\n    //   throw new Error(); // Handle WWW-Authenticate Challenges as needed\n    // }\n    const oauthResult = await oauth.processAuthorizationCodeOpenIDResponse(\n      authServer,\n      this.client,\n      response,\n    );\n\n    this.setTokensFromResponse(oauthResult);\n\n    const accessToken = await this.getAccessToken();\n\n    const userInfoResponse = await oauth.userInfoRequest(\n      authServer,\n      this.client,\n      accessToken,\n    );\n    const userInfo = await userInfoResponse.json();\n\n    const profile: UserProfile = {\n      sub: userInfo.sub,\n      email: userInfo.email,\n      name: userInfo.name,\n      emailVerified: userInfo.email_verified ?? false,\n      pictureUrl: userInfo.picture,\n    };\n\n    useAuthState.setState({\n      isAuthenticated: true,\n      isPending: false,\n      profile,\n    });\n\n    const redirectTo = sessionStorage.getItem(\"redirect-to\") ?? \"/\";\n    sessionStorage.removeItem(\"redirect-to\");\n    return redirectTo;\n  };\n\n  getRoutes() {\n    return [\n      ...super.getRoutes(),\n      {\n        path: OPENID_CALLBACK_PATH,\n        element: (\n          <ClientOnly>\n            <ErrorBoundary\n              fallbackRender={({ error }) => <OAuthErrorPage error={error} />}\n            >\n              <CallbackHandler handleCallback={this.handleCallback} />\n            </ErrorBoundary>\n          </ClientOnly>\n        ),\n      },\n    ];\n  }\n}\n\nconst openIDAuth: AuthenticationProviderInitializer<\n  OpenIDAuthenticationConfig\n> = (options) => new OpenIDAuthenticationProvider(options);\n\nexport default openIDAuth;\n"],"names":["root","definition","module","this","noop","undefinedType","isIE","logMethods","_loggersByName","defaultLogger","bindMethod","obj","methodName","method","traceForIE","realMethod","replaceLoggingMethods","level","i","enableLoggingWhenConsoleArrives","defaultMethodFactory","_level","_loggerName","Logger","name","factory","self","inheritedLevel","defaultLevel","userLevel","storageKey","persistLevelIfPossible","levelNum","levelName","getPersistedLevel","storedLevel","cookie","cookieName","location","clearPersistedLevel","normalizeLevel","input","persist","childName","initialLevel","logger","_log","USER_AGENT","looseInstanceOf","expected","clockSkew","clockTolerance","customFetch","modifyAssertion","jweDecrypt","useMtlsAlias","encoder","decoder","buf","CHUNK_SIZE","encodeBase64Url","arr","decodeBase64Url","binary","bytes","cause","OPE","b64u","LRU","maxSize","key","v","value","UnsupportedOperationError","message","OperationProcessingError","options","dpopNonces","isCryptoKey","isPrivateKey","isPublicKey","processDpopNonce","response","nonce","isJsonObject","prepareHeaders","headers","signal","discoveryRequest","issuerIdentifier","url","validateString","processDiscoveryResponse","expectedIssuerIdentifier","assertReadableResponse","json","randomBytes","generateRandomCodeVerifier","generateRandomState","calculatePKCECodeChallenge","codeVerifier","formUrlEncode","token","clientSecretBasic","clientId","clientSecret","username","password","psAlg","rsAlg","esAlg","keyToJws","getClockSkew","client","skew","getClockTolerance","tolerance","epochTime","assertAs","as","assertClient","assertClientSecret","assertNoClientSecret","clientAuthMethod","clientAuthentication","body","clientPrivateKey","jwt","header","payload","signature","keyToSubtle","dpopProofJwt","htm","accessToken","privateKey","publicKey","now","publicJwk","jwkCache","getSetPublicJwkCache","kty","e","n","x","y","crv","jwk","validateEndpoint","endpoint","resolveEndpoint","alias","isOAuth2Error","protectedResourceRequest","userInfoRequest","authenticatedRequest","tokenEndpointRequest","grantType","parameters","refreshTokenGrantRequest","refreshToken","idTokenClaims","getValidatedIdTokenClaims","ref","claims","processGenericAccessTokenResponse","ignoreIdToken","ignoreRefreshToken","err","handleOAuthBodyError","validateJwt","checkSigningAlgorithm","noSignatureCheck","validatePresence","validateIssuer","validateAudience","processRefreshTokenResponse","result","branded","brand","searchParams","authorizationCodeGrantRequest","callbackParameters","redirectUri","code","getURLSearchParameter","jwtClaimNames","required","claim","expectNoNonce","skipAuthTimeCheck","processAuthorizationCodeOpenIDResponse","expectedNonce","maxAge","checkRsaKeyAlgorithm","algorithm","ecdsaHashName","namedCurve","validateJwsSignature","protectedHeader","jws","checkAlg","getKey","decryptJwt","encodedSignature","length","issuer","skipStateCheck","expectNoState","validateAuthResponse","expectedState","iss","state","error","id_token","CODE_VERIFIER_KEY","STATE_KEY","OPENID_CALLBACK_PATH","OpenIDAuthenticationProvider","CoreAuthenticationPlugin","audience","redirectToAfterSignUp","redirectToAfterSignIn","redirectToAfterSignOut","basePath","scopes","joinUrl","issuerUrl","oauth.discoveryRequest","oauth.processDiscoveryResponse","oauth.isOAuth2Error","OAuthAuthorizationError","AuthorizationError","tokens","useAuthState","redirectTo","replace","isSignUp","code_challenge_method","authorizationServer","oauth.generateRandomCodeVerifier","codeChallenge","oauth.calculatePKCECodeChallenge","authorizationUrl","redirectUrl","oauth.generateRandomState","providerData","tokenState","request","oauth.refreshTokenGrantRequest","oauth.processRefreshTokenResponse","logoutUrl","storedState","authServer","params","oauth.validateAuthResponse","oauth.authorizationCodeGrantRequest","oauthResult","oauth.processAuthorizationCodeOpenIDResponse","userInfo","oauth.userInfoRequest","profile","ClientOnly","jsx","ErrorBoundary","OAuthErrorPage","CallbackHandler","openIDAuth"],"mappings":"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","x_google_ignoreList":[0,1]}