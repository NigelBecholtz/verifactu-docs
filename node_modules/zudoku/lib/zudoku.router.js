import { f as We, s as $, g as ve, F as j, R as qe, S as Se, h as Ge, a as Xe, E as D, j as Ee, k as X, l as U, n as Ye, o as oe, p as Je, q as Ke, t as _e, v as Qe, w as be, x as Ce, i as A, y as De, z as Ze, A as C, B as et, C as tt, D as rt, G as at, O as nt, H as L, I as ot, J as st, K as it, M as lt, P as T, Q as ut, T as dt, r as ct, U as Z, V as ft, W as ht, X as pt, Y as mt, Z as yt, _ as Rt, $ as wt, a0 as gt, a1 as vt } from "./chunk-PVWAREVJ-BO6B-RAk.js";
import { a2 as Ur, a3 as Mr, a4 as Nr, a5 as Or, a6 as zr, a7 as Br, a8 as $r, L as jr, a9 as Vr, aa as Wr, ab as qr, ac as Gr, N as Xr, ad as Yr, ae as Jr, af as Kr, ag as Qr, ah as Zr, ai as ea, aj as ta, ak as ra, al as aa, am as na, an as oa, ao as sa, ap as ia, aq as la, ar as ua, as as da, at as ca, au as fa, av as ha, aw as pa, ax as ma, ay as ya, az as Ra, aA as wa, aB as ga, aC as va, aD as Sa, aE as Ea, aF as _a, aG as ba, aH as Ca, aI as Da, aJ as Aa, aK as xa, aL as Fa, m as ka, aM as La, aN as Ta, aO as Ha, aP as Ia, aQ as Pa, aR as Ua, aS as Ma, aT as Na, aU as Oa, aV as za, aW as Ba, aX as $a, aY as ja, aZ as Va, a_ as Wa, a$ as qa, b0 as Ga, c as Xa, d as Ya, b1 as Ja, b as Ka, b2 as Qa, b3 as Za, b4 as en, b5 as tn, u as rn, b6 as an, b7 as nn, b8 as on, b9 as sn, e as ln, ba as un, bb as dn } from "./chunk-PVWAREVJ-BO6B-RAk.js";
import * as g from "react";
import E from "react";
import * as St from "react-dom";
var k = {}, se;
function Et() {
  if (se) return k;
  se = 1, Object.defineProperty(k, "__esModule", { value: !0 }), k.parse = o, k.serialize = l;
  const e = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/, t = /^[\u0021-\u003A\u003C-\u007E]*$/, r = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i, a = /^[\u0020-\u003A\u003D-\u007E]*$/, n = Object.prototype.toString, s = /* @__PURE__ */ (() => {
    const c = function() {
    };
    return c.prototype = /* @__PURE__ */ Object.create(null), c;
  })();
  function o(c, p) {
    const f = new s(), m = c.length;
    if (m < 2)
      return f;
    const y = p?.decode || d;
    let R = 0;
    do {
      const S = c.indexOf("=", R);
      if (S === -1)
        break;
      const v = c.indexOf(";", R), w = v === -1 ? m : v;
      if (S > w) {
        R = c.lastIndexOf(";", S - 1) + 1;
        continue;
      }
      const _ = u(c, R, S), I = i(c, S, _), ae = c.slice(_, I);
      if (f[ae] === void 0) {
        let ne = u(c, S + 1, w), je = i(c, w, ne);
        const Ve = y(c.slice(ne, je));
        f[ae] = Ve;
      }
      R = w + 1;
    } while (R < m);
    return f;
  }
  function u(c, p, f) {
    do {
      const m = c.charCodeAt(p);
      if (m !== 32 && m !== 9)
        return p;
    } while (++p < f);
    return f;
  }
  function i(c, p, f) {
    for (; p > f; ) {
      const m = c.charCodeAt(--p);
      if (m !== 32 && m !== 9)
        return p + 1;
    }
    return f;
  }
  function l(c, p, f) {
    const m = f?.encode || encodeURIComponent;
    if (!e.test(c))
      throw new TypeError(`argument name is invalid: ${c}`);
    const y = m(p);
    if (!t.test(y))
      throw new TypeError(`argument val is invalid: ${p}`);
    let R = c + "=" + y;
    if (!f)
      return R;
    if (f.maxAge !== void 0) {
      if (!Number.isInteger(f.maxAge))
        throw new TypeError(`option maxAge is invalid: ${f.maxAge}`);
      R += "; Max-Age=" + f.maxAge;
    }
    if (f.domain) {
      if (!r.test(f.domain))
        throw new TypeError(`option domain is invalid: ${f.domain}`);
      R += "; Domain=" + f.domain;
    }
    if (f.path) {
      if (!a.test(f.path))
        throw new TypeError(`option path is invalid: ${f.path}`);
      R += "; Path=" + f.path;
    }
    if (f.expires) {
      if (!h(f.expires) || !Number.isFinite(f.expires.valueOf()))
        throw new TypeError(`option expires is invalid: ${f.expires}`);
      R += "; Expires=" + f.expires.toUTCString();
    }
    if (f.httpOnly && (R += "; HttpOnly"), f.secure && (R += "; Secure"), f.partitioned && (R += "; Partitioned"), f.priority)
      switch (typeof f.priority == "string" ? f.priority.toLowerCase() : void 0) {
        case "low":
          R += "; Priority=Low";
          break;
        case "medium":
          R += "; Priority=Medium";
          break;
        case "high":
          R += "; Priority=High";
          break;
        default:
          throw new TypeError(`option priority is invalid: ${f.priority}`);
      }
    if (f.sameSite)
      switch (typeof f.sameSite == "string" ? f.sameSite.toLowerCase() : f.sameSite) {
        case !0:
        case "strict":
          R += "; SameSite=Strict";
          break;
        case "lax":
          R += "; SameSite=Lax";
          break;
        case "none":
          R += "; SameSite=None";
          break;
        default:
          throw new TypeError(`option sameSite is invalid: ${f.sameSite}`);
      }
    return R;
  }
  function d(c) {
    if (c.indexOf("%") === -1)
      return c;
    try {
      return decodeURIComponent(c);
    } catch {
      return c;
    }
  }
  function h(c) {
    return n.call(c) === "[object Date]";
  }
  return k;
}
var ie = Et(), x = { exports: {} }, le;
function _t() {
  if (le) return x.exports;
  le = 1;
  var e = {
    decodeValues: !0,
    map: !1,
    silent: !1
  };
  function t(o) {
    return typeof o == "string" && !!o.trim();
  }
  function r(o, u) {
    var i = o.split(";").filter(t), l = i.shift(), d = a(l), h = d.name, c = d.value;
    u = u ? Object.assign({}, e, u) : e;
    try {
      c = u.decodeValues ? decodeURIComponent(c) : c;
    } catch (f) {
      console.error(
        "set-cookie-parser encountered an error while decoding a cookie with value '" + c + "'. Set options.decodeValues to false to disable this feature.",
        f
      );
    }
    var p = {
      name: h,
      value: c
    };
    return i.forEach(function(f) {
      var m = f.split("="), y = m.shift().trimLeft().toLowerCase(), R = m.join("=");
      y === "expires" ? p.expires = new Date(R) : y === "max-age" ? p.maxAge = parseInt(R, 10) : y === "secure" ? p.secure = !0 : y === "httponly" ? p.httpOnly = !0 : y === "samesite" ? p.sameSite = R : y === "partitioned" ? p.partitioned = !0 : p[y] = R;
    }), p;
  }
  function a(o) {
    var u = "", i = "", l = o.split("=");
    return l.length > 1 ? (u = l.shift(), i = l.join("=")) : i = o, { name: u, value: i };
  }
  function n(o, u) {
    if (u = u ? Object.assign({}, e, u) : e, !o)
      return u.map ? {} : [];
    if (o.headers)
      if (typeof o.headers.getSetCookie == "function")
        o = o.headers.getSetCookie();
      else if (o.headers["set-cookie"])
        o = o.headers["set-cookie"];
      else {
        var i = o.headers[Object.keys(o.headers).find(function(d) {
          return d.toLowerCase() === "set-cookie";
        })];
        !i && o.headers.cookie && !u.silent && console.warn(
          "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
        ), o = i;
      }
    if (Array.isArray(o) || (o = [o]), u.map) {
      var l = {};
      return o.filter(t).reduce(function(d, h) {
        var c = r(h, u);
        return d[c.name] = c, d;
      }, l);
    } else
      return o.filter(t).map(function(d) {
        return r(d, u);
      });
  }
  function s(o) {
    if (Array.isArray(o))
      return o;
    if (typeof o != "string")
      return [];
    var u = [], i = 0, l, d, h, c, p;
    function f() {
      for (; i < o.length && /\s/.test(o.charAt(i)); )
        i += 1;
      return i < o.length;
    }
    function m() {
      return d = o.charAt(i), d !== "=" && d !== ";" && d !== ",";
    }
    for (; i < o.length; ) {
      for (l = i, p = !1; f(); )
        if (d = o.charAt(i), d === ",") {
          for (h = i, i += 1, f(), c = i; i < o.length && m(); )
            i += 1;
          i < o.length && o.charAt(i) === "=" ? (p = !0, i = c, u.push(o.substring(l, h)), l = i) : i = h + 1;
        } else
          i += 1;
      (!p || i >= o.length) && u.push(o.substring(l, o.length));
    }
    return u;
  }
  return x.exports = n, x.exports.parse = n, x.exports.parseString = r, x.exports.splitCookiesString = s, x.exports;
}
var bt = /* @__PURE__ */ _t();
/**
 * react-router v7.8.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function gr({
  context: e,
  url: t,
  nonce: r
}) {
  typeof t == "string" && (t = new URL(t));
  let { manifest: a, routeModules: n, criticalCss: s, serverHandoffString: o } = e, u = We(
    a.routes,
    n,
    e.future,
    e.isSpaMode
  );
  e.staticHandlerContext.loaderData = {
    ...e.staticHandlerContext.loaderData
  };
  for (let l of e.staticHandlerContext.matches) {
    let d = l.route.id, h = n[d], c = e.manifest.routes[d];
    h && c && $(
      d,
      h.clientLoader,
      c.hasLoader,
      e.isSpaMode
    ) && (h.HydrateFallback || !c.hasLoader) && delete e.staticHandlerContext.loaderData[d];
  }
  let i = ve(u, e.staticHandlerContext);
  return /* @__PURE__ */ g.createElement(g.Fragment, null, /* @__PURE__ */ g.createElement(
    j.Provider,
    {
      value: {
        manifest: a,
        routeModules: n,
        criticalCss: s,
        serverHandoffString: o,
        future: e.future,
        ssr: e.ssr,
        isSpaMode: e.isSpaMode,
        routeDiscovery: e.routeDiscovery,
        serializeError: e.serializeError,
        renderMeta: e.renderMeta
      }
    },
    /* @__PURE__ */ g.createElement(qe, { location: i.state.location }, /* @__PURE__ */ g.createElement(
      Se,
      {
        router: i,
        context: e.staticHandlerContext,
        hydrate: !1
      }
    ))
  ), e.serverHandoffStream ? /* @__PURE__ */ g.createElement(g.Suspense, null, /* @__PURE__ */ g.createElement(
    Ge,
    {
      context: e,
      identifier: 0,
      reader: e.serverHandoffStream.getReader(),
      textDecoder: new TextDecoder(),
      nonce: r
    }
  )) : null);
}
function vr(e, t) {
  return function({
    initialEntries: a,
    initialIndex: n,
    hydrationData: s,
    future: o
  }) {
    let u = g.useRef(), i = g.useRef();
    if (u.current == null) {
      i.current = {
        future: {
          unstable_subResourceIntegrity: o?.unstable_subResourceIntegrity === !0,
          unstable_middleware: o?.unstable_middleware === !0
        },
        manifest: {
          routes: {},
          entry: { imports: [], module: "" },
          url: "",
          version: ""
        },
        routeModules: {},
        ssr: !1,
        isSpaMode: !1,
        routeDiscovery: { mode: "lazy", manifestPath: "/__manifest" }
      };
      let l = Ae(
        // @ts-expect-error `StubRouteObject` is stricter about `loader`/`action`
        // types compared to `AgnosticRouteObject`
        Je(e, (d) => d),
        t !== void 0 ? t : o?.unstable_middleware ? new X() : {},
        i.current.manifest,
        i.current.routeModules
      );
      u.current = Ke(l, {
        initialEntries: a,
        initialIndex: n,
        hydrationData: s
      });
    }
    return /* @__PURE__ */ g.createElement(j.Provider, { value: i.current }, /* @__PURE__ */ g.createElement(_e, { router: u.current }));
  };
}
function Ae(e, t, r, a, n) {
  return e.map((s) => {
    if (!s.id)
      throw new Error(
        "Expected a route.id in react-router processRoutes() function"
      );
    let o = {
      id: s.id,
      path: s.path,
      index: s.index,
      Component: s.Component ? at(s.Component) : void 0,
      HydrateFallback: s.HydrateFallback ? rt(s.HydrateFallback) : void 0,
      ErrorBoundary: s.ErrorBoundary ? tt(s.ErrorBoundary) : void 0,
      action: s.action ? (i) => s.action({ ...i, context: t }) : void 0,
      loader: s.loader ? (i) => s.loader({ ...i, context: t }) : void 0,
      handle: s.handle,
      shouldRevalidate: s.shouldRevalidate
    }, u = {
      id: s.id,
      path: s.path,
      index: s.index,
      parentId: n,
      hasAction: s.action != null,
      hasLoader: s.loader != null,
      // When testing routes, you should be stubbing loader/action/middleware,
      // not trying to re-implement the full loader/clientLoader/SSR/hydration
      // flow. That is better tested via E2E tests.
      hasClientAction: !1,
      hasClientLoader: !1,
      hasClientMiddleware: !1,
      hasErrorBoundary: s.ErrorBoundary != null,
      // any need for these?
      module: "build/stub-path-to-module.js",
      clientActionModule: void 0,
      clientLoaderModule: void 0,
      clientMiddlewareModule: void 0,
      hydrateFallbackModule: void 0
    };
    return r.routes[o.id] = u, a[s.id] = {
      default: o.Component || nt,
      ErrorBoundary: o.ErrorBoundary || void 0,
      handle: s.handle,
      links: s.links,
      meta: s.meta,
      shouldRevalidate: s.shouldRevalidate
    }, s.children && (o.children = Ae(
      s.children,
      t,
      r,
      a,
      o.id
    )), o;
  });
}
var ee = /* @__PURE__ */ new TextEncoder(), Ct = async (e, t) => {
  let r = ee.encode(e), a = await xe(t, ["sign"]), n = await crypto.subtle.sign("HMAC", a, r), s = btoa(String.fromCharCode(...new Uint8Array(n))).replace(
    /=+$/,
    ""
  );
  return e + "." + s;
}, Dt = async (e, t) => {
  let r = e.lastIndexOf("."), a = e.slice(0, r), n = e.slice(r + 1), s = ee.encode(a), o = await xe(t, ["verify"]);
  try {
    let u = At(atob(n));
    return await crypto.subtle.verify("HMAC", o, u, s) ? a : !1;
  } catch {
    return !1;
  }
}, xe = async (e, t) => crypto.subtle.importKey(
  "raw",
  ee.encode(e),
  { name: "HMAC", hash: "SHA-256" },
  !1,
  t
);
function At(e) {
  let t = new Uint8Array(e.length);
  for (let r = 0; r < e.length; r++)
    t[r] = e.charCodeAt(r);
  return t;
}
var Fe = (e, t = {}) => {
  let { secrets: r = [], ...a } = {
    path: "/",
    sameSite: "lax",
    ...t
  };
  return Ht(e, a.expires), {
    get name() {
      return e;
    },
    get isSigned() {
      return r.length > 0;
    },
    get expires() {
      return typeof a.maxAge < "u" ? new Date(Date.now() + a.maxAge * 1e3) : a.expires;
    },
    async parse(n, s) {
      if (!n) return null;
      let o = ie.parse(n, { ...a, ...s });
      if (e in o) {
        let u = o[e];
        return typeof u == "string" && u !== "" ? await Ft(u, r) : "";
      } else
        return null;
    },
    async serialize(n, s) {
      return ie.serialize(
        e,
        n === "" ? "" : await xt(n, r),
        {
          ...a,
          ...s
        }
      );
    }
  };
}, ke = (e) => e != null && typeof e.name == "string" && typeof e.isSigned == "boolean" && typeof e.parse == "function" && typeof e.serialize == "function";
async function xt(e, t) {
  let r = kt(e);
  return t.length > 0 && (r = await Ct(r, t[0])), r;
}
async function Ft(e, t) {
  if (t.length > 0) {
    for (let r of t) {
      let a = await Dt(e, r);
      if (a !== !1)
        return ue(a);
    }
    return null;
  }
  return ue(e);
}
function kt(e) {
  return btoa(Tt(encodeURIComponent(JSON.stringify(e))));
}
function ue(e) {
  try {
    return JSON.parse(decodeURIComponent(Lt(atob(e))));
  } catch {
    return {};
  }
}
function Lt(e) {
  let t = e.toString(), r = "", a = 0, n, s;
  for (; a < t.length; )
    n = t.charAt(a++), /[\w*+\-./@]/.exec(n) ? r += n : (s = n.charCodeAt(0), s < 256 ? r += "%" + de(s, 2) : r += "%u" + de(s, 4).toUpperCase());
  return r;
}
function de(e, t) {
  let r = e.toString(16);
  for (; r.length < t; ) r = "0" + r;
  return r;
}
function Tt(e) {
  let t = e.toString(), r = "", a = 0, n, s;
  for (; a < t.length; ) {
    if (n = t.charAt(a++), n === "%") {
      if (t.charAt(a) === "u") {
        if (s = t.slice(a + 1, a + 5), /^[\da-f]{4}$/i.exec(s)) {
          r += String.fromCharCode(parseInt(s, 16)), a += 5;
          continue;
        }
      } else if (s = t.slice(a, a + 2), /^[\da-f]{2}$/i.exec(s)) {
        r += String.fromCharCode(parseInt(s, 16)), a += 2;
        continue;
      }
    }
    r += n;
  }
  return r;
}
function Ht(e, t) {
  De(
    !t,
    `The "${e}" cookie has an "expires" property set. This will cause the expires value to not be updated when the session is committed. Instead, you should set the expires value when serializing the cookie. You can use \`commitSession(session, { expires })\` if using a session storage object, or \`cookie.serialize("value", { expires })\` if you're using the cookie directly.`
  );
}
function It(e) {
  return Object.keys(e).reduce((t, r) => {
    let a = e[r];
    return a && (t[r] = a.module), t;
  }, {});
}
var Pt = /* @__PURE__ */ ((e) => (e.Development = "development", e.Production = "production", e.Test = "test", e))(Pt || {});
function Ut(e) {
  return e === "development" || e === "production" || e === "test";
}
function V(e, t) {
  if (e instanceof Error && t !== "development") {
    let r = new Error("Unexpected Server Error");
    return r.stack = void 0, r;
  }
  return e;
}
function O(e, t) {
  return Object.entries(e).reduce((r, [a, n]) => Object.assign(r, { [a]: V(n, t) }), {});
}
function Le(e, t) {
  let r = V(e, t);
  return {
    message: r.message,
    stack: r.stack
  };
}
function ce(e, t) {
  if (!e) return null;
  let r = Object.entries(e), a = {};
  for (let [n, s] of r)
    if (A(s))
      a[n] = { ...s, __type: "RouteErrorResponse" };
    else if (s instanceof Error) {
      let o = V(s, t);
      a[n] = {
        message: o.message,
        stack: o.stack,
        __type: "Error",
        // If this is a subclass (i.e., ReferenceError), send up the type so we
        // can re-create the same type during hydration.  This will only apply
        // in dev mode since all production errors are sanitized to normal
        // Error instances
        ...o.name !== "Error" ? {
          __subType: o.name
        } : {}
      };
    } else
      a[n] = s;
  return a;
}
function Y(e, t, r) {
  let a = Ee(
    e,
    t,
    r
  );
  return a ? a.map((n) => ({
    params: n.params,
    pathname: n.pathname,
    route: n.route
  })) : null;
}
async function fe(e, t) {
  let r = await e({
    request: Nt(Mt(t.request)),
    params: t.params,
    context: t.context
  });
  if (yt(r) && r.init && r.init.status && Z(r.init.status))
    throw new Response(null, r.init);
  return r;
}
function Mt(e) {
  let t = new URL(e.url), r = t.searchParams.getAll("index");
  t.searchParams.delete("index");
  let a = [];
  for (let s of r)
    s && a.push(s);
  for (let s of a)
    t.searchParams.append("index", s);
  let n = {
    method: e.method,
    body: e.body,
    headers: e.headers,
    signal: e.signal
  };
  return n.body && (n.duplex = "half"), new Request(t.href, n);
}
function Nt(e) {
  let t = new URL(e.url);
  t.searchParams.delete("_routes");
  let r = {
    method: e.method,
    body: e.body,
    headers: e.headers,
    signal: e.signal
  };
  return r.body && (r.duplex = "half"), new Request(t.href, r);
}
function M(e, t) {
  if (e === !1 || e === null || typeof e > "u")
    throw console.error(
      "The following error is a bug in React Router; please open an issue! https://github.com/remix-run/react-router/issues/new/choose"
    ), new Error(t);
}
var Te = "__reactRouterDevServerHooks";
function Sr(e) {
  globalThis[Te] = e;
}
function W() {
  return globalThis[Te];
}
function He(e, t) {
  if (typeof process < "u")
    try {
      if (process.env?.IS_RR_BUILD_REQUEST === "yes")
        return e.headers.get(t);
    } catch {
    }
  return null;
}
function Ie(e) {
  let t = {};
  return Object.values(e).forEach((r) => {
    if (r) {
      let a = r.parentId || "";
      t[a] || (t[a] = []), t[a].push(r);
    }
  }), t;
}
function Pe(e, t = "", r = Ie(e)) {
  return (r[t] || []).map((a) => ({
    ...a,
    children: Pe(e, a.id, r)
  }));
}
function Ue(e, t, r = "", a = Ie(e)) {
  return (a[r] || []).map((n) => {
    let s = {
      // Always include root due to default boundaries
      hasErrorBoundary: n.id === "root" || n.module.ErrorBoundary != null,
      id: n.id,
      path: n.path,
      unstable_middleware: n.module.unstable_middleware,
      // Need to use RR's version in the param typed here to permit the optional
      // context even though we know it'll always be provided in remix
      loader: n.module.loader ? async (o) => {
        let u = He(
          o.request,
          "X-React-Router-Prerender-Data"
        );
        if (u != null) {
          let l = u && decodeURI(u);
          M(l, "Missing prerendered data for route");
          let d = new TextEncoder().encode(l), h = new ReadableStream({
            start(f) {
              f.enqueue(d), f.close();
            }
          }), p = (await lt(h, global)).value;
          if (p && T in p) {
            let f = p[T], m = { status: f.status };
            throw f.reload ? ut(f.redirect, m) : f.replace ? dt(f.redirect, m) : ct(f.redirect, m);
          } else {
            M(
              p && n.id in p,
              "Unable to decode prerendered data"
            );
            let f = p[n.id];
            return M(
              "data" in f,
              "Unable to process prerendered data"
            ), f.data;
          }
        }
        return await fe(n.module.loader, o);
      } : void 0,
      action: n.module.action ? (o) => fe(n.module.action, o) : void 0,
      handle: n.module.handle
    };
    return n.index ? {
      index: !0,
      ...s
    } : {
      caseSensitive: n.caseSensitive,
      children: Ue(
        e,
        t,
        n.id,
        a
      ),
      ...s
    };
  });
}
var Ot = {
  "&": "\\u0026",
  ">": "\\u003e",
  "<": "\\u003c",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
}, zt = /[&><\u2028\u2029]/g;
function Bt(e) {
  return e.replace(zt, (t) => Ot[t]);
}
function he(e) {
  return Bt(JSON.stringify(e));
}
function te(e, t) {
  return $t(e, (r) => {
    let a = t.routes[r.route.id];
    return M(a, `Route with id "${r.route.id}" not found in build`), a.module.headers;
  });
}
function $t(e, t, r) {
  let a = e.errors ? e.matches.findIndex((u) => e.errors[u.route.id]) : -1, n = a >= 0 ? e.matches.slice(0, a + 1) : e.matches, s;
  if (a >= 0) {
    let { actionHeaders: u, actionData: i, loaderHeaders: l, loaderData: d } = e;
    e.matches.slice(a).some((h) => {
      let c = h.route.id;
      return u[c] && (!i || !i.hasOwnProperty(c)) ? s = u[c] : l[c] && !d.hasOwnProperty(c) && (s = l[c]), s != null;
    });
  }
  const o = new Headers(r);
  return n.reduce((u, i, l) => {
    let { id: d } = i.route, h = e.loaderHeaders[d] || new Headers(), c = e.actionHeaders[d] || new Headers(), p = s != null && l === n.length - 1, f = p && s !== h && s !== c, m = t(i);
    if (m == null) {
      let R = new Headers(u);
      return f && b(s, R), b(c, R), b(h, R), R;
    }
    let y = new Headers(
      typeof m == "function" ? m({
        loaderHeaders: h,
        parentHeaders: u,
        actionHeaders: c,
        errorHeaders: p ? s : void 0
      }) : m
    );
    return f && b(s, y), b(c, y), b(h, y), b(u, y), y;
  }, new Headers(o));
}
function b(e, t) {
  let r = e.get("Set-Cookie");
  if (r) {
    let a = bt.splitCookiesString(r), n = new Set(t.getSetCookie());
    a.forEach((s) => {
      n.has(s) || t.append("Set-Cookie", s);
    });
  }
}
var Me = /* @__PURE__ */ new Set([
  ...ft,
  304
]);
async function jt(e, t, r, a, n, s, o) {
  try {
    let d = new Request(n, {
      method: a.method,
      body: a.body,
      headers: a.headers,
      signal: a.signal,
      ...a.body ? { duplex: "half" } : void 0
    }), h = await r.query(d, {
      requestContext: s,
      skipLoaderErrorBubbling: !0,
      skipRevalidation: !0,
      unstable_generateMiddlewareResponse: e.future.unstable_middleware ? async (c) => {
        try {
          let p = await c(d);
          return u(p);
        } catch (p) {
          return i(p);
        }
      } : void 0
    });
    return u(h);
  } catch (d) {
    return i(d);
  }
  function u(d) {
    return C(d) ? d : l(d);
  }
  function i(d) {
    return o(d), H(a, e, t, {
      result: { error: d },
      headers: new Headers(),
      status: 500
    });
  }
  function l(d) {
    let h = te(d, e);
    if (Z(d.statusCode) && h.has("Location"))
      return new Response(null, { status: d.statusCode, headers: h });
    d.errors && (Object.values(d.errors).forEach((p) => {
      (!A(p) || p.error) && o(p);
    }), d.errors = O(d.errors, t));
    let c;
    return d.errors ? c = { error: Object.values(d.errors)[0] } : c = {
      data: Object.values(d.actionData || {})[0]
    }, H(a, e, t, {
      result: c,
      headers: h,
      status: d.statusCode
    });
  }
}
async function Vt(e, t, r, a, n, s, o) {
  let u = new URL(a.url).searchParams.get("_routes"), i = u ? new Set(u.split(",")) : null;
  try {
    let c = new Request(n, {
      headers: a.headers,
      signal: a.signal
    }), p = await r.query(c, {
      requestContext: s,
      filterMatchesToLoad: (f) => !i || i.has(f.route.id),
      skipLoaderErrorBubbling: !0,
      unstable_generateMiddlewareResponse: e.future.unstable_middleware ? async (f) => {
        try {
          let m = await f(c);
          return l(m);
        } catch (m) {
          return d(m);
        }
      } : void 0
    });
    return l(p);
  } catch (c) {
    return d(c);
  }
  function l(c) {
    return C(c) ? c : h(c);
  }
  function d(c) {
    return o(c), H(a, e, t, {
      result: { error: c },
      headers: new Headers(),
      status: 500
    });
  }
  function h(c) {
    let p = te(c, e);
    if (Z(c.statusCode) && p.has("Location"))
      return new Response(null, { status: c.statusCode, headers: p });
    c.errors && (Object.values(c.errors).forEach((y) => {
      (!A(y) || y.error) && o(y);
    }), c.errors = O(c.errors, t));
    let f = {}, m = new Set(
      c.matches.filter(
        (y) => i ? i.has(y.route.id) : y.route.loader != null
      ).map((y) => y.route.id)
    );
    if (c.errors)
      for (let [y, R] of Object.entries(c.errors))
        f[y] = { error: R };
    for (let [y, R] of Object.entries(c.loaderData))
      !(y in f) && m.has(y) && (f[y] = { data: R });
    return H(a, e, t, {
      result: f,
      headers: p,
      status: c.statusCode
    });
  }
}
function H(e, t, r, {
  result: a,
  headers: n,
  status: s
}) {
  let o = new Headers(n);
  return o.set("X-Remix-Response", "yes"), Me.has(s) ? new Response(null, { status: s, headers: o }) : (o.set("Content-Type", "text/x-script"), o.delete("Content-Length"), new Response(
    J(
      a,
      e.signal,
      t.entry.module.streamTimeout,
      r
    ),
    {
      status: s || 200,
      headers: o
    }
  ));
}
function pe(e, t, r, a) {
  let n = Wt(
    e.status,
    e.headers,
    r.basename
  ), s = new Headers(e.headers);
  return s.delete("Location"), s.set("Content-Type", "text/x-script"), H(t, r, a, {
    result: t.method === "GET" ? { [T]: n } : n,
    headers: s,
    status: Ce
  });
}
function Wt(e, t, r) {
  let a = t.get("Location");
  return r && (a = U(a, r) || a), {
    redirect: a,
    status: e,
    revalidate: (
      // Technically X-Remix-Revalidate isn't needed here - that was an implementation
      // detail of ?_data requests as our way to tell the front end to revalidate when
      // we didn't have a response body to include that information in.
      // With single fetch, we tell the front end via this revalidate boolean field.
      // However, we're respecting it for now because it may be something folks have
      // used in their own responses
      // TODO(v3): Consider removing or making this official public API
      t.has("X-Remix-Revalidate") || t.has("Set-Cookie")
    ),
    reload: t.has("X-Remix-Reload-Document"),
    replace: t.has("X-Remix-Replace")
  };
}
function J(e, t, r, a) {
  let n = new AbortController(), s = setTimeout(
    () => n.abort(new Error("Server Timeout")),
    typeof r == "number" ? r : 4950
  );
  return t.addEventListener("abort", () => clearTimeout(s)), ht(e, {
    signal: n.signal,
    plugins: [
      (o) => {
        if (o instanceof Error) {
          let { name: u, message: i, stack: l } = a === "production" ? V(o, a) : o;
          return ["SanitizedError", u, i, l];
        }
        if (o instanceof D) {
          let { data: u, status: i, statusText: l } = o;
          return ["ErrorResponse", u, i, l];
        }
        if (o && typeof o == "object" && T in o)
          return ["SingleFetchRedirect", o[T]];
      }
    ],
    postPlugins: [
      (o) => {
        if (o && typeof o == "object")
          return [
            "SingleFetchClassInstance",
            Object.fromEntries(Object.entries(o))
          ];
      },
      () => ["SingleFetchFallback"]
    ]
  });
}
function me(e, t) {
  let r = Pe(e.routes), a = Ue(e.routes, e.future), n = Ut(t) ? t : "production", s = Ze(a, {
    basename: e.basename
  }), o = e.entry.module.handleError || ((u, { request: i }) => {
    n !== "test" && !i.signal.aborted && console.error(
      // @ts-expect-error This is "private" from users but intended for internal use
      A(u) && u.error ? u.error : u
    );
  });
  return {
    routes: r,
    dataRoutes: a,
    serverMode: n,
    staticHandler: s,
    errorHandler: o
  };
}
var Er = (e, t) => {
  let r, a, n, s, o;
  return async function(i, l) {
    if (r = typeof e == "function" ? await e() : e, typeof e == "function") {
      let w = me(r, t);
      a = w.routes, n = w.serverMode, s = w.staticHandler, o = w.errorHandler;
    } else if (!a || !n || !s || !o) {
      let w = me(r, t);
      a = w.routes, n = w.serverMode, s = w.staticHandler, o = w.errorHandler;
    }
    let d = {}, h, c = (w) => {
      t === "development" && W()?.processRequestError?.(w), o(w, {
        context: h,
        params: d,
        request: i
      });
    };
    if (r.future.unstable_middleware) {
      if (l && !(l instanceof X)) {
        let w = new Error(
          "Invalid `context` value provided to `handleRequest`. When middleware is enabled you must return an instance of `unstable_RouterContextProvider` from your `getLoadContext` function."
        );
        return c(w), z(w, n);
      }
      h = l || new X();
    } else
      h = l || {};
    let p = new URL(i.url), f = r.basename || "/", m = p.pathname;
    U(m, f) === "/_root.data" ? m = f : m.endsWith(".data") && (m = m.replace(/\.data$/, "")), U(m, f) !== "/" && m.endsWith("/") && (m = m.slice(0, -1));
    let y = He(i, "X-React-Router-SPA-Mode") === "yes";
    if (!r.ssr) {
      let w = decodeURI(m);
      if (f !== "/") {
        let _ = U(w, f);
        if (_ == null)
          return o(
            new D(
              404,
              "Not Found",
              `Refusing to prerender the \`${w}\` path because it does not start with the basename \`${f}\``
            ),
            {
              context: h,
              params: d,
              request: i
            }
          ), new Response("Not Found", {
            status: 404,
            statusText: "Not Found"
          });
        w = _;
      }
      if (r.prerender.length === 0)
        y = !0;
      else if (!r.prerender.includes(w) && !r.prerender.includes(w + "/")) {
        if (p.pathname.endsWith(".data"))
          return o(
            new D(
              404,
              "Not Found",
              `Refusing to SSR the path \`${w}\` because \`ssr:false\` is set and the path is not included in the \`prerender\` config, so in production the path will be a 404.`
            ),
            {
              context: h,
              params: d,
              request: i
            }
          ), new Response("Not Found", {
            status: 404,
            statusText: "Not Found"
          });
        y = !0;
      }
    }
    let R = Ye(
      r.routeDiscovery.manifestPath,
      f
    );
    if (p.pathname === R)
      try {
        return await qt(r, a, p);
      } catch (w) {
        return c(w), new Response("Unknown Server Error", { status: 500 });
      }
    let S = Y(a, m, r.basename);
    S && S.length > 0 && Object.assign(d, S[0].params);
    let v;
    if (p.pathname.endsWith(".data")) {
      let w = new URL(i.url);
      w.pathname = m;
      let _ = Y(
        a,
        w.pathname,
        r.basename
      );
      v = await Gt(
        n,
        r,
        s,
        i,
        w,
        h,
        c
      ), oe(v) && (v = pe(
        v,
        i,
        r,
        n
      )), r.entry.module.handleDataRequest && (v = await r.entry.module.handleDataRequest(v, {
        context: h,
        params: _ ? _[0].params : {},
        request: i
      }), oe(v) && (v = pe(
        v,
        i,
        r,
        n
      )));
    } else if (!y && S && S[S.length - 1].route.module.default == null && S[S.length - 1].route.module.ErrorBoundary == null)
      v = await Yt(
        n,
        r,
        s,
        S.slice(-1)[0].route.id,
        i,
        h,
        c
      );
    else {
      let { pathname: w } = p, _;
      r.unstable_getCriticalCss ? _ = await r.unstable_getCriticalCss({ pathname: w }) : t === "development" && W()?.getCriticalCss && (_ = await W()?.getCriticalCss?.(w)), v = await Xt(
        n,
        r,
        s,
        i,
        h,
        c,
        y,
        _
      );
    }
    return i.method === "HEAD" ? new Response(null, {
      headers: v.headers,
      status: v.status,
      statusText: v.statusText
    }) : v;
  };
};
async function qt(e, t, r) {
  if (e.assets.version !== r.searchParams.get("version"))
    return new Response(null, {
      status: 204,
      headers: {
        "X-Remix-Reload-Document": "true"
      }
    });
  let a = {};
  if (r.searchParams.has("p")) {
    let n = /* @__PURE__ */ new Set();
    r.searchParams.getAll("p").forEach((s) => {
      s.startsWith("/") || (s = `/${s}`);
      let o = s.split("/").slice(1);
      o.forEach((u, i) => {
        let l = o.slice(0, i + 1).join("/");
        n.add(`/${l}`);
      });
    });
    for (let s of n) {
      let o = Y(t, s, e.basename);
      if (o)
        for (let u of o) {
          let i = u.route.id, l = e.assets.routes[i];
          l && (a[i] = l);
        }
    }
    return Response.json(a, {
      headers: {
        "Cache-Control": "public, max-age=31536000, immutable"
      }
    });
  }
  return new Response("Invalid Request", { status: 400 });
}
async function Gt(e, t, r, a, n, s, o) {
  return a.method !== "GET" ? await jt(
    t,
    e,
    r,
    a,
    n,
    s,
    o
  ) : await Vt(
    t,
    e,
    r,
    a,
    n,
    s,
    o
  );
}
async function Xt(e, t, r, a, n, s, o, u) {
  try {
    let l = await r.query(a, {
      requestContext: n,
      unstable_generateMiddlewareResponse: t.future.unstable_middleware ? async (d) => {
        try {
          let h = await d(a);
          return C(h) || (h = await i(h, o)), h;
        } catch (h) {
          return s(h), new Response(null, { status: 500 });
        }
      } : void 0
    });
    return C(l) || (l = await i(l, o)), l;
  } catch (l) {
    return s(l), new Response(null, { status: 500 });
  }
  async function i(l, d) {
    let h = te(l, t);
    if (Me.has(l.statusCode))
      return new Response(null, { status: l.statusCode, headers: h });
    l.errors && (Object.values(l.errors).forEach((y) => {
      (!A(y) || y.error) && s(y);
    }), l.errors = O(l.errors, e));
    let c = {
      loaderData: l.loaderData,
      actionData: l.actionData,
      errors: ce(l.errors, e)
    }, p = {
      basename: t.basename,
      future: t.future,
      routeDiscovery: t.routeDiscovery,
      ssr: t.ssr,
      isSpaMode: d
    }, f = {
      manifest: t.assets,
      routeModules: It(t.routes),
      staticHandlerContext: l,
      criticalCss: u,
      serverHandoffString: he({
        ...p,
        criticalCss: u
      }),
      serverHandoffStream: J(
        c,
        a.signal,
        t.entry.module.streamTimeout,
        e
      ),
      renderMeta: {},
      future: t.future,
      ssr: t.ssr,
      routeDiscovery: t.routeDiscovery,
      isSpaMode: d,
      serializeError: (y) => Le(y, e)
    }, m = t.entry.module.default;
    try {
      return await m(
        a,
        l.statusCode,
        h,
        f,
        n
      );
    } catch (y) {
      s(y);
      let R = y;
      if (C(y))
        try {
          let v = await Kt(y);
          R = new D(
            y.status,
            y.statusText,
            v
          );
        } catch {
        }
      l = et(
        r.dataRoutes,
        l,
        R
      ), l.errors && (l.errors = O(l.errors, e));
      let S = {
        loaderData: l.loaderData,
        actionData: l.actionData,
        errors: ce(l.errors, e)
      };
      f = {
        ...f,
        staticHandlerContext: l,
        serverHandoffString: he(p),
        serverHandoffStream: J(
          S,
          a.signal,
          t.entry.module.streamTimeout,
          e
        ),
        renderMeta: {}
      };
      try {
        return await m(
          a,
          l.statusCode,
          h,
          f,
          n
        );
      } catch (v) {
        return s(v), z(v, e);
      }
    }
  }
}
async function Yt(e, t, r, a, n, s, o) {
  try {
    let l = await r.queryRoute(n, {
      routeId: a,
      requestContext: s,
      unstable_generateMiddlewareResponse: t.future.unstable_middleware ? async (d) => {
        try {
          let h = await d(n);
          return u(h);
        } catch (h) {
          return i(h);
        }
      } : void 0
    });
    return u(l);
  } catch (l) {
    return i(l);
  }
  function u(l) {
    return C(l) ? l : typeof l == "string" ? new Response(l) : Response.json(l);
  }
  function i(l) {
    if (C(l))
      return l.headers.set("X-Remix-Catch", "yes"), l;
    if (A(l))
      return o(l), Jt(l, e);
    if (l instanceof Error && l.message === "Expected a response from queryRoute") {
      let d = new Error(
        "Expected a Response to be returned from resource route handler"
      );
      return o(d), z(d, e);
    }
    return o(l), z(l, e);
  }
}
function Jt(e, t) {
  return Response.json(
    Le(
      // @ts-expect-error This is "private" from users but intended for internal use
      e.error || new Error("Unexpected Server Error"),
      t
    ),
    {
      status: e.status,
      statusText: e.statusText,
      headers: {
        "X-Remix-Error": "yes"
      }
    }
  );
}
function z(e, t) {
  let r = "Unexpected Server Error";
  return t !== "production" && (r += `

${String(e)}`), new Response(r, {
    status: 500,
    headers: {
      "Content-Type": "text/plain"
    }
  });
}
function Kt(e) {
  let t = e.headers.get("Content-Type");
  return t && /\bapplication\/json\b/.test(t) ? e.body == null ? null : e.json() : e.text();
}
function q(e) {
  return `__flash_${e}__`;
}
var Ne = (e = {}, t = "") => {
  let r = new Map(Object.entries(e));
  return {
    get id() {
      return t;
    },
    get data() {
      return Object.fromEntries(r);
    },
    has(a) {
      return r.has(a) || r.has(q(a));
    },
    get(a) {
      if (r.has(a)) return r.get(a);
      let n = q(a);
      if (r.has(n)) {
        let s = r.get(n);
        return r.delete(n), s;
      }
    },
    set(a, n) {
      r.set(a, n);
    },
    flash(a, n) {
      r.set(q(a), n);
    },
    unset(a) {
      r.delete(a);
    }
  };
}, _r = (e) => e != null && typeof e.id == "string" && typeof e.data < "u" && typeof e.has == "function" && typeof e.get == "function" && typeof e.set == "function" && typeof e.flash == "function" && typeof e.unset == "function";
function Qt({
  cookie: e,
  createData: t,
  readData: r,
  updateData: a,
  deleteData: n
}) {
  let s = ke(e) ? e : Fe(e?.name || "__session", e);
  return Oe(s), {
    async getSession(o, u) {
      let i = o && await s.parse(o, u), l = i && await r(i);
      return Ne(l || {}, i || "");
    },
    async commitSession(o, u) {
      let { id: i, data: l } = o, d = u?.maxAge != null ? new Date(Date.now() + u.maxAge * 1e3) : u?.expires != null ? u.expires : s.expires;
      return i ? await a(i, l, d) : i = await t(l, d), s.serialize(i, u);
    },
    async destroySession(o, u) {
      return await n(o.id), s.serialize("", {
        ...u,
        maxAge: void 0,
        expires: /* @__PURE__ */ new Date(0)
      });
    }
  };
}
function Oe(e) {
  De(
    e.isSigned,
    `The "${e.name}" cookie is not signed, but session cookies should be signed to prevent tampering on the client before they are sent back to the server. See https://reactrouter.com/explanation/sessions-and-cookies#signing-cookies for more information.`
  );
}
function br({ cookie: e } = {}) {
  let t = ke(e) ? e : Fe(e?.name || "__session", e);
  return Oe(t), {
    async getSession(r, a) {
      return Ne(
        r && await t.parse(r, a) || {}
      );
    },
    async commitSession(r, a) {
      let n = await t.serialize(r.data, a);
      if (n.length > 4096)
        throw new Error(
          "Cookie length will exceed browser maximum. Length: " + n.length
        );
      return n;
    },
    async destroySession(r, a) {
      return t.serialize("", {
        ...a,
        maxAge: void 0,
        expires: /* @__PURE__ */ new Date(0)
      });
    }
  };
}
function Cr({ cookie: e } = {}) {
  let t = /* @__PURE__ */ new Map();
  return Qt({
    cookie: e,
    async createData(r, a) {
      let n = Math.random().toString(36).substring(2, 10);
      return t.set(n, { data: r, expires: a }), n;
    },
    async readData(r) {
      if (t.has(r)) {
        let { data: a, expires: n } = t.get(r);
        if (!n || n > /* @__PURE__ */ new Date())
          return a;
        n && t.delete(r);
      }
      return null;
    },
    async updateData(r, a, n) {
      t.set(r, { data: a, expires: n });
    },
    async deleteData(r) {
      t.delete(r);
    }
  });
}
function Dr(e, ...t) {
  let r = t[0];
  return e.split("/").map((a) => {
    if (a === "*")
      return r ? r["*"] : void 0;
    const n = a.match(/^:([\w-]+)(\?)?/);
    if (!n) return a;
    const s = n[1], o = r ? r[s] : void 0;
    if (n[2] === void 0 && o === void 0)
      throw Error(
        `Path '${e}' requires param '${s}' but it was not provided`
      );
    return o;
  }).filter((a) => a !== void 0).join("/");
}
function Zt(e, t, r, a, n, s) {
  let o = {
    ...e,
    loaderData: { ...e.loaderData }
  }, u = Ee(t, a, n);
  if (u)
    for (let i of u) {
      let l = i.route.id, d = r(l);
      $(
        l,
        d.clientLoader,
        d.hasLoader,
        s
      ) && (d.hasHydrateFallback || !d.hasLoader) ? delete o.loaderData[l] : d.hasLoader || (o.loaderData[l] = null);
    }
  return o;
}
var ze = class extends E.Component {
  constructor(e) {
    super(e), this.state = { error: null, location: e.location };
  }
  static getDerivedStateFromError(e) {
    return { error: e };
  }
  static getDerivedStateFromProps(e, t) {
    return t.location !== e.location ? { error: null, location: e.location } : { error: t.error, location: t.location };
  }
  render() {
    return this.state.error ? /* @__PURE__ */ E.createElement(
      Be,
      {
        error: this.state.error,
        renderAppShell: !0
      }
    ) : this.props.children;
  }
};
function ye({
  renderAppShell: e,
  title: t,
  children: r
}) {
  return e ? /* @__PURE__ */ E.createElement("html", { lang: "en" }, /* @__PURE__ */ E.createElement("head", null, /* @__PURE__ */ E.createElement("meta", { charSet: "utf-8" }), /* @__PURE__ */ E.createElement(
    "meta",
    {
      name: "viewport",
      content: "width=device-width,initial-scale=1,viewport-fit=cover"
    }
  ), /* @__PURE__ */ E.createElement("title", null, t)), /* @__PURE__ */ E.createElement("body", null, /* @__PURE__ */ E.createElement("main", { style: { fontFamily: "system-ui, sans-serif", padding: "2rem" } }, r))) : r;
}
function Be({
  error: e,
  renderAppShell: t
}) {
  console.error(e);
  let r = /* @__PURE__ */ E.createElement(
    "script",
    {
      dangerouslySetInnerHTML: {
        __html: `
        console.log(
          "ðŸ’¿ Hey developer ðŸ‘‹. You can provide a way better UX than this when your app throws errors. Check out https://reactrouter.com/how-to/error-boundary for more information."
        );
      `
      }
    }
  );
  if (A(e))
    return /* @__PURE__ */ E.createElement(
      ye,
      {
        renderAppShell: t,
        title: "Unhandled Thrown Response!"
      },
      /* @__PURE__ */ E.createElement("h1", { style: { fontSize: "24px" } }, e.status, " ", e.statusText),
      r
    );
  let a;
  if (e instanceof Error)
    a = e;
  else {
    let n = e == null ? "Unknown Error" : typeof e == "object" && "toString" in e ? e.toString() : JSON.stringify(e);
    a = new Error(n);
  }
  return /* @__PURE__ */ E.createElement(ye, { renderAppShell: t, title: "Application Error!" }, /* @__PURE__ */ E.createElement("h1", { style: { fontSize: "24px" } }, "Application Error"), /* @__PURE__ */ E.createElement(
    "pre",
    {
      style: {
        padding: "2rem",
        background: "hsla(10, 50%, 50%, 0.1)",
        color: "red",
        overflow: "auto"
      }
    },
    a.stack
  ), r);
}
function Ar({
  hasRootLayout: e
}) {
  let t = Xe();
  if (e === void 0)
    throw new Error("Missing 'hasRootLayout' prop");
  return /* @__PURE__ */ E.createElement(
    Be,
    {
      renderAppShell: !e,
      error: t
    }
  );
}
function er(e) {
  const t = {};
  for (const r of e.matches)
    re(t, r);
  return t;
}
function re(e, t) {
  t = Array.isArray(t) ? t : [t];
  for (const r of t)
    e[r.id] = {
      links: r.links,
      meta: r.meta,
      default: tr
    };
}
var tr = () => null;
function xr({
  createFromReadableStream: e,
  createTemporaryReferenceSet: t,
  encodeReply: r,
  fetch: a = fetch
}) {
  const n = window;
  let s = 0;
  return async (o, u) => {
    let i = n.__routerActionID = (n.__routerActionID ?? (n.__routerActionID = 0)) + 1;
    const l = t(), d = await a(
      new Request(location.href, {
        body: await r(u, { temporaryReferences: l }),
        method: "POST",
        headers: {
          Accept: "text/x-component",
          "rsc-action-id": o
        }
      })
    );
    if (!d.body)
      throw new Error("No response body");
    const h = await e(d.body, {
      temporaryReferences: l
    });
    if (h.type === "redirect") {
      if (h.reload) {
        window.location.href = h.location;
        return;
      }
      return n.__reactRouterDataRouter.navigate(h.location, {
        replace: h.replace
      }), h.actionResult;
    }
    if (h.type !== "action")
      throw new Error("Unexpected payload type");
    return h.rerender && g.startTransition(
      // @ts-expect-error - We have old react types that don't know this can be async
      async () => {
        const c = await h.rerender;
        if (c && s < i && n.__routerActionID <= i) {
          if (s = i, c.type === "redirect") {
            if (c.reload) {
              window.location.href = c.location;
              return;
            }
            n.__reactRouterDataRouter.navigate(c.location, {
              replace: c.replace
            });
            return;
          }
          let p;
          for (const f of c.matches)
            n.__reactRouterDataRouter.patchRoutes(
              p?.id ?? null,
              [F(f)],
              !0
            ), p = f;
          window.__reactRouterDataRouter._internalSetStateDoNotUseOrYouWillBreakYourApp(
            {}
          ), g.startTransition(() => {
            window.__reactRouterDataRouter._internalSetStateDoNotUseOrYouWillBreakYourApp(
              {
                loaderData: Object.assign(
                  {},
                  n.__reactRouterDataRouter.state.loaderData,
                  c.loaderData
                ),
                errors: c.errors ? Object.assign(
                  {},
                  n.__reactRouterDataRouter.state.errors,
                  c.errors
                ) : null
              }
            );
          });
        }
      }
    ), h.actionResult;
  };
}
function rr({
  fetchImplementation: e,
  createFromReadableStream: t,
  unstable_getContext: r,
  payload: a
}) {
  const n = window;
  if (n.__reactRouterDataRouter && n.__reactRouterRouteModules)
    return {
      router: n.__reactRouterDataRouter,
      routeModules: n.__reactRouterRouteModules
    };
  if (a.type !== "render") throw new Error("Invalid payload type");
  n.__reactRouterRouteModules = n.__reactRouterRouteModules ?? {}, re(n.__reactRouterRouteModules, a.matches);
  let s = /* @__PURE__ */ new Map();
  a.patches?.forEach((i) => {
    L(i.parentId, "Invalid patch parentId"), s.has(i.parentId) || s.set(i.parentId, []), s.get(i.parentId)?.push(i);
  });
  let o = a.matches.reduceRight((i, l) => {
    const d = F(
      l,
      a
    );
    if (i.length > 0) {
      d.children = i;
      let h = s.get(l.id);
      h && d.children.push(
        ...h.map((c) => F(c))
      );
    }
    return [d];
  }, []);
  n.__reactRouterDataRouter = ot({
    routes: o,
    unstable_getContext: r,
    basename: a.basename,
    history: st(),
    hydrationData: Zt(
      {
        loaderData: a.loaderData,
        actionData: a.actionData,
        errors: a.errors
      },
      o,
      (i) => {
        let l = a.matches.find((d) => d.id === i);
        return L(l, "Route not found in payload"), {
          clientLoader: l.clientLoader,
          hasLoader: l.hasLoader,
          hasHydrateFallback: l.hydrateFallbackElement != null
        };
      },
      a.location,
      void 0,
      !1
    ),
    async patchRoutesOnNavigation({ path: i, signal: l }) {
      B.has(i) || await $e(
        [i],
        t,
        e,
        l
      );
    },
    // FIXME: Pass `build.ssr` into this function
    dataStrategy: ar(
      () => n.__reactRouterDataRouter,
      !0,
      a.basename,
      t,
      e
    )
  }), n.__reactRouterDataRouter.state.initialized ? (n.__routerInitialized = !0, n.__reactRouterDataRouter.initialize()) : n.__routerInitialized = !1;
  let u;
  return n.__reactRouterDataRouter.subscribe(({ loaderData: i, actionData: l }) => {
    u !== i && (n.__routerActionID = (n.__routerActionID ?? (n.__routerActionID = 0)) + 1);
  }), n.__reactRouterDataRouter._updateRoutesForHMR = (i) => {
    const l = window.__reactRouterDataRouter.routes, d = [];
    function h(c, p) {
      return c.map((f) => {
        const m = i.get(f.id);
        if (m) {
          const {
            routeModule: R,
            hasAction: S,
            hasComponent: v,
            hasErrorBoundary: w,
            hasLoader: _
          } = m, I = F({
            clientAction: R.clientAction,
            clientLoader: R.clientLoader,
            element: f.element,
            errorElement: f.errorElement,
            handle: f.handle,
            hasAction: S,
            hasComponent: v,
            hasErrorBoundary: w,
            hasLoader: _,
            hydrateFallbackElement: f.hydrateFallbackElement,
            id: f.id,
            index: f.index,
            links: R.links,
            meta: R.meta,
            parentId: p,
            path: f.path,
            shouldRevalidate: R.shouldRevalidate
          });
          return f.children && (I.children = h(f.children, f.id)), I;
        }
        const y = { ...f };
        return f.children && (y.children = h(f.children, f.id)), y;
      });
    }
    d.push(
      ...h(l, void 0)
    ), window.__reactRouterDataRouter._internalSetRoutes(d);
  }, {
    router: n.__reactRouterDataRouter,
    routeModules: n.__reactRouterRouteModules
  };
}
var K = pt();
function ar(e, t, r, a, n) {
  let s = mt(
    e,
    (o) => {
      let u = o;
      return {
        hasLoader: u.route.hasLoader,
        hasClientLoader: u.route.hasClientLoader,
        hasComponent: u.route.hasComponent,
        hasAction: u.route.hasAction,
        hasClientAction: u.route.hasClientAction,
        hasShouldRevalidate: u.route.hasShouldRevalidate
      };
    },
    // pass map into fetchAndDecode so it can add payloads
    nr(a, n),
    t,
    r,
    // If the route has a component but we don't have an element, we need to hit
    // the server loader flow regardless of whether the client loader calls
    // `serverLoader` or not, otherwise we'll have nothing to render.
    (o) => {
      let u = o;
      return u.route.hasComponent && !u.route.element;
    }
  );
  return async (o) => o.unstable_runClientMiddleware(async () => {
    let u = o.context;
    u.set(K, []);
    let i = await s(o);
    const l = /* @__PURE__ */ new Map();
    for (const d of u.get(K))
      l.has(d.id) || l.set(d.id, []), l.get(d.id).push(d);
    for (const d of o.matches) {
      const h = l.get(d.route.id);
      if (h)
        for (const c of h)
          window.__reactRouterDataRouter.patchRoutes(
            c.parentId ?? null,
            [F(c)],
            !0
          );
    }
    return i;
  });
}
function nr(e, t) {
  return async (r, a, n) => {
    let { request: s, context: o } = r, u = Rt(s.url, a, "rsc");
    s.method === "GET" && (u = wt(u), n && u.searchParams.set("_routes", n.join(",")));
    let i = await t(
      new Request(u, await gt(s))
    );
    if (i.status === 404 && !i.headers.has("X-Remix-Response"))
      throw new D(404, "Not Found", !0);
    L(i.body, "No response body to decode");
    try {
      const l = await e(i.body, {
        temporaryReferences: void 0
      });
      if (l.type === "redirect")
        return {
          status: i.status,
          data: {
            redirect: {
              redirect: l.location,
              reload: l.reload,
              replace: l.replace,
              revalidate: !1,
              status: l.status
            }
          }
        };
      if (l.type !== "render")
        throw new Error("Unexpected payload type");
      o.get(K).push(...l.matches);
      let d = { routes: {} };
      const h = vt(s.method) ? "actionData" : "loaderData";
      for (let [c, p] of Object.entries(l[h] || {}))
        d.routes[c] = { data: p };
      if (l.errors)
        for (let [c, p] of Object.entries(l.errors))
          d.routes[c] = { error: p };
      return { status: i.status, data: d };
    } catch {
      throw new Error("Unable to decode RSC response");
    }
  };
}
function Fr({
  createFromReadableStream: e,
  fetch: t = fetch,
  payload: r,
  routeDiscovery: a = "eager",
  unstable_getContext: n
}) {
  if (r.type !== "render") throw new Error("Invalid payload type");
  let { router: s, routeModules: o } = g.useMemo(
    () => rr({
      payload: r,
      fetchImplementation: t,
      unstable_getContext: n,
      createFromReadableStream: e
    }),
    [
      e,
      r,
      t,
      n
    ]
  );
  g.useEffect(() => {
    Qe();
  }, []), g.useLayoutEffect(() => {
    const d = window;
    d.__routerInitialized || (d.__routerInitialized = !0, d.__reactRouterDataRouter.initialize());
  }, []);
  let [u, i] = g.useState(s.state.location);
  g.useLayoutEffect(
    () => s.subscribe((d) => {
      d.location !== u && i(d.location);
    }),
    [s, u]
  ), g.useEffect(() => {
    if (a === "lazy" || // @ts-expect-error - TS doesn't know about this yet
    window.navigator?.connection?.saveData === !0)
      return;
    function d(f) {
      let m = f.tagName === "FORM" ? f.getAttribute("action") : f.getAttribute("href");
      if (!m)
        return;
      let y = f.tagName === "A" ? f.pathname : new URL(m, window.location.origin).pathname;
      B.has(y) || N.add(y);
    }
    async function h() {
      document.querySelectorAll("a[data-discover], form[data-discover]").forEach(d);
      let f = Array.from(N.keys()).filter((m) => B.has(m) ? (N.delete(m), !1) : !0);
      if (f.length !== 0)
        try {
          await $e(
            f,
            e,
            t
          );
        } catch (m) {
          console.error("Failed to fetch manifest patches", m);
        }
    }
    let c = ur(h, 100);
    h(), new MutationObserver(() => c()).observe(document.documentElement, {
      subtree: !0,
      childList: !0,
      attributes: !0,
      attributeFilter: ["data-discover", "href", "action"]
    });
  }, [a, e, t]);
  const l = {
    future: {
      // These flags have no runtime impact so can always be false.  If we add
      // flags that drive runtime behavior they'll need to be proxied through.
      unstable_middleware: !1,
      unstable_subResourceIntegrity: !1
    },
    isSpaMode: !1,
    ssr: !0,
    criticalCss: "",
    manifest: {
      routes: {},
      version: "1",
      url: "",
      entry: {
        module: "",
        imports: []
      }
    },
    routeDiscovery: { mode: "lazy", manifestPath: "/__manifest" },
    routeModules: o
  };
  return /* @__PURE__ */ g.createElement(be.Provider, { value: !0 }, /* @__PURE__ */ g.createElement(ze, { location: u }, /* @__PURE__ */ g.createElement(j.Provider, { value: l }, /* @__PURE__ */ g.createElement(_e, { router: s, flushSync: St.flushSync }))));
}
function F(e, t) {
  let r = t && e.id in t.loaderData, a = t?.loaderData[e.id], n = t?.errors && e.id in t.errors, s = t?.errors?.[e.id], o = e.clientLoader?.hydrate === !0 || !e.hasLoader || // If the route has a component but we don't have an element, we need to hit
  // the server loader flow regardless of whether the client loader calls
  // `serverLoader` or not, otherwise we'll have nothing to render.
  e.hasComponent && !e.element;
  L(window.__reactRouterRouteModules), re(window.__reactRouterRouteModules, e);
  let u = {
    id: e.id,
    element: e.element,
    errorElement: e.errorElement,
    handle: e.handle,
    hasErrorBoundary: e.hasErrorBoundary,
    hydrateFallbackElement: e.hydrateFallbackElement,
    index: e.index,
    loader: e.clientLoader ? async (i, l) => {
      try {
        return await e.clientLoader({
          ...i,
          serverLoader: () => {
            if (Re(
              "loader",
              e.id,
              e.hasLoader
            ), o) {
              if (r)
                return a;
              if (n)
                throw s;
            }
            return P(l);
          }
        });
      } finally {
        o = !1;
      }
    } : (
      // We always make the call in this RSC world since even if we don't
      // have a `loader` we may need to get the `element` implementation
      (i, l) => P(l)
    ),
    action: e.clientAction ? (i, l) => e.clientAction({
      ...i,
      serverAction: async () => (Re(
        "action",
        e.id,
        e.hasLoader
      ), await P(l))
    }) : e.hasAction ? (i, l) => P(l) : () => {
      throw it("action", e.id);
    },
    path: e.path,
    shouldRevalidate: e.shouldRevalidate,
    // We always have a "loader" in this RSC world since even if we don't
    // have a `loader` we may need to get the `element` implementation
    hasLoader: !0,
    hasClientLoader: e.clientLoader != null,
    hasAction: e.hasAction,
    hasClientAction: e.clientAction != null,
    hasShouldRevalidate: e.shouldRevalidate != null
  };
  return typeof u.loader == "function" && (u.loader.hydrate = $(
    e.id,
    e.clientLoader,
    e.hasLoader,
    !1
  )), u;
}
function P(e) {
  return L(typeof e == "function", "Invalid singleFetch parameter"), e();
}
function Re(e, t, r) {
  if (!r) {
    let n = `You are trying to call ${e === "action" ? "serverAction()" : "serverLoader()"} on a route that does not have a server ${e} (routeId: "${t}")`;
    throw console.error(n), new D(400, "Bad Request", new Error(n), !0);
  }
}
var N = /* @__PURE__ */ new Set(), or = 1e3, B = /* @__PURE__ */ new Set(), sr = 7680;
function ir(e) {
  if (e.length === 0)
    return null;
  if (e.length === 1)
    return new URL(`${e[0]}.manifest`, window.location.origin);
  let r = (window.__reactRouterDataRouter.basename ?? "").replace(
    /^\/|\/$/g,
    ""
  ), a = new URL(`${r}/.manifest`, window.location.origin);
  return e.sort().forEach((n) => a.searchParams.append("p", n)), a;
}
async function $e(e, t, r, a) {
  let n = ir(e);
  if (n == null)
    return;
  if (n.toString().length > sr) {
    N.clear();
    return;
  }
  let s = await r(new Request(n, { signal: a }));
  if (!s.body || s.status < 200 || s.status >= 300)
    throw new Error("Unable to fetch new route matches from the server");
  let o = await t(s.body, {
    temporaryReferences: void 0
  });
  if (o.type !== "manifest")
    throw new Error("Failed to patch routes");
  e.forEach((u) => lr(u, B)), o.patches.forEach((u) => {
    window.__reactRouterDataRouter.patchRoutes(
      u.parentId ?? null,
      [F(u)]
    );
  });
}
function lr(e, t) {
  if (t.size >= or) {
    let r = t.values().next().value;
    t.delete(r);
  }
  t.add(e);
}
function ur(e, t) {
  let r;
  return (...a) => {
    window.clearTimeout(r), r = window.setTimeout(() => e(...a), t);
  };
}
var Q = new TextEncoder(), we = "</body></html>";
function dr(e) {
  let t = new TextDecoder(), r, a = new Promise(
    (i) => r = i
  ), n = !1, s = [], o = null;
  function u(i) {
    for (let l of s) {
      let d = t.decode(l, { stream: !0 });
      d.endsWith(we) && (d = d.slice(0, -we.length)), i.enqueue(Q.encode(d));
    }
    s.length = 0, o = null;
  }
  return new TransformStream({
    transform(i, l) {
      s.push(i), !o && (o = setTimeout(async () => {
        u(l), n || (n = !0, cr(e, l).catch((d) => l.error(d)).then(r));
      }, 0));
    },
    async flush(i) {
      await a, o && (clearTimeout(o), u(i)), i.enqueue(Q.encode("</body></html>"));
    }
  });
}
async function cr(e, t) {
  let r = new TextDecoder("utf-8", { fatal: !0 });
  const a = e.getReader();
  try {
    let s;
    for (; (s = await a.read()) && !s.done; ) {
      const o = s.value;
      try {
        G(
          JSON.stringify(r.decode(o, { stream: !0 })),
          t
        );
      } catch {
        let i = JSON.stringify(btoa(String.fromCodePoint(...o)));
        G(
          `Uint8Array.from(atob(${i}), m => m.codePointAt(0))`,
          t
        );
      }
    }
  } finally {
    a.releaseLock();
  }
  let n = r.decode();
  n.length && G(JSON.stringify(n), t);
}
function G(e, t) {
  t.enqueue(
    Q.encode(
      `<script>${fr(
        `(self.__FLIGHT_DATA||=[]).push(${e})`
      )}<\/script>`
    )
  );
}
function fr(e) {
  return e.replace(/<!--/g, "<\\!--").replace(/<\/(script)/gi, "</\\$1");
}
var hr = "use", ge = g[hr];
function pr(e) {
  if (ge)
    return ge(e);
  throw new Error("React Router v7 requires React 19+ for RSC features.");
}
async function kr({
  request: e,
  fetchServer: t,
  createFromReadableStream: r,
  renderHTML: a,
  hydrate: n = !0
}) {
  const s = new URL(e.url), u = mr(s) || yr(s) || e.headers.has("rsc-action-id"), i = await t(e);
  if (u || i.headers.get("React-Router-Resource") === "true")
    return i;
  if (!i.body)
    throw new Error("Missing body in server response");
  let l = null;
  n && (l = i.clone());
  const d = i.body;
  let h;
  const c = async () => h || (h = r(d), h);
  try {
    const p = await c();
    if (i.status === Ce && p.type === "redirect") {
      const R = new Headers(i.headers);
      return R.delete("Content-Encoding"), R.delete("Content-Length"), R.delete("Content-Type"), R.delete("x-remix-response"), R.set("Location", p.location), new Response(l?.body || "", {
        headers: R,
        status: p.status,
        statusText: i.statusText
      });
    }
    const f = await a(c), m = new Headers(i.headers);
    if (m.set("Content-Type", "text/html"), !n)
      return new Response(f, {
        status: i.status,
        headers: m
      });
    if (!l?.body)
      throw new Error("Failed to clone server response");
    const y = f.pipeThrough(dr(l.body));
    return new Response(y, {
      status: i.status,
      headers: m
    });
  } catch (p) {
    if (p instanceof Response)
      return p;
    throw p;
  }
}
function Lr({ getPayload: e }) {
  const t = pr(e());
  if (t.type === "redirect")
    throw new Response(null, {
      status: t.status,
      headers: {
        Location: t.location
      }
    });
  if (t.type !== "render") return null;
  let r = { ...t.loaderData };
  for (const o of t.matches)
    $(
      o.id,
      o.clientLoader,
      o.hasLoader,
      !1
    ) && (o.hydrateFallbackElement || !o.hasLoader) && delete r[o.id];
  const a = {
    actionData: t.actionData,
    actionHeaders: {},
    basename: t.basename,
    errors: t.errors,
    loaderData: r,
    loaderHeaders: {},
    location: t.location,
    statusCode: 200,
    matches: t.matches.map((o) => ({
      params: o.params,
      pathname: o.pathname,
      pathnameBase: o.pathnameBase,
      route: {
        id: o.id,
        action: o.hasAction || !!o.clientAction,
        handle: o.handle,
        hasErrorBoundary: o.hasErrorBoundary,
        loader: o.hasLoader || !!o.clientLoader,
        index: o.index,
        path: o.path,
        shouldRevalidate: o.shouldRevalidate
      }
    }))
  }, n = ve(
    t.matches.reduceRight((o, u) => {
      const i = {
        id: u.id,
        action: u.hasAction || !!u.clientAction,
        element: u.element,
        errorElement: u.errorElement,
        handle: u.handle,
        hasErrorBoundary: !!u.errorElement,
        hydrateFallbackElement: u.hydrateFallbackElement,
        index: u.index,
        loader: u.hasLoader || !!u.clientLoader,
        path: u.path,
        shouldRevalidate: u.shouldRevalidate
      };
      return o.length > 0 && (i.children = o), [i];
    }, []),
    a
  ), s = {
    future: {
      // These flags have no runtime impact so can always be false.  If we add
      // flags that drive runtime behavior they'll need to be proxied through.
      unstable_middleware: !1,
      unstable_subResourceIntegrity: !1
    },
    isSpaMode: !1,
    ssr: !0,
    criticalCss: "",
    manifest: {
      routes: {},
      version: "1",
      url: "",
      entry: {
        module: "",
        imports: []
      }
    },
    routeDiscovery: { mode: "lazy", manifestPath: "/__manifest" },
    routeModules: er(t)
  };
  return /* @__PURE__ */ g.createElement(be.Provider, { value: !0 }, /* @__PURE__ */ g.createElement(ze, { location: t.location }, /* @__PURE__ */ g.createElement(j.Provider, { value: s }, /* @__PURE__ */ g.createElement(
    Se,
    {
      context: a,
      router: n,
      hydrate: !1,
      nonce: t.nonce
    }
  ))));
}
function mr(e) {
  return e.pathname.endsWith(".rsc");
}
function yr(e) {
  return e.pathname.endsWith(".manifest");
}
function Tr() {
  let e = new TextEncoder(), t = null, r = new ReadableStream({
    start(a) {
      if (typeof window > "u")
        return;
      let n = (s) => {
        typeof s == "string" ? a.enqueue(e.encode(s)) : a.enqueue(s);
      };
      window.__FLIGHT_DATA || (window.__FLIGHT_DATA = []), window.__FLIGHT_DATA.forEach(n), window.__FLIGHT_DATA.push = (s) => (n(s), 0), t = a;
    }
  });
  return typeof document < "u" && document.readyState === "loading" ? document.addEventListener("DOMContentLoaded", () => {
    t?.close();
  }) : t?.close(), r;
}
function Hr(e) {
  if (!e) return null;
  let t = Object.entries(e), r = {};
  for (let [a, n] of t)
    if (n && n.__type === "RouteErrorResponse")
      r[a] = new D(
        n.status,
        n.statusText,
        n.data,
        n.internal === !0
      );
    else if (n && n.__type === "Error") {
      if (n.__subType) {
        let s = window[n.__subType];
        if (typeof s == "function")
          try {
            let o = new s(n.message);
            o.stack = n.stack, r[a] = o;
          } catch {
          }
      }
      if (r[a] == null) {
        let s = new Error(n.message);
        s.stack = n.stack, r[a] = s;
      }
    } else
      r[a] = n;
  return r;
}
export {
  Ur as Await,
  Mr as BrowserRouter,
  Nr as Form,
  Or as HashRouter,
  zr as IDLE_BLOCKER,
  Br as IDLE_FETCHER,
  $r as IDLE_NAVIGATION,
  jr as Link,
  Vr as Links,
  Wr as MemoryRouter,
  qr as Meta,
  Gr as NavLink,
  Xr as Navigate,
  Yr as NavigationType,
  nt as Outlet,
  Jr as PrefetchPageLinks,
  Kr as Route,
  Qr as Router,
  _e as RouterProvider,
  Zr as Routes,
  ea as Scripts,
  ta as ScrollRestoration,
  gr as ServerRouter,
  ra as StaticRouter,
  Se as StaticRouterProvider,
  aa as UNSAFE_DataRouterContext,
  na as UNSAFE_DataRouterStateContext,
  D as UNSAFE_ErrorResponseImpl,
  oa as UNSAFE_FetchersContext,
  j as UNSAFE_FrameworkContext,
  sa as UNSAFE_LocationContext,
  ia as UNSAFE_NavigationContext,
  Ar as UNSAFE_RSCDefaultRootErrorBoundary,
  qe as UNSAFE_RemixErrorBoundary,
  la as UNSAFE_RouteContext,
  Pt as UNSAFE_ServerMode,
  T as UNSAFE_SingleFetchRedirectSymbol,
  ua as UNSAFE_ViewTransitionContext,
  da as UNSAFE_WithComponentProps,
  ca as UNSAFE_WithErrorBoundaryProps,
  fa as UNSAFE_WithHydrateFallbackProps,
  st as UNSAFE_createBrowserHistory,
  ha as UNSAFE_createClientRoutes,
  pa as UNSAFE_createClientRoutesWithHMRRevalidationOptOut,
  ot as UNSAFE_createRouter,
  lt as UNSAFE_decodeViaTurboStream,
  Hr as UNSAFE_deserializeErrors,
  Zt as UNSAFE_getHydrationData,
  ma as UNSAFE_getPatchRoutesOnNavigationFunction,
  ya as UNSAFE_getTurboStreamSingleFetchDataStrategy,
  Ra as UNSAFE_hydrationRouteProperties,
  L as UNSAFE_invariant,
  wa as UNSAFE_mapRouteProperties,
  $ as UNSAFE_shouldHydrateRouteLoader,
  ga as UNSAFE_useFogOFWarDiscovery,
  va as UNSAFE_useScrollRestoration,
  at as UNSAFE_withComponentProps,
  tt as UNSAFE_withErrorBoundaryProps,
  rt as UNSAFE_withHydrateFallbackProps,
  Sa as createBrowserRouter,
  Fe as createCookie,
  br as createCookieSessionStorage,
  Ea as createHashRouter,
  Ke as createMemoryRouter,
  Cr as createMemorySessionStorage,
  _a as createPath,
  Er as createRequestHandler,
  ba as createRoutesFromChildren,
  Ca as createRoutesFromElements,
  vr as createRoutesStub,
  Da as createSearchParams,
  Ne as createSession,
  Qt as createSessionStorage,
  Aa as createStaticHandler,
  ve as createStaticRouter,
  xa as data,
  Fa as generatePath,
  Dr as href,
  ke as isCookie,
  A as isRouteErrorResponse,
  _r as isSession,
  ka as matchPath,
  Ee as matchRoutes,
  La as parsePath,
  ct as redirect,
  ut as redirectDocument,
  Ta as renderMatches,
  dt as replace,
  Ha as resolvePath,
  Ia as unstable_HistoryRouter,
  Fr as unstable_RSCHydratedRouter,
  Lr as unstable_RSCStaticRouter,
  X as unstable_RouterContextProvider,
  xr as unstable_createCallServer,
  pt as unstable_createContext,
  Tr as unstable_getRSCStream,
  kr as unstable_routeRSCServerRequest,
  Sr as unstable_setDevServerHooks,
  Pa as unstable_usePrompt,
  Ua as useActionData,
  Ma as useAsyncError,
  Na as useAsyncValue,
  Oa as useBeforeUnload,
  za as useBlocker,
  Ba as useFetcher,
  $a as useFetchers,
  ja as useFormAction,
  Va as useHref,
  Wa as useInRouterContext,
  qa as useLinkClickHandler,
  Ga as useLoaderData,
  Xa as useLocation,
  Ya as useMatch,
  Ja as useMatches,
  Ka as useNavigate,
  Qa as useNavigation,
  Za as useNavigationType,
  en as useOutlet,
  tn as useOutletContext,
  rn as useParams,
  an as useResolvedPath,
  nn as useRevalidator,
  Xe as useRouteError,
  on as useRouteLoaderData,
  sn as useRoutes,
  ln as useSearchParams,
  un as useSubmit,
  dn as useViewTransitionState
};
//# sourceMappingURL=zudoku.router.js.map
