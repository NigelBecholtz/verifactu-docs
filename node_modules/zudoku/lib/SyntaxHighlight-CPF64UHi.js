import { j as at } from "./jsx-runtime-DywqP_6a.js";
import { Fragment as rs, memo as os } from "react";
import { d as ss } from "./ZudokuContext-BcqSiygJ.js";
import { c as as } from "./cn-dYga0KKN.js";
import { g as is, i as ls } from "./invariant-Bm-FVUQE.js";
import { C as us } from "./CodeBlock-i0BM_QFf.js";
import { EmbeddedCodeBlock as cs } from "./ui/EmbeddedCodeBlock.js";
function th() {
}
function nh() {
}
function rh(t) {
  const e = [], n = String(t || "");
  let r = n.indexOf(","), o = 0, s = !1;
  for (; !s; ) {
    r === -1 && (r = n.length, s = !0);
    const a = n.slice(o, r).trim();
    (a || !s) && e.push(a), o = r + 1, r = n.indexOf(",", o);
  }
  return e;
}
function Ir(t, e) {
  const n = e || {};
  return (t[t.length - 1] === "" ? [...t, ""] : t).join(
    (n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")
  ).trim();
}
const hs = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, fs = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, ps = {};
function In(t, e) {
  return (ps.jsx ? fs : hs).test(t);
}
const ds = /[ \t\n\f\r]/g;
function Ct(t) {
  return typeof t == "object" ? t.type === "text" ? Nn(t.value) : !1 : Nn(t);
}
function Nn(t) {
  return t.replace(ds, "") === "";
}
let qe = class {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(e, n, r) {
    this.normal = n, this.property = e, r && (this.space = r);
  }
};
qe.prototype.normal = {};
qe.prototype.property = {};
qe.prototype.space = void 0;
function Nr(t, e) {
  const n = {}, r = {};
  for (const o of t)
    Object.assign(n, o.property), Object.assign(r, o.normal);
  return new qe(n, r, e);
}
function zt(t) {
  return t.toLowerCase();
}
let W = class {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(e, n) {
    this.attribute = n, this.property = e;
  }
};
W.prototype.attribute = "";
W.prototype.booleanish = !1;
W.prototype.boolean = !1;
W.prototype.commaOrSpaceSeparated = !1;
W.prototype.commaSeparated = !1;
W.prototype.defined = !1;
W.prototype.mustUseProperty = !1;
W.prototype.number = !1;
W.prototype.overloadedBoolean = !1;
W.prototype.property = "";
W.prototype.spaceSeparated = !1;
W.prototype.space = void 0;
let gs = 0;
const x = ye(), $ = ye(), Lr = ye(), b = ye(), I = ye(), xe = ye(), q = ye();
function ye() {
  return 2 ** ++gs;
}
const Ht = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: x,
  booleanish: $,
  commaOrSpaceSeparated: q,
  commaSeparated: xe,
  number: b,
  overloadedBoolean: Lr,
  spaceSeparated: I
}, Symbol.toStringTag, { value: "Module" })), At = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys(Ht)
);
let hn = class extends W {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(e, n, r, o) {
    let s = -1;
    if (super(e, n), Ln(this, "space", o), typeof r == "number")
      for (; ++s < At.length; ) {
        const a = At[s];
        Ln(this, At[s], (r & Ht[a]) === Ht[a]);
      }
  }
};
hn.prototype.defined = !0;
function Ln(t, e, n) {
  n && (t[e] = n);
}
function Ie(t) {
  const e = {}, n = {};
  for (const [r, o] of Object.entries(t.properties)) {
    const s = new hn(
      r,
      t.transform(t.attributes || {}, r),
      o,
      t.space
    );
    t.mustUseProperty && t.mustUseProperty.includes(r) && (s.mustUseProperty = !0), e[r] = s, n[zt(r)] = r, n[zt(s.attribute)] = r;
  }
  return new qe(e, n, t.space);
}
const Pr = Ie({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: $,
    ariaAutoComplete: null,
    ariaBusy: $,
    ariaChecked: $,
    ariaColCount: b,
    ariaColIndex: b,
    ariaColSpan: b,
    ariaControls: I,
    ariaCurrent: null,
    ariaDescribedBy: I,
    ariaDetails: null,
    ariaDisabled: $,
    ariaDropEffect: I,
    ariaErrorMessage: null,
    ariaExpanded: $,
    ariaFlowTo: I,
    ariaGrabbed: $,
    ariaHasPopup: null,
    ariaHidden: $,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: I,
    ariaLevel: b,
    ariaLive: null,
    ariaModal: $,
    ariaMultiLine: $,
    ariaMultiSelectable: $,
    ariaOrientation: null,
    ariaOwns: I,
    ariaPlaceholder: null,
    ariaPosInSet: b,
    ariaPressed: $,
    ariaReadOnly: $,
    ariaRelevant: null,
    ariaRequired: $,
    ariaRoleDescription: I,
    ariaRowCount: b,
    ariaRowIndex: b,
    ariaRowSpan: b,
    ariaSelected: $,
    ariaSetSize: b,
    ariaSort: null,
    ariaValueMax: b,
    ariaValueMin: b,
    ariaValueNow: b,
    ariaValueText: null,
    role: null
  },
  transform(t, e) {
    return e === "role" ? e : "aria-" + e.slice(4).toLowerCase();
  }
});
function $r(t, e) {
  return e in t ? t[e] : e;
}
function Tr(t, e) {
  return $r(t, e.toLowerCase());
}
const ms = Ie({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: xe,
    acceptCharset: I,
    accessKey: I,
    action: null,
    allow: null,
    allowFullScreen: x,
    allowPaymentRequest: x,
    allowUserMedia: x,
    alt: null,
    as: null,
    async: x,
    autoCapitalize: null,
    autoComplete: I,
    autoFocus: x,
    autoPlay: x,
    blocking: I,
    capture: null,
    charSet: null,
    checked: x,
    cite: null,
    className: I,
    cols: b,
    colSpan: null,
    content: null,
    contentEditable: $,
    controls: x,
    controlsList: I,
    coords: b | xe,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: x,
    defer: x,
    dir: null,
    dirName: null,
    disabled: x,
    download: Lr,
    draggable: $,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: x,
    formTarget: null,
    headers: I,
    height: b,
    hidden: x,
    high: b,
    href: null,
    hrefLang: null,
    htmlFor: I,
    httpEquiv: I,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: x,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: x,
    itemId: null,
    itemProp: I,
    itemRef: I,
    itemScope: x,
    itemType: I,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: x,
    low: b,
    manifest: null,
    max: null,
    maxLength: b,
    media: null,
    method: null,
    min: null,
    minLength: b,
    multiple: x,
    muted: x,
    name: null,
    nonce: null,
    noModule: x,
    noValidate: x,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: x,
    optimum: b,
    pattern: null,
    ping: I,
    placeholder: null,
    playsInline: x,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: x,
    referrerPolicy: null,
    rel: I,
    required: x,
    reversed: x,
    rows: b,
    rowSpan: b,
    sandbox: I,
    scope: null,
    scoped: x,
    seamless: x,
    selected: x,
    shadowRootClonable: x,
    shadowRootDelegatesFocus: x,
    shadowRootMode: null,
    shape: null,
    size: b,
    sizes: null,
    slot: null,
    span: b,
    spellCheck: $,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: b,
    step: null,
    style: null,
    tabIndex: b,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: x,
    useMap: null,
    value: $,
    width: b,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: I,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: b,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: b,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: x,
    // Lists. Use CSS to reduce space between items instead
    declare: x,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: b,
    // `<img>` and `<object>`
    leftMargin: b,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: b,
    // `<body>`
    marginWidth: b,
    // `<body>`
    noResize: x,
    // `<frame>`
    noHref: x,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: x,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: x,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: b,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: $,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: b,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: b,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: x,
    disableRemotePlayback: x,
    prefix: null,
    property: null,
    results: b,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: Tr
}), ys = Ie({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: q,
    accentHeight: b,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: b,
    amplitude: b,
    arabicForm: null,
    ascent: b,
    attributeName: null,
    attributeType: null,
    azimuth: b,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: b,
    by: null,
    calcMode: null,
    capHeight: b,
    className: I,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: b,
    diffuseConstant: b,
    direction: null,
    display: null,
    dur: null,
    divisor: b,
    dominantBaseline: null,
    download: x,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: b,
    enableBackground: null,
    end: null,
    event: null,
    exponent: b,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: b,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: xe,
    g2: xe,
    glyphName: xe,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: b,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: b,
    horizOriginX: b,
    horizOriginY: b,
    id: null,
    ideographic: b,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: b,
    k: b,
    k1: b,
    k2: b,
    k3: b,
    k4: b,
    kernelMatrix: q,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: b,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: b,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: b,
    overlineThickness: b,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: b,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: I,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: b,
    pointsAtY: b,
    pointsAtZ: b,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: q,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: q,
    rev: q,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: q,
    requiredFeatures: q,
    requiredFonts: q,
    requiredFormats: q,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: b,
    specularExponent: b,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: b,
    strikethroughThickness: b,
    string: null,
    stroke: null,
    strokeDashArray: q,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: b,
    strokeOpacity: b,
    strokeWidth: null,
    style: null,
    surfaceScale: b,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: q,
    tabIndex: b,
    tableValues: null,
    target: null,
    targetX: b,
    targetY: b,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: q,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: b,
    underlineThickness: b,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: b,
    values: null,
    vAlphabetic: b,
    vMathematical: b,
    vectorEffect: null,
    vHanging: b,
    vIdeographic: b,
    version: null,
    vertAdvY: b,
    vertOriginX: b,
    vertOriginY: b,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: b,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: $r
}), Mr = Ie({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(t, e) {
    return "xlink:" + e.slice(5).toLowerCase();
  }
}), Or = Ie({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: Tr
}), Dr = Ie({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(t, e) {
    return "xml:" + e.slice(3).toLowerCase();
  }
}), bs = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, ws = /[A-Z]/g, Pn = /-[a-z]/g, Cs = /^data[-\w.:]+$/i;
function _s(t, e) {
  const n = zt(e);
  let r = e, o = W;
  if (n in t.normal)
    return t.property[t.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && Cs.test(e)) {
    if (e.charAt(4) === "-") {
      const s = e.slice(5).replace(Pn, ks);
      r = "data" + s.charAt(0).toUpperCase() + s.slice(1);
    } else {
      const s = e.slice(4);
      if (!Pn.test(s)) {
        let a = s.replace(ws, Ss);
        a.charAt(0) !== "-" && (a = "-" + a), e = "data" + a;
      }
    }
    o = hn;
  }
  return new o(r, e);
}
function Ss(t) {
  return "-" + t.toLowerCase();
}
function ks(t) {
  return t.charAt(1).toUpperCase();
}
const vs = Nr([Pr, ms, Mr, Or, Dr], "html"), fn = Nr([Pr, ys, Mr, Or, Dr], "svg");
function ih(t) {
  const e = String(t || "").trim();
  return e ? e.split(/[ \t\n\r\f]+/g) : [];
}
function Gr(t) {
  return t.join(" ").trim();
}
var we = {}, Rt, $n;
function xs() {
  if ($n) return Rt;
  $n = 1;
  var t = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, e = /\n/g, n = /^\s*/, r = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, o = /^:\s*/, s = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, a = /^[;\s]*/, i = /^\s+|\s+$/g, l = `
`, u = "/", c = "*", h = "", p = "comment", d = "declaration";
  Rt = function(g, C) {
    if (typeof g != "string")
      throw new TypeError("First argument must be a string");
    if (!g) return [];
    C = C || {};
    var y = 1, m = 1;
    function _(R) {
      var k = R.match(e);
      k && (y += k.length);
      var G = R.lastIndexOf(l);
      m = ~G ? R.length - G : m + R.length;
    }
    function S() {
      var R = { line: y, column: m };
      return function(k) {
        return k.position = new A(R), j(), k;
      };
    }
    function A(R) {
      this.start = R, this.end = { line: y, column: m }, this.source = C.source;
    }
    A.prototype.content = g;
    function D(R) {
      var k = new Error(
        C.source + ":" + y + ":" + m + ": " + R
      );
      if (k.reason = R, k.filename = C.source, k.line = y, k.column = m, k.source = g, !C.silent) throw k;
    }
    function L(R) {
      var k = R.exec(g);
      if (k) {
        var G = k[0];
        return _(G), g = g.slice(G.length), k;
      }
    }
    function j() {
      L(n);
    }
    function Z(R) {
      var k;
      for (R = R || []; k = ee(); )
        k !== !1 && R.push(k);
      return R;
    }
    function ee() {
      var R = S();
      if (!(u != g.charAt(0) || c != g.charAt(1))) {
        for (var k = 2; h != g.charAt(k) && (c != g.charAt(k) || u != g.charAt(k + 1)); )
          ++k;
        if (k += 2, h === g.charAt(k - 1))
          return D("End of comment missing");
        var G = g.slice(2, k - 2);
        return m += 2, _(G), g = g.slice(k), m += 2, R({
          type: p,
          comment: G
        });
      }
    }
    function ce() {
      var R = S(), k = L(r);
      if (k) {
        if (ee(), !L(o)) return D("property missing ':'");
        var G = L(s), Te = R({
          type: d,
          property: f(k[0].replace(t, h)),
          value: G ? f(G[0].replace(t, h)) : h
        });
        return L(a), Te;
      }
    }
    function te() {
      var R = [];
      Z(R);
      for (var k; k = ce(); )
        k !== !1 && (R.push(k), Z(R));
      return R;
    }
    return j(), te();
  };
  function f(g) {
    return g ? g.replace(i, h) : h;
  }
  return Rt;
}
var Tn;
function Es() {
  if (Tn) return we;
  Tn = 1;
  var t = we && we.__importDefault || function(r) {
    return r && r.__esModule ? r : { default: r };
  };
  Object.defineProperty(we, "__esModule", { value: !0 }), we.default = n;
  var e = t(xs());
  function n(r, o) {
    var s = null;
    if (!r || typeof r != "string")
      return s;
    var a = (0, e.default)(r), i = typeof o == "function";
    return a.forEach(function(l) {
      if (l.type === "declaration") {
        var u = l.property, c = l.value;
        i ? o(u, c, l) : c && (s = s || {}, s[u] = c);
      }
    }), s;
  }
  return we;
}
var Me = {}, Mn;
function As() {
  if (Mn) return Me;
  Mn = 1, Object.defineProperty(Me, "__esModule", { value: !0 }), Me.camelCase = void 0;
  var t = /^--[a-zA-Z0-9_-]+$/, e = /-([a-z])/g, n = /^[^-]+$/, r = /^-(webkit|moz|ms|o|khtml)-/, o = /^-(ms)-/, s = function(u) {
    return !u || n.test(u) || t.test(u);
  }, a = function(u, c) {
    return c.toUpperCase();
  }, i = function(u, c) {
    return "".concat(c, "-");
  }, l = function(u, c) {
    return c === void 0 && (c = {}), s(u) ? u : (u = u.toLowerCase(), c.reactCompat ? u = u.replace(o, i) : u = u.replace(r, i), u.replace(e, a));
  };
  return Me.camelCase = l, Me;
}
var Oe, On;
function Rs() {
  if (On) return Oe;
  On = 1;
  var t = Oe && Oe.__importDefault || function(o) {
    return o && o.__esModule ? o : { default: o };
  }, e = t(Es()), n = As();
  function r(o, s) {
    var a = {};
    return !o || typeof o != "string" || (0, e.default)(o, function(i, l) {
      i && l && (a[(0, n.camelCase)(i, s)] = l);
    }), a;
  }
  return r.default = r, Oe = r, Oe;
}
var Is = Rs();
const Ns = /* @__PURE__ */ is(Is), Ls = Br("end"), Fr = Br("start");
function Br(t) {
  return e;
  function e(n) {
    const r = n && n.position && n.position[t] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
function lh(t) {
  const e = Fr(t), n = Ls(t);
  if (e && n)
    return { start: e, end: n };
}
function Ps(t) {
  return !t || typeof t != "object" ? "" : "position" in t || "type" in t ? Dn(t.position) : "start" in t || "end" in t ? Dn(t) : "line" in t || "column" in t ? Wt(t) : "";
}
function Wt(t) {
  return Gn(t && t.line) + ":" + Gn(t && t.column);
}
function Dn(t) {
  return Wt(t && t.start) + "-" + Wt(t && t.end);
}
function Gn(t) {
  return t && typeof t == "number" ? t : 1;
}
class H extends Error {
  /**
   * Create a message for `reason`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(e, n, r) {
    super(), typeof n == "string" && (r = n, n = void 0);
    let o = "", s = {}, a = !1;
    if (n && ("line" in n && "column" in n ? s = { place: n } : "start" in n && "end" in n ? s = { place: n } : "type" in n ? s = {
      ancestors: [n],
      place: n.position
    } : s = { ...n }), typeof e == "string" ? o = e : !s.cause && e && (a = !0, o = e.message, s.cause = e), !s.ruleId && !s.source && typeof r == "string") {
      const l = r.indexOf(":");
      l === -1 ? s.ruleId = r : (s.source = r.slice(0, l), s.ruleId = r.slice(l + 1));
    }
    if (!s.place && s.ancestors && s.ancestors) {
      const l = s.ancestors[s.ancestors.length - 1];
      l && (s.place = l.position);
    }
    const i = s.place && "start" in s.place ? s.place.start : s.place;
    this.ancestors = s.ancestors || void 0, this.cause = s.cause || void 0, this.column = i ? i.column : void 0, this.fatal = void 0, this.file, this.message = o, this.line = i ? i.line : void 0, this.name = Ps(s.place) || "1:1", this.place = s.place || void 0, this.reason = this.message, this.ruleId = s.ruleId || void 0, this.source = s.source || void 0, this.stack = a && s.cause && typeof s.cause.stack == "string" ? s.cause.stack : "", this.actual, this.expected, this.note, this.url;
  }
}
H.prototype.file = "";
H.prototype.name = "";
H.prototype.reason = "";
H.prototype.message = "";
H.prototype.stack = "";
H.prototype.column = void 0;
H.prototype.line = void 0;
H.prototype.ancestors = void 0;
H.prototype.cause = void 0;
H.prototype.fatal = void 0;
H.prototype.place = void 0;
H.prototype.ruleId = void 0;
H.prototype.source = void 0;
const pn = {}.hasOwnProperty, $s = /* @__PURE__ */ new Map(), Ts = /[A-Z]/g, Ms = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]), Os = /* @__PURE__ */ new Set(["td", "th"]), jr = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function Ds(t, e) {
  if (!e || e.Fragment === void 0)
    throw new TypeError("Expected `Fragment` in options");
  const n = e.filePath || void 0;
  let r;
  if (e.development) {
    if (typeof e.jsxDEV != "function")
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    r = Ws(n, e.jsxDEV);
  } else {
    if (typeof e.jsx != "function")
      throw new TypeError("Expected `jsx` in production options");
    if (typeof e.jsxs != "function")
      throw new TypeError("Expected `jsxs` in production options");
    r = Hs(n, e.jsx, e.jsxs);
  }
  const o = {
    Fragment: e.Fragment,
    ancestors: [],
    components: e.components || {},
    create: r,
    elementAttributeNameCase: e.elementAttributeNameCase || "react",
    evaluater: e.createEvaluater ? e.createEvaluater() : void 0,
    filePath: n,
    ignoreInvalidStyle: e.ignoreInvalidStyle || !1,
    passKeys: e.passKeys !== !1,
    passNode: e.passNode || !1,
    schema: e.space === "svg" ? fn : vs,
    stylePropertyNameCase: e.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: e.tableCellAlignToStyle !== !1
  }, s = Ur(o, t, void 0);
  return s && typeof s != "string" ? s : o.create(
    t,
    o.Fragment,
    { children: s || void 0 },
    void 0
  );
}
function Ur(t, e, n) {
  if (e.type === "element")
    return Gs(t, e, n);
  if (e.type === "mdxFlowExpression" || e.type === "mdxTextExpression")
    return Fs(t, e);
  if (e.type === "mdxJsxFlowElement" || e.type === "mdxJsxTextElement")
    return js(t, e, n);
  if (e.type === "mdxjsEsm")
    return Bs(t, e);
  if (e.type === "root")
    return Us(t, e, n);
  if (e.type === "text")
    return zs(t, e);
}
function Gs(t, e, n) {
  const r = t.schema;
  let o = r;
  e.tagName.toLowerCase() === "svg" && r.space === "html" && (o = fn, t.schema = o), t.ancestors.push(e);
  const s = Hr(t, e.tagName, !1), a = Vs(t, e);
  let i = gn(t, e);
  return Ms.has(e.tagName) && (i = i.filter(function(l) {
    return typeof l == "string" ? !Ct(l) : !0;
  })), zr(t, a, s, e), dn(a, i), t.ancestors.pop(), t.schema = r, t.create(e, s, a, n);
}
function Fs(t, e) {
  if (e.data && e.data.estree && t.evaluater) {
    const r = e.data.estree.body[0];
    return r.type, /** @type {Child | undefined} */
    t.evaluater.evaluateExpression(r.expression);
  }
  je(t, e.position);
}
function Bs(t, e) {
  if (e.data && e.data.estree && t.evaluater)
    return (
      /** @type {Child | undefined} */
      t.evaluater.evaluateProgram(e.data.estree)
    );
  je(t, e.position);
}
function js(t, e, n) {
  const r = t.schema;
  let o = r;
  e.name === "svg" && r.space === "html" && (o = fn, t.schema = o), t.ancestors.push(e);
  const s = e.name === null ? t.Fragment : Hr(t, e.name, !0), a = qs(t, e), i = gn(t, e);
  return zr(t, a, s, e), dn(a, i), t.ancestors.pop(), t.schema = r, t.create(e, s, a, n);
}
function Us(t, e, n) {
  const r = {};
  return dn(r, gn(t, e)), t.create(e, t.Fragment, r, n);
}
function zs(t, e) {
  return e.value;
}
function zr(t, e, n, r) {
  typeof n != "string" && n !== t.Fragment && t.passNode && (e.node = r);
}
function dn(t, e) {
  if (e.length > 0) {
    const n = e.length > 1 ? e : e[0];
    n && (t.children = n);
  }
}
function Hs(t, e, n) {
  return r;
  function r(o, s, a, i) {
    const u = Array.isArray(a.children) ? n : e;
    return i ? u(s, a, i) : u(s, a);
  }
}
function Ws(t, e) {
  return n;
  function n(r, o, s, a) {
    const i = Array.isArray(s.children), l = Fr(r);
    return e(
      o,
      s,
      a,
      i,
      {
        columnNumber: l ? l.column - 1 : void 0,
        fileName: t,
        lineNumber: l ? l.line : void 0
      },
      void 0
    );
  }
}
function Vs(t, e) {
  const n = {};
  let r, o;
  for (o in e.properties)
    if (o !== "children" && pn.call(e.properties, o)) {
      const s = Xs(t, o, e.properties[o]);
      if (s) {
        const [a, i] = s;
        t.tableCellAlignToStyle && a === "align" && typeof i == "string" && Os.has(e.tagName) ? r = i : n[a] = i;
      }
    }
  if (r) {
    const s = (
      /** @type {Style} */
      n.style || (n.style = {})
    );
    s[t.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = r;
  }
  return n;
}
function qs(t, e) {
  const n = {};
  for (const r of e.attributes)
    if (r.type === "mdxJsxExpressionAttribute")
      if (r.data && r.data.estree && t.evaluater) {
        const s = r.data.estree.body[0];
        s.type;
        const a = s.expression;
        a.type;
        const i = a.properties[0];
        i.type, Object.assign(
          n,
          t.evaluater.evaluateExpression(i.argument)
        );
      } else
        je(t, e.position);
    else {
      const o = r.name;
      let s;
      if (r.value && typeof r.value == "object")
        if (r.value.data && r.value.data.estree && t.evaluater) {
          const i = r.value.data.estree.body[0];
          i.type, s = t.evaluater.evaluateExpression(i.expression);
        } else
          je(t, e.position);
      else
        s = r.value === null ? !0 : r.value;
      n[o] = /** @type {Props[keyof Props]} */
      s;
    }
  return n;
}
function gn(t, e) {
  const n = [];
  let r = -1;
  const o = t.passKeys ? /* @__PURE__ */ new Map() : $s;
  for (; ++r < e.children.length; ) {
    const s = e.children[r];
    let a;
    if (t.passKeys) {
      const l = s.type === "element" ? s.tagName : s.type === "mdxJsxFlowElement" || s.type === "mdxJsxTextElement" ? s.name : void 0;
      if (l) {
        const u = o.get(l) || 0;
        a = l + "-" + u, o.set(l, u + 1);
      }
    }
    const i = Ur(t, s, a);
    i !== void 0 && n.push(i);
  }
  return n;
}
function Xs(t, e, n) {
  const r = _s(t.schema, e);
  if (!(n == null || typeof n == "number" && Number.isNaN(n))) {
    if (Array.isArray(n) && (n = r.commaSeparated ? Ir(n) : Gr(n)), r.property === "style") {
      let o = typeof n == "object" ? n : Ks(t, String(n));
      return t.stylePropertyNameCase === "css" && (o = Ys(o)), ["style", o];
    }
    return [
      t.elementAttributeNameCase === "react" && r.space ? bs[r.property] || r.property : r.attribute,
      n
    ];
  }
}
function Ks(t, e) {
  try {
    return Ns(e, { reactCompat: !0 });
  } catch (n) {
    if (t.ignoreInvalidStyle)
      return {};
    const r = (
      /** @type {Error} */
      n
    ), o = new H("Cannot parse `style` attribute", {
      ancestors: t.ancestors,
      cause: r,
      ruleId: "style",
      source: "hast-util-to-jsx-runtime"
    });
    throw o.file = t.filePath || void 0, o.url = jr + "#cannot-parse-style-attribute", o;
  }
}
function Hr(t, e, n) {
  let r;
  if (!n)
    r = { type: "Literal", value: e };
  else if (e.includes(".")) {
    const o = e.split(".");
    let s = -1, a;
    for (; ++s < o.length; ) {
      const i = In(o[s]) ? { type: "Identifier", name: o[s] } : { type: "Literal", value: o[s] };
      a = a ? {
        type: "MemberExpression",
        object: a,
        property: i,
        computed: !!(s && i.type === "Literal"),
        optional: !1
      } : i;
    }
    r = a;
  } else
    r = In(e) && !/^[a-z]/.test(e) ? { type: "Identifier", name: e } : { type: "Literal", value: e };
  if (r.type === "Literal") {
    const o = (
      /** @type {string | number} */
      r.value
    );
    return pn.call(t.components, o) ? t.components[o] : o;
  }
  if (t.evaluater)
    return t.evaluater.evaluateExpression(r);
  je(t);
}
function je(t, e) {
  const n = new H(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: t.ancestors,
      place: e,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  throw n.file = t.filePath || void 0, n.url = jr + "#cannot-handle-mdx-estrees-without-createevaluater", n;
}
function Ys(t) {
  const e = {};
  let n;
  for (n in t)
    pn.call(t, n) && (e[Js(n)] = t[n]);
  return e;
}
function Js(t) {
  let e = t.replace(Ts, Zs);
  return e.slice(0, 3) === "ms-" && (e = "-" + e), e;
}
function Zs(t) {
  return "-" + t.toLowerCase();
}
const Wr = (
  // Note: overloads in JSDoc can’t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(t) {
    if (t == null)
      return na;
    if (typeof t == "function")
      return _t(t);
    if (typeof t == "object")
      return Array.isArray(t) ? Qs(t) : ea(t);
    if (typeof t == "string")
      return ta(t);
    throw new Error("Expected function, string, or object as test");
  }
);
function Qs(t) {
  const e = [];
  let n = -1;
  for (; ++n < t.length; )
    e[n] = Wr(t[n]);
  return _t(r);
  function r(...o) {
    let s = -1;
    for (; ++s < e.length; )
      if (e[s].apply(this, o)) return !0;
    return !1;
  }
}
function ea(t) {
  const e = (
    /** @type {Record<string, unknown>} */
    t
  );
  return _t(n);
  function n(r) {
    const o = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let s;
    for (s in t)
      if (o[s] !== e[s]) return !1;
    return !0;
  }
}
function ta(t) {
  return _t(e);
  function e(n) {
    return n && n.type === t;
  }
}
function _t(t) {
  return e;
  function e(n, r, o) {
    return !!(ra(n) && t.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      o || void 0
    ));
  }
}
function na() {
  return !0;
}
function ra(t) {
  return t !== null && typeof t == "object" && "type" in t;
}
const Vr = [], oa = !0, Fn = !1, sa = "skip";
function aa(t, e, n, r) {
  let o;
  typeof e == "function" && typeof n != "function" ? (r = n, n = e) : o = e;
  const s = Wr(o), a = r ? -1 : 1;
  i(t, void 0, [])();
  function i(l, u, c) {
    const h = (
      /** @type {Record<string, unknown>} */
      l && typeof l == "object" ? l : {}
    );
    if (typeof h.type == "string") {
      const d = (
        // `hast`
        typeof h.tagName == "string" ? h.tagName : (
          // `xast`
          typeof h.name == "string" ? h.name : void 0
        )
      );
      Object.defineProperty(p, "name", {
        value: "node (" + (l.type + (d ? "<" + d + ">" : "")) + ")"
      });
    }
    return p;
    function p() {
      let d = Vr, f, g, C;
      if ((!e || s(l, u, c[c.length - 1] || void 0)) && (d = ia(n(l, c)), d[0] === Fn))
        return d;
      if ("children" in l && l.children) {
        const y = (
          /** @type {UnistParent} */
          l
        );
        if (y.children && d[0] !== sa)
          for (g = (r ? y.children.length : -1) + a, C = c.concat(y); g > -1 && g < y.children.length; ) {
            const m = y.children[g];
            if (f = i(m, g, C)(), f[0] === Fn)
              return f;
            g = typeof f[1] == "number" ? f[1] : g + a;
          }
      }
      return d;
    }
  }
}
function ia(t) {
  return Array.isArray(t) ? t : typeof t == "number" ? [oa, t] : t == null ? Vr : [t];
}
function qr(t, e, n, r) {
  let o, s, a;
  typeof e == "function" && typeof n != "function" ? (s = void 0, a = e, o = n) : (s = e, a = n, o = r), aa(t, s, i, o);
  function i(l, u) {
    const c = u[u.length - 1], h = c ? c.children.indexOf(l) : void 0;
    return a(l, h, c);
  }
}
const Bn = {}.hasOwnProperty;
function la(t, e) {
  const n = e || {};
  function r(o, ...s) {
    let a = r.invalid;
    const i = r.handlers;
    if (o && Bn.call(o, t)) {
      const l = String(o[t]);
      a = Bn.call(i, l) ? i[l] : r.unknown;
    }
    if (a)
      return a.call(this, o, ...s);
  }
  return r.handlers = n.handlers || {}, r.invalid = n.invalid, r.unknown = n.unknown, r;
}
const ua = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
function jn(t, e) {
  const n = String(t);
  if (typeof e != "string")
    throw new TypeError("Expected character");
  let r = 0, o = n.indexOf(e);
  for (; o !== -1; )
    r++, o = n.indexOf(e, o + e.length);
  return r;
}
let F = class extends Error {
  constructor(e) {
    super(e), this.name = "ShikiError";
  }
};
function ca(t) {
  return mn(t);
}
function mn(t) {
  return Array.isArray(t) ? ha(t) : t instanceof RegExp ? t : typeof t == "object" ? fa(t) : t;
}
function ha(t) {
  let e = [];
  for (let n = 0, r = t.length; n < r; n++)
    e[n] = mn(t[n]);
  return e;
}
function fa(t) {
  let e = {};
  for (let n in t)
    e[n] = mn(t[n]);
  return e;
}
function Xr(t, ...e) {
  return e.forEach((n) => {
    for (let r in n)
      t[r] = n[r];
  }), t;
}
function Kr(t) {
  const e = ~t.lastIndexOf("/") || ~t.lastIndexOf("\\");
  return e === 0 ? t : ~e === t.length - 1 ? Kr(t.substring(0, t.length - 1)) : t.substr(~e + 1);
}
var It = /\$(\d+)|\${(\d+):\/(downcase|upcase)}/g, Je = class {
  static hasCaptures(t) {
    return t === null ? !1 : (It.lastIndex = 0, It.test(t));
  }
  static replaceCaptures(t, e, n) {
    return t.replace(It, (r, o, s, a) => {
      let i = n[parseInt(o || s, 10)];
      if (i) {
        let l = e.substring(i.start, i.end);
        for (; l[0] === "."; )
          l = l.substring(1);
        switch (a) {
          case "downcase":
            return l.toLowerCase();
          case "upcase":
            return l.toUpperCase();
          default:
            return l;
        }
      } else
        return r;
    });
  }
};
function Yr(t, e) {
  return t < e ? -1 : t > e ? 1 : 0;
}
function Jr(t, e) {
  if (t === null && e === null)
    return 0;
  if (!t)
    return -1;
  if (!e)
    return 1;
  let n = t.length, r = e.length;
  if (n === r) {
    for (let o = 0; o < n; o++) {
      let s = Yr(t[o], e[o]);
      if (s !== 0)
        return s;
    }
    return 0;
  }
  return n - r;
}
function Un(t) {
  return !!(/^#[0-9a-f]{6}$/i.test(t) || /^#[0-9a-f]{8}$/i.test(t) || /^#[0-9a-f]{3}$/i.test(t) || /^#[0-9a-f]{4}$/i.test(t));
}
function Zr(t) {
  return t.replace(/[\-\\\{\}\*\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&");
}
var Qr = class {
  constructor(t) {
    this.fn = t;
  }
  cache = /* @__PURE__ */ new Map();
  get(t) {
    if (this.cache.has(t))
      return this.cache.get(t);
    const e = this.fn(t);
    return this.cache.set(t, e), e;
  }
}, it = class {
  constructor(t, e, n) {
    this._colorMap = t, this._defaults = e, this._root = n;
  }
  static createFromRawTheme(t, e) {
    return this.createFromParsedTheme(ga(t), e);
  }
  static createFromParsedTheme(t, e) {
    return ya(t, e);
  }
  _cachedMatchRoot = new Qr(
    (t) => this._root.match(t)
  );
  getColorMap() {
    return this._colorMap.getColorMap();
  }
  getDefaults() {
    return this._defaults;
  }
  match(t) {
    if (t === null)
      return this._defaults;
    const e = t.scopeName, r = this._cachedMatchRoot.get(e).find(
      (o) => pa(t.parent, o.parentScopes)
    );
    return r ? new eo(
      r.fontStyle,
      r.foreground,
      r.background
    ) : null;
  }
}, Nt = class rt {
  constructor(e, n) {
    this.parent = e, this.scopeName = n;
  }
  static push(e, n) {
    for (const r of n)
      e = new rt(e, r);
    return e;
  }
  static from(...e) {
    let n = null;
    for (let r = 0; r < e.length; r++)
      n = new rt(n, e[r]);
    return n;
  }
  push(e) {
    return new rt(this, e);
  }
  getSegments() {
    let e = this;
    const n = [];
    for (; e; )
      n.push(e.scopeName), e = e.parent;
    return n.reverse(), n;
  }
  toString() {
    return this.getSegments().join(" ");
  }
  extends(e) {
    return this === e ? !0 : this.parent === null ? !1 : this.parent.extends(e);
  }
  getExtensionIfDefined(e) {
    const n = [];
    let r = this;
    for (; r && r !== e; )
      n.push(r.scopeName), r = r.parent;
    return r === e ? n.reverse() : void 0;
  }
};
function pa(t, e) {
  if (e.length === 0)
    return !0;
  for (let n = 0; n < e.length; n++) {
    let r = e[n], o = !1;
    if (r === ">") {
      if (n === e.length - 1)
        return !1;
      r = e[++n], o = !0;
    }
    for (; t && !da(t.scopeName, r); ) {
      if (o)
        return !1;
      t = t.parent;
    }
    if (!t)
      return !1;
    t = t.parent;
  }
  return !0;
}
function da(t, e) {
  return e === t || t.startsWith(e) && t[e.length] === ".";
}
var eo = class {
  constructor(t, e, n) {
    this.fontStyle = t, this.foregroundId = e, this.backgroundId = n;
  }
};
function ga(t) {
  if (!t)
    return [];
  if (!t.settings || !Array.isArray(t.settings))
    return [];
  let e = t.settings, n = [], r = 0;
  for (let o = 0, s = e.length; o < s; o++) {
    let a = e[o];
    if (!a.settings)
      continue;
    let i;
    if (typeof a.scope == "string") {
      let h = a.scope;
      h = h.replace(/^[,]+/, ""), h = h.replace(/[,]+$/, ""), i = h.split(",");
    } else Array.isArray(a.scope) ? i = a.scope : i = [""];
    let l = -1;
    if (typeof a.settings.fontStyle == "string") {
      l = 0;
      let h = a.settings.fontStyle.split(" ");
      for (let p = 0, d = h.length; p < d; p++)
        switch (h[p]) {
          case "italic":
            l = l | 1;
            break;
          case "bold":
            l = l | 2;
            break;
          case "underline":
            l = l | 4;
            break;
          case "strikethrough":
            l = l | 8;
            break;
        }
    }
    let u = null;
    typeof a.settings.foreground == "string" && Un(a.settings.foreground) && (u = a.settings.foreground);
    let c = null;
    typeof a.settings.background == "string" && Un(a.settings.background) && (c = a.settings.background);
    for (let h = 0, p = i.length; h < p; h++) {
      let f = i[h].trim().split(" "), g = f[f.length - 1], C = null;
      f.length > 1 && (C = f.slice(0, f.length - 1), C.reverse()), n[r++] = new ma(
        g,
        C,
        o,
        l,
        u,
        c
      );
    }
  }
  return n;
}
var ma = class {
  constructor(t, e, n, r, o, s) {
    this.scope = t, this.parentScopes = e, this.index = n, this.fontStyle = r, this.foreground = o, this.background = s;
  }
}, z = /* @__PURE__ */ ((t) => (t[t.NotSet = -1] = "NotSet", t[t.None = 0] = "None", t[t.Italic = 1] = "Italic", t[t.Bold = 2] = "Bold", t[t.Underline = 4] = "Underline", t[t.Strikethrough = 8] = "Strikethrough", t))(z || {});
function ya(t, e) {
  t.sort((l, u) => {
    let c = Yr(l.scope, u.scope);
    return c !== 0 || (c = Jr(l.parentScopes, u.parentScopes), c !== 0) ? c : l.index - u.index;
  });
  let n = 0, r = "#000000", o = "#ffffff";
  for (; t.length >= 1 && t[0].scope === ""; ) {
    let l = t.shift();
    l.fontStyle !== -1 && (n = l.fontStyle), l.foreground !== null && (r = l.foreground), l.background !== null && (o = l.background);
  }
  let s = new ba(e), a = new eo(n, s.getId(r), s.getId(o)), i = new Ca(new Vt(0, null, -1, 0, 0), []);
  for (let l = 0, u = t.length; l < u; l++) {
    let c = t[l];
    i.insert(0, c.scope, c.parentScopes, c.fontStyle, s.getId(c.foreground), s.getId(c.background));
  }
  return new it(s, a, i);
}
var ba = class {
  _isFrozen;
  _lastColorId;
  _id2color;
  _color2id;
  constructor(t) {
    if (this._lastColorId = 0, this._id2color = [], this._color2id = /* @__PURE__ */ Object.create(null), Array.isArray(t)) {
      this._isFrozen = !0;
      for (let e = 0, n = t.length; e < n; e++)
        this._color2id[t[e]] = e, this._id2color[e] = t[e];
    } else
      this._isFrozen = !1;
  }
  getId(t) {
    if (t === null)
      return 0;
    t = t.toUpperCase();
    let e = this._color2id[t];
    if (e)
      return e;
    if (this._isFrozen)
      throw new Error(`Missing color in color map - ${t}`);
    return e = ++this._lastColorId, this._color2id[t] = e, this._id2color[e] = t, e;
  }
  getColorMap() {
    return this._id2color.slice(0);
  }
}, wa = Object.freeze([]), Vt = class to {
  scopeDepth;
  parentScopes;
  fontStyle;
  foreground;
  background;
  constructor(e, n, r, o, s) {
    this.scopeDepth = e, this.parentScopes = n || wa, this.fontStyle = r, this.foreground = o, this.background = s;
  }
  clone() {
    return new to(this.scopeDepth, this.parentScopes, this.fontStyle, this.foreground, this.background);
  }
  static cloneArr(e) {
    let n = [];
    for (let r = 0, o = e.length; r < o; r++)
      n[r] = e[r].clone();
    return n;
  }
  acceptOverwrite(e, n, r, o) {
    this.scopeDepth > e ? console.log("how did this happen?") : this.scopeDepth = e, n !== -1 && (this.fontStyle = n), r !== 0 && (this.foreground = r), o !== 0 && (this.background = o);
  }
}, Ca = class qt {
  constructor(e, n = [], r = {}) {
    this._mainRule = e, this._children = r, this._rulesWithParentScopes = n;
  }
  _rulesWithParentScopes;
  static _cmpBySpecificity(e, n) {
    if (e.scopeDepth !== n.scopeDepth)
      return n.scopeDepth - e.scopeDepth;
    let r = 0, o = 0;
    for (; e.parentScopes[r] === ">" && r++, n.parentScopes[o] === ">" && o++, !(r >= e.parentScopes.length || o >= n.parentScopes.length); ) {
      const s = n.parentScopes[o].length - e.parentScopes[r].length;
      if (s !== 0)
        return s;
      r++, o++;
    }
    return n.parentScopes.length - e.parentScopes.length;
  }
  match(e) {
    if (e !== "") {
      let r = e.indexOf("."), o, s;
      if (r === -1 ? (o = e, s = "") : (o = e.substring(0, r), s = e.substring(r + 1)), this._children.hasOwnProperty(o))
        return this._children[o].match(s);
    }
    const n = this._rulesWithParentScopes.concat(this._mainRule);
    return n.sort(qt._cmpBySpecificity), n;
  }
  insert(e, n, r, o, s, a) {
    if (n === "") {
      this._doInsertHere(e, r, o, s, a);
      return;
    }
    let i = n.indexOf("."), l, u;
    i === -1 ? (l = n, u = "") : (l = n.substring(0, i), u = n.substring(i + 1));
    let c;
    this._children.hasOwnProperty(l) ? c = this._children[l] : (c = new qt(this._mainRule.clone(), Vt.cloneArr(this._rulesWithParentScopes)), this._children[l] = c), c.insert(e + 1, u, r, o, s, a);
  }
  _doInsertHere(e, n, r, o, s) {
    if (n === null) {
      this._mainRule.acceptOverwrite(e, r, o, s);
      return;
    }
    for (let a = 0, i = this._rulesWithParentScopes.length; a < i; a++) {
      let l = this._rulesWithParentScopes[a];
      if (Jr(l.parentScopes, n) === 0) {
        l.acceptOverwrite(e, r, o, s);
        return;
      }
    }
    r === -1 && (r = this._mainRule.fontStyle), o === 0 && (o = this._mainRule.foreground), s === 0 && (s = this._mainRule.background), this._rulesWithParentScopes.push(new Vt(e, n, r, o, s));
  }
}, Re = class K {
  static toBinaryStr(e) {
    return e.toString(2).padStart(32, "0");
  }
  static print(e) {
    const n = K.getLanguageId(e), r = K.getTokenType(e), o = K.getFontStyle(e), s = K.getForeground(e), a = K.getBackground(e);
    console.log({
      languageId: n,
      tokenType: r,
      fontStyle: o,
      foreground: s,
      background: a
    });
  }
  static getLanguageId(e) {
    return (e & 255) >>> 0;
  }
  static getTokenType(e) {
    return (e & 768) >>> 8;
  }
  static containsBalancedBrackets(e) {
    return (e & 1024) !== 0;
  }
  static getFontStyle(e) {
    return (e & 30720) >>> 11;
  }
  static getForeground(e) {
    return (e & 16744448) >>> 15;
  }
  static getBackground(e) {
    return (e & 4278190080) >>> 24;
  }
  /**
   * Updates the fields in `metadata`.
   * A value of `0`, `NotSet` or `null` indicates that the corresponding field should be left as is.
   */
  static set(e, n, r, o, s, a, i) {
    let l = K.getLanguageId(e), u = K.getTokenType(e), c = K.containsBalancedBrackets(e) ? 1 : 0, h = K.getFontStyle(e), p = K.getForeground(e), d = K.getBackground(e);
    return n !== 0 && (l = n), r !== 8 && (u = r), o !== null && (c = o ? 1 : 0), s !== -1 && (h = s), a !== 0 && (p = a), i !== 0 && (d = i), (l << 0 | u << 8 | c << 10 | h << 11 | p << 15 | d << 24) >>> 0;
  }
};
function lt(t, e) {
  const n = [], r = _a(t);
  let o = r.next();
  for (; o !== null; ) {
    let l = 0;
    if (o.length === 2 && o.charAt(1) === ":") {
      switch (o.charAt(0)) {
        case "R":
          l = 1;
          break;
        case "L":
          l = -1;
          break;
        default:
          console.log(`Unknown priority ${o} in scope selector`);
      }
      o = r.next();
    }
    let u = a();
    if (n.push({ matcher: u, priority: l }), o !== ",")
      break;
    o = r.next();
  }
  return n;
  function s() {
    if (o === "-") {
      o = r.next();
      const l = s();
      return (u) => !!l && !l(u);
    }
    if (o === "(") {
      o = r.next();
      const l = i();
      return o === ")" && (o = r.next()), l;
    }
    if (zn(o)) {
      const l = [];
      do
        l.push(o), o = r.next();
      while (zn(o));
      return (u) => e(l, u);
    }
    return null;
  }
  function a() {
    const l = [];
    let u = s();
    for (; u; )
      l.push(u), u = s();
    return (c) => l.every((h) => h(c));
  }
  function i() {
    const l = [];
    let u = a();
    for (; u && (l.push(u), o === "|" || o === ","); ) {
      do
        o = r.next();
      while (o === "|" || o === ",");
      u = a();
    }
    return (c) => l.some((h) => h(c));
  }
}
function zn(t) {
  return !!t && !!t.match(/[\w\.:]+/);
}
function _a(t) {
  let e = /([LR]:|[\w\.:][\w\.:\-]*|[\,\|\-\(\)])/g, n = e.exec(t);
  return {
    next: () => {
      if (!n)
        return null;
      const r = n[0];
      return n = e.exec(t), r;
    }
  };
}
function no(t) {
  typeof t.dispose == "function" && t.dispose();
}
var Ue = class {
  constructor(t) {
    this.scopeName = t;
  }
  toKey() {
    return this.scopeName;
  }
}, Sa = class {
  constructor(t, e) {
    this.scopeName = t, this.ruleName = e;
  }
  toKey() {
    return `${this.scopeName}#${this.ruleName}`;
  }
}, ka = class {
  _references = [];
  _seenReferenceKeys = /* @__PURE__ */ new Set();
  get references() {
    return this._references;
  }
  visitedRule = /* @__PURE__ */ new Set();
  add(t) {
    const e = t.toKey();
    this._seenReferenceKeys.has(e) || (this._seenReferenceKeys.add(e), this._references.push(t));
  }
}, va = class {
  constructor(t, e) {
    this.repo = t, this.initialScopeName = e, this.seenFullScopeRequests.add(this.initialScopeName), this.Q = [new Ue(this.initialScopeName)];
  }
  seenFullScopeRequests = /* @__PURE__ */ new Set();
  seenPartialScopeRequests = /* @__PURE__ */ new Set();
  Q;
  processQueue() {
    const t = this.Q;
    this.Q = [];
    const e = new ka();
    for (const n of t)
      xa(n, this.initialScopeName, this.repo, e);
    for (const n of e.references)
      if (n instanceof Ue) {
        if (this.seenFullScopeRequests.has(n.scopeName))
          continue;
        this.seenFullScopeRequests.add(n.scopeName), this.Q.push(n);
      } else {
        if (this.seenFullScopeRequests.has(n.scopeName) || this.seenPartialScopeRequests.has(n.toKey()))
          continue;
        this.seenPartialScopeRequests.add(n.toKey()), this.Q.push(n);
      }
  }
};
function xa(t, e, n, r) {
  const o = n.lookup(t.scopeName);
  if (!o) {
    if (t.scopeName === e)
      throw new Error(`No grammar provided for <${e}>`);
    return;
  }
  const s = n.lookup(e);
  t instanceof Ue ? ot({ baseGrammar: s, selfGrammar: o }, r) : Xt(
    t.ruleName,
    { baseGrammar: s, selfGrammar: o, repository: o.repository },
    r
  );
  const a = n.injections(t.scopeName);
  if (a)
    for (const i of a)
      r.add(new Ue(i));
}
function Xt(t, e, n) {
  if (e.repository && e.repository[t]) {
    const r = e.repository[t];
    ut([r], e, n);
  }
}
function ot(t, e) {
  t.selfGrammar.patterns && Array.isArray(t.selfGrammar.patterns) && ut(
    t.selfGrammar.patterns,
    { ...t, repository: t.selfGrammar.repository },
    e
  ), t.selfGrammar.injections && ut(
    Object.values(t.selfGrammar.injections),
    { ...t, repository: t.selfGrammar.repository },
    e
  );
}
function ut(t, e, n) {
  for (const r of t) {
    if (n.visitedRule.has(r))
      continue;
    n.visitedRule.add(r);
    const o = r.repository ? Xr({}, e.repository, r.repository) : e.repository;
    Array.isArray(r.patterns) && ut(r.patterns, { ...e, repository: o }, n);
    const s = r.include;
    if (!s)
      continue;
    const a = ro(s);
    switch (a.kind) {
      case 0:
        ot({ ...e, selfGrammar: e.baseGrammar }, n);
        break;
      case 1:
        ot(e, n);
        break;
      case 2:
        Xt(a.ruleName, { ...e, repository: o }, n);
        break;
      case 3:
      case 4:
        const i = a.scopeName === e.selfGrammar.scopeName ? e.selfGrammar : a.scopeName === e.baseGrammar.scopeName ? e.baseGrammar : void 0;
        if (i) {
          const l = { baseGrammar: e.baseGrammar, selfGrammar: i, repository: o };
          a.kind === 4 ? Xt(a.ruleName, l, n) : ot(l, n);
        } else
          a.kind === 4 ? n.add(new Sa(a.scopeName, a.ruleName)) : n.add(new Ue(a.scopeName));
        break;
    }
  }
}
var Ea = class {
  kind = 0;
}, Aa = class {
  kind = 1;
}, Ra = class {
  constructor(t) {
    this.ruleName = t;
  }
  kind = 2;
}, Ia = class {
  constructor(t) {
    this.scopeName = t;
  }
  kind = 3;
}, Na = class {
  constructor(t, e) {
    this.scopeName = t, this.ruleName = e;
  }
  kind = 4;
};
function ro(t) {
  if (t === "$base")
    return new Ea();
  if (t === "$self")
    return new Aa();
  const e = t.indexOf("#");
  if (e === -1)
    return new Ia(t);
  if (e === 0)
    return new Ra(t.substring(1));
  {
    const n = t.substring(0, e), r = t.substring(e + 1);
    return new Na(n, r);
  }
}
var La = /\\(\d+)/, Hn = /\\(\d+)/g, Pa = -1, oo = -2;
var Xe = class {
  $location;
  id;
  _nameIsCapturing;
  _name;
  _contentNameIsCapturing;
  _contentName;
  constructor(t, e, n, r) {
    this.$location = t, this.id = e, this._name = n || null, this._nameIsCapturing = Je.hasCaptures(this._name), this._contentName = r || null, this._contentNameIsCapturing = Je.hasCaptures(this._contentName);
  }
  get debugName() {
    const t = this.$location ? `${Kr(this.$location.filename)}:${this.$location.line}` : "unknown";
    return `${this.constructor.name}#${this.id} @ ${t}`;
  }
  getName(t, e) {
    return !this._nameIsCapturing || this._name === null || t === null || e === null ? this._name : Je.replaceCaptures(this._name, t, e);
  }
  getContentName(t, e) {
    return !this._contentNameIsCapturing || this._contentName === null ? this._contentName : Je.replaceCaptures(this._contentName, t, e);
  }
}, $a = class extends Xe {
  retokenizeCapturedWithRuleId;
  constructor(t, e, n, r, o) {
    super(t, e, n, r), this.retokenizeCapturedWithRuleId = o;
  }
  dispose() {
  }
  collectPatterns(t, e) {
    throw new Error("Not supported!");
  }
  compile(t, e) {
    throw new Error("Not supported!");
  }
  compileAG(t, e, n, r) {
    throw new Error("Not supported!");
  }
}, Ta = class extends Xe {
  _match;
  captures;
  _cachedCompiledPatterns;
  constructor(t, e, n, r, o) {
    super(t, e, n, null), this._match = new ze(r, this.id), this.captures = o, this._cachedCompiledPatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
  }
  get debugMatchRegExp() {
    return `${this._match.source}`;
  }
  collectPatterns(t, e) {
    e.push(this._match);
  }
  compile(t, e) {
    return this._getCachedCompiledPatterns(t).compile(t);
  }
  compileAG(t, e, n, r) {
    return this._getCachedCompiledPatterns(t).compileAG(t, n, r);
  }
  _getCachedCompiledPatterns(t) {
    return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new He(), this.collectPatterns(t, this._cachedCompiledPatterns)), this._cachedCompiledPatterns;
  }
}, Wn = class extends Xe {
  hasMissingPatterns;
  patterns;
  _cachedCompiledPatterns;
  constructor(t, e, n, r, o) {
    super(t, e, n, r), this.patterns = o.patterns, this.hasMissingPatterns = o.hasMissingPatterns, this._cachedCompiledPatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
  }
  collectPatterns(t, e) {
    for (const n of this.patterns)
      t.getRule(n).collectPatterns(t, e);
  }
  compile(t, e) {
    return this._getCachedCompiledPatterns(t).compile(t);
  }
  compileAG(t, e, n, r) {
    return this._getCachedCompiledPatterns(t).compileAG(t, n, r);
  }
  _getCachedCompiledPatterns(t) {
    return this._cachedCompiledPatterns || (this._cachedCompiledPatterns = new He(), this.collectPatterns(t, this._cachedCompiledPatterns)), this._cachedCompiledPatterns;
  }
}, Kt = class extends Xe {
  _begin;
  beginCaptures;
  _end;
  endHasBackReferences;
  endCaptures;
  applyEndPatternLast;
  hasMissingPatterns;
  patterns;
  _cachedCompiledPatterns;
  constructor(t, e, n, r, o, s, a, i, l, u) {
    super(t, e, n, r), this._begin = new ze(o, this.id), this.beginCaptures = s, this._end = new ze(a || "￿", -1), this.endHasBackReferences = this._end.hasBackReferences, this.endCaptures = i, this.applyEndPatternLast = l || !1, this.patterns = u.patterns, this.hasMissingPatterns = u.hasMissingPatterns, this._cachedCompiledPatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null);
  }
  get debugBeginRegExp() {
    return `${this._begin.source}`;
  }
  get debugEndRegExp() {
    return `${this._end.source}`;
  }
  getEndWithResolvedBackReferences(t, e) {
    return this._end.resolveBackReferences(t, e);
  }
  collectPatterns(t, e) {
    e.push(this._begin);
  }
  compile(t, e) {
    return this._getCachedCompiledPatterns(t, e).compile(t);
  }
  compileAG(t, e, n, r) {
    return this._getCachedCompiledPatterns(t, e).compileAG(t, n, r);
  }
  _getCachedCompiledPatterns(t, e) {
    if (!this._cachedCompiledPatterns) {
      this._cachedCompiledPatterns = new He();
      for (const n of this.patterns)
        t.getRule(n).collectPatterns(t, this._cachedCompiledPatterns);
      this.applyEndPatternLast ? this._cachedCompiledPatterns.push(this._end.hasBackReferences ? this._end.clone() : this._end) : this._cachedCompiledPatterns.unshift(this._end.hasBackReferences ? this._end.clone() : this._end);
    }
    return this._end.hasBackReferences && (this.applyEndPatternLast ? this._cachedCompiledPatterns.setSource(this._cachedCompiledPatterns.length() - 1, e) : this._cachedCompiledPatterns.setSource(0, e)), this._cachedCompiledPatterns;
  }
}, ct = class extends Xe {
  _begin;
  beginCaptures;
  whileCaptures;
  _while;
  whileHasBackReferences;
  hasMissingPatterns;
  patterns;
  _cachedCompiledPatterns;
  _cachedCompiledWhilePatterns;
  constructor(t, e, n, r, o, s, a, i, l) {
    super(t, e, n, r), this._begin = new ze(o, this.id), this.beginCaptures = s, this.whileCaptures = i, this._while = new ze(a, oo), this.whileHasBackReferences = this._while.hasBackReferences, this.patterns = l.patterns, this.hasMissingPatterns = l.hasMissingPatterns, this._cachedCompiledPatterns = null, this._cachedCompiledWhilePatterns = null;
  }
  dispose() {
    this._cachedCompiledPatterns && (this._cachedCompiledPatterns.dispose(), this._cachedCompiledPatterns = null), this._cachedCompiledWhilePatterns && (this._cachedCompiledWhilePatterns.dispose(), this._cachedCompiledWhilePatterns = null);
  }
  get debugBeginRegExp() {
    return `${this._begin.source}`;
  }
  get debugWhileRegExp() {
    return `${this._while.source}`;
  }
  getWhileWithResolvedBackReferences(t, e) {
    return this._while.resolveBackReferences(t, e);
  }
  collectPatterns(t, e) {
    e.push(this._begin);
  }
  compile(t, e) {
    return this._getCachedCompiledPatterns(t).compile(t);
  }
  compileAG(t, e, n, r) {
    return this._getCachedCompiledPatterns(t).compileAG(t, n, r);
  }
  _getCachedCompiledPatterns(t) {
    if (!this._cachedCompiledPatterns) {
      this._cachedCompiledPatterns = new He();
      for (const e of this.patterns)
        t.getRule(e).collectPatterns(t, this._cachedCompiledPatterns);
    }
    return this._cachedCompiledPatterns;
  }
  compileWhile(t, e) {
    return this._getCachedCompiledWhilePatterns(t, e).compile(t);
  }
  compileWhileAG(t, e, n, r) {
    return this._getCachedCompiledWhilePatterns(t, e).compileAG(t, n, r);
  }
  _getCachedCompiledWhilePatterns(t, e) {
    return this._cachedCompiledWhilePatterns || (this._cachedCompiledWhilePatterns = new He(), this._cachedCompiledWhilePatterns.push(this._while.hasBackReferences ? this._while.clone() : this._while)), this._while.hasBackReferences && this._cachedCompiledWhilePatterns.setSource(0, e || "￿"), this._cachedCompiledWhilePatterns;
  }
}, so = class U {
  static createCaptureRule(e, n, r, o, s) {
    return e.registerRule((a) => new $a(n, a, r, o, s));
  }
  static getCompiledRuleId(e, n, r) {
    return e.id || n.registerRule((o) => {
      if (e.id = o, e.match)
        return new Ta(
          e.$vscodeTextmateLocation,
          e.id,
          e.name,
          e.match,
          U._compileCaptures(e.captures, n, r)
        );
      if (typeof e.begin > "u") {
        e.repository && (r = Xr({}, r, e.repository));
        let s = e.patterns;
        return typeof s > "u" && e.include && (s = [{ include: e.include }]), new Wn(
          e.$vscodeTextmateLocation,
          e.id,
          e.name,
          e.contentName,
          U._compilePatterns(s, n, r)
        );
      }
      return e.while ? new ct(
        e.$vscodeTextmateLocation,
        e.id,
        e.name,
        e.contentName,
        e.begin,
        U._compileCaptures(e.beginCaptures || e.captures, n, r),
        e.while,
        U._compileCaptures(e.whileCaptures || e.captures, n, r),
        U._compilePatterns(e.patterns, n, r)
      ) : new Kt(
        e.$vscodeTextmateLocation,
        e.id,
        e.name,
        e.contentName,
        e.begin,
        U._compileCaptures(e.beginCaptures || e.captures, n, r),
        e.end,
        U._compileCaptures(e.endCaptures || e.captures, n, r),
        e.applyEndPatternLast,
        U._compilePatterns(e.patterns, n, r)
      );
    }), e.id;
  }
  static _compileCaptures(e, n, r) {
    let o = [];
    if (e) {
      let s = 0;
      for (const a in e) {
        if (a === "$vscodeTextmateLocation")
          continue;
        const i = parseInt(a, 10);
        i > s && (s = i);
      }
      for (let a = 0; a <= s; a++)
        o[a] = null;
      for (const a in e) {
        if (a === "$vscodeTextmateLocation")
          continue;
        const i = parseInt(a, 10);
        let l = 0;
        e[a].patterns && (l = U.getCompiledRuleId(e[a], n, r)), o[i] = U.createCaptureRule(n, e[a].$vscodeTextmateLocation, e[a].name, e[a].contentName, l);
      }
    }
    return o;
  }
  static _compilePatterns(e, n, r) {
    let o = [];
    if (e)
      for (let s = 0, a = e.length; s < a; s++) {
        const i = e[s];
        let l = -1;
        if (i.include) {
          const u = ro(i.include);
          switch (u.kind) {
            case 0:
            case 1:
              l = U.getCompiledRuleId(r[i.include], n, r);
              break;
            case 2:
              let c = r[u.ruleName];
              c && (l = U.getCompiledRuleId(c, n, r));
              break;
            case 3:
            case 4:
              const h = u.scopeName, p = u.kind === 4 ? u.ruleName : null, d = n.getExternalGrammar(h, r);
              if (d)
                if (p) {
                  let f = d.repository[p];
                  f && (l = U.getCompiledRuleId(f, n, d.repository));
                } else
                  l = U.getCompiledRuleId(d.repository.$self, n, d.repository);
              break;
          }
        } else
          l = U.getCompiledRuleId(i, n, r);
        if (l !== -1) {
          const u = n.getRule(l);
          let c = !1;
          if ((u instanceof Wn || u instanceof Kt || u instanceof ct) && u.hasMissingPatterns && u.patterns.length === 0 && (c = !0), c)
            continue;
          o.push(l);
        }
      }
    return {
      patterns: o,
      hasMissingPatterns: (e ? e.length : 0) !== o.length
    };
  }
}, ze = class ao {
  source;
  ruleId;
  hasAnchor;
  hasBackReferences;
  _anchorCache;
  constructor(e, n) {
    if (e && typeof e == "string") {
      const r = e.length;
      let o = 0, s = [], a = !1;
      for (let i = 0; i < r; i++)
        if (e.charAt(i) === "\\" && i + 1 < r) {
          const u = e.charAt(i + 1);
          u === "z" ? (s.push(e.substring(o, i)), s.push("$(?!\\n)(?<!\\n)"), o = i + 2) : (u === "A" || u === "G") && (a = !0), i++;
        }
      this.hasAnchor = a, o === 0 ? this.source = e : (s.push(e.substring(o, r)), this.source = s.join(""));
    } else
      this.hasAnchor = !1, this.source = e;
    this.hasAnchor ? this._anchorCache = this._buildAnchorCache() : this._anchorCache = null, this.ruleId = n, typeof this.source == "string" ? this.hasBackReferences = La.test(this.source) : this.hasBackReferences = !1;
  }
  clone() {
    return new ao(this.source, this.ruleId);
  }
  setSource(e) {
    this.source !== e && (this.source = e, this.hasAnchor && (this._anchorCache = this._buildAnchorCache()));
  }
  resolveBackReferences(e, n) {
    if (typeof this.source != "string")
      throw new Error("This method should only be called if the source is a string");
    let r = n.map((o) => e.substring(o.start, o.end));
    return Hn.lastIndex = 0, this.source.replace(Hn, (o, s) => Zr(r[parseInt(s, 10)] || ""));
  }
  _buildAnchorCache() {
    if (typeof this.source != "string")
      throw new Error("This method should only be called if the source is a string");
    let e = [], n = [], r = [], o = [], s, a, i, l;
    for (s = 0, a = this.source.length; s < a; s++)
      i = this.source.charAt(s), e[s] = i, n[s] = i, r[s] = i, o[s] = i, i === "\\" && s + 1 < a && (l = this.source.charAt(s + 1), l === "A" ? (e[s + 1] = "￿", n[s + 1] = "￿", r[s + 1] = "A", o[s + 1] = "A") : l === "G" ? (e[s + 1] = "￿", n[s + 1] = "G", r[s + 1] = "￿", o[s + 1] = "G") : (e[s + 1] = l, n[s + 1] = l, r[s + 1] = l, o[s + 1] = l), s++);
    return {
      A0_G0: e.join(""),
      A0_G1: n.join(""),
      A1_G0: r.join(""),
      A1_G1: o.join("")
    };
  }
  resolveAnchors(e, n) {
    return !this.hasAnchor || !this._anchorCache || typeof this.source != "string" ? this.source : e ? n ? this._anchorCache.A1_G1 : this._anchorCache.A1_G0 : n ? this._anchorCache.A0_G1 : this._anchorCache.A0_G0;
  }
}, He = class {
  _items;
  _hasAnchors;
  _cached;
  _anchorCache;
  constructor() {
    this._items = [], this._hasAnchors = !1, this._cached = null, this._anchorCache = {
      A0_G0: null,
      A0_G1: null,
      A1_G0: null,
      A1_G1: null
    };
  }
  dispose() {
    this._disposeCaches();
  }
  _disposeCaches() {
    this._cached && (this._cached.dispose(), this._cached = null), this._anchorCache.A0_G0 && (this._anchorCache.A0_G0.dispose(), this._anchorCache.A0_G0 = null), this._anchorCache.A0_G1 && (this._anchorCache.A0_G1.dispose(), this._anchorCache.A0_G1 = null), this._anchorCache.A1_G0 && (this._anchorCache.A1_G0.dispose(), this._anchorCache.A1_G0 = null), this._anchorCache.A1_G1 && (this._anchorCache.A1_G1.dispose(), this._anchorCache.A1_G1 = null);
  }
  push(t) {
    this._items.push(t), this._hasAnchors = this._hasAnchors || t.hasAnchor;
  }
  unshift(t) {
    this._items.unshift(t), this._hasAnchors = this._hasAnchors || t.hasAnchor;
  }
  length() {
    return this._items.length;
  }
  setSource(t, e) {
    this._items[t].source !== e && (this._disposeCaches(), this._items[t].setSource(e));
  }
  compile(t) {
    if (!this._cached) {
      let e = this._items.map((n) => n.source);
      this._cached = new Vn(t, e, this._items.map((n) => n.ruleId));
    }
    return this._cached;
  }
  compileAG(t, e, n) {
    return this._hasAnchors ? e ? n ? (this._anchorCache.A1_G1 || (this._anchorCache.A1_G1 = this._resolveAnchors(t, e, n)), this._anchorCache.A1_G1) : (this._anchorCache.A1_G0 || (this._anchorCache.A1_G0 = this._resolveAnchors(t, e, n)), this._anchorCache.A1_G0) : n ? (this._anchorCache.A0_G1 || (this._anchorCache.A0_G1 = this._resolveAnchors(t, e, n)), this._anchorCache.A0_G1) : (this._anchorCache.A0_G0 || (this._anchorCache.A0_G0 = this._resolveAnchors(t, e, n)), this._anchorCache.A0_G0) : this.compile(t);
  }
  _resolveAnchors(t, e, n) {
    let r = this._items.map((o) => o.resolveAnchors(e, n));
    return new Vn(t, r, this._items.map((o) => o.ruleId));
  }
}, Vn = class {
  constructor(t, e, n) {
    this.regExps = e, this.rules = n, this.scanner = t.createOnigScanner(e);
  }
  scanner;
  dispose() {
    typeof this.scanner.dispose == "function" && this.scanner.dispose();
  }
  toString() {
    const t = [];
    for (let e = 0, n = this.rules.length; e < n; e++)
      t.push("   - " + this.rules[e] + ": " + this.regExps[e]);
    return t.join(`
`);
  }
  findNextMatchSync(t, e, n) {
    const r = this.scanner.findNextMatchSync(t, e, n);
    return r ? {
      ruleId: this.rules[r.index],
      captureIndices: r.captureIndices
    } : null;
  }
}, Lt = class {
  constructor(t, e) {
    this.languageId = t, this.tokenType = e;
  }
}, Ma = class Yt {
  _defaultAttributes;
  _embeddedLanguagesMatcher;
  constructor(e, n) {
    this._defaultAttributes = new Lt(
      e,
      8
      /* NotSet */
    ), this._embeddedLanguagesMatcher = new Oa(Object.entries(n || {}));
  }
  getDefaultAttributes() {
    return this._defaultAttributes;
  }
  getBasicScopeAttributes(e) {
    return e === null ? Yt._NULL_SCOPE_METADATA : this._getBasicScopeAttributes.get(e);
  }
  static _NULL_SCOPE_METADATA = new Lt(0, 0);
  _getBasicScopeAttributes = new Qr((e) => {
    const n = this._scopeToLanguage(e), r = this._toStandardTokenType(e);
    return new Lt(n, r);
  });
  /**
   * Given a produced TM scope, return the language that token describes or null if unknown.
   * e.g. source.html => html, source.css.embedded.html => css, punctuation.definition.tag.html => null
   */
  _scopeToLanguage(e) {
    return this._embeddedLanguagesMatcher.match(e) || 0;
  }
  _toStandardTokenType(e) {
    const n = e.match(Yt.STANDARD_TOKEN_TYPE_REGEXP);
    if (!n)
      return 8;
    switch (n[1]) {
      case "comment":
        return 1;
      case "string":
        return 2;
      case "regex":
        return 3;
      case "meta.embedded":
        return 0;
    }
    throw new Error("Unexpected match for standard token type!");
  }
  static STANDARD_TOKEN_TYPE_REGEXP = /\b(comment|string|regex|meta\.embedded)\b/;
}, Oa = class {
  values;
  scopesRegExp;
  constructor(t) {
    if (t.length === 0)
      this.values = null, this.scopesRegExp = null;
    else {
      this.values = new Map(t);
      const e = t.map(
        ([n, r]) => Zr(n)
      );
      e.sort(), e.reverse(), this.scopesRegExp = new RegExp(
        `^((${e.join(")|(")}))($|\\.)`,
        ""
      );
    }
  }
  match(t) {
    if (!this.scopesRegExp)
      return;
    const e = t.match(this.scopesRegExp);
    if (e)
      return this.values.get(e[1]);
  }
};
typeof process < "u" && process.env.VSCODE_TEXTMATE_DEBUG;
var qn = class {
  constructor(t, e) {
    this.stack = t, this.stoppedEarly = e;
  }
};
function io(t, e, n, r, o, s, a, i) {
  const l = e.content.length;
  let u = !1, c = -1;
  if (a) {
    const d = Da(
      t,
      e,
      n,
      r,
      o,
      s
    );
    o = d.stack, r = d.linePos, n = d.isFirstLine, c = d.anchorPosition;
  }
  const h = Date.now();
  for (; !u; ) {
    if (i !== 0 && Date.now() - h > i)
      return new qn(o, !0);
    p();
  }
  return new qn(o, !1);
  function p() {
    const d = Ga(
      t,
      e,
      n,
      r,
      o,
      c
    );
    if (!d) {
      s.produce(o, l), u = !0;
      return;
    }
    const f = d.captureIndices, g = d.matchedRuleId, C = f && f.length > 0 ? f[0].end > r : !1;
    if (g === Pa) {
      const y = o.getRule(t);
      s.produce(o, f[0].start), o = o.withContentNameScopesList(o.nameScopesList), Ge(
        t,
        e,
        n,
        o,
        s,
        y.endCaptures,
        f
      ), s.produce(o, f[0].end);
      const m = o;
      if (o = o.parent, c = m.getAnchorPos(), !C && m.getEnterPos() === r) {
        o = m, s.produce(o, l), u = !0;
        return;
      }
    } else {
      const y = t.getRule(g);
      s.produce(o, f[0].start);
      const m = o, _ = y.getName(e.content, f), S = o.contentNameScopesList.pushAttributed(
        _,
        t
      );
      if (o = o.push(
        g,
        r,
        c,
        f[0].end === l,
        null,
        S,
        S
      ), y instanceof Kt) {
        const A = y;
        Ge(
          t,
          e,
          n,
          o,
          s,
          A.beginCaptures,
          f
        ), s.produce(o, f[0].end), c = f[0].end;
        const D = A.getContentName(
          e.content,
          f
        ), L = S.pushAttributed(
          D,
          t
        );
        if (o = o.withContentNameScopesList(L), A.endHasBackReferences && (o = o.withEndRule(
          A.getEndWithResolvedBackReferences(
            e.content,
            f
          )
        )), !C && m.hasSameRuleAs(o)) {
          o = o.pop(), s.produce(o, l), u = !0;
          return;
        }
      } else if (y instanceof ct) {
        const A = y;
        Ge(
          t,
          e,
          n,
          o,
          s,
          A.beginCaptures,
          f
        ), s.produce(o, f[0].end), c = f[0].end;
        const D = A.getContentName(
          e.content,
          f
        ), L = S.pushAttributed(
          D,
          t
        );
        if (o = o.withContentNameScopesList(L), A.whileHasBackReferences && (o = o.withEndRule(
          A.getWhileWithResolvedBackReferences(
            e.content,
            f
          )
        )), !C && m.hasSameRuleAs(o)) {
          o = o.pop(), s.produce(o, l), u = !0;
          return;
        }
      } else if (Ge(
        t,
        e,
        n,
        o,
        s,
        y.captures,
        f
      ), s.produce(o, f[0].end), o = o.pop(), !C) {
        o = o.safePop(), s.produce(o, l), u = !0;
        return;
      }
    }
    f[0].end > r && (r = f[0].end, n = !1);
  }
}
function Da(t, e, n, r, o, s) {
  let a = o.beginRuleCapturedEOL ? 0 : -1;
  const i = [];
  for (let l = o; l; l = l.pop()) {
    const u = l.getRule(t);
    u instanceof ct && i.push({
      rule: u,
      stack: l
    });
  }
  for (let l = i.pop(); l; l = i.pop()) {
    const { ruleScanner: u, findOptions: c } = ja(l.rule, t, l.stack.endRule, n, r === a), h = u.findNextMatchSync(e, r, c);
    if (h) {
      if (h.ruleId !== oo) {
        o = l.stack.pop();
        break;
      }
      h.captureIndices && h.captureIndices.length && (s.produce(l.stack, h.captureIndices[0].start), Ge(t, e, n, l.stack, s, l.rule.whileCaptures, h.captureIndices), s.produce(l.stack, h.captureIndices[0].end), a = h.captureIndices[0].end, h.captureIndices[0].end > r && (r = h.captureIndices[0].end, n = !1));
    } else {
      o = l.stack.pop();
      break;
    }
  }
  return { stack: o, linePos: r, anchorPosition: a, isFirstLine: n };
}
function Ga(t, e, n, r, o, s) {
  const a = Fa(t, e, n, r, o, s), i = t.getInjections();
  if (i.length === 0)
    return a;
  const l = Ba(i, t, e, n, r, o, s);
  if (!l)
    return a;
  if (!a)
    return l;
  const u = a.captureIndices[0].start, c = l.captureIndices[0].start;
  return c < u || l.priorityMatch && c === u ? l : a;
}
function Fa(t, e, n, r, o, s) {
  const a = o.getRule(t), { ruleScanner: i, findOptions: l } = lo(a, t, o.endRule, n, r === s), u = i.findNextMatchSync(e, r, l);
  return u ? {
    captureIndices: u.captureIndices,
    matchedRuleId: u.ruleId
  } : null;
}
function Ba(t, e, n, r, o, s, a) {
  let i = Number.MAX_VALUE, l = null, u, c = 0;
  const h = s.contentNameScopesList.getScopeNames();
  for (let p = 0, d = t.length; p < d; p++) {
    const f = t[p];
    if (!f.matcher(h))
      continue;
    const g = e.getRule(f.ruleId), { ruleScanner: C, findOptions: y } = lo(g, e, null, r, o === a), m = C.findNextMatchSync(n, o, y);
    if (!m)
      continue;
    const _ = m.captureIndices[0].start;
    if (!(_ >= i) && (i = _, l = m.captureIndices, u = m.ruleId, c = f.priority, i === o))
      break;
  }
  return l ? {
    priorityMatch: c === -1,
    captureIndices: l,
    matchedRuleId: u
  } : null;
}
function lo(t, e, n, r, o) {
  return {
    ruleScanner: t.compileAG(e, n, r, o),
    findOptions: 0
    /* None */
  };
}
function ja(t, e, n, r, o) {
  return {
    ruleScanner: t.compileWhileAG(e, n, r, o),
    findOptions: 0
    /* None */
  };
}
function Ge(t, e, n, r, o, s, a) {
  if (s.length === 0)
    return;
  const i = e.content, l = Math.min(s.length, a.length), u = [], c = a[0].end;
  for (let h = 0; h < l; h++) {
    const p = s[h];
    if (p === null)
      continue;
    const d = a[h];
    if (d.length === 0)
      continue;
    if (d.start > c)
      break;
    for (; u.length > 0 && u[u.length - 1].endPos <= d.start; )
      o.produceFromScopes(u[u.length - 1].scopes, u[u.length - 1].endPos), u.pop();
    if (u.length > 0 ? o.produceFromScopes(u[u.length - 1].scopes, d.start) : o.produce(r, d.start), p.retokenizeCapturedWithRuleId) {
      const g = p.getName(i, a), C = r.contentNameScopesList.pushAttributed(g, t), y = p.getContentName(i, a), m = C.pushAttributed(y, t), _ = r.push(p.retokenizeCapturedWithRuleId, d.start, -1, !1, null, C, m), S = t.createOnigString(i.substring(0, d.end));
      io(
        t,
        S,
        n && d.start === 0,
        d.start,
        _,
        o,
        !1,
        /* no time limit */
        0
      ), no(S);
      continue;
    }
    const f = p.getName(i, a);
    if (f !== null) {
      const C = (u.length > 0 ? u[u.length - 1].scopes : r.contentNameScopesList).pushAttributed(f, t);
      u.push(new Ua(C, d.end));
    }
  }
  for (; u.length > 0; )
    o.produceFromScopes(u[u.length - 1].scopes, u[u.length - 1].endPos), u.pop();
}
var Ua = class {
  scopes;
  endPos;
  constructor(t, e) {
    this.scopes = t, this.endPos = e;
  }
};
function za(t, e, n, r, o, s, a, i) {
  return new Wa(
    t,
    e,
    n,
    r,
    o,
    s,
    a,
    i
  );
}
function Xn(t, e, n, r, o) {
  const s = lt(e, ht), a = so.getCompiledRuleId(n, r, o.repository);
  for (const i of s)
    t.push({
      debugSelector: e,
      matcher: i.matcher,
      ruleId: a,
      grammar: o,
      priority: i.priority
    });
}
function ht(t, e) {
  if (e.length < t.length)
    return !1;
  let n = 0;
  return t.every((r) => {
    for (let o = n; o < e.length; o++)
      if (Ha(e[o], r))
        return n = o + 1, !0;
    return !1;
  });
}
function Ha(t, e) {
  if (!t)
    return !1;
  if (t === e)
    return !0;
  const n = e.length;
  return t.length > n && t.substr(0, n) === e && t[n] === ".";
}
var Wa = class {
  constructor(t, e, n, r, o, s, a, i) {
    if (this._rootScopeName = t, this.balancedBracketSelectors = s, this._onigLib = i, this._basicScopeAttributesProvider = new Ma(
      n,
      r
    ), this._rootId = -1, this._lastRuleId = 0, this._ruleId2desc = [null], this._includedGrammars = {}, this._grammarRepository = a, this._grammar = Kn(e, null), this._injections = null, this._tokenTypeMatchers = [], o)
      for (const l of Object.keys(o)) {
        const u = lt(l, ht);
        for (const c of u)
          this._tokenTypeMatchers.push({
            matcher: c.matcher,
            type: o[l]
          });
      }
  }
  _rootId;
  _lastRuleId;
  _ruleId2desc;
  _includedGrammars;
  _grammarRepository;
  _grammar;
  _injections;
  _basicScopeAttributesProvider;
  _tokenTypeMatchers;
  get themeProvider() {
    return this._grammarRepository;
  }
  dispose() {
    for (const t of this._ruleId2desc)
      t && t.dispose();
  }
  createOnigScanner(t) {
    return this._onigLib.createOnigScanner(t);
  }
  createOnigString(t) {
    return this._onigLib.createOnigString(t);
  }
  getMetadataForScope(t) {
    return this._basicScopeAttributesProvider.getBasicScopeAttributes(t);
  }
  _collectInjections() {
    const t = {
      lookup: (o) => o === this._rootScopeName ? this._grammar : this.getExternalGrammar(o),
      injections: (o) => this._grammarRepository.injections(o)
    }, e = [], n = this._rootScopeName, r = t.lookup(n);
    if (r) {
      const o = r.injections;
      if (o)
        for (let a in o)
          Xn(
            e,
            a,
            o[a],
            this,
            r
          );
      const s = this._grammarRepository.injections(n);
      s && s.forEach((a) => {
        const i = this.getExternalGrammar(a);
        if (i) {
          const l = i.injectionSelector;
          l && Xn(
            e,
            l,
            i,
            this,
            i
          );
        }
      });
    }
    return e.sort((o, s) => o.priority - s.priority), e;
  }
  getInjections() {
    return this._injections === null && (this._injections = this._collectInjections()), this._injections;
  }
  registerRule(t) {
    const e = ++this._lastRuleId, n = t(e);
    return this._ruleId2desc[e] = n, n;
  }
  getRule(t) {
    return this._ruleId2desc[t];
  }
  getExternalGrammar(t, e) {
    if (this._includedGrammars[t])
      return this._includedGrammars[t];
    if (this._grammarRepository) {
      const n = this._grammarRepository.lookup(t);
      if (n)
        return this._includedGrammars[t] = Kn(
          n,
          e && e.$base
        ), this._includedGrammars[t];
    }
  }
  tokenizeLine(t, e, n = 0) {
    const r = this._tokenize(t, e, !1, n);
    return {
      tokens: r.lineTokens.getResult(r.ruleStack, r.lineLength),
      ruleStack: r.ruleStack,
      stoppedEarly: r.stoppedEarly
    };
  }
  tokenizeLine2(t, e, n = 0) {
    const r = this._tokenize(t, e, !0, n);
    return {
      tokens: r.lineTokens.getBinaryResult(r.ruleStack, r.lineLength),
      ruleStack: r.ruleStack,
      stoppedEarly: r.stoppedEarly
    };
  }
  _tokenize(t, e, n, r) {
    this._rootId === -1 && (this._rootId = so.getCompiledRuleId(
      this._grammar.repository.$self,
      this,
      this._grammar.repository
    ), this.getInjections());
    let o;
    if (!e || e === Jt.NULL) {
      o = !0;
      const u = this._basicScopeAttributesProvider.getDefaultAttributes(), c = this.themeProvider.getDefaults(), h = Re.set(
        0,
        u.languageId,
        u.tokenType,
        null,
        c.fontStyle,
        c.foregroundId,
        c.backgroundId
      ), p = this.getRule(this._rootId).getName(
        null,
        null
      );
      let d;
      p ? d = Fe.createRootAndLookUpScopeName(
        p,
        h,
        this
      ) : d = Fe.createRoot(
        "unknown",
        h
      ), e = new Jt(
        null,
        this._rootId,
        -1,
        -1,
        !1,
        null,
        d,
        d
      );
    } else
      o = !1, e.reset();
    t = t + `
`;
    const s = this.createOnigString(t), a = s.content.length, i = new qa(
      n,
      t,
      this._tokenTypeMatchers,
      this.balancedBracketSelectors
    ), l = io(
      this,
      s,
      o,
      0,
      e,
      i,
      !0,
      r
    );
    return no(s), {
      lineLength: a,
      lineTokens: i,
      ruleStack: l.stack,
      stoppedEarly: l.stoppedEarly
    };
  }
};
function Kn(t, e) {
  return t = ca(t), t.repository = t.repository || {}, t.repository.$self = {
    $vscodeTextmateLocation: t.$vscodeTextmateLocation,
    patterns: t.patterns,
    name: t.scopeName
  }, t.repository.$base = e || t.repository.$self, t;
}
var Fe = class ne {
  /**
   * Invariant:
   * ```
   * if (parent && !scopePath.extends(parent.scopePath)) {
   * 	throw new Error();
   * }
   * ```
   */
  constructor(e, n, r) {
    this.parent = e, this.scopePath = n, this.tokenAttributes = r;
  }
  static fromExtension(e, n) {
    let r = e, o = e?.scopePath ?? null;
    for (const s of n)
      o = Nt.push(o, s.scopeNames), r = new ne(r, o, s.encodedTokenAttributes);
    return r;
  }
  static createRoot(e, n) {
    return new ne(null, new Nt(null, e), n);
  }
  static createRootAndLookUpScopeName(e, n, r) {
    const o = r.getMetadataForScope(e), s = new Nt(null, e), a = r.themeProvider.themeMatch(s), i = ne.mergeAttributes(
      n,
      o,
      a
    );
    return new ne(null, s, i);
  }
  get scopeName() {
    return this.scopePath.scopeName;
  }
  toString() {
    return this.getScopeNames().join(" ");
  }
  equals(e) {
    return ne.equals(this, e);
  }
  static equals(e, n) {
    do {
      if (e === n || !e && !n)
        return !0;
      if (!e || !n || e.scopeName !== n.scopeName || e.tokenAttributes !== n.tokenAttributes)
        return !1;
      e = e.parent, n = n.parent;
    } while (!0);
  }
  static mergeAttributes(e, n, r) {
    let o = -1, s = 0, a = 0;
    return r !== null && (o = r.fontStyle, s = r.foregroundId, a = r.backgroundId), Re.set(
      e,
      n.languageId,
      n.tokenType,
      null,
      o,
      s,
      a
    );
  }
  pushAttributed(e, n) {
    if (e === null)
      return this;
    if (e.indexOf(" ") === -1)
      return ne._pushAttributed(this, e, n);
    const r = e.split(/ /g);
    let o = this;
    for (const s of r)
      o = ne._pushAttributed(o, s, n);
    return o;
  }
  static _pushAttributed(e, n, r) {
    const o = r.getMetadataForScope(n), s = e.scopePath.push(n), a = r.themeProvider.themeMatch(s), i = ne.mergeAttributes(
      e.tokenAttributes,
      o,
      a
    );
    return new ne(e, s, i);
  }
  getScopeNames() {
    return this.scopePath.getSegments();
  }
  getExtensionIfDefined(e) {
    const n = [];
    let r = this;
    for (; r && r !== e; )
      n.push({
        encodedTokenAttributes: r.tokenAttributes,
        scopeNames: r.scopePath.getExtensionIfDefined(r.parent?.scopePath ?? null)
      }), r = r.parent;
    return r === e ? n.reverse() : void 0;
  }
}, Jt = class fe {
  /**
   * Invariant:
   * ```
   * if (contentNameScopesList !== nameScopesList && contentNameScopesList?.parent !== nameScopesList) {
   * 	throw new Error();
   * }
   * if (this.parent && !nameScopesList.extends(this.parent.contentNameScopesList)) {
   * 	throw new Error();
   * }
   * ```
   */
  constructor(e, n, r, o, s, a, i, l) {
    this.parent = e, this.ruleId = n, this.beginRuleCapturedEOL = s, this.endRule = a, this.nameScopesList = i, this.contentNameScopesList = l, this.depth = this.parent ? this.parent.depth + 1 : 1, this._enterPos = r, this._anchorPos = o;
  }
  _stackElementBrand = void 0;
  // TODO remove me
  static NULL = new fe(
    null,
    0,
    0,
    0,
    !1,
    null,
    null,
    null
  );
  /**
   * The position on the current line where this state was pushed.
   * This is relevant only while tokenizing a line, to detect endless loops.
   * Its value is meaningless across lines.
   */
  _enterPos;
  /**
   * The captured anchor position when this stack element was pushed.
   * This is relevant only while tokenizing a line, to restore the anchor position when popping.
   * Its value is meaningless across lines.
   */
  _anchorPos;
  /**
   * The depth of the stack.
   */
  depth;
  equals(e) {
    return e === null ? !1 : fe._equals(this, e);
  }
  static _equals(e, n) {
    return e === n ? !0 : this._structuralEquals(e, n) ? Fe.equals(e.contentNameScopesList, n.contentNameScopesList) : !1;
  }
  /**
   * A structural equals check. Does not take into account `scopes`.
   */
  static _structuralEquals(e, n) {
    do {
      if (e === n || !e && !n)
        return !0;
      if (!e || !n || e.depth !== n.depth || e.ruleId !== n.ruleId || e.endRule !== n.endRule)
        return !1;
      e = e.parent, n = n.parent;
    } while (!0);
  }
  clone() {
    return this;
  }
  static _reset(e) {
    for (; e; )
      e._enterPos = -1, e._anchorPos = -1, e = e.parent;
  }
  reset() {
    fe._reset(this);
  }
  pop() {
    return this.parent;
  }
  safePop() {
    return this.parent ? this.parent : this;
  }
  push(e, n, r, o, s, a, i) {
    return new fe(
      this,
      e,
      n,
      r,
      o,
      s,
      a,
      i
    );
  }
  getEnterPos() {
    return this._enterPos;
  }
  getAnchorPos() {
    return this._anchorPos;
  }
  getRule(e) {
    return e.getRule(this.ruleId);
  }
  toString() {
    const e = [];
    return this._writeString(e, 0), "[" + e.join(",") + "]";
  }
  _writeString(e, n) {
    return this.parent && (n = this.parent._writeString(e, n)), e[n++] = `(${this.ruleId}, ${this.nameScopesList?.toString()}, ${this.contentNameScopesList?.toString()})`, n;
  }
  withContentNameScopesList(e) {
    return this.contentNameScopesList === e ? this : this.parent.push(
      this.ruleId,
      this._enterPos,
      this._anchorPos,
      this.beginRuleCapturedEOL,
      this.endRule,
      this.nameScopesList,
      e
    );
  }
  withEndRule(e) {
    return this.endRule === e ? this : new fe(
      this.parent,
      this.ruleId,
      this._enterPos,
      this._anchorPos,
      this.beginRuleCapturedEOL,
      e,
      this.nameScopesList,
      this.contentNameScopesList
    );
  }
  // Used to warn of endless loops
  hasSameRuleAs(e) {
    let n = this;
    for (; n && n._enterPos === e._enterPos; ) {
      if (n.ruleId === e.ruleId)
        return !0;
      n = n.parent;
    }
    return !1;
  }
  toStateStackFrame() {
    return {
      ruleId: this.ruleId,
      beginRuleCapturedEOL: this.beginRuleCapturedEOL,
      endRule: this.endRule,
      nameScopesList: this.nameScopesList?.getExtensionIfDefined(this.parent?.nameScopesList ?? null) ?? [],
      contentNameScopesList: this.contentNameScopesList?.getExtensionIfDefined(this.nameScopesList) ?? []
    };
  }
  static pushFrame(e, n) {
    const r = Fe.fromExtension(e?.nameScopesList ?? null, n.nameScopesList);
    return new fe(
      e,
      n.ruleId,
      n.enterPos ?? -1,
      n.anchorPos ?? -1,
      n.beginRuleCapturedEOL,
      n.endRule,
      r,
      Fe.fromExtension(r, n.contentNameScopesList)
    );
  }
}, Va = class {
  balancedBracketScopes;
  unbalancedBracketScopes;
  allowAny = !1;
  constructor(t, e) {
    this.balancedBracketScopes = t.flatMap(
      (n) => n === "*" ? (this.allowAny = !0, []) : lt(n, ht).map((r) => r.matcher)
    ), this.unbalancedBracketScopes = e.flatMap(
      (n) => lt(n, ht).map((r) => r.matcher)
    );
  }
  get matchesAlways() {
    return this.allowAny && this.unbalancedBracketScopes.length === 0;
  }
  get matchesNever() {
    return this.balancedBracketScopes.length === 0 && !this.allowAny;
  }
  match(t) {
    for (const e of this.unbalancedBracketScopes)
      if (e(t))
        return !1;
    for (const e of this.balancedBracketScopes)
      if (e(t))
        return !0;
    return this.allowAny;
  }
}, qa = class {
  constructor(t, e, n, r) {
    this.balancedBracketSelectors = r, this._emitBinaryTokens = t, this._tokenTypeOverrides = n, this._lineText = null, this._tokens = [], this._binaryTokens = [], this._lastTokenEndIndex = 0;
  }
  _emitBinaryTokens;
  /**
   * defined only if `false`.
   */
  _lineText;
  /**
   * used only if `_emitBinaryTokens` is false.
   */
  _tokens;
  /**
   * used only if `_emitBinaryTokens` is true.
   */
  _binaryTokens;
  _lastTokenEndIndex;
  _tokenTypeOverrides;
  produce(t, e) {
    this.produceFromScopes(t.contentNameScopesList, e);
  }
  produceFromScopes(t, e) {
    if (this._lastTokenEndIndex >= e)
      return;
    if (this._emitBinaryTokens) {
      let r = t?.tokenAttributes ?? 0, o = !1;
      if (this.balancedBracketSelectors?.matchesAlways && (o = !0), this._tokenTypeOverrides.length > 0 || this.balancedBracketSelectors && !this.balancedBracketSelectors.matchesAlways && !this.balancedBracketSelectors.matchesNever) {
        const s = t?.getScopeNames() ?? [];
        for (const a of this._tokenTypeOverrides)
          a.matcher(s) && (r = Re.set(
            r,
            0,
            a.type,
            null,
            -1,
            0,
            0
          ));
        this.balancedBracketSelectors && (o = this.balancedBracketSelectors.match(s));
      }
      if (o && (r = Re.set(
        r,
        0,
        8,
        o,
        -1,
        0,
        0
      )), this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 1] === r) {
        this._lastTokenEndIndex = e;
        return;
      }
      this._binaryTokens.push(this._lastTokenEndIndex), this._binaryTokens.push(r), this._lastTokenEndIndex = e;
      return;
    }
    const n = t?.getScopeNames() ?? [];
    this._tokens.push({
      startIndex: this._lastTokenEndIndex,
      endIndex: e,
      // value: lineText.substring(lastTokenEndIndex, endIndex),
      scopes: n
    }), this._lastTokenEndIndex = e;
  }
  getResult(t, e) {
    return this._tokens.length > 0 && this._tokens[this._tokens.length - 1].startIndex === e - 1 && this._tokens.pop(), this._tokens.length === 0 && (this._lastTokenEndIndex = -1, this.produce(t, e), this._tokens[this._tokens.length - 1].startIndex = 0), this._tokens;
  }
  getBinaryResult(t, e) {
    this._binaryTokens.length > 0 && this._binaryTokens[this._binaryTokens.length - 2] === e - 1 && (this._binaryTokens.pop(), this._binaryTokens.pop()), this._binaryTokens.length === 0 && (this._lastTokenEndIndex = -1, this.produce(t, e), this._binaryTokens[this._binaryTokens.length - 2] = 0);
    const n = new Uint32Array(this._binaryTokens.length);
    for (let r = 0, o = this._binaryTokens.length; r < o; r++)
      n[r] = this._binaryTokens[r];
    return n;
  }
}, Xa = class {
  constructor(t, e) {
    this._onigLib = e, this._theme = t;
  }
  _grammars = /* @__PURE__ */ new Map();
  _rawGrammars = /* @__PURE__ */ new Map();
  _injectionGrammars = /* @__PURE__ */ new Map();
  _theme;
  dispose() {
    for (const t of this._grammars.values())
      t.dispose();
  }
  setTheme(t) {
    this._theme = t;
  }
  getColorMap() {
    return this._theme.getColorMap();
  }
  /**
   * Add `grammar` to registry and return a list of referenced scope names
   */
  addGrammar(t, e) {
    this._rawGrammars.set(t.scopeName, t), e && this._injectionGrammars.set(t.scopeName, e);
  }
  /**
   * Lookup a raw grammar.
   */
  lookup(t) {
    return this._rawGrammars.get(t);
  }
  /**
   * Returns the injections for the given grammar
   */
  injections(t) {
    return this._injectionGrammars.get(t);
  }
  /**
   * Get the default theme settings
   */
  getDefaults() {
    return this._theme.getDefaults();
  }
  /**
   * Match a scope in the theme.
   */
  themeMatch(t) {
    return this._theme.match(t);
  }
  /**
   * Lookup a grammar.
   */
  grammarForScopeName(t, e, n, r, o) {
    if (!this._grammars.has(t)) {
      let s = this._rawGrammars.get(t);
      if (!s)
        return null;
      this._grammars.set(t, za(
        t,
        s,
        e,
        n,
        r,
        o,
        this,
        this._onigLib
      ));
    }
    return this._grammars.get(t);
  }
}, Ka = class {
  _options;
  _syncRegistry;
  _ensureGrammarCache;
  constructor(e) {
    this._options = e, this._syncRegistry = new Xa(
      it.createFromRawTheme(e.theme, e.colorMap),
      e.onigLib
    ), this._ensureGrammarCache = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._syncRegistry.dispose();
  }
  /**
   * Change the theme. Once called, no previous `ruleStack` should be used anymore.
   */
  setTheme(e, n) {
    this._syncRegistry.setTheme(it.createFromRawTheme(e, n));
  }
  /**
   * Returns a lookup array for color ids.
   */
  getColorMap() {
    return this._syncRegistry.getColorMap();
  }
  /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   * Please do not use language id 0.
   */
  loadGrammarWithEmbeddedLanguages(e, n, r) {
    return this.loadGrammarWithConfiguration(e, n, { embeddedLanguages: r });
  }
  /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   * Please do not use language id 0.
   */
  loadGrammarWithConfiguration(e, n, r) {
    return this._loadGrammar(
      e,
      n,
      r.embeddedLanguages,
      r.tokenTypes,
      new Va(
        r.balancedBracketSelectors || [],
        r.unbalancedBracketSelectors || []
      )
    );
  }
  /**
   * Load the grammar for `scopeName` and all referenced included grammars asynchronously.
   */
  loadGrammar(e) {
    return this._loadGrammar(e, 0, null, null, null);
  }
  _loadGrammar(e, n, r, o, s) {
    const a = new va(this._syncRegistry, e);
    for (; a.Q.length > 0; )
      a.Q.map((i) => this._loadSingleGrammar(i.scopeName)), a.processQueue();
    return this._grammarForScopeName(
      e,
      n,
      r,
      o,
      s
    );
  }
  _loadSingleGrammar(e) {
    this._ensureGrammarCache.has(e) || (this._doLoadSingleGrammar(e), this._ensureGrammarCache.set(e, !0));
  }
  _doLoadSingleGrammar(e) {
    const n = this._options.loadGrammar(e);
    if (n) {
      const r = typeof this._options.getInjections == "function" ? this._options.getInjections(e) : void 0;
      this._syncRegistry.addGrammar(n, r);
    }
  }
  /**
   * Adds a rawGrammar.
   */
  addGrammar(e, n = [], r = 0, o = null) {
    return this._syncRegistry.addGrammar(e, n), this._grammarForScopeName(e.scopeName, r, o);
  }
  /**
   * Get the grammar for `scopeName`. The grammar must first be created via `loadGrammar` or `addGrammar`.
   */
  _grammarForScopeName(e, n = 0, r = null, o = null, s = null) {
    return this._syncRegistry.grammarForScopeName(
      e,
      n,
      r,
      o,
      s
    );
  }
}, Zt = Jt.NULL;
class Ke {
  /**
   * @param {SchemaType['property']} property
   *   Property.
   * @param {SchemaType['normal']} normal
   *   Normal.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Schema.
   */
  constructor(e, n, r) {
    this.normal = n, this.property = e, r && (this.space = r);
  }
}
Ke.prototype.normal = {};
Ke.prototype.property = {};
Ke.prototype.space = void 0;
function uo(t, e) {
  const n = {}, r = {};
  for (const o of t)
    Object.assign(n, o.property), Object.assign(r, o.normal);
  return new Ke(n, r, e);
}
function Qt(t) {
  return t.toLowerCase();
}
class V {
  /**
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @returns
   *   Info.
   */
  constructor(e, n) {
    this.attribute = n, this.property = e;
  }
}
V.prototype.attribute = "";
V.prototype.booleanish = !1;
V.prototype.boolean = !1;
V.prototype.commaOrSpaceSeparated = !1;
V.prototype.commaSeparated = !1;
V.prototype.defined = !1;
V.prototype.mustUseProperty = !1;
V.prototype.number = !1;
V.prototype.overloadedBoolean = !1;
V.prototype.property = "";
V.prototype.spaceSeparated = !1;
V.prototype.space = void 0;
let Ya = 0;
const E = be(), T = be(), en = be(), w = be(), N = be(), Ee = be(), X = be();
function be() {
  return 2 ** ++Ya;
}
const tn = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: E,
  booleanish: T,
  commaOrSpaceSeparated: X,
  commaSeparated: Ee,
  number: w,
  overloadedBoolean: en,
  spaceSeparated: N
}, Symbol.toStringTag, { value: "Module" })), Pt = (
  /** @type {ReadonlyArray<keyof typeof types>} */
  Object.keys(tn)
);
class yn extends V {
  /**
   * @constructor
   * @param {string} property
   *   Property.
   * @param {string} attribute
   *   Attribute.
   * @param {number | null | undefined} [mask]
   *   Mask.
   * @param {Space | undefined} [space]
   *   Space.
   * @returns
   *   Info.
   */
  constructor(e, n, r, o) {
    let s = -1;
    if (super(e, n), Yn(this, "space", o), typeof r == "number")
      for (; ++s < Pt.length; ) {
        const a = Pt[s];
        Yn(this, Pt[s], (r & tn[a]) === tn[a]);
      }
  }
}
yn.prototype.defined = !0;
function Yn(t, e, n) {
  n && (t[e] = n);
}
function Ne(t) {
  const e = {}, n = {};
  for (const [r, o] of Object.entries(t.properties)) {
    const s = new yn(
      r,
      t.transform(t.attributes || {}, r),
      o,
      t.space
    );
    t.mustUseProperty && t.mustUseProperty.includes(r) && (s.mustUseProperty = !0), e[r] = s, n[Qt(r)] = r, n[Qt(s.attribute)] = r;
  }
  return new Ke(e, n, t.space);
}
const co = Ne({
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: T,
    ariaAutoComplete: null,
    ariaBusy: T,
    ariaChecked: T,
    ariaColCount: w,
    ariaColIndex: w,
    ariaColSpan: w,
    ariaControls: N,
    ariaCurrent: null,
    ariaDescribedBy: N,
    ariaDetails: null,
    ariaDisabled: T,
    ariaDropEffect: N,
    ariaErrorMessage: null,
    ariaExpanded: T,
    ariaFlowTo: N,
    ariaGrabbed: T,
    ariaHasPopup: null,
    ariaHidden: T,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: N,
    ariaLevel: w,
    ariaLive: null,
    ariaModal: T,
    ariaMultiLine: T,
    ariaMultiSelectable: T,
    ariaOrientation: null,
    ariaOwns: N,
    ariaPlaceholder: null,
    ariaPosInSet: w,
    ariaPressed: T,
    ariaReadOnly: T,
    ariaRelevant: null,
    ariaRequired: T,
    ariaRoleDescription: N,
    ariaRowCount: w,
    ariaRowIndex: w,
    ariaRowSpan: w,
    ariaSelected: T,
    ariaSetSize: w,
    ariaSort: null,
    ariaValueMax: w,
    ariaValueMin: w,
    ariaValueNow: w,
    ariaValueText: null,
    role: null
  },
  transform(t, e) {
    return e === "role" ? e : "aria-" + e.slice(4).toLowerCase();
  }
});
function ho(t, e) {
  return e in t ? t[e] : e;
}
function fo(t, e) {
  return ho(t, e.toLowerCase());
}
const Ja = Ne({
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: Ee,
    acceptCharset: N,
    accessKey: N,
    action: null,
    allow: null,
    allowFullScreen: E,
    allowPaymentRequest: E,
    allowUserMedia: E,
    alt: null,
    as: null,
    async: E,
    autoCapitalize: null,
    autoComplete: N,
    autoFocus: E,
    autoPlay: E,
    blocking: N,
    capture: null,
    charSet: null,
    checked: E,
    cite: null,
    className: N,
    cols: w,
    colSpan: null,
    content: null,
    contentEditable: T,
    controls: E,
    controlsList: N,
    coords: w | Ee,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: E,
    defer: E,
    dir: null,
    dirName: null,
    disabled: E,
    download: en,
    draggable: T,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: E,
    formTarget: null,
    headers: N,
    height: w,
    hidden: en,
    high: w,
    href: null,
    hrefLang: null,
    htmlFor: N,
    httpEquiv: N,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: E,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: E,
    itemId: null,
    itemProp: N,
    itemRef: N,
    itemScope: E,
    itemType: N,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: E,
    low: w,
    manifest: null,
    max: null,
    maxLength: w,
    media: null,
    method: null,
    min: null,
    minLength: w,
    multiple: E,
    muted: E,
    name: null,
    nonce: null,
    noModule: E,
    noValidate: E,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: E,
    optimum: w,
    pattern: null,
    ping: N,
    placeholder: null,
    playsInline: E,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: E,
    referrerPolicy: null,
    rel: N,
    required: E,
    reversed: E,
    rows: w,
    rowSpan: w,
    sandbox: N,
    scope: null,
    scoped: E,
    seamless: E,
    selected: E,
    shadowRootClonable: E,
    shadowRootDelegatesFocus: E,
    shadowRootMode: null,
    shape: null,
    size: w,
    sizes: null,
    slot: null,
    span: w,
    spellCheck: T,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: w,
    step: null,
    style: null,
    tabIndex: w,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: E,
    useMap: null,
    value: T,
    width: w,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: N,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: w,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: w,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: E,
    // Lists. Use CSS to reduce space between items instead
    declare: E,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: w,
    // `<img>` and `<object>`
    leftMargin: w,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: w,
    // `<body>`
    marginWidth: w,
    // `<body>`
    noResize: E,
    // `<frame>`
    noHref: E,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: E,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: E,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: w,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: T,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: w,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: w,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: E,
    disableRemotePlayback: E,
    prefix: null,
    property: null,
    results: w,
    security: null,
    unselectable: null
  },
  space: "html",
  transform: fo
}), Za = Ne({
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  properties: {
    about: X,
    accentHeight: w,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: w,
    amplitude: w,
    arabicForm: null,
    ascent: w,
    attributeName: null,
    attributeType: null,
    azimuth: w,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: w,
    by: null,
    calcMode: null,
    capHeight: w,
    className: N,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: w,
    diffuseConstant: w,
    direction: null,
    display: null,
    dur: null,
    divisor: w,
    dominantBaseline: null,
    download: E,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: w,
    enableBackground: null,
    end: null,
    event: null,
    exponent: w,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: w,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: Ee,
    g2: Ee,
    glyphName: Ee,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: w,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: w,
    horizOriginX: w,
    horizOriginY: w,
    id: null,
    ideographic: w,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: w,
    k: w,
    k1: w,
    k2: w,
    k3: w,
    k4: w,
    kernelMatrix: X,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: w,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: w,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: w,
    overlineThickness: w,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: w,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: N,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: w,
    pointsAtY: w,
    pointsAtZ: w,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: X,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: X,
    rev: X,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: X,
    requiredFeatures: X,
    requiredFonts: X,
    requiredFormats: X,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: w,
    specularExponent: w,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: w,
    strikethroughThickness: w,
    string: null,
    stroke: null,
    strokeDashArray: X,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: w,
    strokeOpacity: w,
    strokeWidth: null,
    style: null,
    surfaceScale: w,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: X,
    tabIndex: w,
    tableValues: null,
    target: null,
    targetX: w,
    targetY: w,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: X,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: w,
    underlineThickness: w,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: w,
    values: null,
    vAlphabetic: w,
    vMathematical: w,
    vectorEffect: null,
    vHanging: w,
    vIdeographic: w,
    version: null,
    vertAdvY: w,
    vertOriginX: w,
    vertOriginY: w,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: w,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  },
  space: "svg",
  transform: ho
}), po = Ne({
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  },
  space: "xlink",
  transform(t, e) {
    return "xlink:" + e.slice(5).toLowerCase();
  }
}), go = Ne({
  attributes: { xmlnsxlink: "xmlns:xlink" },
  properties: { xmlnsXLink: null, xmlns: null },
  space: "xmlns",
  transform: fo
}), mo = Ne({
  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },
  space: "xml",
  transform(t, e) {
    return "xml:" + e.slice(3).toLowerCase();
  }
}), Qa = /[A-Z]/g, Jn = /-[a-z]/g, ei = /^data[-\w.:]+$/i;
function ti(t, e) {
  const n = Qt(e);
  let r = e, o = V;
  if (n in t.normal)
    return t.property[t.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && ei.test(e)) {
    if (e.charAt(4) === "-") {
      const s = e.slice(5).replace(Jn, ri);
      r = "data" + s.charAt(0).toUpperCase() + s.slice(1);
    } else {
      const s = e.slice(4);
      if (!Jn.test(s)) {
        let a = s.replace(Qa, ni);
        a.charAt(0) !== "-" && (a = "-" + a), e = "data" + a;
      }
    }
    o = yn;
  }
  return new o(r, e);
}
function ni(t) {
  return "-" + t.toLowerCase();
}
function ri(t) {
  return t.charAt(1).toUpperCase();
}
const oi = uo([co, Ja, po, go, mo], "html"), yo = uo([co, Za, po, go, mo], "svg"), si = /["&'<>`]/g, ai = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, ii = (
  // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
  /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g
), li = /[|\\{}()[\]^$+*?.]/g, Zn = /* @__PURE__ */ new WeakMap();
function ui(t, e) {
  if (t = t.replace(
    e.subset ? ci(e.subset) : si,
    r
  ), e.subset || e.escapeOnly)
    return t;
  return t.replace(ai, n).replace(ii, r);
  function n(o, s, a) {
    return e.format(
      (o.charCodeAt(0) - 55296) * 1024 + o.charCodeAt(1) - 56320 + 65536,
      a.charCodeAt(s + 2),
      e
    );
  }
  function r(o, s, a) {
    return e.format(
      o.charCodeAt(0),
      a.charCodeAt(s + 1),
      e
    );
  }
}
function ci(t) {
  let e = Zn.get(t);
  return e || (e = hi(t), Zn.set(t, e)), e;
}
function hi(t) {
  const e = [];
  let n = -1;
  for (; ++n < t.length; )
    e.push(t[n].replace(li, "\\$&"));
  return new RegExp("(?:" + e.join("|") + ")", "g");
}
const fi = /[\dA-Fa-f]/;
function pi(t, e, n) {
  const r = "&#x" + t.toString(16).toUpperCase();
  return n && e && !fi.test(String.fromCharCode(e)) ? r : r + ";";
}
const di = /\d/;
function gi(t, e, n) {
  const r = "&#" + String(t);
  return n && e && !di.test(String.fromCharCode(e)) ? r : r + ";";
}
const mi = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
], $t = {
  nbsp: " ",
  iexcl: "¡",
  cent: "¢",
  pound: "£",
  curren: "¤",
  yen: "¥",
  brvbar: "¦",
  sect: "§",
  uml: "¨",
  copy: "©",
  ordf: "ª",
  laquo: "«",
  not: "¬",
  shy: "­",
  reg: "®",
  macr: "¯",
  deg: "°",
  plusmn: "±",
  sup2: "²",
  sup3: "³",
  acute: "´",
  micro: "µ",
  para: "¶",
  middot: "·",
  cedil: "¸",
  sup1: "¹",
  ordm: "º",
  raquo: "»",
  frac14: "¼",
  frac12: "½",
  frac34: "¾",
  iquest: "¿",
  Agrave: "À",
  Aacute: "Á",
  Acirc: "Â",
  Atilde: "Ã",
  Auml: "Ä",
  Aring: "Å",
  AElig: "Æ",
  Ccedil: "Ç",
  Egrave: "È",
  Eacute: "É",
  Ecirc: "Ê",
  Euml: "Ë",
  Igrave: "Ì",
  Iacute: "Í",
  Icirc: "Î",
  Iuml: "Ï",
  ETH: "Ð",
  Ntilde: "Ñ",
  Ograve: "Ò",
  Oacute: "Ó",
  Ocirc: "Ô",
  Otilde: "Õ",
  Ouml: "Ö",
  times: "×",
  Oslash: "Ø",
  Ugrave: "Ù",
  Uacute: "Ú",
  Ucirc: "Û",
  Uuml: "Ü",
  Yacute: "Ý",
  THORN: "Þ",
  szlig: "ß",
  agrave: "à",
  aacute: "á",
  acirc: "â",
  atilde: "ã",
  auml: "ä",
  aring: "å",
  aelig: "æ",
  ccedil: "ç",
  egrave: "è",
  eacute: "é",
  ecirc: "ê",
  euml: "ë",
  igrave: "ì",
  iacute: "í",
  icirc: "î",
  iuml: "ï",
  eth: "ð",
  ntilde: "ñ",
  ograve: "ò",
  oacute: "ó",
  ocirc: "ô",
  otilde: "õ",
  ouml: "ö",
  divide: "÷",
  oslash: "ø",
  ugrave: "ù",
  uacute: "ú",
  ucirc: "û",
  uuml: "ü",
  yacute: "ý",
  thorn: "þ",
  yuml: "ÿ",
  fnof: "ƒ",
  Alpha: "Α",
  Beta: "Β",
  Gamma: "Γ",
  Delta: "Δ",
  Epsilon: "Ε",
  Zeta: "Ζ",
  Eta: "Η",
  Theta: "Θ",
  Iota: "Ι",
  Kappa: "Κ",
  Lambda: "Λ",
  Mu: "Μ",
  Nu: "Ν",
  Xi: "Ξ",
  Omicron: "Ο",
  Pi: "Π",
  Rho: "Ρ",
  Sigma: "Σ",
  Tau: "Τ",
  Upsilon: "Υ",
  Phi: "Φ",
  Chi: "Χ",
  Psi: "Ψ",
  Omega: "Ω",
  alpha: "α",
  beta: "β",
  gamma: "γ",
  delta: "δ",
  epsilon: "ε",
  zeta: "ζ",
  eta: "η",
  theta: "θ",
  iota: "ι",
  kappa: "κ",
  lambda: "λ",
  mu: "μ",
  nu: "ν",
  xi: "ξ",
  omicron: "ο",
  pi: "π",
  rho: "ρ",
  sigmaf: "ς",
  sigma: "σ",
  tau: "τ",
  upsilon: "υ",
  phi: "φ",
  chi: "χ",
  psi: "ψ",
  omega: "ω",
  thetasym: "ϑ",
  upsih: "ϒ",
  piv: "ϖ",
  bull: "•",
  hellip: "…",
  prime: "′",
  Prime: "″",
  oline: "‾",
  frasl: "⁄",
  weierp: "℘",
  image: "ℑ",
  real: "ℜ",
  trade: "™",
  alefsym: "ℵ",
  larr: "←",
  uarr: "↑",
  rarr: "→",
  darr: "↓",
  harr: "↔",
  crarr: "↵",
  lArr: "⇐",
  uArr: "⇑",
  rArr: "⇒",
  dArr: "⇓",
  hArr: "⇔",
  forall: "∀",
  part: "∂",
  exist: "∃",
  empty: "∅",
  nabla: "∇",
  isin: "∈",
  notin: "∉",
  ni: "∋",
  prod: "∏",
  sum: "∑",
  minus: "−",
  lowast: "∗",
  radic: "√",
  prop: "∝",
  infin: "∞",
  ang: "∠",
  and: "∧",
  or: "∨",
  cap: "∩",
  cup: "∪",
  int: "∫",
  there4: "∴",
  sim: "∼",
  cong: "≅",
  asymp: "≈",
  ne: "≠",
  equiv: "≡",
  le: "≤",
  ge: "≥",
  sub: "⊂",
  sup: "⊃",
  nsub: "⊄",
  sube: "⊆",
  supe: "⊇",
  oplus: "⊕",
  otimes: "⊗",
  perp: "⊥",
  sdot: "⋅",
  lceil: "⌈",
  rceil: "⌉",
  lfloor: "⌊",
  rfloor: "⌋",
  lang: "〈",
  rang: "〉",
  loz: "◊",
  spades: "♠",
  clubs: "♣",
  hearts: "♥",
  diams: "♦",
  quot: '"',
  amp: "&",
  lt: "<",
  gt: ">",
  OElig: "Œ",
  oelig: "œ",
  Scaron: "Š",
  scaron: "š",
  Yuml: "Ÿ",
  circ: "ˆ",
  tilde: "˜",
  ensp: " ",
  emsp: " ",
  thinsp: " ",
  zwnj: "‌",
  zwj: "‍",
  lrm: "‎",
  rlm: "‏",
  ndash: "–",
  mdash: "—",
  lsquo: "‘",
  rsquo: "’",
  sbquo: "‚",
  ldquo: "“",
  rdquo: "”",
  bdquo: "„",
  dagger: "†",
  Dagger: "‡",
  permil: "‰",
  lsaquo: "‹",
  rsaquo: "›",
  euro: "€"
}, yi = [
  "cent",
  "copy",
  "divide",
  "gt",
  "lt",
  "not",
  "para",
  "times"
], bo = {}.hasOwnProperty, nn = {};
let Ze;
for (Ze in $t)
  bo.call($t, Ze) && (nn[$t[Ze]] = Ze);
const bi = /[^\dA-Za-z]/;
function wi(t, e, n, r) {
  const o = String.fromCharCode(t);
  if (bo.call(nn, o)) {
    const s = nn[o], a = "&" + s;
    return n && mi.includes(s) && !yi.includes(s) && (!r || e && e !== 61 && bi.test(String.fromCharCode(e))) ? a : a + ";";
  }
  return "";
}
function Ci(t, e, n) {
  let r = pi(t, e, n.omitOptionalSemicolons), o;
  if ((n.useNamedReferences || n.useShortestReferences) && (o = wi(
    t,
    e,
    n.omitOptionalSemicolons,
    n.attribute
  )), (n.useShortestReferences || !o) && n.useShortestReferences) {
    const s = gi(t, e, n.omitOptionalSemicolons);
    s.length < r.length && (r = s);
  }
  return o && (!n.useShortestReferences || o.length < r.length) ? o : r;
}
function Ae(t, e) {
  return ui(t, Object.assign({ format: Ci }, e));
}
const _i = /^>|^->|<!--|-->|--!>|<!-$/g, Si = [">"], ki = ["<", ">"];
function vi(t, e, n, r) {
  return r.settings.bogusComments ? "<?" + Ae(
    t.value,
    Object.assign({}, r.settings.characterReferences, {
      subset: Si
    })
  ) + ">" : "<!--" + t.value.replace(_i, o) + "-->";
  function o(s) {
    return Ae(
      s,
      Object.assign({}, r.settings.characterReferences, {
        subset: ki
      })
    );
  }
}
function xi(t, e, n, r) {
  return "<!" + (r.settings.upperDoctype ? "DOCTYPE" : "doctype") + (r.settings.tightDoctype ? "" : " ") + "html>";
}
const O = Co(1), wo = Co(-1), Ei = [];
function Co(t) {
  return e;
  function e(n, r, o) {
    const s = n ? n.children : Ei;
    let a = (r || 0) + t, i = s[a];
    if (!o)
      for (; i && Ct(i); )
        a += t, i = s[a];
    return i;
  }
}
const Ai = {}.hasOwnProperty;
function _o(t) {
  return e;
  function e(n, r, o) {
    return Ai.call(t, n.tagName) && t[n.tagName](n, r, o);
  }
}
const bn = _o({
  body: Ii,
  caption: Tt,
  colgroup: Tt,
  dd: $i,
  dt: Pi,
  head: Tt,
  html: Ri,
  li: Li,
  optgroup: Ti,
  option: Mi,
  p: Ni,
  rp: Qn,
  rt: Qn,
  tbody: Di,
  td: er,
  tfoot: Gi,
  th: er,
  thead: Oi,
  tr: Fi
});
function Tt(t, e, n) {
  const r = O(n, e, !0);
  return !r || r.type !== "comment" && !(r.type === "text" && Ct(r.value.charAt(0)));
}
function Ri(t, e, n) {
  const r = O(n, e);
  return !r || r.type !== "comment";
}
function Ii(t, e, n) {
  const r = O(n, e);
  return !r || r.type !== "comment";
}
function Ni(t, e, n) {
  const r = O(n, e);
  return r ? r.type === "element" && (r.tagName === "address" || r.tagName === "article" || r.tagName === "aside" || r.tagName === "blockquote" || r.tagName === "details" || r.tagName === "div" || r.tagName === "dl" || r.tagName === "fieldset" || r.tagName === "figcaption" || r.tagName === "figure" || r.tagName === "footer" || r.tagName === "form" || r.tagName === "h1" || r.tagName === "h2" || r.tagName === "h3" || r.tagName === "h4" || r.tagName === "h5" || r.tagName === "h6" || r.tagName === "header" || r.tagName === "hgroup" || r.tagName === "hr" || r.tagName === "main" || r.tagName === "menu" || r.tagName === "nav" || r.tagName === "ol" || r.tagName === "p" || r.tagName === "pre" || r.tagName === "section" || r.tagName === "table" || r.tagName === "ul") : !n || // Confusing parent.
  !(n.type === "element" && (n.tagName === "a" || n.tagName === "audio" || n.tagName === "del" || n.tagName === "ins" || n.tagName === "map" || n.tagName === "noscript" || n.tagName === "video"));
}
function Li(t, e, n) {
  const r = O(n, e);
  return !r || r.type === "element" && r.tagName === "li";
}
function Pi(t, e, n) {
  const r = O(n, e);
  return !!(r && r.type === "element" && (r.tagName === "dt" || r.tagName === "dd"));
}
function $i(t, e, n) {
  const r = O(n, e);
  return !r || r.type === "element" && (r.tagName === "dt" || r.tagName === "dd");
}
function Qn(t, e, n) {
  const r = O(n, e);
  return !r || r.type === "element" && (r.tagName === "rp" || r.tagName === "rt");
}
function Ti(t, e, n) {
  const r = O(n, e);
  return !r || r.type === "element" && r.tagName === "optgroup";
}
function Mi(t, e, n) {
  const r = O(n, e);
  return !r || r.type === "element" && (r.tagName === "option" || r.tagName === "optgroup");
}
function Oi(t, e, n) {
  const r = O(n, e);
  return !!(r && r.type === "element" && (r.tagName === "tbody" || r.tagName === "tfoot"));
}
function Di(t, e, n) {
  const r = O(n, e);
  return !r || r.type === "element" && (r.tagName === "tbody" || r.tagName === "tfoot");
}
function Gi(t, e, n) {
  return !O(n, e);
}
function Fi(t, e, n) {
  const r = O(n, e);
  return !r || r.type === "element" && r.tagName === "tr";
}
function er(t, e, n) {
  const r = O(n, e);
  return !r || r.type === "element" && (r.tagName === "td" || r.tagName === "th");
}
const Bi = _o({
  body: zi,
  colgroup: Hi,
  head: Ui,
  html: ji,
  tbody: Wi
});
function ji(t) {
  const e = O(t, -1);
  return !e || e.type !== "comment";
}
function Ui(t) {
  const e = /* @__PURE__ */ new Set();
  for (const r of t.children)
    if (r.type === "element" && (r.tagName === "base" || r.tagName === "title")) {
      if (e.has(r.tagName)) return !1;
      e.add(r.tagName);
    }
  const n = t.children[0];
  return !n || n.type === "element";
}
function zi(t) {
  const e = O(t, -1, !0);
  return !e || e.type !== "comment" && !(e.type === "text" && Ct(e.value.charAt(0))) && !(e.type === "element" && (e.tagName === "meta" || e.tagName === "link" || e.tagName === "script" || e.tagName === "style" || e.tagName === "template"));
}
function Hi(t, e, n) {
  const r = wo(n, e), o = O(t, -1, !0);
  return n && r && r.type === "element" && r.tagName === "colgroup" && bn(r, n.children.indexOf(r), n) ? !1 : !!(o && o.type === "element" && o.tagName === "col");
}
function Wi(t, e, n) {
  const r = wo(n, e), o = O(t, -1);
  return n && r && r.type === "element" && (r.tagName === "thead" || r.tagName === "tbody") && bn(r, n.children.indexOf(r), n) ? !1 : !!(o && o.type === "element" && o.tagName === "tr");
}
const Qe = {
  // See: <https://html.spec.whatwg.org/#attribute-name-state>.
  name: [
    [`	
\f\r &/=>`.split(""), `	
\f\r "&'/=>\``.split("")],
    [`\0	
\f\r "&'/<=>`.split(""), `\0	
\f\r "&'/<=>\``.split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(unquoted)-state>.
  unquoted: [
    [`	
\f\r &>`.split(""), `\0	
\f\r "&'<=>\``.split("")],
    [`\0	
\f\r "&'<=>\``.split(""), `\0	
\f\r "&'<=>\``.split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(single-quoted)-state>.
  single: [
    ["&'".split(""), "\"&'`".split("")],
    ["\0&'".split(""), "\0\"&'`".split("")]
  ],
  // See: <https://html.spec.whatwg.org/#attribute-value-(double-quoted)-state>.
  double: [
    ['"&'.split(""), "\"&'`".split("")],
    ['\0"&'.split(""), "\0\"&'`".split("")]
  ]
};
function Vi(t, e, n, r) {
  const o = r.schema, s = o.space === "svg" ? !1 : r.settings.omitOptionalTags;
  let a = o.space === "svg" ? r.settings.closeEmptyElements : r.settings.voids.includes(t.tagName.toLowerCase());
  const i = [];
  let l;
  o.space === "html" && t.tagName === "svg" && (r.schema = yo);
  const u = qi(r, t.properties), c = r.all(
    o.space === "html" && t.tagName === "template" ? t.content : t
  );
  return r.schema = o, c && (a = !1), (u || !s || !Bi(t, e, n)) && (i.push("<", t.tagName, u ? " " + u : ""), a && (o.space === "svg" || r.settings.closeSelfClosing) && (l = u.charAt(u.length - 1), (!r.settings.tightSelfClosing || l === "/" || l && l !== '"' && l !== "'") && i.push(" "), i.push("/")), i.push(">")), i.push(c), !a && (!s || !bn(t, e, n)) && i.push("</" + t.tagName + ">"), i.join("");
}
function qi(t, e) {
  const n = [];
  let r = -1, o;
  if (e) {
    for (o in e)
      if (e[o] !== null && e[o] !== void 0) {
        const s = Xi(t, o, e[o]);
        s && n.push(s);
      }
  }
  for (; ++r < n.length; ) {
    const s = t.settings.tightAttributes ? n[r].charAt(n[r].length - 1) : void 0;
    r !== n.length - 1 && s !== '"' && s !== "'" && (n[r] += " ");
  }
  return n.join("");
}
function Xi(t, e, n) {
  const r = ti(t.schema, e), o = t.settings.allowParseErrors && t.schema.space === "html" ? 0 : 1, s = t.settings.allowDangerousCharacters ? 0 : 1;
  let a = t.quote, i;
  if (r.overloadedBoolean && (n === r.attribute || n === "") ? n = !0 : (r.boolean || r.overloadedBoolean) && (typeof n != "string" || n === r.attribute || n === "") && (n = !!n), n == null || n === !1 || typeof n == "number" && Number.isNaN(n))
    return "";
  const l = Ae(
    r.attribute,
    Object.assign({}, t.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: Qe.name[o][s]
    })
  );
  return n === !0 || (n = Array.isArray(n) ? (r.commaSeparated ? Ir : Gr)(n, {
    padLeft: !t.settings.tightCommaSeparatedLists
  }) : String(n), t.settings.collapseEmptyAttributes && !n) ? l : (t.settings.preferUnquoted && (i = Ae(
    n,
    Object.assign({}, t.settings.characterReferences, {
      attribute: !0,
      subset: Qe.unquoted[o][s]
    })
  )), i !== n && (t.settings.quoteSmart && jn(n, a) > jn(n, t.alternative) && (a = t.alternative), i = a + Ae(
    n,
    Object.assign({}, t.settings.characterReferences, {
      // Always encode without parse errors in non-HTML.
      subset: (a === "'" ? Qe.single : Qe.double)[o][s],
      attribute: !0
    })
  ) + a), l + (i && "=" + i));
}
const Ki = ["<", "&"];
function So(t, e, n, r) {
  return n && n.type === "element" && (n.tagName === "script" || n.tagName === "style") ? t.value : Ae(
    t.value,
    Object.assign({}, r.settings.characterReferences, {
      subset: Ki
    })
  );
}
function Yi(t, e, n, r) {
  return r.settings.allowDangerousHtml ? t.value : So(t, e, n, r);
}
function Ji(t, e, n, r) {
  return r.all(t);
}
const Zi = la("type", {
  invalid: Qi,
  unknown: el,
  handlers: { comment: vi, doctype: xi, element: Vi, raw: Yi, root: Ji, text: So }
});
function Qi(t) {
  throw new Error("Expected node, not `" + t + "`");
}
function el(t) {
  const e = (
    /** @type {Nodes} */
    t
  );
  throw new Error("Cannot compile unknown node `" + e.type + "`");
}
const tl = {}, nl = {}, rl = [];
function ol(t, e) {
  const n = e || tl, r = n.quote || '"', o = r === '"' ? "'" : '"';
  if (r !== '"' && r !== "'")
    throw new Error("Invalid quote `" + r + "`, expected `'` or `\"`");
  return {
    one: sl,
    all: al,
    settings: {
      omitOptionalTags: n.omitOptionalTags || !1,
      allowParseErrors: n.allowParseErrors || !1,
      allowDangerousCharacters: n.allowDangerousCharacters || !1,
      quoteSmart: n.quoteSmart || !1,
      preferUnquoted: n.preferUnquoted || !1,
      tightAttributes: n.tightAttributes || !1,
      upperDoctype: n.upperDoctype || !1,
      tightDoctype: n.tightDoctype || !1,
      bogusComments: n.bogusComments || !1,
      tightCommaSeparatedLists: n.tightCommaSeparatedLists || !1,
      tightSelfClosing: n.tightSelfClosing || !1,
      collapseEmptyAttributes: n.collapseEmptyAttributes || !1,
      allowDangerousHtml: n.allowDangerousHtml || !1,
      voids: n.voids || ua,
      characterReferences: n.characterReferences || nl,
      closeSelfClosing: n.closeSelfClosing || !1,
      closeEmptyElements: n.closeEmptyElements || !1
    },
    schema: n.space === "svg" ? yo : oi,
    quote: r,
    alternative: o
  }.one(
    Array.isArray(t) ? { type: "root", children: t } : t,
    void 0,
    void 0
  );
}
function sl(t, e, n) {
  return Zi(t, e, n, this);
}
function al(t) {
  const e = [], n = t && t.children || rl;
  let r = -1;
  for (; ++r < n.length; )
    e[r] = this.one(n[r], r, t);
  return e.join("");
}
function ft(t, e) {
  const n = typeof t == "string" ? {} : { ...t.colorReplacements }, r = typeof t == "string" ? t : t.name;
  for (const [o, s] of Object.entries(e?.colorReplacements || {}))
    typeof s == "string" ? n[o] = s : o === r && Object.assign(n, s);
  return n;
}
function ue(t, e) {
  return t && (e?.[t?.toLowerCase()] || t);
}
function il(t) {
  return Array.isArray(t) ? t : [t];
}
async function ko(t) {
  return Promise.resolve(typeof t == "function" ? t() : t).then((e) => e.default || e);
}
function wn(t) {
  return !t || ["plaintext", "txt", "text", "plain"].includes(t);
}
function vo(t) {
  return t === "ansi" || wn(t);
}
function Cn(t) {
  return t === "none";
}
function ll(t) {
  return Cn(t);
}
function xo(t, e) {
  if (!e)
    return t;
  t.properties ||= {}, t.properties.class ||= [], typeof t.properties.class == "string" && (t.properties.class = t.properties.class.split(/\s+/g)), Array.isArray(t.properties.class) || (t.properties.class = []);
  const n = Array.isArray(e) ? e : e.split(/\s+/g);
  for (const r of n)
    r && !t.properties.class.includes(r) && t.properties.class.push(r);
  return t;
}
function St(t, e = !1) {
  const n = t.split(/(\r?\n)/g);
  let r = 0;
  const o = [];
  for (let s = 0; s < n.length; s += 2) {
    const a = e ? n[s] + (n[s + 1] || "") : n[s];
    o.push([a, r]), r += n[s].length, r += n[s + 1]?.length || 0;
  }
  return o;
}
function ul(t) {
  const e = St(t, !0).map(([o]) => o);
  function n(o) {
    if (o === t.length)
      return {
        line: e.length - 1,
        character: e[e.length - 1].length
      };
    let s = o, a = 0;
    for (const i of e) {
      if (s < i.length)
        break;
      s -= i.length, a++;
    }
    return { line: a, character: s };
  }
  function r(o, s) {
    let a = 0;
    for (let i = 0; i < o; i++)
      a += e[i].length;
    return a += s, a;
  }
  return {
    lines: e,
    indexToPos: n,
    posToIndex: r
  };
}
const _n = "light-dark()", cl = ["color", "background-color"];
function hl(t, e) {
  let n = 0;
  const r = [];
  for (const o of e)
    o > n && r.push({
      ...t,
      content: t.content.slice(n, o),
      offset: t.offset + n
    }), n = o;
  return n < t.content.length && r.push({
    ...t,
    content: t.content.slice(n),
    offset: t.offset + n
  }), r;
}
function fl(t, e) {
  const n = Array.from(e instanceof Set ? e : new Set(e)).sort((r, o) => r - o);
  return n.length ? t.map((r) => r.flatMap((o) => {
    const s = n.filter((a) => o.offset < a && a < o.offset + o.content.length).map((a) => a - o.offset).sort((a, i) => a - i);
    return s.length ? hl(o, s) : o;
  })) : t;
}
function pl(t, e, n, r, o = "css-vars") {
  const s = {
    content: t.content,
    explanation: t.explanation,
    offset: t.offset
  }, a = e.map((c) => pt(t.variants[c])), i = new Set(a.flatMap((c) => Object.keys(c))), l = {}, u = (c, h) => {
    const p = h === "color" ? "" : h === "background-color" ? "-bg" : `-${h}`;
    return n + e[c] + (h === "color" ? "" : p);
  };
  return a.forEach((c, h) => {
    for (const p of i) {
      const d = c[p] || "inherit";
      if (h === 0 && r && cl.includes(p))
        if (r === _n && a.length > 1) {
          const f = e.findIndex((m) => m === "light"), g = e.findIndex((m) => m === "dark");
          if (f === -1 || g === -1)
            throw new F('When using `defaultColor: "light-dark()"`, you must provide both `light` and `dark` themes');
          const C = a[f][p] || "inherit", y = a[g][p] || "inherit";
          l[p] = `light-dark(${C}, ${y})`, o === "css-vars" && (l[u(h, p)] = d);
        } else
          l[p] = d;
      else
        o === "css-vars" && (l[u(h, p)] = d);
    }
  }), s.htmlStyle = l, s;
}
function pt(t) {
  const e = {};
  if (t.color && (e.color = t.color), t.bgColor && (e["background-color"] = t.bgColor), t.fontStyle) {
    t.fontStyle & z.Italic && (e["font-style"] = "italic"), t.fontStyle & z.Bold && (e["font-weight"] = "bold");
    const n = [];
    t.fontStyle & z.Underline && n.push("underline"), t.fontStyle & z.Strikethrough && n.push("line-through"), n.length && (e["text-decoration"] = n.join(" "));
  }
  return e;
}
function rn(t) {
  return typeof t == "string" ? t : Object.entries(t).map(([e, n]) => `${e}:${n}`).join(";");
}
const Eo = /* @__PURE__ */ new WeakMap();
function kt(t, e) {
  Eo.set(t, e);
}
function We(t) {
  return Eo.get(t);
}
class Le {
  /**
   * Theme to Stack mapping
   */
  _stacks = {};
  lang;
  get themes() {
    return Object.keys(this._stacks);
  }
  get theme() {
    return this.themes[0];
  }
  get _stack() {
    return this._stacks[this.theme];
  }
  /**
   * Static method to create a initial grammar state.
   */
  static initial(e, n) {
    return new Le(
      Object.fromEntries(il(n).map((r) => [r, Zt])),
      e
    );
  }
  constructor(...e) {
    if (e.length === 2) {
      const [n, r] = e;
      this.lang = r, this._stacks = n;
    } else {
      const [n, r, o] = e;
      this.lang = r, this._stacks = { [o]: n };
    }
  }
  /**
   * Get the internal stack object.
   * @internal
   */
  getInternalStack(e = this.theme) {
    return this._stacks[e];
  }
  getScopes(e = this.theme) {
    return dl(this._stacks[e]);
  }
  toJSON() {
    return {
      lang: this.lang,
      theme: this.theme,
      themes: this.themes,
      scopes: this.getScopes()
    };
  }
}
function dl(t) {
  const e = [], n = /* @__PURE__ */ new Set();
  function r(o) {
    if (n.has(o))
      return;
    n.add(o);
    const s = o?.nameScopesList?.scopeName;
    s && e.push(s), o.parent && r(o.parent);
  }
  return r(t), e;
}
function gl(t, e) {
  if (!(t instanceof Le))
    throw new F("Invalid grammar state");
  return t.getInternalStack(e);
}
function ml() {
  const t = /* @__PURE__ */ new WeakMap();
  function e(n) {
    if (!t.has(n.meta)) {
      let r = function(a) {
        if (typeof a == "number") {
          if (a < 0 || a > n.source.length)
            throw new F(`Invalid decoration offset: ${a}. Code length: ${n.source.length}`);
          return {
            ...o.indexToPos(a),
            offset: a
          };
        } else {
          const i = o.lines[a.line];
          if (i === void 0)
            throw new F(`Invalid decoration position ${JSON.stringify(a)}. Lines length: ${o.lines.length}`);
          let l = a.character;
          if (l < 0 && (l = i.length + l), l < 0 || l > i.length)
            throw new F(`Invalid decoration position ${JSON.stringify(a)}. Line ${a.line} length: ${i.length}`);
          return {
            ...a,
            character: l,
            offset: o.posToIndex(a.line, l)
          };
        }
      };
      const o = ul(n.source), s = (n.options.decorations || []).map((a) => ({
        ...a,
        start: r(a.start),
        end: r(a.end)
      }));
      yl(s), t.set(n.meta, {
        decorations: s,
        converter: o,
        source: n.source
      });
    }
    return t.get(n.meta);
  }
  return {
    name: "shiki:decorations",
    tokens(n) {
      if (!this.options.decorations?.length)
        return;
      const o = e(this).decorations.flatMap((a) => [a.start.offset, a.end.offset]);
      return fl(n, o);
    },
    code(n) {
      if (!this.options.decorations?.length)
        return;
      const r = e(this), o = Array.from(n.children).filter((c) => c.type === "element" && c.tagName === "span");
      if (o.length !== r.converter.lines.length)
        throw new F(`Number of lines in code element (${o.length}) does not match the number of lines in the source (${r.converter.lines.length}). Failed to apply decorations.`);
      function s(c, h, p, d) {
        const f = o[c];
        let g = "", C = -1, y = -1;
        if (h === 0 && (C = 0), p === 0 && (y = 0), p === Number.POSITIVE_INFINITY && (y = f.children.length), C === -1 || y === -1)
          for (let _ = 0; _ < f.children.length; _++)
            g += Ao(f.children[_]), C === -1 && g.length === h && (C = _ + 1), y === -1 && g.length === p && (y = _ + 1);
        if (C === -1)
          throw new F(`Failed to find start index for decoration ${JSON.stringify(d.start)}`);
        if (y === -1)
          throw new F(`Failed to find end index for decoration ${JSON.stringify(d.end)}`);
        const m = f.children.slice(C, y);
        if (!d.alwaysWrap && m.length === f.children.length)
          i(f, d, "line");
        else if (!d.alwaysWrap && m.length === 1 && m[0].type === "element")
          i(m[0], d, "token");
        else {
          const _ = {
            type: "element",
            tagName: "span",
            properties: {},
            children: m
          };
          i(_, d, "wrapper"), f.children.splice(C, m.length, _);
        }
      }
      function a(c, h) {
        o[c] = i(o[c], h, "line");
      }
      function i(c, h, p) {
        const d = h.properties || {}, f = h.transform || ((g) => g);
        return c.tagName = h.tagName || "span", c.properties = {
          ...c.properties,
          ...d,
          class: c.properties.class
        }, h.properties?.class && xo(c, h.properties.class), c = f(c, p) || c, c;
      }
      const l = [], u = r.decorations.sort((c, h) => h.start.offset - c.start.offset || c.end.offset - h.end.offset);
      for (const c of u) {
        const { start: h, end: p } = c;
        if (h.line === p.line)
          s(h.line, h.character, p.character, c);
        else if (h.line < p.line) {
          s(h.line, h.character, Number.POSITIVE_INFINITY, c);
          for (let d = h.line + 1; d < p.line; d++)
            l.unshift(() => a(d, c));
          s(p.line, 0, p.character, c);
        }
      }
      l.forEach((c) => c());
    }
  };
}
function yl(t) {
  for (let e = 0; e < t.length; e++) {
    const n = t[e];
    if (n.start.offset > n.end.offset)
      throw new F(`Invalid decoration range: ${JSON.stringify(n.start)} - ${JSON.stringify(n.end)}`);
    for (let r = e + 1; r < t.length; r++) {
      const o = t[r], s = n.start.offset <= o.start.offset && o.start.offset < n.end.offset, a = n.start.offset < o.end.offset && o.end.offset <= n.end.offset, i = o.start.offset <= n.start.offset && n.start.offset < o.end.offset, l = o.start.offset < n.end.offset && n.end.offset <= o.end.offset;
      if (s || a || i || l) {
        if (s && a || i && l || i && n.start.offset === n.end.offset || a && o.start.offset === o.end.offset)
          continue;
        throw new F(`Decorations ${JSON.stringify(n.start)} and ${JSON.stringify(o.start)} intersect.`);
      }
    }
  }
}
function Ao(t) {
  return t.type === "text" ? t.value : t.type === "element" ? t.children.map(Ao).join("") : "";
}
const bl = [
  /* @__PURE__ */ ml()
];
function dt(t) {
  const e = wl(t.transformers || []);
  return [
    ...e.pre,
    ...e.normal,
    ...e.post,
    ...bl
  ];
}
function wl(t) {
  const e = [], n = [], r = [];
  for (const o of t)
    switch (o.enforce) {
      case "pre":
        e.push(o);
        break;
      case "post":
        n.push(o);
        break;
      default:
        r.push(o);
    }
  return { pre: e, post: n, normal: r };
}
var de = [
  "black",
  "red",
  "green",
  "yellow",
  "blue",
  "magenta",
  "cyan",
  "white",
  "brightBlack",
  "brightRed",
  "brightGreen",
  "brightYellow",
  "brightBlue",
  "brightMagenta",
  "brightCyan",
  "brightWhite"
], Mt = {
  1: "bold",
  2: "dim",
  3: "italic",
  4: "underline",
  7: "reverse",
  8: "hidden",
  9: "strikethrough"
};
function Cl(t, e) {
  const n = t.indexOf("\x1B", e);
  if (n !== -1 && t[n + 1] === "[") {
    const r = t.indexOf("m", n);
    if (r !== -1)
      return {
        sequence: t.substring(n + 2, r).split(";"),
        startPosition: n,
        position: r + 1
      };
  }
  return {
    position: t.length
  };
}
function tr(t) {
  const e = t.shift();
  if (e === "2") {
    const n = t.splice(0, 3).map((r) => Number.parseInt(r));
    return n.length !== 3 || n.some((r) => Number.isNaN(r)) ? void 0 : {
      type: "rgb",
      rgb: n
    };
  } else if (e === "5") {
    const n = t.shift();
    if (n)
      return { type: "table", index: Number(n) };
  }
}
function _l(t) {
  const e = [];
  for (; t.length > 0; ) {
    const n = t.shift();
    if (!n)
      continue;
    const r = Number.parseInt(n);
    if (!Number.isNaN(r))
      if (r === 0)
        e.push({ type: "resetAll" });
      else if (r <= 9)
        Mt[r] && e.push({
          type: "setDecoration",
          value: Mt[r]
        });
      else if (r <= 29) {
        const o = Mt[r - 20];
        o && (e.push({
          type: "resetDecoration",
          value: o
        }), o === "dim" && e.push({
          type: "resetDecoration",
          value: "bold"
        }));
      } else if (r <= 37)
        e.push({
          type: "setForegroundColor",
          value: { type: "named", name: de[r - 30] }
        });
      else if (r === 38) {
        const o = tr(t);
        o && e.push({
          type: "setForegroundColor",
          value: o
        });
      } else if (r === 39)
        e.push({
          type: "resetForegroundColor"
        });
      else if (r <= 47)
        e.push({
          type: "setBackgroundColor",
          value: { type: "named", name: de[r - 40] }
        });
      else if (r === 48) {
        const o = tr(t);
        o && e.push({
          type: "setBackgroundColor",
          value: o
        });
      } else r === 49 ? e.push({
        type: "resetBackgroundColor"
      }) : r === 53 ? e.push({
        type: "setDecoration",
        value: "overline"
      }) : r === 55 ? e.push({
        type: "resetDecoration",
        value: "overline"
      }) : r >= 90 && r <= 97 ? e.push({
        type: "setForegroundColor",
        value: { type: "named", name: de[r - 90 + 8] }
      }) : r >= 100 && r <= 107 && e.push({
        type: "setBackgroundColor",
        value: { type: "named", name: de[r - 100 + 8] }
      });
  }
  return e;
}
function Sl() {
  let t = null, e = null, n = /* @__PURE__ */ new Set();
  return {
    parse(r) {
      const o = [];
      let s = 0;
      do {
        const a = Cl(r, s), i = a.sequence ? r.substring(s, a.startPosition) : r.substring(s);
        if (i.length > 0 && o.push({
          value: i,
          foreground: t,
          background: e,
          decorations: new Set(n)
        }), a.sequence) {
          const l = _l(a.sequence);
          for (const u of l)
            u.type === "resetAll" ? (t = null, e = null, n.clear()) : u.type === "resetForegroundColor" ? t = null : u.type === "resetBackgroundColor" ? e = null : u.type === "resetDecoration" && n.delete(u.value);
          for (const u of l)
            u.type === "setForegroundColor" ? t = u.value : u.type === "setBackgroundColor" ? e = u.value : u.type === "setDecoration" && n.add(u.value);
        }
        s = a.position;
      } while (s < r.length);
      return o;
    }
  };
}
var kl = {
  black: "#000000",
  red: "#bb0000",
  green: "#00bb00",
  yellow: "#bbbb00",
  blue: "#0000bb",
  magenta: "#ff00ff",
  cyan: "#00bbbb",
  white: "#eeeeee",
  brightBlack: "#555555",
  brightRed: "#ff5555",
  brightGreen: "#00ff00",
  brightYellow: "#ffff55",
  brightBlue: "#5555ff",
  brightMagenta: "#ff55ff",
  brightCyan: "#55ffff",
  brightWhite: "#ffffff"
};
function vl(t = kl) {
  function e(i) {
    return t[i];
  }
  function n(i) {
    return `#${i.map((l) => Math.max(0, Math.min(l, 255)).toString(16).padStart(2, "0")).join("")}`;
  }
  let r;
  function o() {
    if (r)
      return r;
    r = [];
    for (let u = 0; u < de.length; u++)
      r.push(e(de[u]));
    let i = [0, 95, 135, 175, 215, 255];
    for (let u = 0; u < 6; u++)
      for (let c = 0; c < 6; c++)
        for (let h = 0; h < 6; h++)
          r.push(n([i[u], i[c], i[h]]));
    let l = 8;
    for (let u = 0; u < 24; u++, l += 10)
      r.push(n([l, l, l]));
    return r;
  }
  function s(i) {
    return o()[i];
  }
  function a(i) {
    switch (i.type) {
      case "named":
        return e(i.name);
      case "rgb":
        return n(i.rgb);
      case "table":
        return s(i.index);
    }
  }
  return {
    value: a
  };
}
function xl(t, e, n) {
  const r = ft(t, n), o = St(e), s = vl(
    Object.fromEntries(
      de.map((i) => [
        i,
        t.colors?.[`terminal.ansi${i[0].toUpperCase()}${i.substring(1)}`]
      ])
    )
  ), a = Sl();
  return o.map(
    (i) => a.parse(i[0]).map((l) => {
      let u, c;
      l.decorations.has("reverse") ? (u = l.background ? s.value(l.background) : t.bg, c = l.foreground ? s.value(l.foreground) : t.fg) : (u = l.foreground ? s.value(l.foreground) : t.fg, c = l.background ? s.value(l.background) : void 0), u = ue(u, r), c = ue(c, r), l.decorations.has("dim") && (u = El(u));
      let h = z.None;
      return l.decorations.has("bold") && (h |= z.Bold), l.decorations.has("italic") && (h |= z.Italic), l.decorations.has("underline") && (h |= z.Underline), l.decorations.has("strikethrough") && (h |= z.Strikethrough), {
        content: l.value,
        offset: i[1],
        // TODO: more accurate offset? might need to fork ansi-sequence-parser
        color: u,
        bgColor: c,
        fontStyle: h
      };
    })
  );
}
function El(t) {
  const e = t.match(/#([0-9a-f]{3})([0-9a-f]{3})?([0-9a-f]{2})?/);
  if (e)
    if (e[3]) {
      const r = Math.round(Number.parseInt(e[3], 16) / 2).toString(16).padStart(2, "0");
      return `#${e[1]}${e[2]}${r}`;
    } else return e[2] ? `#${e[1]}${e[2]}80` : `#${Array.from(e[1]).map((r) => `${r}${r}`).join("")}80`;
  const n = t.match(/var\((--[\w-]+-ansi-[\w-]+)\)/);
  return n ? `var(${n[1]}-dim)` : t;
}
function Sn(t, e, n = {}) {
  const {
    lang: r = "text",
    theme: o = t.getLoadedThemes()[0]
  } = n;
  if (wn(r) || Cn(o))
    return St(e).map((l) => [{ content: l[0], offset: l[1] }]);
  const { theme: s, colorMap: a } = t.setTheme(o);
  if (r === "ansi")
    return xl(s, e, n);
  const i = t.getLanguage(r);
  if (n.grammarState) {
    if (n.grammarState.lang !== i.name)
      throw new F(`Grammar state language "${n.grammarState.lang}" does not match highlight language "${i.name}"`);
    if (!n.grammarState.themes.includes(s.name))
      throw new F(`Grammar state themes "${n.grammarState.themes}" do not contain highlight theme "${s.name}"`);
  }
  return Rl(e, i, s, a, n);
}
function Al(...t) {
  if (t.length === 2)
    return We(t[1]);
  const [e, n, r = {}] = t, {
    lang: o = "text",
    theme: s = e.getLoadedThemes()[0]
  } = r;
  if (wn(o) || Cn(s))
    throw new F("Plain language does not have grammar state");
  if (o === "ansi")
    throw new F("ANSI language does not have grammar state");
  const { theme: a, colorMap: i } = e.setTheme(s), l = e.getLanguage(o);
  return new Le(
    gt(n, l, a, i, r).stateStack,
    l.name,
    a.name
  );
}
function Rl(t, e, n, r, o) {
  const s = gt(t, e, n, r, o), a = new Le(
    gt(t, e, n, r, o).stateStack,
    e.name,
    n.name
  );
  return kt(s.tokens, a), s.tokens;
}
function gt(t, e, n, r, o) {
  const s = ft(n, o), {
    tokenizeMaxLineLength: a = 0,
    tokenizeTimeLimit: i = 500
  } = o, l = St(t);
  let u = o.grammarState ? gl(o.grammarState, n.name) ?? Zt : o.grammarContextCode != null ? gt(
    o.grammarContextCode,
    e,
    n,
    r,
    {
      ...o,
      grammarState: void 0,
      grammarContextCode: void 0
    }
  ).stateStack : Zt, c = [];
  const h = [];
  for (let p = 0, d = l.length; p < d; p++) {
    const [f, g] = l[p];
    if (f === "") {
      c = [], h.push([]);
      continue;
    }
    if (a > 0 && f.length >= a) {
      c = [], h.push([{
        content: f,
        offset: g,
        color: "",
        fontStyle: 0
      }]);
      continue;
    }
    let C, y, m;
    o.includeExplanation && (C = e.tokenizeLine(f, u, i), y = C.tokens, m = 0);
    const _ = e.tokenizeLine2(f, u, i), S = _.tokens.length / 2;
    for (let A = 0; A < S; A++) {
      const D = _.tokens[2 * A], L = A + 1 < S ? _.tokens[2 * A + 2] : f.length;
      if (D === L)
        continue;
      const j = _.tokens[2 * A + 1], Z = ue(
        r[Re.getForeground(j)],
        s
      ), ee = Re.getFontStyle(j), ce = {
        content: f.substring(D, L),
        offset: g + D,
        color: Z,
        fontStyle: ee
      };
      if (o.includeExplanation) {
        const te = [];
        if (o.includeExplanation !== "scopeName")
          for (const k of n.settings) {
            let G;
            switch (typeof k.scope) {
              case "string":
                G = k.scope.split(/,/).map((Te) => Te.trim());
                break;
              case "object":
                G = k.scope;
                break;
              default:
                continue;
            }
            te.push({
              settings: k,
              selectors: G.map((Te) => Te.split(/ /))
            });
          }
        ce.explanation = [];
        let R = 0;
        for (; D + R < L; ) {
          const k = y[m], G = f.substring(
            k.startIndex,
            k.endIndex
          );
          R += G.length, ce.explanation.push({
            content: G,
            scopes: o.includeExplanation === "scopeName" ? Il(
              k.scopes
            ) : Nl(
              te,
              k.scopes
            )
          }), m += 1;
        }
      }
      c.push(ce);
    }
    h.push(c), c = [], u = _.ruleStack;
  }
  return {
    tokens: h,
    stateStack: u
  };
}
function Il(t) {
  return t.map((e) => ({ scopeName: e }));
}
function Nl(t, e) {
  const n = [];
  for (let r = 0, o = e.length; r < o; r++) {
    const s = e[r];
    n[r] = {
      scopeName: s,
      themeMatches: Pl(t, s, e.slice(0, r))
    };
  }
  return n;
}
function nr(t, e) {
  return t === e || e.substring(0, t.length) === t && e[t.length] === ".";
}
function Ll(t, e, n) {
  if (!nr(t[t.length - 1], e))
    return !1;
  let r = t.length - 2, o = n.length - 1;
  for (; r >= 0 && o >= 0; )
    nr(t[r], n[o]) && (r -= 1), o -= 1;
  return r === -1;
}
function Pl(t, e, n) {
  const r = [];
  for (const { selectors: o, settings: s } of t)
    for (const a of o)
      if (Ll(a, e, n)) {
        r.push(s);
        break;
      }
  return r;
}
function Ro(t, e, n) {
  const r = Object.entries(n.themes).filter((l) => l[1]).map((l) => ({ color: l[0], theme: l[1] })), o = r.map((l) => {
    const u = Sn(t, e, {
      ...n,
      theme: l.theme
    }), c = We(u), h = typeof l.theme == "string" ? l.theme : l.theme.name;
    return {
      tokens: u,
      state: c,
      theme: h
    };
  }), s = $l(
    ...o.map((l) => l.tokens)
  ), a = s[0].map(
    (l, u) => l.map((c, h) => {
      const p = {
        content: c.content,
        variants: {},
        offset: c.offset
      };
      return "includeExplanation" in n && n.includeExplanation && (p.explanation = c.explanation), s.forEach((d, f) => {
        const {
          content: g,
          explanation: C,
          offset: y,
          ...m
        } = d[u][h];
        p.variants[r[f].color] = m;
      }), p;
    })
  ), i = o[0].state ? new Le(
    Object.fromEntries(o.map((l) => [l.theme, l.state?.getInternalStack(l.theme)])),
    o[0].state.lang
  ) : void 0;
  return i && kt(a, i), a;
}
function $l(...t) {
  const e = t.map(() => []), n = t.length;
  for (let r = 0; r < t[0].length; r++) {
    const o = t.map((l) => l[r]), s = e.map(() => []);
    e.forEach((l, u) => l.push(s[u]));
    const a = o.map(() => 0), i = o.map((l) => l[0]);
    for (; i.every((l) => l); ) {
      const l = Math.min(...i.map((u) => u.content.length));
      for (let u = 0; u < n; u++) {
        const c = i[u];
        c.content.length === l ? (s[u].push(c), a[u] += 1, i[u] = o[u][a[u]]) : (s[u].push({
          ...c,
          content: c.content.slice(0, l)
        }), i[u] = {
          ...c,
          content: c.content.slice(l),
          offset: c.offset + l
        });
      }
    }
  }
  return e;
}
function mt(t, e, n) {
  let r, o, s, a, i, l;
  if ("themes" in n) {
    const {
      defaultColor: u = "light",
      cssVariablePrefix: c = "--shiki-",
      colorsRendering: h = "css-vars"
    } = n, p = Object.entries(n.themes).filter((y) => y[1]).map((y) => ({ color: y[0], theme: y[1] })).sort((y, m) => y.color === u ? -1 : m.color === u ? 1 : 0);
    if (p.length === 0)
      throw new F("`themes` option must not be empty");
    const d = Ro(
      t,
      e,
      n
    );
    if (l = We(d), u && _n !== u && !p.find((y) => y.color === u))
      throw new F(`\`themes\` option must contain the defaultColor key \`${u}\``);
    const f = p.map((y) => t.getTheme(y.theme)), g = p.map((y) => y.color);
    s = d.map((y) => y.map((m) => pl(m, g, c, u, h))), l && kt(s, l);
    const C = p.map((y) => ft(y.theme, n));
    o = rr(p, f, C, c, u, "fg", h), r = rr(p, f, C, c, u, "bg", h), a = `shiki-themes ${f.map((y) => y.name).join(" ")}`, i = u ? void 0 : [o, r].join(";");
  } else if ("theme" in n) {
    const u = ft(n.theme, n);
    s = Sn(
      t,
      e,
      n
    );
    const c = t.getTheme(n.theme);
    r = ue(c.bg, u), o = ue(c.fg, u), a = c.name, l = We(s);
  } else
    throw new F("Invalid options, either `theme` or `themes` must be provided");
  return {
    tokens: s,
    fg: o,
    bg: r,
    themeName: a,
    rootStyle: i,
    grammarState: l
  };
}
function rr(t, e, n, r, o, s, a) {
  return t.map((i, l) => {
    const u = ue(e[l][s], n[l]) || "inherit", c = `${r + i.color}${s === "bg" ? "-bg" : ""}:${u}`;
    if (l === 0 && o) {
      if (o === _n && t.length > 1) {
        const h = t.findIndex((g) => g.color === "light"), p = t.findIndex((g) => g.color === "dark");
        if (h === -1 || p === -1)
          throw new F('When using `defaultColor: "light-dark()"`, you must provide both `light` and `dark` themes');
        const d = ue(e[h][s], n[h]) || "inherit", f = ue(e[p][s], n[p]) || "inherit";
        return `light-dark(${d}, ${f});${c}`;
      }
      return u;
    }
    return a === "css-vars" ? c : null;
  }).filter((i) => !!i).join(";");
}
function yt(t, e, n, r = {
  meta: {},
  options: n,
  codeToHast: (o, s) => yt(t, o, s),
  codeToTokens: (o, s) => mt(t, o, s)
}) {
  let o = e;
  for (const f of dt(n))
    o = f.preprocess?.call(r, o, n) || o;
  let {
    tokens: s,
    fg: a,
    bg: i,
    themeName: l,
    rootStyle: u,
    grammarState: c
  } = mt(t, o, n);
  const {
    mergeWhitespaces: h = !0,
    mergeSameStyleTokens: p = !1
  } = n;
  h === !0 ? s = Ml(s) : h === "never" && (s = Ol(s)), p && (s = Dl(s));
  const d = {
    ...r,
    get source() {
      return o;
    }
  };
  for (const f of dt(n))
    s = f.tokens?.call(d, s) || s;
  return Tl(
    s,
    {
      ...n,
      fg: a,
      bg: i,
      themeName: l,
      rootStyle: u
    },
    d,
    c
  );
}
function Tl(t, e, n, r = We(t)) {
  const o = dt(e), s = [], a = {
    type: "root",
    children: []
  }, {
    structure: i = "classic",
    tabindex: l = "0"
  } = e;
  let u = {
    type: "element",
    tagName: "pre",
    properties: {
      class: `shiki ${e.themeName || ""}`,
      style: e.rootStyle || `background-color:${e.bg};color:${e.fg}`,
      ...l !== !1 && l != null ? {
        tabindex: l.toString()
      } : {},
      ...Object.fromEntries(
        Array.from(
          Object.entries(e.meta || {})
        ).filter(([f]) => !f.startsWith("_"))
      )
    },
    children: []
  }, c = {
    type: "element",
    tagName: "code",
    properties: {},
    children: s
  };
  const h = [], p = {
    ...n,
    structure: i,
    addClassToHast: xo,
    get source() {
      return n.source;
    },
    get tokens() {
      return t;
    },
    get options() {
      return e;
    },
    get root() {
      return a;
    },
    get pre() {
      return u;
    },
    get code() {
      return c;
    },
    get lines() {
      return h;
    }
  };
  if (t.forEach((f, g) => {
    g && (i === "inline" ? a.children.push({ type: "element", tagName: "br", properties: {}, children: [] }) : i === "classic" && s.push({ type: "text", value: `
` }));
    let C = {
      type: "element",
      tagName: "span",
      properties: { class: "line" },
      children: []
    }, y = 0;
    for (const m of f) {
      let _ = {
        type: "element",
        tagName: "span",
        properties: {
          ...m.htmlAttrs
        },
        children: [{ type: "text", value: m.content }]
      };
      const S = rn(m.htmlStyle || pt(m));
      S && (_.properties.style = S);
      for (const A of o)
        _ = A?.span?.call(p, _, g + 1, y, C, m) || _;
      i === "inline" ? a.children.push(_) : i === "classic" && C.children.push(_), y += m.content.length;
    }
    if (i === "classic") {
      for (const m of o)
        C = m?.line?.call(p, C, g + 1) || C;
      h.push(C), s.push(C);
    }
  }), i === "classic") {
    for (const f of o)
      c = f?.code?.call(p, c) || c;
    u.children.push(c);
    for (const f of o)
      u = f?.pre?.call(p, u) || u;
    a.children.push(u);
  }
  let d = a;
  for (const f of o)
    d = f?.root?.call(p, d) || d;
  return r && kt(d, r), d;
}
function Ml(t) {
  return t.map((e) => {
    const n = [];
    let r = "", o = 0;
    return e.forEach((s, a) => {
      const l = !(s.fontStyle && (s.fontStyle & z.Underline || s.fontStyle & z.Strikethrough));
      l && s.content.match(/^\s+$/) && e[a + 1] ? (o || (o = s.offset), r += s.content) : r ? (l ? n.push({
        ...s,
        offset: o,
        content: r + s.content
      }) : n.push(
        {
          content: r,
          offset: o
        },
        s
      ), o = 0, r = "") : n.push(s);
    }), n;
  });
}
function Ol(t) {
  return t.map((e) => e.flatMap((n) => {
    if (n.content.match(/^\s+$/))
      return n;
    const r = n.content.match(/^(\s*)(.*?)(\s*)$/);
    if (!r)
      return n;
    const [, o, s, a] = r;
    if (!o && !a)
      return n;
    const i = [{
      ...n,
      offset: n.offset + o.length,
      content: s
    }];
    return o && i.unshift({
      content: o,
      offset: n.offset
    }), a && i.push({
      content: a,
      offset: n.offset + o.length + s.length
    }), i;
  }));
}
function Dl(t) {
  return t.map((e) => {
    const n = [];
    for (const r of e) {
      if (n.length === 0) {
        n.push({ ...r });
        continue;
      }
      const o = n[n.length - 1], s = rn(o.htmlStyle || pt(o)), a = rn(r.htmlStyle || pt(r)), i = o.fontStyle && (o.fontStyle & z.Underline || o.fontStyle & z.Strikethrough), l = r.fontStyle && (r.fontStyle & z.Underline || r.fontStyle & z.Strikethrough);
      !i && !l && s === a ? o.content += r.content : n.push({ ...r });
    }
    return n;
  });
}
const Gl = ol;
function Fl(t, e, n) {
  const r = {
    meta: {},
    options: n,
    codeToHast: (s, a) => yt(t, s, a),
    codeToTokens: (s, a) => mt(t, s, a)
  };
  let o = Gl(yt(t, e, n, r));
  for (const s of dt(n))
    o = s.postprocess?.call(r, o, n) || o;
  return o;
}
const or = { light: "#333333", dark: "#bbbbbb" }, sr = { light: "#fffffe", dark: "#1e1e1e" }, ar = "__shiki_resolved";
function kn(t) {
  if (t?.[ar])
    return t;
  const e = {
    ...t
  };
  e.tokenColors && !e.settings && (e.settings = e.tokenColors, delete e.tokenColors), e.type ||= "dark", e.colorReplacements = { ...e.colorReplacements }, e.settings ||= [];
  let { bg: n, fg: r } = e;
  if (!n || !r) {
    const i = e.settings ? e.settings.find((l) => !l.name && !l.scope) : void 0;
    i?.settings?.foreground && (r = i.settings.foreground), i?.settings?.background && (n = i.settings.background), !r && e?.colors?.["editor.foreground"] && (r = e.colors["editor.foreground"]), !n && e?.colors?.["editor.background"] && (n = e.colors["editor.background"]), r || (r = e.type === "light" ? or.light : or.dark), n || (n = e.type === "light" ? sr.light : sr.dark), e.fg = r, e.bg = n;
  }
  e.settings[0] && e.settings[0].settings && !e.settings[0].scope || e.settings.unshift({
    settings: {
      foreground: e.fg,
      background: e.bg
    }
  });
  let o = 0;
  const s = /* @__PURE__ */ new Map();
  function a(i) {
    if (s.has(i))
      return s.get(i);
    o += 1;
    const l = `#${o.toString(16).padStart(8, "0").toLowerCase()}`;
    return e.colorReplacements?.[`#${l}`] ? a(i) : (s.set(i, l), l);
  }
  e.settings = e.settings.map((i) => {
    const l = i.settings?.foreground && !i.settings.foreground.startsWith("#"), u = i.settings?.background && !i.settings.background.startsWith("#");
    if (!l && !u)
      return i;
    const c = {
      ...i,
      settings: {
        ...i.settings
      }
    };
    if (l) {
      const h = a(i.settings.foreground);
      e.colorReplacements[h] = i.settings.foreground, c.settings.foreground = h;
    }
    if (u) {
      const h = a(i.settings.background);
      e.colorReplacements[h] = i.settings.background, c.settings.background = h;
    }
    return c;
  });
  for (const i of Object.keys(e.colors || {}))
    if ((i === "editor.foreground" || i === "editor.background" || i.startsWith("terminal.ansi")) && !e.colors[i]?.startsWith("#")) {
      const l = a(e.colors[i]);
      e.colorReplacements[l] = e.colors[i], e.colors[i] = l;
    }
  return Object.defineProperty(e, ar, {
    enumerable: !1,
    writable: !1,
    value: !0
  }), e;
}
async function Io(t) {
  return Array.from(new Set((await Promise.all(
    t.filter((e) => !vo(e)).map(async (e) => await ko(e).then((n) => Array.isArray(n) ? n : [n]))
  )).flat()));
}
async function No(t) {
  return (await Promise.all(
    t.map(
      async (n) => ll(n) ? null : kn(await ko(n))
    )
  )).filter((n) => !!n);
}
let Bl = 3;
function jl(t, e = 3) {
  e > Bl || console.trace(`[SHIKI DEPRECATE]: ${t}`);
}
class ve extends Error {
  constructor(e) {
    super(e), this.name = "ShikiError";
  }
}
class Ul extends Ka {
  constructor(e, n, r, o = {}) {
    super(e), this._resolver = e, this._themes = n, this._langs = r, this._alias = o, this._themes.map((s) => this.loadTheme(s)), this.loadLanguages(this._langs);
  }
  _resolvedThemes = /* @__PURE__ */ new Map();
  _resolvedGrammars = /* @__PURE__ */ new Map();
  _langMap = /* @__PURE__ */ new Map();
  _langGraph = /* @__PURE__ */ new Map();
  _textmateThemeCache = /* @__PURE__ */ new WeakMap();
  _loadedThemesCache = null;
  _loadedLanguagesCache = null;
  getTheme(e) {
    return typeof e == "string" ? this._resolvedThemes.get(e) : this.loadTheme(e);
  }
  loadTheme(e) {
    const n = kn(e);
    return n.name && (this._resolvedThemes.set(n.name, n), this._loadedThemesCache = null), n;
  }
  getLoadedThemes() {
    return this._loadedThemesCache || (this._loadedThemesCache = [...this._resolvedThemes.keys()]), this._loadedThemesCache;
  }
  // Override and re-implement this method to cache the textmate themes as `TextMateTheme.createFromRawTheme`
  // is expensive. Themes can switch often especially for dual-theme support.
  //
  // The parent class also accepts `colorMap` as the second parameter, but since we don't use that,
  // we omit here so it's easier to cache the themes.
  setTheme(e) {
    let n = this._textmateThemeCache.get(e);
    n || (n = it.createFromRawTheme(e), this._textmateThemeCache.set(e, n)), this._syncRegistry.setTheme(n);
  }
  getGrammar(e) {
    if (this._alias[e]) {
      const n = /* @__PURE__ */ new Set([e]);
      for (; this._alias[e]; ) {
        if (e = this._alias[e], n.has(e))
          throw new ve(`Circular alias \`${Array.from(n).join(" -> ")} -> ${e}\``);
        n.add(e);
      }
    }
    return this._resolvedGrammars.get(e);
  }
  loadLanguage(e) {
    if (this.getGrammar(e.name))
      return;
    const n = new Set(
      [...this._langMap.values()].filter((s) => s.embeddedLangsLazy?.includes(e.name))
    );
    this._resolver.addLanguage(e);
    const r = {
      balancedBracketSelectors: e.balancedBracketSelectors || ["*"],
      unbalancedBracketSelectors: e.unbalancedBracketSelectors || []
    };
    this._syncRegistry._rawGrammars.set(e.scopeName, e);
    const o = this.loadGrammarWithConfiguration(e.scopeName, 1, r);
    if (o.name = e.name, this._resolvedGrammars.set(e.name, o), e.aliases && e.aliases.forEach((s) => {
      this._alias[s] = e.name;
    }), this._loadedLanguagesCache = null, n.size)
      for (const s of n)
        this._resolvedGrammars.delete(s.name), this._loadedLanguagesCache = null, this._syncRegistry?._injectionGrammars?.delete(s.scopeName), this._syncRegistry?._grammars?.delete(s.scopeName), this.loadLanguage(this._langMap.get(s.name));
  }
  dispose() {
    super.dispose(), this._resolvedThemes.clear(), this._resolvedGrammars.clear(), this._langMap.clear(), this._langGraph.clear(), this._loadedThemesCache = null;
  }
  loadLanguages(e) {
    for (const o of e)
      this.resolveEmbeddedLanguages(o);
    const n = Array.from(this._langGraph.entries()), r = n.filter(([o, s]) => !s);
    if (r.length) {
      const o = n.filter(([s, a]) => a && a.embeddedLangs?.some((i) => r.map(([l]) => l).includes(i))).filter((s) => !r.includes(s));
      throw new ve(`Missing languages ${r.map(([s]) => `\`${s}\``).join(", ")}, required by ${o.map(([s]) => `\`${s}\``).join(", ")}`);
    }
    for (const [o, s] of n)
      this._resolver.addLanguage(s);
    for (const [o, s] of n)
      this.loadLanguage(s);
  }
  getLoadedLanguages() {
    return this._loadedLanguagesCache || (this._loadedLanguagesCache = [
      .../* @__PURE__ */ new Set([...this._resolvedGrammars.keys(), ...Object.keys(this._alias)])
    ]), this._loadedLanguagesCache;
  }
  resolveEmbeddedLanguages(e) {
    if (this._langMap.set(e.name, e), this._langGraph.set(e.name, e), e.embeddedLangs)
      for (const n of e.embeddedLangs)
        this._langGraph.set(n, this._langMap.get(n));
  }
}
class zl {
  _langs = /* @__PURE__ */ new Map();
  _scopeToLang = /* @__PURE__ */ new Map();
  _injections = /* @__PURE__ */ new Map();
  _onigLib;
  constructor(e, n) {
    this._onigLib = {
      createOnigScanner: (r) => e.createScanner(r),
      createOnigString: (r) => e.createString(r)
    }, n.forEach((r) => this.addLanguage(r));
  }
  get onigLib() {
    return this._onigLib;
  }
  getLangRegistration(e) {
    return this._langs.get(e);
  }
  loadGrammar(e) {
    return this._scopeToLang.get(e);
  }
  addLanguage(e) {
    this._langs.set(e.name, e), e.aliases && e.aliases.forEach((n) => {
      this._langs.set(n, e);
    }), this._scopeToLang.set(e.scopeName, e), e.injectTo && e.injectTo.forEach((n) => {
      this._injections.get(n) || this._injections.set(n, []), this._injections.get(n).push(e.scopeName);
    });
  }
  getInjections(e) {
    const n = e.split(".");
    let r = [];
    for (let o = 1; o <= n.length; o++) {
      const s = n.slice(0, o).join(".");
      r = [...r, ...this._injections.get(s) || []];
    }
    return r;
  }
}
let De = 0;
function Hl(t) {
  De += 1, t.warnings !== !1 && De >= 10 && De % 10 === 0 && console.warn(`[Shiki] ${De} instances have been created. Shiki is supposed to be used as a singleton, consider refactoring your code to cache your highlighter instance; Or call \`highlighter.dispose()\` to release unused instances.`);
  let e = !1;
  if (!t.engine)
    throw new ve("`engine` option is required for synchronous mode");
  const n = (t.langs || []).flat(1), r = (t.themes || []).flat(1).map(kn), o = new zl(t.engine, n), s = new Ul(o, r, n, t.langAlias);
  let a;
  function i(m) {
    C();
    const _ = s.getGrammar(typeof m == "string" ? m : m.name);
    if (!_)
      throw new ve(`Language \`${m}\` not found, you may need to load it first`);
    return _;
  }
  function l(m) {
    if (m === "none")
      return { bg: "", fg: "", name: "none", settings: [], type: "dark" };
    C();
    const _ = s.getTheme(m);
    if (!_)
      throw new ve(`Theme \`${m}\` not found, you may need to load it first`);
    return _;
  }
  function u(m) {
    C();
    const _ = l(m);
    a !== m && (s.setTheme(_), a = m);
    const S = s.getColorMap();
    return {
      theme: _,
      colorMap: S
    };
  }
  function c() {
    return C(), s.getLoadedThemes();
  }
  function h() {
    return C(), s.getLoadedLanguages();
  }
  function p(...m) {
    C(), s.loadLanguages(m.flat(1));
  }
  async function d(...m) {
    return p(await Io(m));
  }
  function f(...m) {
    C();
    for (const _ of m.flat(1))
      s.loadTheme(_);
  }
  async function g(...m) {
    return C(), f(await No(m));
  }
  function C() {
    if (e)
      throw new ve("Shiki instance has been disposed");
  }
  function y() {
    e || (e = !0, s.dispose(), De -= 1);
  }
  return {
    setTheme: u,
    getTheme: l,
    getLanguage: i,
    getLoadedThemes: c,
    getLoadedLanguages: h,
    loadLanguage: d,
    loadLanguageSync: p,
    loadTheme: g,
    loadThemeSync: f,
    dispose: y,
    [Symbol.dispose]: y
  };
}
async function Wl(t) {
  t.engine || jl("`engine` option is required. Use `createOnigurumaEngine` or `createJavaScriptRegexEngine` to create an engine.");
  const [
    e,
    n,
    r
  ] = await Promise.all([
    No(t.themes || []),
    Io(t.langs || []),
    t.engine
  ]);
  return Hl({
    ...t,
    themes: e,
    langs: n,
    engine: r
  });
}
async function Vl(t) {
  const e = await Wl(t);
  return {
    getLastGrammarState: (...n) => Al(e, ...n),
    codeToTokensBase: (n, r) => Sn(e, n, r),
    codeToTokensWithThemes: (n, r) => Ro(e, n, r),
    codeToTokens: (n, r) => mt(e, n, r),
    codeToHast: (n, r) => yt(e, n, r),
    codeToHtml: (n, r) => Fl(e, n, r),
    getBundledLanguages: () => ({}),
    getBundledThemes: () => ({}),
    ...e,
    getInternalContext: () => e
  };
}
function Lo(t) {
  return "children" in t ? Po(t) : "value" in t ? t.value : "";
}
function ql(t) {
  return t.type === "text" ? t.value : "children" in t ? Po(t) : "";
}
function Po(t) {
  let e = -1;
  const n = [];
  for (; ++e < t.children.length; )
    n[e] = ql(t.children[e]);
  return n.join("");
}
const Xl = {
  "tailing-curly-colon": (t, e) => {
    const n = Lo(e), r = n.match(/(.+)\{:([\w-]+)\}$/);
    if (r)
      return {
        type: "inline",
        code: r[1] ?? n,
        lang: r.at(2)
      };
  }
}, ir = "language-", Kl = (t, e) => {
  const n = e.children[0];
  if (!n || n.type !== "element" || n.tagName !== "code" || !n.properties)
    return;
  const r = n.properties.className, o = Array.isArray(r) ? r.find(
    (s) => typeof s == "string" && s.startsWith(ir)
  ) : void 0;
  return {
    type: "pre",
    lang: typeof o == "string" ? o.slice(ir.length) : void 0,
    code: Lo(n),
    meta: n.data?.meta ?? n.properties.metastring?.toString() ?? ""
  };
}, Yl = "language-";
function Jl(t, e) {
  const {
    addLanguageClass: n = !1,
    parseMetaString: r,
    cache: o,
    defaultLanguage: s,
    fallbackLanguage: a,
    onError: i,
    stripEndNewline: l = !0,
    inline: u = !1,
    lazy: c = !1,
    ...h
  } = e;
  function p(d, f, g = "", C = {}) {
    const y = `${d}:${g}:${f}`, m = o?.get(y);
    if (m)
      return m;
    const _ = {
      ...h,
      lang: d,
      meta: {
        ...h.meta,
        ...C,
        __raw: g
      }
    };
    n && (_.transformers = [
      ..._.transformers ?? [],
      {
        name: "rehype-shiki:code-language-class",
        code(S) {
          return this.addClassToHast(S, `${Yl}${d}`), S;
        }
      }
    ]), l && f.endsWith(`
`) && (f = f.slice(0, -1));
    try {
      const S = t.codeToHast(f, _);
      return o?.set(y, S), S;
    } catch (S) {
      if (i)
        i(S);
      else
        throw S;
    }
  }
  return (d) => {
    const f = [];
    if (qr(d, "element", (g, C, y) => {
      let m;
      if (!y || C == null)
        return;
      if (g.tagName === "pre")
        m = Kl;
      else if (g.tagName === "code" && u)
        m = Xl[u];
      else
        return;
      const _ = m(d, g);
      if (!_)
        return;
      let S, A = !1;
      if (_.lang ? t.getLoadedLanguages().includes(_.lang) || vo(_.lang) ? S = _.lang : c ? (A = !0, S = _.lang) : a && (S = a) : S = s, !S)
        return;
      const D = _.meta ? r?.(_.meta, g, d) : void 0, L = (j) => {
        const Z = p(j, _.code, _.meta, D ?? {});
        if (Z) {
          if (_.type === "inline") {
            const ee = Z.children[0];
            ee.type === "element" && ee.tagName === "pre" && (ee.tagName = "span");
          }
          y.children[C] = Z;
        }
      };
      if (A)
        try {
          f.push(t.loadLanguage(S).then(() => L(S)));
        } catch (j) {
          if (a)
            return L(a);
          if (i)
            i(j);
          else throw j;
        }
      else
        L(S);
      return "skip";
    }), f.length > 0) {
      async function g() {
        await Promise.all(f);
      }
      return g();
    }
  };
}
function Zl(t) {
  if (!t)
    return null;
  const e = t.match(/\{([\d,-]+)\}/);
  return e ? e[1].split(",").flatMap((r) => {
    const o = r.split("-").map((s) => Number.parseInt(s, 10));
    return o.length === 1 ? [o[0]] : Array.from({ length: o[1] - o[0] + 1 }, (s, a) => a + o[0]);
  }) : null;
}
const lr = Symbol("highlighted-lines");
function Ql(t = {}) {
  const {
    className: e = "highlighted"
  } = t;
  return {
    name: "@shikijs/transformers:meta-highlight",
    line(n, r) {
      if (!this.options.meta?.__raw)
        return;
      const o = this.meta;
      return o[lr] ??= Zl(this.options.meta.__raw), (o[lr] ?? []).includes(r) && this.addClassToHast(n, e), n;
    }
  };
}
function eu(t) {
  return t ? Array.from(t.matchAll(/\/((?:\\.|[^/])+)\//g)).map((n) => n[1].replace(/\\(.)/g, "$1")) : [];
}
function tu(t = {}) {
  const {
    className: e = "highlighted-word"
  } = t;
  return {
    name: "@shikijs/transformers:meta-word-highlight",
    preprocess(n, r) {
      if (!this.options.meta?.__raw)
        return;
      const o = eu(this.options.meta.__raw);
      r.decorations ||= [];
      for (const s of o) {
        const a = nu(n, s);
        for (const i of a)
          r.decorations.push({
            start: i,
            end: i + s.length,
            properties: {
              class: e
            }
          });
      }
    }
  };
}
function nu(t, e) {
  const n = [];
  let r = 0;
  for (; ; ) {
    const o = t.indexOf(e, r);
    if (o === -1 || o >= t.length || o < r)
      break;
    n.push(o), r = o + e.length;
  }
  return n;
}
function Pe(t) {
  if ([...t].length !== 1) throw new Error(`Expected "${t}" to be a single code point`);
  return t.codePointAt(0);
}
function ru(t, e, n) {
  return t.has(e) || t.set(e, n), t.get(e);
}
const vn = /* @__PURE__ */ new Set(["alnum", "alpha", "ascii", "blank", "cntrl", "digit", "graph", "lower", "print", "punct", "space", "upper", "word", "xdigit"]), B = String.raw;
function $e(t, e) {
  if (t == null) throw new Error(e ?? "Value expected");
  return t;
}
const $o = B`\[\^?`, To = `c.? | C(?:-.?)?|${B`[pP]\{(?:\^?[-\x20_]*[A-Za-z][-\x20\w]*\})?`}|${B`x[89A-Fa-f]\p{AHex}(?:\\x[89A-Fa-f]\p{AHex})*`}|${B`u(?:\p{AHex}{4})? | x\{[^\}]*\}? | x\p{AHex}{0,2}`}|${B`o\{[^\}]*\}?`}|${B`\d{1,3}`}`, xn = /[?*+][?+]?|\{(?:\d+(?:,\d*)?|,\d+)\}\??/, et = new RegExp(B`
  \\ (?:
    ${To}
    | [gk]<[^>]*>?
    | [gk]'[^']*'?
    | .
  )
  | \( (?:
    \? (?:
      [:=!>({]
      | <[=!]
      | <[^>]*>
      | '[^']*'
      | ~\|?
      | #(?:[^)\\]|\\.?)*
      | [^:)]*[:)]
    )?
    | \*[^\)]*\)?
  )?
  | (?:${xn.source})+
  | ${$o}
  | .
`.replace(/\s+/g, ""), "gsu"), Ot = new RegExp(B`
  \\ (?:
    ${To}
    | .
  )
  | \[:(?:\^?\p{Alpha}+|\^):\]
  | ${$o}
  | &&
  | .
`.replace(/\s+/g, ""), "gsu");
function ou(t, e = {}) {
  const n = { flags: "", ...e, rules: { captureGroup: !1, singleline: !1, ...e.rules } };
  if (typeof t != "string") throw new Error("String expected as pattern");
  const r = ku(n.flags), o = [r.extended], s = { captureGroup: n.rules.captureGroup, getCurrentModX() {
    return o.at(-1);
  }, numOpenGroups: 0, popModX() {
    o.pop();
  }, pushModX(h) {
    o.push(h);
  }, replaceCurrentModX(h) {
    o[o.length - 1] = h;
  }, singleline: n.rules.singleline };
  let a = [], i;
  for (et.lastIndex = 0; i = et.exec(t); ) {
    const h = su(s, t, i[0], et.lastIndex);
    h.tokens ? a.push(...h.tokens) : h.token && a.push(h.token), h.lastIndex !== void 0 && (et.lastIndex = h.lastIndex);
  }
  const l = [];
  let u = 0;
  a.filter((h) => h.type === "GroupOpen").forEach((h) => {
    h.kind === "capturing" ? h.number = ++u : h.raw === "(" && l.push(h);
  }), u || l.forEach((h, p) => {
    h.kind = "capturing", h.number = p + 1;
  });
  const c = u || l.length;
  return { tokens: a.map((h) => h.type === "EscapedNumber" ? xu(h, c) : h).flat(), flags: r };
}
function su(t, e, n, r) {
  const [o, s] = n;
  if (n === "[" || n === "[^") {
    const a = au(e, n, r);
    return { tokens: a.tokens, lastIndex: a.lastIndex };
  }
  if (o === "\\") {
    if ("AbBGyYzZ".includes(s)) return { token: ur(n, n) };
    if (/^\\g[<']/.test(n)) {
      if (!/^\\g(?:<[^>]+>|'[^']+')$/.test(n)) throw new Error(`Invalid group name "${n}"`);
      return { token: mu(n) };
    }
    if (/^\\k[<']/.test(n)) {
      if (!/^\\k(?:<[^>]+>|'[^']+')$/.test(n)) throw new Error(`Invalid group name "${n}"`);
      return { token: Oo(n) };
    }
    if (s === "K") return { token: Do("keep", n) };
    if (s === "N" || s === "R") return { token: ge("newline", n, { negate: s === "N" }) };
    if (s === "O") return { token: ge("any", n) };
    if (s === "X") return { token: ge("text_segment", n) };
    const a = Mo(n, { inCharClass: !1 });
    return Array.isArray(a) ? { tokens: a } : { token: a };
  }
  if (o === "(") {
    if (s === "*") return { token: Cu(n) };
    if (n === "(?{") throw new Error(`Unsupported callout "${n}"`);
    if (n.startsWith("(?#")) {
      if (e[r] !== ")") throw new Error('Unclosed comment group "(?#"');
      return { lastIndex: r + 1 };
    }
    if (/^\(\?[-imx]+[:)]$/.test(n)) return { token: wu(n, t) };
    if (t.pushModX(t.getCurrentModX()), t.numOpenGroups++, n === "(" && !t.captureGroup || n === "(?:") return { token: Se("group", n) };
    if (n === "(?>") return { token: Se("atomic", n) };
    if (n === "(?=" || n === "(?!" || n === "(?<=" || n === "(?<!") return { token: Se(n[2] === "<" ? "lookbehind" : "lookahead", n, { negate: n.endsWith("!") }) };
    if (n === "(" && t.captureGroup || n.startsWith("(?<") && n.endsWith(">") || n.startsWith("(?'") && n.endsWith("'")) return { token: Se("capturing", n, { ...n !== "(" && { name: n.slice(3, -1) } }) };
    if (n.startsWith("(?~")) {
      if (n === "(?~|") throw new Error(`Unsupported absence function kind "${n}"`);
      return { token: Se("absence_repeater", n) };
    }
    throw n === "(?(" ? new Error(`Unsupported conditional "${n}"`) : new Error(`Invalid or unsupported group option "${n}"`);
  }
  if (n === ")") {
    if (t.popModX(), t.numOpenGroups--, t.numOpenGroups < 0) throw new Error('Unmatched ")"');
    return { token: pu(n) };
  }
  if (t.getCurrentModX()) {
    if (n === "#") {
      const a = e.indexOf(`
`, r);
      return { lastIndex: a === -1 ? e.length : a };
    }
    if (/^\s$/.test(n)) {
      const a = /\s+/y;
      return a.lastIndex = r, { lastIndex: a.exec(e) ? a.lastIndex : r };
    }
  }
  if (n === ".") return { token: ge("dot", n) };
  if (n === "^" || n === "$") {
    const a = t.singleline ? { "^": B`\A`, $: B`\Z` }[n] : n;
    return { token: ur(a, n) };
  }
  return n === "|" ? { token: lu(n) } : xn.test(n) ? { tokens: Eu(n) } : { token: se(Pe(n), n) };
}
function au(t, e, n) {
  const r = [cr(e[1] === "^", e)];
  let o = 1, s;
  for (Ot.lastIndex = n; s = Ot.exec(t); ) {
    const a = s[0];
    if (a[0] === "[" && a[1] !== ":") o++, r.push(cr(a[1] === "^", a));
    else if (a === "]") {
      if (r.at(-1).type === "CharacterClassOpen") r.push(se(93, a));
      else if (o--, r.push(uu(a)), !o) break;
    } else {
      const i = iu(a);
      Array.isArray(i) ? r.push(...i) : r.push(i);
    }
  }
  return { tokens: r, lastIndex: Ot.lastIndex || t.length };
}
function iu(t) {
  if (t[0] === "\\") return Mo(t, { inCharClass: !0 });
  if (t[0] === "[") {
    const e = /\[:(?<negate>\^?)(?<name>[a-z]+):\]/.exec(t);
    if (!e || !vn.has(e.groups.name)) throw new Error(`Invalid POSIX class "${t}"`);
    return ge("posix", t, { value: e.groups.name, negate: !!e.groups.negate });
  }
  return t === "-" ? cu(t) : t === "&&" ? hu(t) : se(Pe(t), t);
}
function Mo(t, { inCharClass: e }) {
  const n = t[1];
  if (n === "c" || n === "C") return bu(t);
  if ("dDhHsSwW".includes(n)) return _u(t);
  if (t.startsWith(B`\o{`)) throw new Error(`Incomplete, invalid, or unsupported octal code point "${t}"`);
  if (/^\\[pP]\{/.test(t)) {
    if (t.length === 3) throw new Error(`Incomplete or invalid Unicode property "${t}"`);
    return Su(t);
  }
  if (/^\\x[89A-Fa-f]\p{AHex}/u.test(t)) try {
    const r = t.split(/\\x/).slice(1).map((a) => parseInt(a, 16)), o = new TextDecoder("utf-8", { ignoreBOM: !0, fatal: !0 }).decode(new Uint8Array(r)), s = new TextEncoder();
    return [...o].map((a) => {
      const i = [...s.encode(a)].map((l) => `\\x${l.toString(16)}`).join("");
      return se(Pe(a), i);
    });
  } catch {
    throw new Error(`Multibyte code "${t}" incomplete or invalid in Oniguruma`);
  }
  if (n === "u" || n === "x") return se(vu(t), t);
  if (hr.has(n)) return se(hr.get(n), t);
  if (/\d/.test(n)) return fu(e, t);
  if (t === "\\") throw new Error(B`Incomplete escape "\"`);
  if (n === "M") throw new Error(`Unsupported meta "${t}"`);
  if ([...t].length === 2) return se(t.codePointAt(1), t);
  throw new Error(`Unexpected escape "${t}"`);
}
function lu(t) {
  return { type: "Alternator", raw: t };
}
function ur(t, e) {
  return { type: "Assertion", kind: t, raw: e };
}
function Oo(t) {
  return { type: "Backreference", raw: t };
}
function se(t, e) {
  return { type: "Character", value: t, raw: e };
}
function uu(t) {
  return { type: "CharacterClassClose", raw: t };
}
function cu(t) {
  return { type: "CharacterClassHyphen", raw: t };
}
function hu(t) {
  return { type: "CharacterClassIntersector", raw: t };
}
function cr(t, e) {
  return { type: "CharacterClassOpen", negate: t, raw: e };
}
function ge(t, e, n = {}) {
  return { type: "CharacterSet", kind: t, ...n, raw: e };
}
function Do(t, e, n = {}) {
  return t === "keep" ? { type: "Directive", kind: t, raw: e } : { type: "Directive", kind: t, flags: $e(n.flags), raw: e };
}
function fu(t, e) {
  return { type: "EscapedNumber", inCharClass: t, raw: e };
}
function pu(t) {
  return { type: "GroupClose", raw: t };
}
function Se(t, e, n = {}) {
  return { type: "GroupOpen", kind: t, ...n, raw: e };
}
function du(t, e, n, r) {
  return { type: "NamedCallout", kind: t, tag: e, arguments: n, raw: r };
}
function gu(t, e, n, r) {
  return { type: "Quantifier", kind: t, min: e, max: n, raw: r };
}
function mu(t) {
  return { type: "Subroutine", raw: t };
}
const yu = /* @__PURE__ */ new Set(["COUNT", "CMP", "ERROR", "FAIL", "MAX", "MISMATCH", "SKIP", "TOTAL_COUNT"]), hr = /* @__PURE__ */ new Map([["a", 7], ["b", 8], ["e", 27], ["f", 12], ["n", 10], ["r", 13], ["t", 9], ["v", 11]]);
function bu(t) {
  const e = t[1] === "c" ? t[2] : t[3];
  if (!e || !/[A-Za-z]/.test(e)) throw new Error(`Unsupported control character "${t}"`);
  return se(Pe(e.toUpperCase()) - 64, t);
}
function wu(t, e) {
  let { on: n, off: r } = /^\(\?(?<on>[imx]*)(?:-(?<off>[-imx]*))?/.exec(t).groups;
  r ??= "";
  const o = (e.getCurrentModX() || n.includes("x")) && !r.includes("x"), s = pr(n), a = pr(r), i = {};
  if (s && (i.enable = s), a && (i.disable = a), t.endsWith(")")) return e.replaceCurrentModX(o), Do("flags", t, { flags: i });
  if (t.endsWith(":")) return e.pushModX(o), e.numOpenGroups++, Se("group", t, { ...(s || a) && { flags: i } });
  throw new Error(`Unexpected flag modifier "${t}"`);
}
function Cu(t) {
  const e = /\(\*(?<name>[A-Za-z_]\w*)?(?:\[(?<tag>(?:[A-Za-z_]\w*)?)\])?(?:\{(?<args>[^}]*)\})?\)/.exec(t);
  if (!e) throw new Error(`Incomplete or invalid named callout "${t}"`);
  const { name: n, tag: r, args: o } = e.groups;
  if (!n) throw new Error(`Invalid named callout "${t}"`);
  if (r === "") throw new Error(`Named callout tag with empty value not allowed "${t}"`);
  const s = o ? o.split(",").filter((c) => c !== "").map((c) => /^[+-]?\d+$/.test(c) ? +c : c) : [], [a, i, l] = s, u = yu.has(n) ? n.toLowerCase() : "custom";
  switch (u) {
    case "fail":
    case "mismatch":
    case "skip":
      if (s.length > 0) throw new Error(`Named callout arguments not allowed "${s}"`);
      break;
    case "error":
      if (s.length > 1) throw new Error(`Named callout allows only one argument "${s}"`);
      if (typeof a == "string") throw new Error(`Named callout argument must be a number "${a}"`);
      break;
    case "max":
      if (!s.length || s.length > 2) throw new Error(`Named callout must have one or two arguments "${s}"`);
      if (typeof a == "string" && !/^[A-Za-z_]\w*$/.test(a)) throw new Error(`Named callout argument one must be a tag or number "${a}"`);
      if (s.length === 2 && (typeof i == "number" || !/^[<>X]$/.test(i))) throw new Error(`Named callout optional argument two must be '<', '>', or 'X' "${i}"`);
      break;
    case "count":
    case "total_count":
      if (s.length > 1) throw new Error(`Named callout allows only one argument "${s}"`);
      if (s.length === 1 && (typeof a == "number" || !/^[<>X]$/.test(a))) throw new Error(`Named callout optional argument must be '<', '>', or 'X' "${a}"`);
      break;
    case "cmp":
      if (s.length !== 3) throw new Error(`Named callout must have three arguments "${s}"`);
      if (typeof a == "string" && !/^[A-Za-z_]\w*$/.test(a)) throw new Error(`Named callout argument one must be a tag or number "${a}"`);
      if (typeof i == "number" || !/^(?:[<>!=]=|[<>])$/.test(i)) throw new Error(`Named callout argument two must be '==', '!=', '>', '<', '>=', or '<=' "${i}"`);
      if (typeof l == "string" && !/^[A-Za-z_]\w*$/.test(l)) throw new Error(`Named callout argument three must be a tag or number "${l}"`);
      break;
    case "custom":
      throw new Error(`Undefined callout name "${n}"`);
    default:
      throw new Error(`Unexpected named callout kind "${u}"`);
  }
  return du(u, r ?? null, o?.split(",") ?? null, t);
}
function fr(t) {
  let e = null, n, r;
  if (t[0] === "{") {
    const { minStr: o, maxStr: s } = /^\{(?<minStr>\d*)(?:,(?<maxStr>\d*))?/.exec(t).groups, a = 1e5;
    if (+o > a || s && +s > a) throw new Error("Quantifier value unsupported in Oniguruma");
    if (n = +o, r = s === void 0 ? +o : s === "" ? 1 / 0 : +s, n > r && (e = "possessive", [n, r] = [r, n]), t.endsWith("?")) {
      if (e === "possessive") throw new Error('Unsupported possessive interval quantifier chain with "?"');
      e = "lazy";
    } else e || (e = "greedy");
  } else n = t[0] === "+" ? 1 : 0, r = t[0] === "?" ? 1 : 1 / 0, e = t[1] === "+" ? "possessive" : t[1] === "?" ? "lazy" : "greedy";
  return gu(e, n, r, t);
}
function _u(t) {
  const e = t[1].toLowerCase();
  return ge({ d: "digit", h: "hex", s: "space", w: "word" }[e], t, { negate: t[1] !== e });
}
function Su(t) {
  const { p: e, neg: n, value: r } = /^\\(?<p>[pP])\{(?<neg>\^?)(?<value>[^}]+)/.exec(t).groups;
  return ge("property", t, { value: r, negate: e === "P" && !n || e === "p" && !!n });
}
function pr(t) {
  const e = {};
  return t.includes("i") && (e.ignoreCase = !0), t.includes("m") && (e.dotAll = !0), t.includes("x") && (e.extended = !0), Object.keys(e).length ? e : null;
}
function ku(t) {
  const e = { ignoreCase: !1, dotAll: !1, extended: !1, digitIsAscii: !1, posixIsAscii: !1, spaceIsAscii: !1, wordIsAscii: !1, textSegmentMode: null };
  for (let n = 0; n < t.length; n++) {
    const r = t[n];
    if (!"imxDPSWy".includes(r)) throw new Error(`Invalid flag "${r}"`);
    if (r === "y") {
      if (!/^y{[gw]}/.test(t.slice(n))) throw new Error('Invalid or unspecified flag "y" mode');
      e.textSegmentMode = t[n + 2] === "g" ? "grapheme" : "word", n += 3;
      continue;
    }
    e[{ i: "ignoreCase", m: "dotAll", x: "extended", D: "digitIsAscii", P: "posixIsAscii", S: "spaceIsAscii", W: "wordIsAscii" }[r]] = !0;
  }
  return e;
}
function vu(t) {
  if (/^(?:\\u(?!\p{AHex}{4})|\\x(?!\p{AHex}{1,2}|\{\p{AHex}{1,8}\}))/u.test(t)) throw new Error(`Incomplete or invalid escape "${t}"`);
  const e = t[2] === "{" ? /^\\x\{\s*(?<hex>\p{AHex}+)/u.exec(t).groups.hex : t.slice(2);
  return parseInt(e, 16);
}
function xu(t, e) {
  const { raw: n, inCharClass: r } = t, o = n.slice(1);
  if (!r && (o !== "0" && o.length === 1 || o[0] !== "0" && +o <= e)) return [Oo(n)];
  const s = [], a = o.match(/^[0-7]+|\d/g);
  for (let i = 0; i < a.length; i++) {
    const l = a[i];
    let u;
    if (i === 0 && l !== "8" && l !== "9") {
      if (u = parseInt(l, 8), u > 127) throw new Error(B`Octal encoded byte above 177 unsupported "${n}"`);
    } else u = Pe(l);
    s.push(se(u, (i === 0 ? "\\" : "") + l));
  }
  return s;
}
function Eu(t) {
  const e = [], n = new RegExp(xn, "gy");
  let r;
  for (; r = n.exec(t); ) {
    const o = r[0];
    if (o[0] === "{") {
      const s = /^\{(?<min>\d+),(?<max>\d+)\}\??$/.exec(o);
      if (s) {
        const { min: a, max: i } = s.groups;
        if (+a > +i && o.endsWith("?")) {
          n.lastIndex--, e.push(fr(o.slice(0, -1)));
          continue;
        }
      }
    }
    e.push(fr(o));
  }
  return e;
}
function Go(t, e) {
  if (!Array.isArray(t.body)) throw new Error("Expected node with body array");
  if (t.body.length !== 1) return !1;
  const n = t.body[0];
  return !e || Object.keys(e).every((r) => e[r] === n[r]);
}
function Au(t) {
  return Ru.has(t.type);
}
const Ru = /* @__PURE__ */ new Set(["AbsenceFunction", "Backreference", "CapturingGroup", "Character", "CharacterClass", "CharacterSet", "Group", "Quantifier", "Subroutine"]);
function Fo(t, e = {}) {
  const n = { flags: "", normalizeUnknownPropertyNames: !1, skipBackrefValidation: !1, skipLookbehindValidation: !1, skipPropertyNameValidation: !1, unicodePropertyMap: null, ...e, rules: { captureGroup: !1, singleline: !1, ...e.rules } }, r = ou(t, { flags: n.flags, rules: { captureGroup: n.rules.captureGroup, singleline: n.rules.singleline } }), o = (p, d) => {
    const f = r.tokens[s.nextIndex];
    switch (s.parent = p, s.nextIndex++, f.type) {
      case "Alternator":
        return me();
      case "Assertion":
        return Iu(f);
      case "Backreference":
        return Nu(f, s);
      case "Character":
        return vt(f.value, { useLastValid: !!d.isCheckingRangeEnd });
      case "CharacterClassHyphen":
        return Lu(f, s, d);
      case "CharacterClassOpen":
        return Pu(f, s, d);
      case "CharacterSet":
        return $u(f, s);
      case "Directive":
        return Fu(f.kind, { flags: f.flags });
      case "GroupOpen":
        return Tu(f, s, d);
      case "NamedCallout":
        return ju(f.kind, f.tag, f.arguments);
      case "Quantifier":
        return Mu(f, s);
      case "Subroutine":
        return Ou(f, s);
      default:
        throw new Error(`Unexpected token type "${f.type}"`);
    }
  }, s = { capturingGroups: [], hasNumberedRef: !1, namedGroupsByName: /* @__PURE__ */ new Map(), nextIndex: 0, normalizeUnknownPropertyNames: n.normalizeUnknownPropertyNames, parent: null, skipBackrefValidation: n.skipBackrefValidation, skipLookbehindValidation: n.skipLookbehindValidation, skipPropertyNameValidation: n.skipPropertyNameValidation, subroutines: [], tokens: r.tokens, unicodePropertyMap: n.unicodePropertyMap, walk: o }, a = zu(Bu(r.flags));
  let i = a.body[0];
  for (; s.nextIndex < r.tokens.length; ) {
    const p = o(i, {});
    p.type === "Alternative" ? (a.body.push(p), i = p) : i.body.push(p);
  }
  const { capturingGroups: l, hasNumberedRef: u, namedGroupsByName: c, subroutines: h } = s;
  if (u && c.size && !n.rules.captureGroup) throw new Error("Numbered backref/subroutine not allowed when using named capture");
  for (const { ref: p } of h) if (typeof p == "number") {
    if (p > l.length) throw new Error("Subroutine uses a group number that's not defined");
    p && (l[p - 1].isSubroutined = !0);
  } else if (c.has(p)) {
    if (c.get(p).length > 1) throw new Error(B`Subroutine uses a duplicate group name "\g<${p}>"`);
    c.get(p)[0].isSubroutined = !0;
  } else throw new Error(B`Subroutine uses a group name that's not defined "\g<${p}>"`);
  return a;
}
function Iu({ kind: t }) {
  return on($e({ "^": "line_start", $: "line_end", "\\A": "string_start", "\\b": "word_boundary", "\\B": "word_boundary", "\\G": "search_start", "\\y": "text_segment_boundary", "\\Y": "text_segment_boundary", "\\z": "string_end", "\\Z": "string_end_newline" }[t], `Unexpected assertion kind "${t}"`), { negate: t === B`\B` || t === B`\Y` });
}
function Nu({ raw: t }, e) {
  const n = /^\\k[<']/.test(t), r = n ? t.slice(3, -1) : t.slice(1), o = (s, a = !1) => {
    const i = e.capturingGroups.length;
    let l = !1;
    if (s > i) if (e.skipBackrefValidation) l = !0;
    else throw new Error(`Not enough capturing groups defined to the left "${t}"`);
    return e.hasNumberedRef = !0, sn(a ? i + 1 - s : s, { orphan: l });
  };
  if (n) {
    const s = /^(?<sign>-?)0*(?<num>[1-9]\d*)$/.exec(r);
    if (s) return o(+s.groups.num, !!s.groups.sign);
    if (/[-+]/.test(r)) throw new Error(`Invalid backref name "${t}"`);
    if (!e.namedGroupsByName.has(r)) throw new Error(`Group name not defined to the left "${t}"`);
    return sn(r);
  }
  return o(+r);
}
function Lu(t, e, n) {
  const { tokens: r, walk: o } = e, s = e.parent, a = s.body.at(-1), i = r[e.nextIndex];
  if (!n.isCheckingRangeEnd && a && a.type !== "CharacterClass" && a.type !== "CharacterClassRange" && i && i.type !== "CharacterClassOpen" && i.type !== "CharacterClassClose" && i.type !== "CharacterClassIntersector") {
    const l = o(s, { ...n, isCheckingRangeEnd: !0 });
    if (a.type === "Character" && l.type === "Character") return s.body.pop(), Gu(a, l);
    throw new Error("Invalid character class range");
  }
  return vt(Pe("-"));
}
function Pu({ negate: t }, e, n) {
  const { tokens: r, walk: o } = e, s = r[e.nextIndex], a = [st()];
  let i = mr(s);
  for (; i.type !== "CharacterClassClose"; ) {
    if (i.type === "CharacterClassIntersector") a.push(st()), e.nextIndex++;
    else {
      const u = a.at(-1);
      u.body.push(o(u, n));
    }
    i = mr(r[e.nextIndex], s);
  }
  const l = st({ negate: t });
  return a.length === 1 ? l.body = a[0].body : (l.kind = "intersection", l.body = a.map((u) => u.body.length === 1 ? u.body[0] : u)), e.nextIndex++, l;
}
function $u({ kind: t, negate: e, value: n }, r) {
  const { normalizeUnknownPropertyNames: o, skipPropertyNameValidation: s, unicodePropertyMap: a } = r;
  if (t === "property") {
    const i = xt(n);
    if (vn.has(i) && !a?.has(i)) t = "posix", n = i;
    else return ke(n, { negate: e, normalizeUnknownPropertyNames: o, skipPropertyNameValidation: s, unicodePropertyMap: a });
  }
  return t === "posix" ? Uu(n, { negate: e }) : an(t, { negate: e });
}
function Tu(t, e, n) {
  const { tokens: r, capturingGroups: o, namedGroupsByName: s, skipLookbehindValidation: a, walk: i } = e, l = Hu(t), u = l.type === "AbsenceFunction", c = gr(l), h = c && l.negate;
  if (l.type === "CapturingGroup" && (o.push(l), l.name && ru(s, l.name, []).push(l)), u && n.isInAbsenceFunction) throw new Error("Nested absence function not supported by Oniguruma");
  let p = yr(r[e.nextIndex]);
  for (; p.type !== "GroupClose"; ) {
    if (p.type === "Alternator") l.body.push(me()), e.nextIndex++;
    else {
      const d = l.body.at(-1), f = i(d, { ...n, isInAbsenceFunction: n.isInAbsenceFunction || u, isInLookbehind: n.isInLookbehind || c, isInNegLookbehind: n.isInNegLookbehind || h });
      if (d.body.push(f), (c || n.isInLookbehind) && !a) {
        const g = "Lookbehind includes a pattern not allowed by Oniguruma";
        if (h || n.isInNegLookbehind) {
          if (dr(f) || f.type === "CapturingGroup") throw new Error(g);
        } else if (dr(f) || gr(f) && f.negate) throw new Error(g);
      }
    }
    p = yr(r[e.nextIndex]);
  }
  return e.nextIndex++, l;
}
function Mu({ kind: t, min: e, max: n }, r) {
  const o = r.parent, s = o.body.at(-1);
  if (!s || !Au(s)) throw new Error("Quantifier requires a repeatable token");
  const a = jo(t, e, n, s);
  return o.body.pop(), a;
}
function Ou({ raw: t }, e) {
  const { capturingGroups: n, subroutines: r } = e;
  let o = t.slice(3, -1);
  const s = /^(?<sign>[-+]?)0*(?<num>[1-9]\d*)$/.exec(o);
  if (s) {
    const i = +s.groups.num, l = n.length;
    if (e.hasNumberedRef = !0, o = { "": i, "+": l + i, "-": l + 1 - i }[s.groups.sign], o < 1) throw new Error("Invalid subroutine number");
  } else o === "0" && (o = 0);
  const a = Uo(o);
  return r.push(a), a;
}
function Du(t, e) {
  return { type: "AbsenceFunction", kind: t, body: Ye(e?.body) };
}
function me(t) {
  return { type: "Alternative", body: zo(t?.body) };
}
function on(t, e) {
  const n = { type: "Assertion", kind: t };
  return (t === "word_boundary" || t === "text_segment_boundary") && (n.negate = !!e?.negate), n;
}
function sn(t, e) {
  const n = !!e?.orphan;
  return { type: "Backreference", ref: t, ...n && { orphan: n } };
}
function Bo(t, e) {
  const n = { name: void 0, isSubroutined: !1, ...e };
  if (n.name !== void 0 && !Wu(n.name)) throw new Error(`Group name "${n.name}" invalid in Oniguruma`);
  return { type: "CapturingGroup", number: t, ...n.name && { name: n.name }, ...n.isSubroutined && { isSubroutined: n.isSubroutined }, body: Ye(e?.body) };
}
function vt(t, e) {
  const n = { useLastValid: !1, ...e };
  if (t > 1114111) {
    const r = t.toString(16);
    if (n.useLastValid) t = 1114111;
    else throw t > 1310719 ? new Error(`Invalid code point out of range "\\x{${r}}"`) : new Error(`Invalid code point out of range in JS "\\x{${r}}"`);
  }
  return { type: "Character", value: t };
}
function st(t) {
  const e = { kind: "union", negate: !1, ...t };
  return { type: "CharacterClass", kind: e.kind, negate: e.negate, body: zo(t?.body) };
}
function Gu(t, e) {
  if (e.value < t.value) throw new Error("Character class range out of order");
  return { type: "CharacterClassRange", min: t, max: e };
}
function an(t, e) {
  const n = !!e?.negate, r = { type: "CharacterSet", kind: t };
  return (t === "digit" || t === "hex" || t === "newline" || t === "space" || t === "word") && (r.negate = n), (t === "text_segment" || t === "newline" && !n) && (r.variableLength = !0), r;
}
function Fu(t, e = {}) {
  if (t === "keep") return { type: "Directive", kind: t };
  if (t === "flags") return { type: "Directive", kind: t, flags: $e(e.flags) };
  throw new Error(`Unexpected directive kind "${t}"`);
}
function Bu(t) {
  return { type: "Flags", ...t };
}
function Q(t) {
  const e = t?.atomic, n = t?.flags;
  if (e && n) throw new Error("Atomic group cannot have flags");
  return { type: "Group", ...e && { atomic: e }, ...n && { flags: n }, body: Ye(t?.body) };
}
function pe(t) {
  const e = { behind: !1, negate: !1, ...t };
  return { type: "LookaroundAssertion", kind: e.behind ? "lookbehind" : "lookahead", negate: e.negate, body: Ye(t?.body) };
}
function ju(t, e, n) {
  return { type: "NamedCallout", kind: t, tag: e, arguments: n };
}
function Uu(t, e) {
  const n = !!e?.negate;
  if (!vn.has(t)) throw new Error(`Invalid POSIX class "${t}"`);
  return { type: "CharacterSet", kind: "posix", value: t, negate: n };
}
function jo(t, e, n, r) {
  if (e > n) throw new Error("Invalid reversed quantifier range");
  return { type: "Quantifier", kind: t, min: e, max: n, body: r };
}
function zu(t, e) {
  return { type: "Regex", body: Ye(e?.body), flags: t };
}
function Uo(t) {
  return { type: "Subroutine", ref: t };
}
function ke(t, e) {
  const n = { negate: !1, normalizeUnknownPropertyNames: !1, skipPropertyNameValidation: !1, unicodePropertyMap: null, ...e };
  let r = n.unicodePropertyMap?.get(xt(t));
  if (!r) {
    if (n.normalizeUnknownPropertyNames) r = Vu(t);
    else if (n.unicodePropertyMap && !n.skipPropertyNameValidation) throw new Error(B`Invalid Unicode property "\p{${t}}"`);
  }
  return { type: "CharacterSet", kind: "property", value: r ?? t, negate: n.negate };
}
function Hu({ flags: t, kind: e, name: n, negate: r, number: o }) {
  switch (e) {
    case "absence_repeater":
      return Du("repeater");
    case "atomic":
      return Q({ atomic: !0 });
    case "capturing":
      return Bo(o, { name: n });
    case "group":
      return Q({ flags: t });
    case "lookahead":
    case "lookbehind":
      return pe({ behind: e === "lookbehind", negate: r });
    default:
      throw new Error(`Unexpected group kind "${e}"`);
  }
}
function Ye(t) {
  if (t === void 0) t = [me()];
  else if (!Array.isArray(t) || !t.length || !t.every((e) => e.type === "Alternative")) throw new Error("Invalid body; expected array of one or more Alternative nodes");
  return t;
}
function zo(t) {
  if (t === void 0) t = [];
  else if (!Array.isArray(t) || !t.every((e) => !!e.type)) throw new Error("Invalid body; expected array of nodes");
  return t;
}
function dr(t) {
  return t.type === "LookaroundAssertion" && t.kind === "lookahead";
}
function gr(t) {
  return t.type === "LookaroundAssertion" && t.kind === "lookbehind";
}
function Wu(t) {
  return /^[\p{Alpha}\p{Pc}][^)]*$/u.test(t);
}
function Vu(t) {
  return t.trim().replace(/[- _]+/g, "_").replace(/[A-Z][a-z]+(?=[A-Z])/g, "$&_").replace(/[A-Za-z]+/g, (e) => e[0].toUpperCase() + e.slice(1).toLowerCase());
}
function xt(t) {
  return t.replace(/[- _]+/g, "").toLowerCase();
}
function mr(t, e) {
  return $e(t, `${e?.type === "Character" && e.value === 93 ? "Empty" : "Unclosed"} character class`);
}
function yr(t) {
  return $e(t, "Unclosed group");
}
function Be(t, e, n = null) {
  function r(s, a) {
    for (let i = 0; i < s.length; i++) {
      const l = o(s[i], a, i, s);
      i = Math.max(-1, i + l);
    }
  }
  function o(s, a = null, i = null, l = null) {
    let u = 0, c = !1;
    const h = { node: s, parent: a, key: i, container: l, root: t, remove() {
      tt(l).splice(Math.max(0, Ce(i) + u), 1), u--, c = !0;
    }, removeAllNextSiblings() {
      return tt(l).splice(Ce(i) + 1);
    }, removeAllPrevSiblings() {
      const y = Ce(i) + u;
      return u -= y, tt(l).splice(0, Math.max(0, y));
    }, replaceWith(y, m = {}) {
      const _ = !!m.traverse;
      l ? l[Math.max(0, Ce(i) + u)] = y : $e(a, "Can't replace root node")[i] = y, _ && o(y, a, i, l), c = !0;
    }, replaceWithMultiple(y, m = {}) {
      const _ = !!m.traverse;
      if (tt(l).splice(Math.max(0, Ce(i) + u), 1, ...y), u += y.length - 1, _) {
        let S = 0;
        for (let A = 0; A < y.length; A++) S += o(y[A], a, Ce(i) + A + S, l);
      }
      c = !0;
    }, skip() {
      c = !0;
    } }, { type: p } = s, d = e["*"], f = e[p], g = typeof d == "function" ? d : d?.enter, C = typeof f == "function" ? f : f?.enter;
    if (g?.(h, n), C?.(h, n), !c) switch (p) {
      case "AbsenceFunction":
      case "CapturingGroup":
      case "Group":
        r(s.body, s);
        break;
      case "Alternative":
      case "CharacterClass":
        r(s.body, s);
        break;
      case "Assertion":
      case "Backreference":
      case "Character":
      case "CharacterSet":
      case "Directive":
      case "Flags":
      case "NamedCallout":
      case "Subroutine":
        break;
      case "CharacterClassRange":
        o(s.min, s, "min"), o(s.max, s, "max");
        break;
      case "LookaroundAssertion":
        r(s.body, s);
        break;
      case "Quantifier":
        o(s.body, s, "body");
        break;
      case "Regex":
        r(s.body, s), o(s.flags, s, "flags");
        break;
      default:
        throw new Error(`Unexpected node type "${p}"`);
    }
    return f?.exit?.(h, n), d?.exit?.(h, n), u;
  }
  return o(t), t;
}
function tt(t) {
  if (!Array.isArray(t)) throw new Error("Container expected");
  return t;
}
function Ce(t) {
  if (typeof t != "number") throw new Error("Numeric key expected");
  return t;
}
const qu = String.raw`\(\?(?:[:=!>A-Za-z\-]|<[=!]|\(DEFINE\))`;
function Xu(t, e) {
  for (let n = 0; n < t.length; n++)
    t[n] >= e && t[n]++;
}
function Ku(t, e, n, r) {
  return t.slice(0, e) + r + t.slice(e + n.length);
}
const J = Object.freeze({
  DEFAULT: "DEFAULT",
  CHAR_CLASS: "CHAR_CLASS"
});
function En(t, e, n, r) {
  const o = new RegExp(String.raw`${e}|(?<$skip>\[\^?|\\?.)`, "gsu"), s = [!1];
  let a = 0, i = "";
  for (const l of t.matchAll(o)) {
    const { 0: u, groups: { $skip: c } } = l;
    if (!c && (!r || r === J.DEFAULT == !a)) {
      n instanceof Function ? i += n(l, {
        context: a ? J.CHAR_CLASS : J.DEFAULT,
        negated: s[s.length - 1]
      }) : i += n;
      continue;
    }
    u[0] === "[" ? (a++, s.push(u[1] === "^")) : u === "]" && a && (a--, s.pop()), i += u;
  }
  return i;
}
function Ho(t, e, n, r) {
  En(t, e, n, r);
}
function Yu(t, e, n = 0, r) {
  if (!new RegExp(e, "su").test(t))
    return null;
  const o = new RegExp(`${e}|(?<$skip>\\\\?.)`, "gsu");
  o.lastIndex = n;
  let s = 0, a;
  for (; a = o.exec(t); ) {
    const { 0: i, groups: { $skip: l } } = a;
    if (!l && (!r || r === J.DEFAULT == !s))
      return a;
    i === "[" ? s++ : i === "]" && s && s--, o.lastIndex == a.index && o.lastIndex++;
  }
  return null;
}
function nt(t, e, n) {
  return !!Yu(t, e, 0, n);
}
function Ju(t, e) {
  const n = /\\?./gsu;
  n.lastIndex = e;
  let r = t.length, o = 0, s = 1, a;
  for (; a = n.exec(t); ) {
    const [i] = a;
    if (i === "[")
      o++;
    else if (o)
      i === "]" && o--;
    else if (i === "(")
      s++;
    else if (i === ")" && (s--, !s)) {
      r = a.index;
      break;
    }
  }
  return t.slice(e, r);
}
const br = new RegExp(String.raw`(?<noncapturingStart>${qu})|(?<capturingStart>\((?:\?<[^>]+>)?)|\\?.`, "gsu");
function Zu(t, e) {
  const n = e?.hiddenCaptures ?? [];
  let r = e?.captureTransfers ?? /* @__PURE__ */ new Map();
  if (!/\(\?>/.test(t))
    return {
      pattern: t,
      captureTransfers: r,
      hiddenCaptures: n
    };
  const o = "(?>", s = "(?:(?=(", a = [0], i = [];
  let l = 0, u = 0, c = NaN, h;
  do {
    h = !1;
    let p = 0, d = 0, f = !1, g;
    for (br.lastIndex = Number.isNaN(c) ? 0 : c + s.length; g = br.exec(t); ) {
      const { 0: C, index: y, groups: { capturingStart: m, noncapturingStart: _ } } = g;
      if (C === "[")
        p++;
      else if (p)
        C === "]" && p--;
      else if (C === o && !f)
        c = y, f = !0;
      else if (f && _)
        d++;
      else if (m)
        f ? d++ : (l++, a.push(l + u));
      else if (C === ")" && f) {
        if (!d) {
          u++;
          const S = l + u;
          if (t = `${t.slice(0, c)}${s}${t.slice(c + o.length, y)}))<$$${S}>)${t.slice(y + 1)}`, h = !0, i.push(S), Xu(n, S), r.size) {
            const A = /* @__PURE__ */ new Map();
            r.forEach((D, L) => {
              A.set(
                L >= S ? L + 1 : L,
                D.map((j) => j >= S ? j + 1 : j)
              );
            }), r = A;
          }
          break;
        }
        d--;
      }
    }
  } while (h);
  return n.push(...i), t = En(
    t,
    String.raw`\\(?<backrefNum>[1-9]\d*)|<\$\$(?<wrappedBackrefNum>\d+)>`,
    ({ 0: p, groups: { backrefNum: d, wrappedBackrefNum: f } }) => {
      if (d) {
        const g = +d;
        if (g > a.length - 1)
          throw new Error(`Backref "${p}" greater than number of captures`);
        return `\\${a[g]}`;
      }
      return `\\${f}`;
    },
    J.DEFAULT
  ), {
    pattern: t,
    captureTransfers: r,
    hiddenCaptures: n
  };
}
const Wo = String.raw`(?:[?*+]|\{\d+(?:,\d*)?\})`, Dt = new RegExp(String.raw`
\\(?: \d+
  | c[A-Za-z]
  | [gk]<[^>]+>
  | [pPu]\{[^\}]+\}
  | u[A-Fa-f\d]{4}
  | x[A-Fa-f\d]{2}
  )
| \((?: \? (?: [:=!>]
  | <(?:[=!]|[^>]+>)
  | [A-Za-z\-]+:
  | \(DEFINE\)
  ))?
| (?<qBase>${Wo})(?<qMod>[?+]?)(?<invalidQ>[?*+\{]?)
| \\?.
`.replace(/\s+/g, ""), "gsu");
function Qu(t) {
  if (!new RegExp(`${Wo}\\+`).test(t))
    return {
      pattern: t
    };
  const e = [];
  let n = null, r = null, o = "", s = 0, a;
  for (Dt.lastIndex = 0; a = Dt.exec(t); ) {
    const { 0: i, index: l, groups: { qBase: u, qMod: c, invalidQ: h } } = a;
    if (i === "[")
      s || (r = l), s++;
    else if (i === "]")
      s ? s-- : r = null;
    else if (!s)
      if (c === "+" && o && !o.startsWith("(")) {
        if (h)
          throw new Error(`Invalid quantifier "${i}"`);
        let p = -1;
        if (/^\{\d+\}$/.test(u))
          t = Ku(t, l + u.length, c, "");
        else {
          if (o === ")" || o === "]") {
            const d = o === ")" ? n : r;
            if (d === null)
              throw new Error(`Invalid unmatched "${o}"`);
            t = `${t.slice(0, d)}(?>${t.slice(d, l)}${u})${t.slice(l + i.length)}`;
          } else
            t = `${t.slice(0, l - o.length)}(?>${o}${u})${t.slice(l + i.length)}`;
          p += 4;
        }
        Dt.lastIndex += p;
      } else i[0] === "(" ? e.push(l) : i === ")" && (n = e.length ? e.pop() : null);
    o = i;
  }
  return {
    pattern: t
  };
}
const Y = String.raw, ec = Y`\\g<(?<gRNameOrNum>[^>&]+)&R=(?<gRDepth>[^>]+)>`, ln = Y`\(\?R=(?<rDepth>[^\)]+)\)|${ec}`, Et = Y`\(\?<(?![=!])(?<captureName>[^>]+)>`, Vo = Y`${Et}|(?<unnamed>\()(?!\?)`, he = new RegExp(Y`${Et}|${ln}|\(\?|\\?.`, "gsu"), Gt = "Cannot use multiple overlapping recursions";
function tc(t, e) {
  const { hiddenCaptures: n, mode: r } = {
    hiddenCaptures: [],
    mode: "plugin",
    ...e
  };
  let o = e?.captureTransfers ?? /* @__PURE__ */ new Map();
  if (!new RegExp(ln, "su").test(t))
    return {
      pattern: t,
      captureTransfers: o,
      hiddenCaptures: n
    };
  if (r === "plugin" && nt(t, Y`\(\?\(DEFINE\)`, J.DEFAULT))
    throw new Error("DEFINE groups cannot be used with recursion");
  const s = [], a = nt(t, Y`\\[1-9]`, J.DEFAULT), i = /* @__PURE__ */ new Map(), l = [];
  let u = !1, c = 0, h = 0, p;
  for (he.lastIndex = 0; p = he.exec(t); ) {
    const { 0: d, groups: { captureName: f, rDepth: g, gRNameOrNum: C, gRDepth: y } } = p;
    if (d === "[")
      c++;
    else if (c)
      d === "]" && c--;
    else if (g) {
      if (wr(g), u)
        throw new Error(Gt);
      if (a)
        throw new Error(
          // When used in `external` mode by transpilers other than Regex+, backrefs might have
          // gone through conversion from named to numbered, so avoid a misleading error
          `${r === "external" ? "Backrefs" : "Numbered backrefs"} cannot be used with global recursion`
        );
      const m = t.slice(0, p.index), _ = t.slice(he.lastIndex);
      if (nt(_, ln, J.DEFAULT))
        throw new Error(Gt);
      const S = +g - 1;
      t = Cr(
        m,
        _,
        S,
        !1,
        n,
        s,
        h
      ), o = Sr(
        o,
        m,
        S,
        s.length,
        0,
        h
      );
      break;
    } else if (C) {
      wr(y);
      let m = !1;
      for (const te of l)
        if (te.name === C || te.num === +C) {
          if (m = !0, te.hasRecursedWithin)
            throw new Error(Gt);
          break;
        }
      if (!m)
        throw new Error(Y`Recursive \g cannot be used outside the referenced group "${r === "external" ? C : Y`\g<${C}&R=${y}>`}"`);
      const _ = i.get(C), S = Ju(t, _);
      if (a && nt(S, Y`${Et}|\((?!\?)`, J.DEFAULT))
        throw new Error(
          // When used in `external` mode by transpilers other than Regex+, backrefs might have
          // gone through conversion from named to numbered, so avoid a misleading error
          `${r === "external" ? "Backrefs" : "Numbered backrefs"} cannot be used with recursion of capturing groups`
        );
      const A = t.slice(_, p.index), D = S.slice(A.length + d.length), L = s.length, j = +y - 1, Z = Cr(
        A,
        D,
        j,
        !0,
        n,
        s,
        h
      );
      o = Sr(
        o,
        A,
        j,
        s.length - L,
        L,
        h
      );
      const ee = t.slice(0, _), ce = t.slice(_ + S.length);
      t = `${ee}${Z}${ce}`, he.lastIndex += Z.length - d.length - A.length - D.length, l.forEach((te) => te.hasRecursedWithin = !0), u = !0;
    } else if (f)
      h++, i.set(String(h), he.lastIndex), i.set(f, he.lastIndex), l.push({
        num: h,
        name: f
      });
    else if (d[0] === "(") {
      const m = d === "(";
      m && (h++, i.set(String(h), he.lastIndex)), l.push(m ? { num: h } : {});
    } else d === ")" && l.pop();
  }
  return n.push(...s), {
    pattern: t,
    captureTransfers: o,
    hiddenCaptures: n
  };
}
function wr(t) {
  const e = `Max depth must be integer between 2 and 100; used ${t}`;
  if (!/^[1-9]\d*$/.test(t))
    throw new Error(e);
  if (t = +t, t < 2 || t > 100)
    throw new Error(e);
}
function Cr(t, e, n, r, o, s, a) {
  const i = /* @__PURE__ */ new Set();
  r && Ho(t + e, Et, ({ groups: { captureName: u } }) => {
    i.add(u);
  }, J.DEFAULT);
  const l = [
    n,
    r ? i : null,
    o,
    s,
    a
  ];
  return `${t}${_r(`(?:${t}`, "forward", ...l)}(?:)${_r(`${e})`, "backward", ...l)}${e}`;
}
function _r(t, e, n, r, o, s, a) {
  const l = (c) => e === "forward" ? c + 2 : n - c + 2 - 1;
  let u = "";
  for (let c = 0; c < n; c++) {
    const h = l(c);
    u += En(
      t,
      Y`${Vo}|\\k<(?<backref>[^>]+)>`,
      ({ 0: p, groups: { captureName: d, unnamed: f, backref: g } }) => {
        if (g && r && !r.has(g))
          return p;
        const C = `_$${h}`;
        if (f || d) {
          const y = a + s.length + 1;
          return s.push(y), nc(o, y), f ? p : `(?<${d}${C}>`;
        }
        return Y`\k<${g}${C}>`;
      },
      J.DEFAULT
    );
  }
  return u;
}
function nc(t, e) {
  for (let n = 0; n < t.length; n++)
    t[n] >= e && t[n]++;
}
function Sr(t, e, n, r, o, s) {
  if (t.size && r) {
    let a = 0;
    Ho(e, Vo, () => a++, J.DEFAULT);
    const i = s - a + o, l = /* @__PURE__ */ new Map();
    return t.forEach((u, c) => {
      const h = (r - a * n) / n, p = a * n, d = c > i + a ? c + r : c, f = [];
      for (const g of u)
        if (g <= i)
          f.push(g);
        else if (g > i + a + h)
          f.push(g + r);
        else if (g <= i + a)
          for (let C = 0; C <= n; C++)
            f.push(g + a * C);
        else
          for (let C = 0; C <= n; C++)
            f.push(g + p + h * C);
      l.set(d, f);
    }), l;
  }
  return t;
}
var M = String.fromCodePoint, v = String.raw, ae = {
  flagGroups: (() => {
    try {
      new RegExp("(?i:)");
    } catch {
      return !1;
    }
    return !0;
  })(),
  unicodeSets: (() => {
    try {
      new RegExp("", "v");
    } catch {
      return !1;
    }
    return !0;
  })()
};
ae.bugFlagVLiteralHyphenIsRange = ae.unicodeSets ? (() => {
  try {
    new RegExp(v`[\d\-a]`, "v");
  } catch {
    return !0;
  }
  return !1;
})() : !1;
ae.bugNestedClassIgnoresNegation = ae.unicodeSets && new RegExp("[[^a]]", "v").test("a");
function bt(t, { enable: e, disable: n }) {
  return {
    dotAll: !n?.dotAll && !!(e?.dotAll || t.dotAll),
    ignoreCase: !n?.ignoreCase && !!(e?.ignoreCase || t.ignoreCase)
  };
}
function Ve(t, e, n) {
  return t.has(e) || t.set(e, n), t.get(e);
}
function un(t, e) {
  return kr[t] >= kr[e];
}
function rc(t, e) {
  if (t == null)
    throw new Error(e ?? "Value expected");
  return t;
}
var kr = {
  ES2025: 2025,
  ES2024: 2024,
  ES2018: 2018
}, oc = (
  /** @type {const} */
  {
    auto: "auto",
    ES2025: "ES2025",
    ES2024: "ES2024",
    ES2018: "ES2018"
  }
);
function qo(t = {}) {
  if ({}.toString.call(t) !== "[object Object]")
    throw new Error("Unexpected options");
  if (t.target !== void 0 && !oc[t.target])
    throw new Error(`Unexpected target "${t.target}"`);
  const e = {
    // Sets the level of emulation rigor/strictness.
    accuracy: "default",
    // Disables advanced emulation that relies on returning a `RegExp` subclass, resulting in
    // certain patterns not being emulatable.
    avoidSubclass: !1,
    // Oniguruma flags; a string with `i`, `m`, `x`, `D`, `S`, `W`, `y{g}` in any order (all
    // optional). Oniguruma's `m` is equivalent to JavaScript's `s` (`dotAll`).
    flags: "",
    // Include JavaScript flag `g` (`global`) in the result.
    global: !1,
    // Include JavaScript flag `d` (`hasIndices`) in the result.
    hasIndices: !1,
    // Delay regex construction until first use if the transpiled pattern is at least this length.
    lazyCompileLength: 1 / 0,
    // JavaScript version used for generated regexes. Using `auto` detects the best value based on
    // your environment. Later targets allow faster processing, simpler generated source, and
    // support for additional features.
    target: "auto",
    // Disables minifications that simplify the pattern without changing the meaning.
    verbose: !1,
    ...t,
    // Advanced options that override standard behavior, error checking, and flags when enabled.
    rules: {
      // Useful with TextMate grammars that merge backreferences across patterns.
      allowOrphanBackrefs: !1,
      // Use ASCII `\b` and `\B`, which increases search performance of generated regexes.
      asciiWordBoundaries: !1,
      // Allow unnamed captures and numbered calls (backreferences and subroutines) when using
      // named capture. This is Oniguruma option `ONIG_OPTION_CAPTURE_GROUP`; on by default in
      // `vscode-oniguruma`.
      captureGroup: !1,
      // Change the recursion depth limit from Oniguruma's `20` to an integer `2`–`20`.
      recursionLimit: 20,
      // `^` as `\A`; `$` as`\Z`. Improves search performance of generated regexes without changing
      // the meaning if searching line by line. This is Oniguruma option `ONIG_OPTION_SINGLELINE`.
      singleline: !1,
      ...t.rules
    }
  };
  return e.target === "auto" && (e.target = ae.flagGroups ? "ES2025" : ae.unicodeSets ? "ES2024" : "ES2018"), e;
}
var sc = "[	-\r ]", ac = /* @__PURE__ */ new Set([
  M(304),
  // İ
  M(305)
  // ı
]), re = v`[\p{L}\p{M}\p{N}\p{Pc}]`;
function Xo(t) {
  if (ac.has(t))
    return [t];
  const e = /* @__PURE__ */ new Set(), n = t.toLowerCase(), r = n.toUpperCase(), o = uc.get(n), s = ic.get(n), a = lc.get(n);
  return [...r].length === 1 && e.add(r), a && e.add(a), o && e.add(o), e.add(n), s && e.add(s), [...e];
}
var An = /* @__PURE__ */ new Map(
  `C Other
Cc Control cntrl
Cf Format
Cn Unassigned
Co Private_Use
Cs Surrogate
L Letter
LC Cased_Letter
Ll Lowercase_Letter
Lm Modifier_Letter
Lo Other_Letter
Lt Titlecase_Letter
Lu Uppercase_Letter
M Mark Combining_Mark
Mc Spacing_Mark
Me Enclosing_Mark
Mn Nonspacing_Mark
N Number
Nd Decimal_Number digit
Nl Letter_Number
No Other_Number
P Punctuation punct
Pc Connector_Punctuation
Pd Dash_Punctuation
Pe Close_Punctuation
Pf Final_Punctuation
Pi Initial_Punctuation
Po Other_Punctuation
Ps Open_Punctuation
S Symbol
Sc Currency_Symbol
Sk Modifier_Symbol
Sm Math_Symbol
So Other_Symbol
Z Separator
Zl Line_Separator
Zp Paragraph_Separator
Zs Space_Separator
ASCII
ASCII_Hex_Digit AHex
Alphabetic Alpha
Any
Assigned
Bidi_Control Bidi_C
Bidi_Mirrored Bidi_M
Case_Ignorable CI
Cased
Changes_When_Casefolded CWCF
Changes_When_Casemapped CWCM
Changes_When_Lowercased CWL
Changes_When_NFKC_Casefolded CWKCF
Changes_When_Titlecased CWT
Changes_When_Uppercased CWU
Dash
Default_Ignorable_Code_Point DI
Deprecated Dep
Diacritic Dia
Emoji
Emoji_Component EComp
Emoji_Modifier EMod
Emoji_Modifier_Base EBase
Emoji_Presentation EPres
Extended_Pictographic ExtPict
Extender Ext
Grapheme_Base Gr_Base
Grapheme_Extend Gr_Ext
Hex_Digit Hex
IDS_Binary_Operator IDSB
IDS_Trinary_Operator IDST
ID_Continue IDC
ID_Start IDS
Ideographic Ideo
Join_Control Join_C
Logical_Order_Exception LOE
Lowercase Lower
Math
Noncharacter_Code_Point NChar
Pattern_Syntax Pat_Syn
Pattern_White_Space Pat_WS
Quotation_Mark QMark
Radical
Regional_Indicator RI
Sentence_Terminal STerm
Soft_Dotted SD
Terminal_Punctuation Term
Unified_Ideograph UIdeo
Uppercase Upper
Variation_Selector VS
White_Space space
XID_Continue XIDC
XID_Start XIDS`.split(/\s/).map((t) => [xt(t), t])
), ic = /* @__PURE__ */ new Map([
  ["s", M(383)],
  // s, ſ
  [M(383), "s"]
  // ſ, s
]), lc = /* @__PURE__ */ new Map([
  [M(223), M(7838)],
  // ß, ẞ
  [M(107), M(8490)],
  // k, K (Kelvin)
  [M(229), M(8491)],
  // å, Å (Angstrom)
  [M(969), M(8486)]
  // ω, Ω (Ohm)
]), uc = new Map([
  ie(453),
  ie(456),
  ie(459),
  ie(498),
  ...Ft(8072, 8079),
  ...Ft(8088, 8095),
  ...Ft(8104, 8111),
  ie(8124),
  ie(8140),
  ie(8188)
]), cc = /* @__PURE__ */ new Map([
  ["alnum", v`[\p{Alpha}\p{Nd}]`],
  ["alpha", v`\p{Alpha}`],
  ["ascii", v`\p{ASCII}`],
  ["blank", v`[\p{Zs}\t]`],
  ["cntrl", v`\p{Cc}`],
  ["digit", v`\p{Nd}`],
  ["graph", v`[\P{space}&&\P{Cc}&&\P{Cn}&&\P{Cs}]`],
  ["lower", v`\p{Lower}`],
  ["print", v`[[\P{space}&&\P{Cc}&&\P{Cn}&&\P{Cs}]\p{Zs}]`],
  ["punct", v`[\p{P}\p{S}]`],
  // Updated value from Onig 6.9.9; changed from Unicode `\p{punct}`
  ["space", v`\p{space}`],
  ["upper", v`\p{Upper}`],
  ["word", v`[\p{Alpha}\p{M}\p{Nd}\p{Pc}]`],
  ["xdigit", v`\p{AHex}`]
]);
function hc(t, e) {
  const n = [];
  for (let r = t; r <= e; r++)
    n.push(r);
  return n;
}
function ie(t) {
  const e = M(t);
  return [e.toLowerCase(), e];
}
function Ft(t, e) {
  return hc(t, e).map((n) => ie(n));
}
var Ko = /* @__PURE__ */ new Set([
  "Lower",
  "Lowercase",
  "Upper",
  "Uppercase",
  "Ll",
  "Lowercase_Letter",
  "Lt",
  "Titlecase_Letter",
  "Lu",
  "Uppercase_Letter"
  // The `Changes_When_*` properties (and their aliases) could be included, but they're very rare.
  // Some other properties include a handful of chars with specific cases only, but these chars are
  // generally extreme edge cases and using such properties case insensitively generally produces
  // undesired behavior anyway
]);
function fc(t, e) {
  const n = {
    // A couple edge cases exist where options `accuracy` and `bestEffortTarget` are used:
    // - `CharacterSet` kind `text_segment` (`\X`): An exact representation would require heavy
    //   Unicode data; a best-effort approximation requires knowing the target.
    // - `CharacterSet` kind `posix` with values `graph` and `print`: Their complex Unicode
    //   representations would be hard to change to ASCII versions after the fact in the generator
    //   based on `target`/`accuracy`, so produce the appropriate structure here.
    accuracy: "default",
    asciiWordBoundaries: !1,
    avoidSubclass: !1,
    bestEffortTarget: "ES2025",
    ...e
  };
  Yo(t);
  const r = {
    accuracy: n.accuracy,
    asciiWordBoundaries: n.asciiWordBoundaries,
    avoidSubclass: n.avoidSubclass,
    flagDirectivesByAlt: /* @__PURE__ */ new Map(),
    jsGroupNameMap: /* @__PURE__ */ new Map(),
    minTargetEs2024: un(n.bestEffortTarget, "ES2024"),
    passedLookbehind: !1,
    strategy: null,
    // Subroutines can appear before the groups they ref, so collect reffed nodes for a second pass 
    subroutineRefMap: /* @__PURE__ */ new Map(),
    supportedGNodes: /* @__PURE__ */ new Set(),
    digitIsAscii: t.flags.digitIsAscii,
    spaceIsAscii: t.flags.spaceIsAscii,
    wordIsAscii: t.flags.wordIsAscii
  };
  Be(t, pc, r);
  const o = {
    dotAll: t.flags.dotAll,
    ignoreCase: t.flags.ignoreCase
  }, s = {
    currentFlags: o,
    prevFlags: null,
    globalFlags: o,
    groupOriginByCopy: /* @__PURE__ */ new Map(),
    groupsByName: /* @__PURE__ */ new Map(),
    multiplexCapturesToLeftByRef: /* @__PURE__ */ new Map(),
    openRefs: /* @__PURE__ */ new Map(),
    reffedNodesByReferencer: /* @__PURE__ */ new Map(),
    subroutineRefMap: r.subroutineRefMap
  };
  Be(t, dc, s);
  const a = {
    groupsByName: s.groupsByName,
    highestOrphanBackref: 0,
    numCapturesToLeft: 0,
    reffedNodesByReferencer: s.reffedNodesByReferencer
  };
  return Be(t, gc, a), t._originMap = s.groupOriginByCopy, t._strategy = r.strategy, t;
}
var pc = {
  AbsenceFunction({ node: t, parent: e, replaceWith: n }) {
    const { body: r, kind: o } = t;
    if (o === "repeater") {
      const s = Q();
      s.body[0].body.push(
        // Insert own alts as `body`
        pe({ negate: !0, body: r }),
        ke("Any")
      );
      const a = Q();
      a.body[0].body.push(
        jo("greedy", 0, 1 / 0, s)
      ), n(P(a, e), { traverse: !0 });
    } else
      throw new Error('Unsupported absence function "(?~|"');
  },
  Alternative: {
    enter({ node: t, parent: e, key: n }, { flagDirectivesByAlt: r }) {
      const o = t.body.filter((s) => s.kind === "flags");
      for (let s = n + 1; s < e.body.length; s++) {
        const a = e.body[s];
        Ve(r, a, []).push(...o);
      }
    },
    exit({ node: t }, { flagDirectivesByAlt: e }) {
      if (e.get(t)?.length) {
        const n = Zo(e.get(t));
        if (n) {
          const r = Q({ flags: n });
          r.body[0].body = t.body, t.body = [P(r, t)];
        }
      }
    }
  },
  Assertion({ node: t, parent: e, key: n, container: r, root: o, remove: s, replaceWith: a }, i) {
    const { kind: l, negate: u } = t, { asciiWordBoundaries: c, avoidSubclass: h, supportedGNodes: p, wordIsAscii: d } = i;
    if (l === "text_segment_boundary")
      throw new Error(`Unsupported text segment boundary "\\${u ? "Y" : "y"}"`);
    if (l === "line_end")
      a(P(pe({ body: [
        me({ body: [on("string_end")] }),
        me({ body: [vt(10)] })
        // `\n`
      ] }), e));
    else if (l === "line_start")
      a(P(oe(v`(?<=\A|\n(?!\z))`, { skipLookbehindValidation: !0 }), e));
    else if (l === "search_start")
      if (p.has(t))
        o.flags.sticky = !0, s();
      else {
        const f = r[n - 1];
        if (f && _c(f))
          a(P(pe({ negate: !0 }), e));
        else {
          if (h)
            throw new Error(v`Uses "\G" in a way that requires a subclass`);
          a(le(on("string_start"), e)), i.strategy = "clip_search";
        }
      }
    else if (!(l === "string_end" || l === "string_start")) if (l === "string_end_newline")
      a(P(oe(v`(?=\n?\z)`), e));
    else if (l === "word_boundary") {
      if (!d && !c) {
        const f = `(?:(?<=${re})(?!${re})|(?<!${re})(?=${re}))`, g = `(?:(?<=${re})(?=${re})|(?<!${re})(?!${re}))`;
        a(P(oe(u ? g : f), e));
      }
    } else
      throw new Error(`Unexpected assertion kind "${l}"`);
  },
  Backreference({ node: t }, { jsGroupNameMap: e }) {
    let { ref: n } = t;
    typeof n == "string" && !jt(n) && (n = Bt(n, e), t.ref = n);
  },
  CapturingGroup({ node: t }, { jsGroupNameMap: e, subroutineRefMap: n }) {
    let { name: r } = t;
    r && !jt(r) && (r = Bt(r, e), t.name = r), n.set(t.number, t), r && n.set(r, t);
  },
  CharacterClassRange({ node: t, parent: e, replaceWith: n }) {
    if (e.kind === "intersection") {
      const r = st({ body: [t] });
      n(P(r, e), { traverse: !0 });
    }
  },
  CharacterSet({ node: t, parent: e, replaceWith: n }, { accuracy: r, minTargetEs2024: o, digitIsAscii: s, spaceIsAscii: a, wordIsAscii: i }) {
    const { kind: l, negate: u, value: c } = t;
    if (s && (l === "digit" || c === "digit")) {
      n(le(an("digit", { negate: u }), e));
      return;
    }
    if (a && (l === "space" || c === "space")) {
      n(P(Ut(oe(sc), u), e));
      return;
    }
    if (i && (l === "word" || c === "word")) {
      n(le(an("word", { negate: u }), e));
      return;
    }
    if (l === "any")
      n(le(ke("Any"), e));
    else if (l === "digit")
      n(le(ke("Nd", { negate: u }), e));
    else if (l !== "dot") if (l === "text_segment") {
      if (r === "strict")
        throw new Error(v`Use of "\X" requires non-strict accuracy`);
      const h = "\\p{Emoji}(?:\\p{EMod}|\\uFE0F\\u20E3?|[\\x{E0020}-\\x{E007E}]+\\x{E007F})?", p = v`\p{RI}{2}|${h}(?:\u200D${h})*`;
      n(P(oe(
        // Close approximation of an extended grapheme cluster; see: <unicode.org/reports/tr29/>
        v`(?>\r\n|${o ? v`\p{RGI_Emoji}` : p}|\P{M}\p{M}*)`,
        // Allow JS property `RGI_Emoji` through
        { skipPropertyNameValidation: !0 }
      ), e));
    } else if (l === "hex")
      n(le(ke("AHex", { negate: u }), e));
    else if (l === "newline")
      n(P(oe(u ? `[^
]` : `(?>\r
?|[
\v\f\u2028\u2029])`), e));
    else if (l === "posix")
      if (!o && (c === "graph" || c === "print")) {
        if (r === "strict")
          throw new Error(`POSIX class "${c}" requires min target ES2024 or non-strict accuracy`);
        let h = {
          graph: "!-~",
          print: " -~"
        }[c];
        u && (h = `\0-${M(h.codePointAt(0) - 1)}${M(h.codePointAt(2) + 1)}-􏿿`), n(P(oe(`[${h}]`), e));
      } else
        n(P(Ut(oe(cc.get(c)), u), e));
    else if (l === "property")
      An.has(xt(c)) || (t.key = "sc");
    else if (l === "space")
      n(le(ke("space", { negate: u }), e));
    else if (l === "word")
      n(P(Ut(oe(re), u), e));
    else
      throw new Error(`Unexpected character set kind "${l}"`);
  },
  Directive({ node: t, parent: e, root: n, remove: r, replaceWith: o, removeAllPrevSiblings: s, removeAllNextSiblings: a }) {
    const { kind: i, flags: l } = t;
    if (i === "flags")
      if (!l.enable && !l.disable)
        r();
      else {
        const u = Q({ flags: l });
        u.body[0].body = a(), o(P(u, e), { traverse: !0 });
      }
    else if (i === "keep") {
      const u = n.body[0], h = n.body.length === 1 && // Not emulatable if within a `CapturingGroup`
      Go(u, { type: "Group" }) && u.body[0].body.length === 1 ? u.body[0] : n;
      if (e.parent !== h || h.body.length > 1)
        throw new Error(v`Uses "\K" in a way that's unsupported`);
      const p = pe({ behind: !0 });
      p.body[0].body = s(), o(P(p, e));
    } else
      throw new Error(`Unexpected directive kind "${i}"`);
  },
  Flags({ node: t, parent: e }) {
    if (t.posixIsAscii)
      throw new Error('Unsupported flag "P"');
    if (t.textSegmentMode === "word")
      throw new Error('Unsupported flag "y{w}"');
    [
      "digitIsAscii",
      // Flag D
      "extended",
      // Flag x
      "posixIsAscii",
      // Flag P
      "spaceIsAscii",
      // Flag S
      "wordIsAscii",
      // Flag W
      "textSegmentMode"
      // Flag y{g} or y{w}
    ].forEach((n) => delete t[n]), Object.assign(t, {
      // JS flag g; no Onig equiv
      global: !1,
      // JS flag d; no Onig equiv
      hasIndices: !1,
      // JS flag m; no Onig equiv but its behavior is always on in Onig. Onig's only line break
      // char is line feed, unlike JS, so this flag isn't used since it would produce inaccurate
      // results (also allows `^` and `$` to be used in the generator for string start and end)
      multiline: !1,
      // JS flag y; no Onig equiv, but used for `\G` emulation
      sticky: t.sticky ?? !1
      // Note: Regex+ doesn't allow explicitly adding flags it handles implicitly, so leave out
      // properties `unicode` (JS flag u) and `unicodeSets` (JS flag v). Keep the existing values
      // for `ignoreCase` (flag i) and `dotAll` (JS flag s, but Onig flag m)
    }), e.options = {
      disable: {
        // Onig uses different rules for flag x than Regex+, so disable the implicit flag
        x: !0,
        // Onig has no flag to control "named capture only" mode but contextually applies its
        // behavior when named capturing is used, so disable Regex+'s implicit flag for it
        n: !0
      },
      force: {
        // Always add flag v because we're generating an AST that relies on it (it enables JS
        // support for Onig features nested classes, intersection, Unicode properties, etc.).
        // However, the generator might disable flag v based on its `target` option
        v: !0
      }
    };
  },
  Group({ node: t }) {
    if (!t.flags)
      return;
    const { enable: e, disable: n } = t.flags;
    e?.extended && delete e.extended, n?.extended && delete n.extended, e?.dotAll && n?.dotAll && delete e.dotAll, e?.ignoreCase && n?.ignoreCase && delete e.ignoreCase, e && !Object.keys(e).length && delete t.flags.enable, n && !Object.keys(n).length && delete t.flags.disable, !t.flags.enable && !t.flags.disable && delete t.flags;
  },
  LookaroundAssertion({ node: t }, e) {
    const { kind: n } = t;
    n === "lookbehind" && (e.passedLookbehind = !0);
  },
  NamedCallout({ node: t, parent: e, replaceWith: n }) {
    const { kind: r } = t;
    if (r === "fail")
      n(P(pe({ negate: !0 }), e));
    else
      throw new Error(`Unsupported named callout "(*${r.toUpperCase()}"`);
  },
  Quantifier({ node: t }) {
    if (t.body.type === "Quantifier") {
      const e = Q();
      e.body[0].body.push(t.body), t.body = P(e, t);
    }
  },
  Regex: {
    enter({ node: t }, { supportedGNodes: e }) {
      const n = [];
      let r = !1, o = !1;
      for (const s of t.body)
        if (s.body.length === 1 && s.body[0].kind === "search_start")
          s.body.pop();
        else {
          const a = es(s.body);
          a ? (r = !0, Array.isArray(a) ? n.push(...a) : n.push(a)) : o = !0;
        }
      r && !o && n.forEach((s) => e.add(s));
    },
    exit(t, { accuracy: e, passedLookbehind: n, strategy: r }) {
      if (e === "strict" && n && r)
        throw new Error(v`Uses "\G" in a way that requires non-strict accuracy`);
    }
  },
  Subroutine({ node: t }, { jsGroupNameMap: e }) {
    let { ref: n } = t;
    typeof n == "string" && !jt(n) && (n = Bt(n, e), t.ref = n);
  }
}, dc = {
  Backreference({ node: t }, { multiplexCapturesToLeftByRef: e, reffedNodesByReferencer: n }) {
    const { orphan: r, ref: o } = t;
    r || n.set(t, [...e.get(o).map(({ node: s }) => s)]);
  },
  CapturingGroup: {
    enter({
      node: t,
      parent: e,
      replaceWith: n,
      skip: r
    }, {
      groupOriginByCopy: o,
      groupsByName: s,
      multiplexCapturesToLeftByRef: a,
      openRefs: i,
      reffedNodesByReferencer: l
    }) {
      const u = o.get(t);
      if (u && i.has(t.number)) {
        const h = le(vr(t.number), e);
        l.set(h, i.get(t.number)), n(h);
        return;
      }
      i.set(t.number, t), a.set(t.number, []), t.name && Ve(a, t.name, []);
      const c = a.get(t.name ?? t.number);
      for (let h = 0; h < c.length; h++) {
        const p = c[h];
        if (
          // This group is from subroutine expansion, and there's a multiplex value from either the
          // origin node or a prior subroutine expansion group with the same origin
          u === p.node || u && u === p.origin || // This group is not from subroutine expansion, and it comes after a subroutine expansion
          // group that refers to this group
          t === p.origin
        ) {
          c.splice(h, 1);
          break;
        }
      }
      if (a.get(t.number).push({ node: t, origin: u }), t.name && a.get(t.name).push({ node: t, origin: u }), t.name) {
        const h = Ve(s, t.name, /* @__PURE__ */ new Map());
        let p = !1;
        if (u)
          p = !0;
        else
          for (const d of h.values())
            if (!d.hasDuplicateNameToRemove) {
              p = !0;
              break;
            }
        s.get(t.name).set(t, { node: t, hasDuplicateNameToRemove: p });
      }
    },
    exit({ node: t }, { openRefs: e }) {
      e.delete(t.number);
    }
  },
  Group: {
    enter({ node: t }, e) {
      e.prevFlags = e.currentFlags, t.flags && (e.currentFlags = bt(e.currentFlags, t.flags));
    },
    exit(t, e) {
      e.currentFlags = e.prevFlags;
    }
  },
  Subroutine({ node: t, parent: e, replaceWith: n }, r) {
    const { isRecursive: o, ref: s } = t;
    if (o) {
      let c = e;
      for (; (c = c.parent) && !(c.type === "CapturingGroup" && (c.name === s || c.number === s)); )
        ;
      r.reffedNodesByReferencer.set(t, c);
      return;
    }
    const a = r.subroutineRefMap.get(s), i = s === 0, l = i ? vr(0) : (
      // The reffed group might itself contain subroutines, which are expanded during sub-traversal
      Jo(a, r.groupOriginByCopy, null)
    );
    let u = l;
    if (!i) {
      const c = Zo(bc(
        a,
        (p) => p.type === "Group" && !!p.flags
      )), h = c ? bt(r.globalFlags, c) : r.globalFlags;
      mc(h, r.currentFlags) || (u = Q({
        flags: wc(h)
      }), u.body[0].body.push(l));
    }
    n(P(u, e), { traverse: !i });
  }
}, gc = {
  Backreference({ node: t, parent: e, replaceWith: n }, r) {
    if (t.orphan) {
      r.highestOrphanBackref = Math.max(r.highestOrphanBackref, t.ref);
      return;
    }
    const s = r.reffedNodesByReferencer.get(t).filter((a) => yc(a, t));
    if (!s.length)
      n(P(pe({ negate: !0 }), e));
    else if (s.length > 1) {
      const a = Q({
        atomic: !0,
        body: s.reverse().map((i) => me({
          body: [sn(i.number)]
        }))
      });
      n(P(a, e));
    } else
      t.ref = s[0].number;
  },
  CapturingGroup({ node: t }, e) {
    t.number = ++e.numCapturesToLeft, t.name && e.groupsByName.get(t.name).get(t).hasDuplicateNameToRemove && delete t.name;
  },
  Regex: {
    exit({ node: t }, e) {
      const n = Math.max(e.highestOrphanBackref - e.numCapturesToLeft, 0);
      for (let r = 0; r < n; r++) {
        const o = Bo();
        t.body.at(-1).body.push(o);
      }
    }
  },
  Subroutine({ node: t }, e) {
    !t.isRecursive || t.ref === 0 || (t.ref = e.reffedNodesByReferencer.get(t).number);
  }
};
function Yo(t) {
  Be(t, {
    "*"({ node: e, parent: n }) {
      e.parent = n;
    }
  });
}
function mc(t, e) {
  return t.dotAll === e.dotAll && t.ignoreCase === e.ignoreCase;
}
function yc(t, e) {
  let n = e;
  do {
    if (n.type === "Regex")
      return !1;
    if (n.type === "Alternative")
      continue;
    if (n === t)
      return !1;
    const r = Qo(n.parent);
    for (const o of r) {
      if (o === n)
        break;
      if (o === t || ts(o, t))
        return !0;
    }
  } while (n = n.parent);
  throw new Error("Unexpected path");
}
function Jo(t, e, n, r) {
  const o = Array.isArray(t) ? [] : {};
  for (const [s, a] of Object.entries(t))
    s === "parent" ? o.parent = Array.isArray(n) ? r : n : a && typeof a == "object" ? o[s] = Jo(a, e, o, n) : (s === "type" && a === "CapturingGroup" && e.set(o, e.get(t) ?? t), o[s] = a);
  return o;
}
function vr(t) {
  const e = Uo(t);
  return e.isRecursive = !0, e;
}
function bc(t, e) {
  const n = [];
  for (; t = t.parent; )
    (!e || e(t)) && n.push(t);
  return n;
}
function Bt(t, e) {
  if (e.has(t))
    return e.get(t);
  const n = `$${e.size}_${t.replace(/^[^$_\p{IDS}]|[^$\u200C\u200D\p{IDC}]/ug, "_")}`;
  return e.set(t, n), n;
}
function Zo(t) {
  const e = ["dotAll", "ignoreCase"], n = { enable: {}, disable: {} };
  return t.forEach(({ flags: r }) => {
    e.forEach((o) => {
      r.enable?.[o] && (delete n.disable[o], n.enable[o] = !0), r.disable?.[o] && (n.disable[o] = !0);
    });
  }), Object.keys(n.enable).length || delete n.enable, Object.keys(n.disable).length || delete n.disable, n.enable || n.disable ? n : null;
}
function wc({ dotAll: t, ignoreCase: e }) {
  const n = {};
  return (t || e) && (n.enable = {}, t && (n.enable.dotAll = !0), e && (n.enable.ignoreCase = !0)), (!t || !e) && (n.disable = {}, !t && (n.disable.dotAll = !0), !e && (n.disable.ignoreCase = !0)), n;
}
function Qo(t) {
  if (!t)
    throw new Error("Node expected");
  const { body: e } = t;
  return Array.isArray(e) ? e : e ? [e] : null;
}
function es(t) {
  const e = t.find((n) => n.kind === "search_start" || Sc(n, { negate: !1 }) || !Cc(n));
  if (!e)
    return null;
  if (e.kind === "search_start")
    return e;
  if (e.type === "LookaroundAssertion")
    return e.body[0].body[0];
  if (e.type === "CapturingGroup" || e.type === "Group") {
    const n = [];
    for (const r of e.body) {
      const o = es(r.body);
      if (!o)
        return null;
      Array.isArray(o) ? n.push(...o) : n.push(o);
    }
    return n;
  }
  return null;
}
function ts(t, e) {
  const n = Qo(t) ?? [];
  for (const r of n)
    if (r === e || ts(r, e))
      return !0;
  return !1;
}
function Cc({ type: t }) {
  return t === "Assertion" || t === "Directive" || t === "LookaroundAssertion";
}
function _c(t) {
  const e = [
    "Character",
    "CharacterClass",
    "CharacterSet"
  ];
  return e.includes(t.type) || t.type === "Quantifier" && t.min && e.includes(t.body.type);
}
function Sc(t, e) {
  const n = {
    negate: null,
    ...e
  };
  return t.type === "LookaroundAssertion" && (n.negate === null || t.negate === n.negate) && t.body.length === 1 && Go(t.body[0], {
    type: "Assertion",
    kind: "search_start"
  });
}
function jt(t) {
  return /^[$_\p{IDS}][$\u200C\u200D\p{IDC}]*$/u.test(t);
}
function oe(t, e) {
  const r = Fo(t, {
    ...e,
    // Providing a custom set of Unicode property names avoids converting some JS Unicode
    // properties (ex: `\p{Alpha}`) to Onig POSIX classes
    unicodePropertyMap: An
  }).body;
  return r.length > 1 || r[0].body.length > 1 ? Q({ body: r }) : r[0].body[0];
}
function Ut(t, e) {
  return t.negate = e, t;
}
function le(t, e) {
  return t.parent = e, t;
}
function P(t, e) {
  return Yo(t), t.parent = e, t;
}
function kc(t, e) {
  const n = qo(e), r = un(n.target, "ES2024"), o = un(n.target, "ES2025"), s = n.rules.recursionLimit;
  if (!Number.isInteger(s) || s < 2 || s > 20)
    throw new Error("Invalid recursionLimit; use 2-20");
  let a = null, i = null;
  if (!o) {
    const d = [t.flags.ignoreCase];
    Be(t, vc, {
      getCurrentModI: () => d.at(-1),
      popModI() {
        d.pop();
      },
      pushModI(f) {
        d.push(f);
      },
      setHasCasedChar() {
        d.at(-1) ? a = !0 : i = !0;
      }
    });
  }
  const l = {
    dotAll: t.flags.dotAll,
    // - Turn global flag i on if a case insensitive node was used and no case sensitive nodes were
    //   used (to avoid unnecessary node expansion).
    // - Turn global flag i off if a case sensitive node was used (since case sensitivity can't be
    //   forced without the use of ES2025 flag groups)
    ignoreCase: !!((t.flags.ignoreCase || a) && !i)
  };
  let u = t;
  const c = {
    accuracy: n.accuracy,
    appliedGlobalFlags: l,
    captureMap: /* @__PURE__ */ new Map(),
    currentFlags: {
      dotAll: t.flags.dotAll,
      ignoreCase: t.flags.ignoreCase
    },
    inCharClass: !1,
    lastNode: u,
    originMap: t._originMap,
    recursionLimit: s,
    useAppliedIgnoreCase: !!(!o && a && i),
    useFlagMods: o,
    useFlagV: r,
    verbose: n.verbose
  };
  function h(d) {
    return c.lastNode = u, u = d, rc(xc[d.type], `Unexpected node type "${d.type}"`)(d, c, h);
  }
  const p = {
    pattern: t.body.map(h).join("|"),
    // Could reset `lastNode` at this point via `lastNode = ast`, but it isn't needed by flags
    flags: h(t.flags),
    options: { ...t.options }
  };
  return r || (delete p.options.force.v, p.options.disable.v = !0, p.options.unicodeSetsPlugin = null), p._captureTransfers = /* @__PURE__ */ new Map(), p._hiddenCaptures = [], c.captureMap.forEach((d, f) => {
    d.hidden && p._hiddenCaptures.push(f), d.transferTo && Ve(p._captureTransfers, d.transferTo, []).push(f);
  }), p;
}
var vc = {
  "*": {
    enter({ node: t }, e) {
      if (Er(t)) {
        const n = e.getCurrentModI();
        e.pushModI(
          t.flags ? bt({ ignoreCase: n }, t.flags).ignoreCase : n
        );
      }
    },
    exit({ node: t }, e) {
      Er(t) && e.popModI();
    }
  },
  Backreference(t, e) {
    e.setHasCasedChar();
  },
  Character({ node: t }, e) {
    Rn(M(t.value)) && e.setHasCasedChar();
  },
  CharacterClassRange({ node: t, skip: e }, n) {
    e(), ns(t, { firstOnly: !0 }).length && n.setHasCasedChar();
  },
  CharacterSet({ node: t }, e) {
    t.kind === "property" && Ko.has(t.value) && e.setHasCasedChar();
  }
}, xc = {
  /**
  @param {AlternativeNode} node
  */
  Alternative({ body: t }, e, n) {
    return t.map(n).join("");
  },
  /**
  @param {AssertionNode} node
  */
  Assertion({ kind: t, negate: e }) {
    if (t === "string_end")
      return "$";
    if (t === "string_start")
      return "^";
    if (t === "word_boundary")
      return e ? v`\B` : v`\b`;
    throw new Error(`Unexpected assertion kind "${t}"`);
  },
  /**
  @param {BackreferenceNode} node
  */
  Backreference({ ref: t }, e) {
    if (typeof t != "number")
      throw new Error("Unexpected named backref in transformed AST");
    if (!e.useFlagMods && e.accuracy === "strict" && e.currentFlags.ignoreCase && !e.captureMap.get(t).ignoreCase)
      throw new Error("Use of case-insensitive backref to case-sensitive group requires target ES2025 or non-strict accuracy");
    return "\\" + t;
  },
  /**
  @param {CapturingGroupNode} node
  */
  CapturingGroup(t, e, n) {
    const { body: r, name: o, number: s } = t, a = { ignoreCase: e.currentFlags.ignoreCase }, i = e.originMap.get(t);
    return i && (a.hidden = !0, s > i.number && (a.transferTo = i.number)), e.captureMap.set(s, a), `(${o ? `?<${o}>` : ""}${r.map(n).join("|")})`;
  },
  /**
  @param {CharacterNode} node
  */
  Character({ value: t }, e) {
    const n = M(t), r = _e(t, {
      escDigit: e.lastNode.type === "Backreference",
      inCharClass: e.inCharClass,
      useFlagV: e.useFlagV
    });
    if (r !== n)
      return r;
    if (e.useAppliedIgnoreCase && e.currentFlags.ignoreCase && Rn(n)) {
      const o = Xo(n);
      return e.inCharClass ? o.join("") : o.length > 1 ? `[${o.join("")}]` : o[0];
    }
    return n;
  },
  /**
  @param {CharacterClassNode} node
  */
  CharacterClass(t, e, n) {
    const { kind: r, negate: o, parent: s } = t;
    let { body: a } = t;
    if (r === "intersection" && !e.useFlagV)
      throw new Error("Use of class intersection requires min target ES2024");
    ae.bugFlagVLiteralHyphenIsRange && e.useFlagV && a.some(Ar) && (a = [vt(45), ...a.filter((u) => !Ar(u))]);
    const i = () => `[${o ? "^" : ""}${a.map(n).join(r === "intersection" ? "&&" : "")}]`;
    if (!e.inCharClass) {
      if (
        // Already established `kind !== 'intersection'` if `!state.useFlagV`; don't check again
        (!e.useFlagV || ae.bugNestedClassIgnoresNegation) && !o
      ) {
        const c = a.filter(
          (h) => h.type === "CharacterClass" && h.kind === "union" && h.negate
        );
        if (c.length) {
          const h = Q(), p = h.body[0];
          return h.parent = s, p.parent = h, a = a.filter((d) => !c.includes(d)), t.body = a, a.length ? (t.parent = p, p.body.push(t)) : h.body.pop(), c.forEach((d) => {
            const f = me({ body: [d] });
            d.parent = f, f.parent = h, h.body.push(f);
          }), n(h);
        }
      }
      e.inCharClass = !0;
      const u = i();
      return e.inCharClass = !1, u;
    }
    const l = a[0];
    if (
      // Already established that the parent is a char class via `inCharClass`; don't check again
      r === "union" && !o && l && // Allows many nested classes to work with `target` ES2018 which doesn't support nesting
      ((!e.useFlagV || !e.verbose) && s.kind === "union" && !(ae.bugFlagVLiteralHyphenIsRange && e.useFlagV) || !e.verbose && s.kind === "intersection" && // JS doesn't allow intersection with union or ranges
      a.length === 1 && l.type !== "CharacterClassRange")
    )
      return a.map(n).join("");
    if (!e.useFlagV && s.type === "CharacterClass")
      throw new Error("Use of nested character class requires min target ES2024");
    return i();
  },
  /**
  @param {CharacterClassRangeNode} node
  */
  CharacterClassRange(t, e) {
    const n = t.min.value, r = t.max.value, o = {
      escDigit: !1,
      inCharClass: !0,
      useFlagV: e.useFlagV
    }, s = _e(n, o), a = _e(r, o), i = /* @__PURE__ */ new Set();
    if (e.useAppliedIgnoreCase && e.currentFlags.ignoreCase) {
      const l = ns(t);
      Nc(l).forEach((c) => {
        i.add(
          Array.isArray(c) ? `${_e(c[0], o)}-${_e(c[1], o)}` : _e(c, o)
        );
      });
    }
    return `${s}-${a}${[...i].join("")}`;
  },
  /**
  @param {CharacterSetNode} node
  */
  CharacterSet({ kind: t, negate: e, value: n, key: r }, o) {
    if (t === "dot")
      return o.currentFlags.dotAll ? o.appliedGlobalFlags.dotAll || o.useFlagMods ? "." : "[^]" : (
        // Onig's only line break char is line feed, unlike JS
        v`[^\n]`
      );
    if (t === "digit")
      return e ? v`\D` : v`\d`;
    if (t === "property") {
      if (o.useAppliedIgnoreCase && o.currentFlags.ignoreCase && Ko.has(n))
        throw new Error(`Unicode property "${n}" can't be case-insensitive when other chars have specific case`);
      return `${e ? v`\P` : v`\p`}{${r ? `${r}=` : ""}${n}}`;
    }
    if (t === "word")
      return e ? v`\W` : v`\w`;
    throw new Error(`Unexpected character set kind "${t}"`);
  },
  /**
  @param {FlagsNode} node
  */
  Flags(t, e) {
    return (
      // The transformer should never turn on the properties for flags d, g, m since Onig doesn't
      // have equivs. Flag m is never used since Onig uses different line break chars than JS
      // (node.hasIndices ? 'd' : '') +
      // (node.global ? 'g' : '') +
      // (node.multiline ? 'm' : '') +
      (e.appliedGlobalFlags.ignoreCase ? "i" : "") + (t.dotAll ? "s" : "") + (t.sticky ? "y" : "")
    );
  },
  /**
  @param {GroupNode} node
  */
  Group({ atomic: t, body: e, flags: n, parent: r }, o, s) {
    const a = o.currentFlags;
    n && (o.currentFlags = bt(a, n));
    const i = e.map(s).join("|"), l = !o.verbose && e.length === 1 && // Single alt
    r.type !== "Quantifier" && !t && (!o.useFlagMods || !n) ? i : `(?${Lc(t, n, o.useFlagMods)}${i})`;
    return o.currentFlags = a, l;
  },
  /**
  @param {LookaroundAssertionNode} node
  */
  LookaroundAssertion({ body: t, kind: e, negate: n }, r, o) {
    return `(?${`${e === "lookahead" ? "" : "<"}${n ? "!" : "="}`}${t.map(o).join("|")})`;
  },
  /**
  @param {QuantifierNode} node
  */
  Quantifier(t, e, n) {
    return n(t.body) + Pc(t);
  },
  /**
  @param {SubroutineNode & {isRecursive: true}} node
  */
  Subroutine({ isRecursive: t, ref: e }, n) {
    if (!t)
      throw new Error("Unexpected non-recursive subroutine in transformed AST");
    const r = n.recursionLimit;
    return e === 0 ? `(?R=${r})` : v`\g<${e}&R=${r}>`;
  }
}, Ec = /* @__PURE__ */ new Set([
  "$",
  "(",
  ")",
  "*",
  "+",
  ".",
  "?",
  "[",
  "\\",
  "]",
  "^",
  "{",
  "|",
  "}"
]), Ac = /* @__PURE__ */ new Set([
  "-",
  "\\",
  "]",
  "^",
  // Literal `[` doesn't require escaping with flag u, but this can help work around regex source
  // linters and regex syntax processors that expect unescaped `[` to create a nested class
  "["
]), Rc = /* @__PURE__ */ new Set([
  "(",
  ")",
  "-",
  "/",
  "[",
  "\\",
  "]",
  "^",
  "{",
  "|",
  "}",
  // Double punctuators; also includes already-listed `-` and `^`
  "!",
  "#",
  "$",
  "%",
  "&",
  "*",
  "+",
  ",",
  ".",
  ":",
  ";",
  "<",
  "=",
  ">",
  "?",
  "@",
  "`",
  "~"
]), xr = /* @__PURE__ */ new Map([
  [9, v`\t`],
  // horizontal tab
  [10, v`\n`],
  // line feed
  [11, v`\v`],
  // vertical tab
  [12, v`\f`],
  // form feed
  [13, v`\r`],
  // carriage return
  [8232, v`\u2028`],
  // line separator
  [8233, v`\u2029`],
  // paragraph separator
  [65279, v`\uFEFF`]
  // ZWNBSP/BOM
]), Ic = /^\p{Cased}$/u;
function Rn(t) {
  return Ic.test(t);
}
function ns(t, e) {
  const n = !!e?.firstOnly, r = t.min.value, o = t.max.value, s = [];
  if (r < 65 && (o === 65535 || o >= 131071) || r === 65536 && o >= 131071)
    return s;
  for (let a = r; a <= o; a++) {
    const i = M(a);
    if (!Rn(i))
      continue;
    const l = Xo(i).filter((u) => {
      const c = u.codePointAt(0);
      return c < r || c > o;
    });
    if (l.length && (s.push(...l), n))
      break;
  }
  return s;
}
function _e(t, { escDigit: e, inCharClass: n, useFlagV: r }) {
  if (xr.has(t))
    return xr.get(t);
  if (
    // Control chars, etc.; condition modeled on the Chrome developer console's display for strings
    t < 32 || t > 126 && t < 160 || // Unicode planes 4-16; unassigned, special purpose, and private use area
    t > 262143 || // Avoid corrupting a preceding backref by immediately following it with a literal digit
    e && $c(t)
  )
    return t > 255 ? `\\u{${t.toString(16).toUpperCase()}}` : `\\x${t.toString(16).toUpperCase().padStart(2, "0")}`;
  const o = n ? r ? Rc : Ac : Ec, s = M(t);
  return (o.has(s) ? "\\" : "") + s;
}
function Nc(t) {
  const e = t.map((o) => o.codePointAt(0)).sort((o, s) => o - s), n = [];
  let r = null;
  for (let o = 0; o < e.length; o++)
    e[o + 1] === e[o] + 1 ? r ??= e[o] : r === null ? n.push(e[o]) : (n.push([r, e[o]]), r = null);
  return n;
}
function Lc(t, e, n) {
  if (t)
    return ">";
  let r = "";
  if (e && n) {
    const { enable: o, disable: s } = e;
    r = (o?.ignoreCase ? "i" : "") + (o?.dotAll ? "s" : "") + (s ? "-" : "") + (s?.ignoreCase ? "i" : "") + (s?.dotAll ? "s" : "");
  }
  return `${r}:`;
}
function Pc({ kind: t, max: e, min: n }) {
  let r;
  return !n && e === 1 ? r = "?" : !n && e === 1 / 0 ? r = "*" : n === 1 && e === 1 / 0 ? r = "+" : n === e ? r = `{${n}}` : r = `{${n},${e === 1 / 0 ? "" : e}}`, r + {
    greedy: "",
    lazy: "?",
    possessive: "+"
  }[t];
}
function Er({ type: t }) {
  return t === "CapturingGroup" || t === "Group" || t === "LookaroundAssertion";
}
function $c(t) {
  return t > 47 && t < 58;
}
function Ar({ type: t, value: e }) {
  return t === "Character" && e === 45;
}
var Tc = class cn extends RegExp {
  /**
  @type {Map<number, {
    hidden?: true;
    transferTo?: number;
  }>}
  */
  #t = /* @__PURE__ */ new Map();
  /**
  @type {RegExp | EmulatedRegExp | null}
  */
  #e = null;
  /**
  @type {string}
  */
  #r;
  /**
  @type {Map<number, string>?}
  */
  #n = null;
  /**
  @type {string?}
  */
  #o = null;
  /**
  Can be used to serialize the instance.
  @type {EmulatedRegExpOptions}
  */
  rawOptions = {};
  // Override the getter with one that works with lazy-compiled regexes
  get source() {
    return this.#r || "(?:)";
  }
  /**
  @overload
  @param {string} pattern
  @param {string} [flags]
  @param {EmulatedRegExpOptions} [options]
  */
  /**
  @overload
  @param {EmulatedRegExp} pattern
  @param {string} [flags]
  */
  constructor(e, n, r) {
    const o = !!r?.lazyCompile;
    if (e instanceof RegExp) {
      if (r)
        throw new Error("Cannot provide options when copying a regexp");
      const s = e;
      super(s, n), this.#r = s.source, s instanceof cn && (this.#t = s.#t, this.#n = s.#n, this.#o = s.#o, this.rawOptions = s.rawOptions);
    } else {
      const s = {
        hiddenCaptures: [],
        strategy: null,
        transfers: [],
        ...r
      };
      super(o ? "" : e, n), this.#r = e, this.#t = Oc(s.hiddenCaptures, s.transfers), this.#o = s.strategy, this.rawOptions = r ?? {};
    }
    o || (this.#e = this);
  }
  /**
  Called internally by all String/RegExp methods that use regexes.
  @override
  @param {string} str
  @returns {RegExpExecArray?}
  */
  exec(e) {
    if (!this.#e) {
      const { lazyCompile: o, ...s } = this.rawOptions;
      this.#e = new cn(this.#r, this.flags, s);
    }
    const n = this.global || this.sticky, r = this.lastIndex;
    if (this.#o === "clip_search" && n && r) {
      this.lastIndex = 0;
      const o = this.#s(e.slice(r));
      return o && (Mc(o, r, e, this.hasIndices), this.lastIndex += r), o;
    }
    return this.#s(e);
  }
  /**
  Adds support for hidden and transfer captures.
  @param {string} str
  @returns
  */
  #s(e) {
    this.#e.lastIndex = this.lastIndex;
    const n = super.exec.call(this.#e, e);
    if (this.lastIndex = this.#e.lastIndex, !n || !this.#t.size)
      return n;
    const r = [...n];
    n.length = 1;
    let o;
    this.hasIndices && (o = [...n.indices], n.indices.length = 1);
    const s = [0];
    for (let a = 1; a < r.length; a++) {
      const { hidden: i, transferTo: l } = this.#t.get(a) ?? {};
      if (i ? s.push(null) : (s.push(n.length), n.push(r[a]), this.hasIndices && n.indices.push(o[a])), l && r[a] !== void 0) {
        const u = s[l];
        if (!u)
          throw new Error(`Invalid capture transfer to "${u}"`);
        if (n[u] = r[a], this.hasIndices && (n.indices[u] = o[a]), n.groups) {
          this.#n || (this.#n = Dc(this.source));
          const c = this.#n.get(l);
          c && (n.groups[c] = r[a], this.hasIndices && (n.indices.groups[c] = o[a]));
        }
      }
    }
    return n;
  }
};
function Mc(t, e, n, r) {
  if (t.index += e, t.input = n, r) {
    const o = t.indices;
    for (let a = 0; a < o.length; a++) {
      const i = o[a];
      i && (o[a] = [i[0] + e, i[1] + e]);
    }
    const s = o.groups;
    s && Object.keys(s).forEach((a) => {
      const i = s[a];
      i && (s[a] = [i[0] + e, i[1] + e]);
    });
  }
}
function Oc(t, e) {
  const n = /* @__PURE__ */ new Map();
  for (const r of t)
    n.set(r, {
      hidden: !0
    });
  for (const [r, o] of e)
    for (const s of o)
      Ve(n, s, {}).transferTo = r;
  return n;
}
function Dc(t) {
  const e = /(?<capture>\((?:\?<(?![=!])(?<name>[^>]+)>|(?!\?)))|\\?./gsu, n = /* @__PURE__ */ new Map();
  let r = 0, o = 0, s;
  for (; s = e.exec(t); ) {
    const { 0: a, groups: { capture: i, name: l } } = s;
    a === "[" ? r++ : r ? a === "]" && r-- : i && (o++, l && n.set(o, l));
  }
  return n;
}
function Gc(t, e) {
  const n = Fc(t, e);
  return n.options ? new Tc(n.pattern, n.flags, n.options) : new RegExp(n.pattern, n.flags);
}
function Fc(t, e) {
  const n = qo(e), r = Fo(t, {
    flags: n.flags,
    normalizeUnknownPropertyNames: !0,
    rules: {
      captureGroup: n.rules.captureGroup,
      singleline: n.rules.singleline
    },
    skipBackrefValidation: n.rules.allowOrphanBackrefs,
    unicodePropertyMap: An
  }), o = fc(r, {
    accuracy: n.accuracy,
    asciiWordBoundaries: n.rules.asciiWordBoundaries,
    avoidSubclass: n.avoidSubclass,
    bestEffortTarget: n.target
  }), s = kc(o, n), a = tc(s.pattern, {
    captureTransfers: s._captureTransfers,
    hiddenCaptures: s._hiddenCaptures,
    mode: "external"
  }), i = Qu(a.pattern), l = Zu(i.pattern, {
    captureTransfers: a.captureTransfers,
    hiddenCaptures: a.hiddenCaptures
  }), u = {
    pattern: l.pattern,
    flags: `${n.hasIndices ? "d" : ""}${n.global ? "g" : ""}${s.flags}${s.options.disable.v ? "u" : "v"}`
  };
  if (n.avoidSubclass) {
    if (n.lazyCompileLength !== 1 / 0)
      throw new Error("Lazy compilation requires subclass");
  } else {
    const c = l.hiddenCaptures.sort((f, g) => f - g), h = Array.from(l.captureTransfers), p = o._strategy, d = u.pattern.length >= n.lazyCompileLength;
    (c.length || h.length || p || d) && (u.options = {
      ...c.length && { hiddenCaptures: c },
      ...h.length && { transfers: h },
      ...p && { strategy: p },
      ...d && { lazyCompile: d }
    });
  }
  return u;
}
const Rr = 4294967295;
class Bc {
  constructor(e, n = {}) {
    this.patterns = e, this.options = n;
    const {
      forgiving: r = !1,
      cache: o,
      regexConstructor: s
    } = n;
    if (!s)
      throw new Error("Option `regexConstructor` is not provided");
    this.regexps = e.map((a) => {
      if (typeof a != "string")
        return a;
      const i = o?.get(a);
      if (i) {
        if (i instanceof RegExp)
          return i;
        if (r)
          return null;
        throw i;
      }
      try {
        const l = s(a);
        return o?.set(a, l), l;
      } catch (l) {
        if (o?.set(a, l), r)
          return null;
        throw l;
      }
    });
  }
  regexps;
  findNextMatchSync(e, n, r) {
    const o = typeof e == "string" ? e : e.content, s = [];
    function a(i, l, u = 0) {
      return {
        index: i,
        captureIndices: l.indices.map((c) => c == null ? {
          start: Rr,
          end: Rr,
          length: 0
        } : {
          start: c[0] + u,
          end: c[1] + u,
          length: c[1] - c[0]
        })
      };
    }
    for (let i = 0; i < this.regexps.length; i++) {
      const l = this.regexps[i];
      if (l)
        try {
          l.lastIndex = n;
          const u = l.exec(o);
          if (!u)
            continue;
          if (u.index === n)
            return a(i, u, 0);
          s.push([i, u, 0]);
        } catch (u) {
          if (this.options.forgiving)
            continue;
          throw u;
        }
    }
    if (s.length) {
      const i = Math.min(...s.map((l) => l[1].index));
      for (const [l, u, c] of s)
        if (u.index === i)
          return a(l, u, c);
    }
    return null;
  }
}
function jc(t, e) {
  return Gc(
    t,
    {
      global: !0,
      hasIndices: !0,
      // This has no benefit for the standard JS engine, but it avoids a perf penalty for
      // precompiled grammars when constructing extremely long patterns that aren't always used
      lazyCompileLength: 3e3,
      rules: {
        // Needed since TextMate grammars merge backrefs across patterns
        allowOrphanBackrefs: !0,
        // Improves search performance for generated regexes
        asciiWordBoundaries: !0,
        // Follow `vscode-oniguruma` which enables this Oniguruma option by default
        captureGroup: !0,
        // Oniguruma uses depth limit `20`; lowered here to keep regexes shorter and maybe
        // sometimes faster, but can be increased if issues reported due to low limit
        recursionLimit: 5,
        // Oniguruma option for `^`->`\A`, `$`->`\Z`; improves search performance without any
        // change in meaning since TM grammars search line by line
        singleline: !0
      },
      ...e
    }
  );
}
function Uc(t = {}) {
  const e = Object.assign(
    {
      target: "auto",
      cache: /* @__PURE__ */ new Map()
    },
    t
  );
  return e.regexConstructor ||= (n) => jc(n, { target: e.target }), {
    createScanner(n) {
      return new Bc(n, e);
    },
    createString(n) {
      return {
        content: n
      };
    }
  };
}
const zc = Uc({ forgiving: !0 }), Hc = await Vl({
  engine: zc,
  langAlias: {
    markup: "html",
    svg: "xml",
    mathml: "xml",
    atom: "xml",
    ssml: "xml",
    rss: "xml",
    webmanifest: "json"
  }
}), wt = {
  themes: {
    light: "github-light",
    dark: "github-dark"
  },
  defaultColor: !1,
  defaultLanguage: "text",
  fallbackLanguage: "text",
  inline: "tailing-curly-colon",
  addLanguageClass: !0,
  transformers: [Ql(), tu()],
  parseMetaString: (t) => {
    const e = t.matchAll(
      /([a-z0-9]+)(?:=(["'])(.*?)\2|=(.*?)(?:\s|$)|(?:\s|$))/gi
    );
    return Object.fromEntries(
      Array.from(e).map((n) => {
        const r = n[1], o = n[3] || n[4] || !0;
        return [r, o];
      })
    );
  }
}, Wc = () => (t) => {
  qr(t, "element", (e, n, r) => {
    if (e.tagName !== "code") return;
    const o = r?.type === "element" && r.tagName === "pre";
    e.properties.inline = JSON.stringify(!o), o && (e.properties = {
      ...e.properties,
      ...structuredClone(r.properties),
      class: as(e.properties.class, r.properties.class)
    }, r.properties = {});
  });
}, hh = (t = wt.themes, e = Hc) => [
  [
    Jl,
    e,
    { ...wt, themes: t }
  ],
  Wc
], Vc = (t, e, n = "text", r = wt.themes) => {
  const o = t.codeToHast(e, {
    lang: n,
    ...wt,
    themes: r
  });
  return Ds(o, { Fragment: rs, jsx: at.jsx, jsxs: at.jsxs });
}, qc = os(
  ({ code: t, children: e, embedded: n, ...r }) => {
    const { syntaxHighlighting: o } = ss().options;
    ls(o?.highlighter, "Highlighter not found");
    const s = Vc(
      o.highlighter,
      t ?? e,
      r.language,
      o.themes
    );
    return n ? /* @__PURE__ */ at.jsx(cs, { ...r, children: s }) : /* @__PURE__ */ at.jsx(us, { ...r, children: s });
  }
);
qc.displayName = "SyntaxHighlight";
export {
  Fn as E,
  qc as S,
  H as V,
  Ls as a,
  lh as b,
  ih as c,
  rh as d,
  Ir as e,
  Gr as f,
  ua as g,
  Vc as h,
  Wr as i,
  aa as j,
  jn as k,
  hh as l,
  th as o,
  Fr as p,
  Ps as s,
  Ds as t,
  nh as u,
  qr as v,
  la as z
};
//# sourceMappingURL=SyntaxHighlight-CPF64UHi.js.map
