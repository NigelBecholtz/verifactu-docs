import { createClient as l } from "@supabase/supabase-js";
import { C as g, A as p } from "./errors-ouIp07AW.js";
import { u as r } from "./hook-BkLXq8pm.js";
class f extends g {
  client;
  provider;
  redirectToAfterSignUp;
  redirectToAfterSignIn;
  // biome-ignore lint/correctness/noUnusedPrivateClassMembers: Keep around
  redirectToAfterSignOut;
  constructor({
    supabaseUrl: e,
    supabaseKey: t,
    provider: i,
    redirectToAfterSignUp: c,
    redirectToAfterSignIn: u,
    redirectToAfterSignOut: d,
    basePath: h
  }) {
    super(), this.provider = i, this.client = l(e, t, {
      auth: {
        autoRefreshToken: !0,
        persistSession: !0
      }
    });
    const s = h ?? "/";
    this.redirectToAfterSignUp = c ?? s, this.redirectToAfterSignIn = u ?? s, this.redirectToAfterSignOut = d ?? s, this.client.auth.onAuthStateChange(async (a, o) => {
      o && (a === "SIGNED_IN" || a === "TOKEN_REFRESHED") ? await this.updateUserState(o) : a === "SIGNED_OUT" && r.getState().setLoggedOut();
    });
  }
  async updateUserState(e) {
    const { user: t } = e, i = {
      sub: t.id,
      email: t.email,
      name: t.user_metadata.full_name || t.user_metadata.name,
      emailVerified: t.email_confirmed_at != null,
      pictureUrl: t.user_metadata.avatar_url
    };
    r.getState().setLoggedIn({
      profile: i,
      providerData: { session: e }
    });
  }
  async getAccessToken() {
    const { data: e, error: t } = await this.client.auth.getSession();
    if (t || !e.session)
      throw new p("User is not authenticated");
    return e.session.access_token;
  }
  async signRequest(e) {
    const t = await this.getAccessToken();
    return e.headers.set("Authorization", `Bearer ${t}`), e;
  }
  signUp = async ({ redirectTo: e }) => {
    const t = e ?? this.redirectToAfterSignUp;
    await this.client.auth.signInWithOAuth({
      provider: this.provider,
      options: {
        redirectTo: window.location.origin + t
      }
    });
  };
  signIn = async ({ redirectTo: e }) => {
    const t = e ?? this.redirectToAfterSignIn;
    await this.client.auth.signInWithOAuth({
      provider: this.provider,
      options: {
        redirectTo: window.location.origin + t,
        queryParams: {
          access_type: "offline",
          prompt: "consent"
        }
      }
    });
  };
  signOut = async () => {
    await new Promise((e) => {
      const { data: t } = this.client.auth.onAuthStateChange(async (i) => {
        i === "SIGNED_OUT" && (t.subscription.unsubscribe(), e());
      });
      this.client.auth.signOut();
    }), r.setState({
      isAuthenticated: !1,
      isPending: !1,
      profile: void 0,
      providerData: void 0
    });
  };
  onPageLoad = async () => {
    const { data: e, error: t } = await this.client.auth.getSession();
    !t && e.session && await this.updateUserState(e.session);
  };
}
const T = (n) => new f(n);
export {
  T as default
};
//# sourceMappingURL=zudoku.auth-supabase.js.map
