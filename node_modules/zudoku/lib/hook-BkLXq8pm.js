import { d as _ } from "./ZudokuContext-BcqSiygJ.js";
import y from "react";
const E = (t) => {
  let n;
  const e = /* @__PURE__ */ new Set(), s = (i, v) => {
    const h = typeof i == "function" ? i(n) : i;
    if (!Object.is(h, n)) {
      const m = n;
      n = v ?? (typeof h != "object" || h === null) ? h : Object.assign({}, n, h), e.forEach((f) => f(n, m));
    }
  }, a = () => n, c = { setState: s, getState: a, getInitialState: () => d, subscribe: (i) => (e.add(i), () => e.delete(i)) }, d = n = t(s, a, c);
  return c;
}, k = (t) => t ? E(t) : E, j = (t) => t;
function H(t, n = j) {
  const e = y.useSyncExternalStore(
    t.subscribe,
    y.useCallback(() => n(t.getState()), [t, n]),
    y.useCallback(() => n(t.getInitialState()), [t, n])
  );
  return y.useDebugValue(e), e;
}
const L = (t) => {
  const n = k(t), e = (s) => H(n, s);
  return Object.assign(e, n), e;
}, D = (t) => L;
function A(t, n) {
  let e;
  try {
    e = t();
  } catch {
    return;
  }
  return {
    getItem: (a) => {
      var o;
      const g = (d) => d === null ? null : JSON.parse(d, void 0), c = (o = e.getItem(a)) != null ? o : null;
      return c instanceof Promise ? c.then(g) : g(c);
    },
    setItem: (a, o) => e.setItem(a, JSON.stringify(o, void 0)),
    removeItem: (a) => e.removeItem(a)
  };
}
const b = (t) => (n) => {
  try {
    const e = t(n);
    return e instanceof Promise ? e : {
      then(s) {
        return b(s)(e);
      },
      catch(s) {
        return this;
      }
    };
  } catch (e) {
    return {
      then(s) {
        return this;
      },
      catch(s) {
        return b(s)(e);
      }
    };
  }
}, R = (t, n) => (e, s, a) => {
  let o = {
    storage: A(() => localStorage),
    partialize: (r) => r,
    version: 0,
    merge: (r, S) => ({
      ...S,
      ...r
    }),
    ...n
  }, g = !1;
  const c = /* @__PURE__ */ new Set(), d = /* @__PURE__ */ new Set();
  let i = o.storage;
  if (!i)
    return t(
      (...r) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${o.name}', the given storage is currently unavailable.`
        ), e(...r);
      },
      s,
      a
    );
  const v = () => {
    const r = o.partialize({ ...s() });
    return i.setItem(o.name, {
      state: r,
      version: o.version
    });
  }, h = a.setState;
  a.setState = (r, S) => (h(r, S), v());
  const m = t(
    (...r) => (e(...r), v()),
    s,
    a
  );
  a.getInitialState = () => m;
  let f;
  const I = () => {
    var r, S;
    if (!i) return;
    g = !1, c.forEach((u) => {
      var l;
      return u((l = s()) != null ? l : m);
    });
    const p = ((S = o.onRehydrateStorage) == null ? void 0 : S.call(o, (r = s()) != null ? r : m)) || void 0;
    return b(i.getItem.bind(i))(o.name).then((u) => {
      if (u)
        if (typeof u.version == "number" && u.version !== o.version) {
          if (o.migrate) {
            const l = o.migrate(
              u.state,
              u.version
            );
            return l instanceof Promise ? l.then((w) => [!0, w]) : [!0, l];
          }
          console.error(
            "State loaded from storage couldn't be migrated since no migrate function was provided"
          );
        } else
          return [!1, u.state];
      return [!1, void 0];
    }).then((u) => {
      var l;
      const [w, P] = u;
      if (f = o.merge(
        P,
        (l = s()) != null ? l : m
      ), e(f, !0), w)
        return v();
    }).then(() => {
      p?.(f, void 0), f = s(), g = !0, d.forEach((u) => u(f));
    }).catch((u) => {
      p?.(void 0, u);
    });
  };
  return a.persist = {
    setOptions: (r) => {
      o = {
        ...o,
        ...r
      }, r.storage && (i = r.storage);
    },
    clearStorage: () => {
      i?.removeItem(o.name);
    },
    getOptions: () => o,
    rehydrate: () => I(),
    hasHydrated: () => g,
    onHydrate: (r) => (c.add(r), () => {
      c.delete(r);
    }),
    onFinishHydration: (r) => (d.add(r), () => {
      d.delete(r);
    })
  }, o.skipHydration || I(), f || m;
}, C = R, x = (t) => {
  const n = (e) => {
    e.key === t.persist.getOptions().name && e.newValue && t.persist.rehydrate();
  };
  return window.addEventListener("storage", n), () => {
    window.removeEventListener("storage", n);
  };
}, O = D()(
  C(
    (t) => ({
      isAuthenticated: !1,
      isPending: !0,
      profile: null,
      providerData: null,
      setAuthenticationPending: () => t(() => ({
        isAuthenticated: !1,
        isPending: !1,
        profile: null,
        providerData: null
      })),
      setLoggedOut: () => t(() => ({
        isAuthenticated: !1,
        isPending: !1,
        profile: null,
        providerData: null
      })),
      setLoggedIn: ({
        profile: n,
        providerData: e
      }) => t(() => ({
        isAuthenticated: !0,
        isPending: !1,
        profile: n,
        providerData: e
      }))
    }),
    {
      merge: (t, n) => ({
        ...n,
        isPending: !1,
        ...typeof t == "object" ? t : {}
      }),
      name: "auth-state",
      storage: A(() => localStorage)
    }
  )
);
typeof window < "u" && x(O);
const N = () => {
  const { authentication: t } = _(), n = O(), e = typeof t < "u";
  return {
    isAuthEnabled: e,
    ...n,
    login: async () => {
      if (!e)
        throw new Error("Authentication is not enabled.");
      await t.signIn({
        redirectTo: window.location.href
      });
    },
    logout: async () => {
      if (!e)
        throw new Error("Authentication is not enabled.");
      await t.signOut(), window.location.href = "/";
    },
    signup: async () => {
      if (!e)
        throw new Error("Authentication is not enabled.");
      await t.signUp({
        redirectTo: window.location.href
      });
    }
  };
};
export {
  N as a,
  A as b,
  D as c,
  k as d,
  H as e,
  C as p,
  O as u
};
//# sourceMappingURL=hook-BkLXq8pm.js.map
