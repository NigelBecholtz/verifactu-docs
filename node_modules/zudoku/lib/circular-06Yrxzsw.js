import { Q as Qo, t as di, q as ge, n as Ge, v as qo, m as xe, w as Ko, x as Bo, p as Ze, o as xo } from "./index-BRQDtecD.js";
var ye;
(function(e) {
  e.NAME = "Name", e.DOCUMENT = "Document", e.OPERATION_DEFINITION = "OperationDefinition", e.VARIABLE_DEFINITION = "VariableDefinition", e.SELECTION_SET = "SelectionSet", e.FIELD = "Field", e.ARGUMENT = "Argument", e.FRAGMENT_SPREAD = "FragmentSpread", e.INLINE_FRAGMENT = "InlineFragment", e.FRAGMENT_DEFINITION = "FragmentDefinition", e.VARIABLE = "Variable", e.INT = "IntValue", e.FLOAT = "FloatValue", e.STRING = "StringValue", e.BOOLEAN = "BooleanValue", e.NULL = "NullValue", e.ENUM = "EnumValue", e.LIST = "ListValue", e.OBJECT = "ObjectValue", e.OBJECT_FIELD = "ObjectField", e.DIRECTIVE = "Directive", e.NAMED_TYPE = "NamedType", e.LIST_TYPE = "ListType", e.NON_NULL_TYPE = "NonNullType", e.SCHEMA_DEFINITION = "SchemaDefinition", e.OPERATION_TYPE_DEFINITION = "OperationTypeDefinition", e.SCALAR_TYPE_DEFINITION = "ScalarTypeDefinition", e.OBJECT_TYPE_DEFINITION = "ObjectTypeDefinition", e.FIELD_DEFINITION = "FieldDefinition", e.INPUT_VALUE_DEFINITION = "InputValueDefinition", e.INTERFACE_TYPE_DEFINITION = "InterfaceTypeDefinition", e.UNION_TYPE_DEFINITION = "UnionTypeDefinition", e.ENUM_TYPE_DEFINITION = "EnumTypeDefinition", e.ENUM_VALUE_DEFINITION = "EnumValueDefinition", e.INPUT_OBJECT_TYPE_DEFINITION = "InputObjectTypeDefinition", e.DIRECTIVE_DEFINITION = "DirectiveDefinition", e.SCHEMA_EXTENSION = "SchemaExtension", e.SCALAR_TYPE_EXTENSION = "ScalarTypeExtension", e.OBJECT_TYPE_EXTENSION = "ObjectTypeExtension", e.INTERFACE_TYPE_EXTENSION = "InterfaceTypeExtension", e.UNION_TYPE_EXTENSION = "UnionTypeExtension", e.ENUM_TYPE_EXTENSION = "EnumTypeExtension", e.INPUT_OBJECT_TYPE_EXTENSION = "InputObjectTypeExtension";
})(ye || (ye = {}));
const Yo = 5;
function Jo(e, n) {
  const [s, i] = n ? [e, n] : [void 0, e];
  let t = " Did you mean ";
  s && (t += s + " ");
  const r = i.map((u) => `"${u}"`);
  switch (r.length) {
    case 0:
      return "";
    case 1:
      return t + r[0] + "?";
    case 2:
      return t + r[0] + " or " + r[1] + "?";
  }
  const a = r.slice(0, Yo), c = a.pop();
  return t + a.join(", ") + ", or " + c + "?";
}
function fi(e) {
  return e;
}
function zo(e, n) {
  const s = /* @__PURE__ */ Object.create(null);
  for (const i of e)
    s[n(i)] = i;
  return s;
}
function xr(e, n, s) {
  const i = /* @__PURE__ */ Object.create(null);
  for (const t of e)
    i[n(t)] = s(t);
  return i;
}
function Er(e, n) {
  const s = /* @__PURE__ */ Object.create(null);
  for (const i of Object.keys(e))
    s[i] = n(e[i], i);
  return s;
}
function Xo(e, n) {
  let s = 0, i = 0;
  for (; s < e.length && i < n.length; ) {
    let t = e.charCodeAt(s), r = n.charCodeAt(i);
    if (Jn(t) && Jn(r)) {
      let a = 0;
      do
        ++s, a = a * 10 + t - qr, t = e.charCodeAt(s);
      while (Jn(t) && a > 0);
      let c = 0;
      do
        ++i, c = c * 10 + r - qr, r = n.charCodeAt(i);
      while (Jn(r) && c > 0);
      if (a < c)
        return -1;
      if (a > c)
        return 1;
    } else {
      if (t < r)
        return -1;
      if (t > r)
        return 1;
      ++s, ++i;
    }
  }
  return e.length - n.length;
}
const qr = 48, Ho = 57;
function Jn(e) {
  return !isNaN(e) && qr <= e && e <= Ho;
}
function Wo(e, n) {
  const s = /* @__PURE__ */ Object.create(null), i = new Zo(e), t = Math.floor(e.length * 0.4) + 1;
  for (const r of n) {
    const a = i.measure(r, t);
    a !== void 0 && (s[r] = a);
  }
  return Object.keys(s).sort((r, a) => {
    const c = s[r] - s[a];
    return c !== 0 ? c : Xo(r, a);
  });
}
class Zo {
  constructor(n) {
    this._input = n, this._inputLowerCase = n.toLowerCase(), this._inputArray = mi(this._inputLowerCase), this._rows = [
      new Array(n.length + 1).fill(0),
      new Array(n.length + 1).fill(0),
      new Array(n.length + 1).fill(0)
    ];
  }
  measure(n, s) {
    if (this._input === n)
      return 0;
    const i = n.toLowerCase();
    if (this._inputLowerCase === i)
      return 1;
    let t = mi(i), r = this._inputArray;
    if (t.length < r.length) {
      const y = t;
      t = r, r = y;
    }
    const a = t.length, c = r.length;
    if (a - c > s)
      return;
    const u = this._rows;
    for (let y = 0; y <= c; y++)
      u[0][y] = y;
    for (let y = 1; y <= a; y++) {
      const o = u[(y - 1) % 3], p = u[y % 3];
      let h = p[0] = y;
      for (let l = 1; l <= c; l++) {
        const d = t[y - 1] === r[l - 1] ? 0 : 1;
        let m = Math.min(
          o[l] + 1,
          // delete
          p[l - 1] + 1,
          // insert
          o[l - 1] + d
          // substitute
        );
        if (y > 1 && l > 1 && t[y - 1] === r[l - 2] && t[y - 2] === r[l - 1]) {
          const T = u[(y - 2) % 3][l - 2];
          m = Math.min(m, T + 1);
        }
        m < h && (h = m), p[l] = m;
      }
      if (h > s)
        return;
    }
    const f = u[a % 3][c];
    return f <= s ? f : void 0;
  }
}
function mi(e) {
  const n = e.length, s = new Array(n);
  for (let i = 0; i < n; ++i)
    s[i] = e.charCodeAt(i);
  return s;
}
function $e(e) {
  if (e == null)
    return /* @__PURE__ */ Object.create(null);
  if (Object.getPrototypeOf(e) === null)
    return e;
  const n = /* @__PURE__ */ Object.create(null);
  for (const [s, i] of Object.entries(e))
    n[s] = i;
  return n;
}
function eu(e) {
  return `"${e.replace(nu, tu)}"`;
}
const nu = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function tu(e) {
  return ru[e.charCodeAt(0)];
}
const ru = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
], Cn = Object.freeze({});
function iu(e, n, s = Qo) {
  const i = /* @__PURE__ */ new Map();
  for (const T of Object.values(ye))
    i.set(T, Vs(n, T));
  let t, r = Array.isArray(e), a = [e], c = -1, u = [], f = e, y, o;
  const p = [], h = [];
  do {
    c++;
    const T = c === a.length, O = T && u.length !== 0;
    if (T) {
      if (y = h.length === 0 ? void 0 : p[p.length - 1], f = o, o = h.pop(), O)
        if (r) {
          f = f.slice();
          let D = 0;
          for (const [_, w] of u) {
            const $ = _ - D;
            w === null ? (f.splice($, 1), D++) : f[$] = w;
          }
        } else {
          f = { ...f };
          for (const [D, _] of u)
            f[D] = _;
        }
      c = t.index, a = t.keys, u = t.edits, r = t.inArray, t = t.prev;
    } else if (o) {
      if (y = r ? c : a[c], f = o[y], f == null)
        continue;
      p.push(y);
    }
    let R;
    if (!Array.isArray(f)) {
      var l, d;
      di(f) || ge(!1, `Invalid AST Node: ${Ge(f)}.`);
      const D = T ? (l = i.get(f.kind)) === null || l === void 0 ? void 0 : l.leave : (d = i.get(f.kind)) === null || d === void 0 ? void 0 : d.enter;
      if (R = D?.call(n, f, y, o, p, h), R === Cn)
        break;
      if (R === !1) {
        if (!T) {
          p.pop();
          continue;
        }
      } else if (R !== void 0 && (u.push([y, R]), !T))
        if (di(R))
          f = R;
        else {
          p.pop();
          continue;
        }
    }
    if (R === void 0 && O && u.push([y, f]), T)
      p.pop();
    else {
      var m;
      t = {
        inArray: r,
        index: c,
        keys: a,
        edits: u,
        prev: t
      }, r = Array.isArray(f), a = r ? f : (m = s[f.kind]) !== null && m !== void 0 ? m : [], c = -1, u = [], o && h.push(o), o = f;
    }
  } while (t !== void 0);
  return u.length !== 0 ? u[u.length - 1][1] : e;
}
function ic(e) {
  const n = new Array(e.length).fill(null), s = /* @__PURE__ */ Object.create(null);
  for (const i of Object.values(ye)) {
    let t = !1;
    const r = new Array(e.length).fill(void 0), a = new Array(e.length).fill(void 0);
    for (let u = 0; u < e.length; ++u) {
      const { enter: f, leave: y } = Vs(e[u], i);
      t || (t = f != null || y != null), r[u] = f, a[u] = y;
    }
    if (!t)
      continue;
    const c = {
      enter(...u) {
        const f = u[0];
        for (let o = 0; o < e.length; o++)
          if (n[o] === null) {
            var y;
            const p = (y = r[o]) === null || y === void 0 ? void 0 : y.apply(e[o], u);
            if (p === !1)
              n[o] = f;
            else if (p === Cn)
              n[o] = Cn;
            else if (p !== void 0)
              return p;
          }
      },
      leave(...u) {
        const f = u[0];
        for (let o = 0; o < e.length; o++)
          if (n[o] === null) {
            var y;
            const p = (y = a[o]) === null || y === void 0 ? void 0 : y.apply(e[o], u);
            if (p === Cn)
              n[o] = Cn;
            else if (p !== void 0 && p !== !1)
              return p;
          } else n[o] === f && (n[o] = null);
      }
    };
    s[i] = c;
  }
  return s;
}
function Vs(e, n) {
  const s = e[n];
  return typeof s == "object" ? s : typeof s == "function" ? {
    enter: s,
    leave: void 0
  } : {
    enter: e.enter,
    leave: e.leave
  };
}
function gr(e) {
  return iu(e, su);
}
const au = 80, su = {
  Name: {
    leave: (e) => e.value
  },
  Variable: {
    leave: (e) => "$" + e.name
  },
  // Document
  Document: {
    leave: (e) => X(e.definitions, `

`)
  },
  OperationDefinition: {
    leave(e) {
      const n = ie("(", X(e.variableDefinitions, ", "), ")"), s = X(
        [
          e.operation,
          X([e.name, n]),
          X(e.directives, " ")
        ],
        " "
      );
      return (s === "query" ? "" : s + " ") + e.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable: e, type: n, defaultValue: s, directives: i }) => e + ": " + n + ie(" = ", s) + ie(" ", X(i, " "))
  },
  SelectionSet: {
    leave: ({ selections: e }) => ke(e)
  },
  Field: {
    leave({ alias: e, name: n, arguments: s, directives: i, selectionSet: t }) {
      const r = ie("", e, ": ") + n;
      let a = r + ie("(", X(s, ", "), ")");
      return a.length > au && (a = r + ie(`(
`, br(X(s, `
`)), `
)`)), X([a, X(i, " "), t], " ");
    }
  },
  Argument: {
    leave: ({ name: e, value: n }) => e + ": " + n
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name: e, directives: n }) => "..." + e + ie(" ", X(n, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition: e, directives: n, selectionSet: s }) => X(
      [
        "...",
        ie("on ", e),
        X(n, " "),
        s
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name: e, typeCondition: n, variableDefinitions: s, directives: i, selectionSet: t }) => (
      // or removed in the future.
      `fragment ${e}${ie("(", X(s, ", "), ")")} on ${n} ${ie("", X(i, " "), " ")}` + t
    )
  },
  // Value
  IntValue: {
    leave: ({ value: e }) => e
  },
  FloatValue: {
    leave: ({ value: e }) => e
  },
  StringValue: {
    leave: ({ value: e, block: n }) => n ? qo(e) : eu(e)
  },
  BooleanValue: {
    leave: ({ value: e }) => e ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value: e }) => e
  },
  ListValue: {
    leave: ({ values: e }) => "[" + X(e, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields: e }) => "{" + X(e, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name: e, value: n }) => e + ": " + n
  },
  // Directive
  Directive: {
    leave: ({ name: e, arguments: n }) => "@" + e + ie("(", X(n, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name: e }) => e
  },
  ListType: {
    leave: ({ type: e }) => "[" + e + "]"
  },
  NonNullType: {
    leave: ({ type: e }) => e + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description: e, directives: n, operationTypes: s }) => ie("", e, `
`) + X(["schema", X(n, " "), ke(s)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation: e, type: n }) => e + ": " + n
  },
  ScalarTypeDefinition: {
    leave: ({ description: e, name: n, directives: s }) => ie("", e, `
`) + X(["scalar", n, X(s, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description: e, name: n, interfaces: s, directives: i, fields: t }) => ie("", e, `
`) + X(
      [
        "type",
        n,
        ie("implements ", X(s, " & ")),
        X(i, " "),
        ke(t)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description: e, name: n, arguments: s, type: i, directives: t }) => ie("", e, `
`) + n + (yi(s) ? ie(`(
`, br(X(s, `
`)), `
)`) : ie("(", X(s, ", "), ")")) + ": " + i + ie(" ", X(t, " "))
  },
  InputValueDefinition: {
    leave: ({ description: e, name: n, type: s, defaultValue: i, directives: t }) => ie("", e, `
`) + X(
      [n + ": " + s, ie("= ", i), X(t, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description: e, name: n, interfaces: s, directives: i, fields: t }) => ie("", e, `
`) + X(
      [
        "interface",
        n,
        ie("implements ", X(s, " & ")),
        X(i, " "),
        ke(t)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description: e, name: n, directives: s, types: i }) => ie("", e, `
`) + X(
      ["union", n, X(s, " "), ie("= ", X(i, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description: e, name: n, directives: s, values: i }) => ie("", e, `
`) + X(["enum", n, X(s, " "), ke(i)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description: e, name: n, directives: s }) => ie("", e, `
`) + X([n, X(s, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description: e, name: n, directives: s, fields: i }) => ie("", e, `
`) + X(["input", n, X(s, " "), ke(i)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description: e, name: n, arguments: s, repeatable: i, locations: t }) => ie("", e, `
`) + "directive @" + n + (yi(s) ? ie(`(
`, br(X(s, `
`)), `
)`) : ie("(", X(s, ", "), ")")) + (i ? " repeatable" : "") + " on " + X(t, " | ")
  },
  SchemaExtension: {
    leave: ({ directives: e, operationTypes: n }) => X(
      ["extend schema", X(e, " "), ke(n)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name: e, directives: n }) => X(["extend scalar", e, X(n, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name: e, interfaces: n, directives: s, fields: i }) => X(
      [
        "extend type",
        e,
        ie("implements ", X(n, " & ")),
        X(s, " "),
        ke(i)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name: e, interfaces: n, directives: s, fields: i }) => X(
      [
        "extend interface",
        e,
        ie("implements ", X(n, " & ")),
        X(s, " "),
        ke(i)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name: e, directives: n, types: s }) => X(
      [
        "extend union",
        e,
        X(n, " "),
        ie("= ", X(s, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name: e, directives: n, values: s }) => X(["extend enum", e, X(n, " "), ke(s)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name: e, directives: n, fields: s }) => X(["extend input", e, X(n, " "), ke(s)], " ")
  }
};
function X(e, n = "") {
  var s;
  return (s = e?.filter((i) => i).join(n)) !== null && s !== void 0 ? s : "";
}
function ke(e) {
  return ie(`{
`, br(X(e, `
`)), `
}`);
}
function ie(e, n, s = "") {
  return n != null && n !== "" ? e + n + s : "";
}
function br(e) {
  return ie("  ", e.replace(/\n/g, `
  `));
}
function yi(e) {
  var n;
  return (n = e?.some((s) => s.includes(`
`))) !== null && n !== void 0 ? n : !1;
}
function Kr(e, n) {
  switch (e.kind) {
    case ye.NULL:
      return null;
    case ye.INT:
      return parseInt(e.value, 10);
    case ye.FLOAT:
      return parseFloat(e.value);
    case ye.STRING:
    case ye.ENUM:
    case ye.BOOLEAN:
      return e.value;
    case ye.LIST:
      return e.values.map(
        (s) => Kr(s, n)
      );
    case ye.OBJECT:
      return xr(
        e.fields,
        (s) => s.name.value,
        (s) => Kr(s.value, n)
      );
    case ye.VARIABLE:
      return n?.[e.name.value];
  }
}
function Ce(e) {
  if (e != null || ge(!1, "Must provide name."), typeof e == "string" || ge(!1, "Expected name to be a string."), e.length === 0)
    throw new xe("Expected name to be a non-empty string.");
  for (let n = 1; n < e.length; ++n)
    if (!Ko(e.charCodeAt(n)))
      throw new xe(
        `Names must only contain [_a-zA-Z0-9] but "${e}" does not.`
      );
  if (!Bo(e.charCodeAt(0)))
    throw new xe(
      `Names must start with [_a-zA-Z] but "${e}" does not.`
    );
  return e;
}
function ou(e) {
  if (e === "true" || e === "false" || e === "null")
    throw new xe(`Enum values cannot be named: ${e}`);
  return Ce(e);
}
function Gs(e) {
  return Un(e) || Nr(e) || Qn(e) || qn(e) || Kn(e) || Yr(e) || Ms(e) || Nn(e);
}
function Un(e) {
  return Ze(e, zr);
}
function Nr(e) {
  return Ze(e, fu);
}
function Qn(e) {
  return Ze(e, hu);
}
function qn(e) {
  return Ze(e, vu);
}
function Kn(e) {
  return Ze(e, bu);
}
function Yr(e) {
  return Ze(e, gu);
}
function Ms(e) {
  return Ze(e, lu);
}
function Nn(e) {
  return Ze(e, pu);
}
function uu(e) {
  return Un(e) || Kn(e) || Yr(e) || Jr(e) && uu(e.ofType);
}
function cu(e) {
  return Un(e) || Nr(e) || Qn(e) || qn(e) || Kn(e) || Jr(e) && cu(e.ofType);
}
function ac(e) {
  return Un(e) || Kn(e);
}
function sc(e) {
  return Nr(e) || Qn(e) || qn(e);
}
function oc(e) {
  return Qn(e) || qn(e);
}
class lu {
  constructor(n) {
    Gs(n) || ge(!1, `Expected ${Ge(n)} to be a GraphQL type.`), this.ofType = n;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLList";
  }
  toString() {
    return "[" + String(this.ofType) + "]";
  }
  toJSON() {
    return this.toString();
  }
}
class pu {
  constructor(n) {
    du(n) || ge(
      !1,
      `Expected ${Ge(n)} to be a GraphQL nullable type.`
    ), this.ofType = n;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLNonNull";
  }
  toString() {
    return String(this.ofType) + "!";
  }
  toJSON() {
    return this.toString();
  }
}
function Jr(e) {
  return Ms(e) || Nn(e);
}
function du(e) {
  return Gs(e) && !Nn(e);
}
function uc(e) {
  if (e)
    return Nn(e) ? e.ofType : e;
}
function cc(e) {
  return Un(e) || Nr(e) || Qn(e) || qn(e) || Kn(e) || Yr(e);
}
function lc(e) {
  if (e) {
    let n = e;
    for (; Jr(n); )
      n = n.ofType;
    return n;
  }
}
function $s(e) {
  return typeof e == "function" ? e() : e;
}
function Cs(e) {
  return typeof e == "function" ? e() : e;
}
class zr {
  constructor(n) {
    var s, i, t, r;
    const a = (s = n.parseValue) !== null && s !== void 0 ? s : fi;
    this.name = Ce(n.name), this.description = n.description, this.specifiedByURL = n.specifiedByURL, this.serialize = (i = n.serialize) !== null && i !== void 0 ? i : fi, this.parseValue = a, this.parseLiteral = (t = n.parseLiteral) !== null && t !== void 0 ? t : (c, u) => a(Kr(c, u)), this.extensions = $e(n.extensions), this.astNode = n.astNode, this.extensionASTNodes = (r = n.extensionASTNodes) !== null && r !== void 0 ? r : [], n.specifiedByURL == null || typeof n.specifiedByURL == "string" || ge(
      !1,
      `${this.name} must provide "specifiedByURL" as a string, but got: ${Ge(n.specifiedByURL)}.`
    ), n.serialize == null || typeof n.serialize == "function" || ge(
      !1,
      `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`
    ), n.parseLiteral && (typeof n.parseValue == "function" && typeof n.parseLiteral == "function" || ge(
      !1,
      `${this.name} must provide both "parseValue" and "parseLiteral" functions.`
    ));
  }
  get [Symbol.toStringTag]() {
    return "GraphQLScalarType";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      specifiedByURL: this.specifiedByURL,
      serialize: this.serialize,
      parseValue: this.parseValue,
      parseLiteral: this.parseLiteral,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
class fu {
  constructor(n) {
    var s;
    this.name = Ce(n.name), this.description = n.description, this.isTypeOf = n.isTypeOf, this.extensions = $e(n.extensions), this.astNode = n.astNode, this.extensionASTNodes = (s = n.extensionASTNodes) !== null && s !== void 0 ? s : [], this._fields = () => Qs(n), this._interfaces = () => Us(n), n.isTypeOf == null || typeof n.isTypeOf == "function" || ge(
      !1,
      `${this.name} must provide "isTypeOf" as a function, but got: ${Ge(n.isTypeOf)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLObjectType";
  }
  getFields() {
    return typeof this._fields == "function" && (this._fields = this._fields()), this._fields;
  }
  getInterfaces() {
    return typeof this._interfaces == "function" && (this._interfaces = this._interfaces()), this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: qs(this.getFields()),
      isTypeOf: this.isTypeOf,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
function Us(e) {
  var n;
  const s = $s(
    (n = e.interfaces) !== null && n !== void 0 ? n : []
  );
  return Array.isArray(s) || ge(
    !1,
    `${e.name} interfaces must be an Array or a function which returns an Array.`
  ), s;
}
function Qs(e) {
  const n = Cs(e.fields);
  return En(n) || ge(
    !1,
    `${e.name} fields must be an object with field names as keys or a function which returns such an object.`
  ), Er(n, (s, i) => {
    var t;
    En(s) || ge(
      !1,
      `${e.name}.${i} field config must be an object.`
    ), s.resolve == null || typeof s.resolve == "function" || ge(
      !1,
      `${e.name}.${i} field resolver must be a function if provided, but got: ${Ge(s.resolve)}.`
    );
    const r = (t = s.args) !== null && t !== void 0 ? t : {};
    return En(r) || ge(
      !1,
      `${e.name}.${i} args must be an object with argument names as keys.`
    ), {
      name: Ce(i),
      description: s.description,
      type: s.type,
      args: mu(r),
      resolve: s.resolve,
      subscribe: s.subscribe,
      deprecationReason: s.deprecationReason,
      extensions: $e(s.extensions),
      astNode: s.astNode
    };
  });
}
function mu(e) {
  return Object.entries(e).map(([n, s]) => ({
    name: Ce(n),
    description: s.description,
    type: s.type,
    defaultValue: s.defaultValue,
    deprecationReason: s.deprecationReason,
    extensions: $e(s.extensions),
    astNode: s.astNode
  }));
}
function En(e) {
  return xo(e) && !Array.isArray(e);
}
function qs(e) {
  return Er(e, (n) => ({
    description: n.description,
    type: n.type,
    args: yu(n.args),
    resolve: n.resolve,
    subscribe: n.subscribe,
    deprecationReason: n.deprecationReason,
    extensions: n.extensions,
    astNode: n.astNode
  }));
}
function yu(e) {
  return xr(
    e,
    (n) => n.name,
    (n) => ({
      description: n.description,
      type: n.type,
      defaultValue: n.defaultValue,
      deprecationReason: n.deprecationReason,
      extensions: n.extensions,
      astNode: n.astNode
    })
  );
}
function pc(e) {
  return Nn(e.type) && e.defaultValue === void 0;
}
class hu {
  constructor(n) {
    var s;
    this.name = Ce(n.name), this.description = n.description, this.resolveType = n.resolveType, this.extensions = $e(n.extensions), this.astNode = n.astNode, this.extensionASTNodes = (s = n.extensionASTNodes) !== null && s !== void 0 ? s : [], this._fields = Qs.bind(void 0, n), this._interfaces = Us.bind(void 0, n), n.resolveType == null || typeof n.resolveType == "function" || ge(
      !1,
      `${this.name} must provide "resolveType" as a function, but got: ${Ge(n.resolveType)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInterfaceType";
  }
  getFields() {
    return typeof this._fields == "function" && (this._fields = this._fields()), this._fields;
  }
  getInterfaces() {
    return typeof this._interfaces == "function" && (this._interfaces = this._interfaces()), this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: qs(this.getFields()),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
class vu {
  constructor(n) {
    var s;
    this.name = Ce(n.name), this.description = n.description, this.resolveType = n.resolveType, this.extensions = $e(n.extensions), this.astNode = n.astNode, this.extensionASTNodes = (s = n.extensionASTNodes) !== null && s !== void 0 ? s : [], this._types = Tu.bind(void 0, n), n.resolveType == null || typeof n.resolveType == "function" || ge(
      !1,
      `${this.name} must provide "resolveType" as a function, but got: ${Ge(n.resolveType)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLUnionType";
  }
  getTypes() {
    return typeof this._types == "function" && (this._types = this._types()), this._types;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      types: this.getTypes(),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
function Tu(e) {
  const n = $s(e.types);
  return Array.isArray(n) || ge(
    !1,
    `Must provide Array of types or a function which returns such an array for Union ${e.name}.`
  ), n;
}
class bu {
  /* <T> */
  constructor(n) {
    var s;
    this.name = Ce(n.name), this.description = n.description, this.extensions = $e(n.extensions), this.astNode = n.astNode, this.extensionASTNodes = (s = n.extensionASTNodes) !== null && s !== void 0 ? s : [], this._values = typeof n.values == "function" ? n.values : hi(this.name, n.values), this._valueLookup = null, this._nameLookup = null;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLEnumType";
  }
  getValues() {
    return typeof this._values == "function" && (this._values = hi(this.name, this._values())), this._values;
  }
  getValue(n) {
    return this._nameLookup === null && (this._nameLookup = zo(this.getValues(), (s) => s.name)), this._nameLookup[n];
  }
  serialize(n) {
    this._valueLookup === null && (this._valueLookup = new Map(
      this.getValues().map((i) => [i.value, i])
    ));
    const s = this._valueLookup.get(n);
    if (s === void 0)
      throw new xe(
        `Enum "${this.name}" cannot represent value: ${Ge(n)}`
      );
    return s.name;
  }
  parseValue(n) {
    if (typeof n != "string") {
      const i = Ge(n);
      throw new xe(
        `Enum "${this.name}" cannot represent non-string value: ${i}.` + zn(this, i)
      );
    }
    const s = this.getValue(n);
    if (s == null)
      throw new xe(
        `Value "${n}" does not exist in "${this.name}" enum.` + zn(this, n)
      );
    return s.value;
  }
  parseLiteral(n, s) {
    if (n.kind !== ye.ENUM) {
      const t = gr(n);
      throw new xe(
        `Enum "${this.name}" cannot represent non-enum value: ${t}.` + zn(this, t),
        {
          nodes: n
        }
      );
    }
    const i = this.getValue(n.value);
    if (i == null) {
      const t = gr(n);
      throw new xe(
        `Value "${t}" does not exist in "${this.name}" enum.` + zn(this, t),
        {
          nodes: n
        }
      );
    }
    return i.value;
  }
  toConfig() {
    const n = xr(
      this.getValues(),
      (s) => s.name,
      (s) => ({
        description: s.description,
        value: s.value,
        deprecationReason: s.deprecationReason,
        extensions: s.extensions,
        astNode: s.astNode
      })
    );
    return {
      name: this.name,
      description: this.description,
      values: n,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
function zn(e, n) {
  const s = e.getValues().map((t) => t.name), i = Wo(n, s);
  return Jo("the enum value", i);
}
function hi(e, n) {
  return En(n) || ge(
    !1,
    `${e} values must be an object with value names as keys.`
  ), Object.entries(n).map(([s, i]) => (En(i) || ge(
    !1,
    `${e}.${s} must refer to an object with a "value" key representing an internal value but got: ${Ge(i)}.`
  ), {
    name: ou(s),
    description: i.description,
    value: i.value !== void 0 ? i.value : s,
    deprecationReason: i.deprecationReason,
    extensions: $e(i.extensions),
    astNode: i.astNode
  }));
}
class gu {
  constructor(n) {
    var s, i;
    this.name = Ce(n.name), this.description = n.description, this.extensions = $e(n.extensions), this.astNode = n.astNode, this.extensionASTNodes = (s = n.extensionASTNodes) !== null && s !== void 0 ? s : [], this.isOneOf = (i = n.isOneOf) !== null && i !== void 0 ? i : !1, this._fields = Eu.bind(void 0, n);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInputObjectType";
  }
  getFields() {
    return typeof this._fields == "function" && (this._fields = this._fields()), this._fields;
  }
  toConfig() {
    const n = Er(this.getFields(), (s) => ({
      description: s.description,
      type: s.type,
      defaultValue: s.defaultValue,
      deprecationReason: s.deprecationReason,
      extensions: s.extensions,
      astNode: s.astNode
    }));
    return {
      name: this.name,
      description: this.description,
      fields: n,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes,
      isOneOf: this.isOneOf
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
function Eu(e) {
  const n = Cs(e.fields);
  return En(n) || ge(
    !1,
    `${e.name} fields must be an object with field names as keys or a function which returns such an object.`
  ), Er(n, (s, i) => (!("resolve" in s) || ge(
    !1,
    `${e.name}.${i} field has a resolve property, but Input Types cannot define resolvers.`
  ), {
    name: Ce(i),
    description: s.description,
    type: s.type,
    defaultValue: s.defaultValue,
    deprecationReason: s.deprecationReason,
    extensions: $e(s.extensions),
    astNode: s.astNode
  }));
}
function dc(e) {
  return Nn(e.type) && e.defaultValue === void 0;
}
function vi(e) {
  return e;
}
function Ti(e) {
  if (typeof e != "object" || e === null || Array.isArray(e))
    throw new TypeError("JSONObject cannot represent non-object value: " + e);
  return e;
}
function Ks(e, n, s) {
  var i = /* @__PURE__ */ Object.create(null);
  return n.fields.forEach(function(t) {
    i[t.name.value] = Xr(e, t.value, s);
  }), i;
}
function Xr(e, n, s) {
  switch (n.kind) {
    case ye.STRING:
    case ye.BOOLEAN:
      return n.value;
    case ye.INT:
    case ye.FLOAT:
      return parseFloat(n.value);
    case ye.OBJECT:
      return Ks(e, n, s);
    case ye.LIST:
      return n.values.map(function(i) {
        return Xr(e, i, s);
      });
    case ye.NULL:
      return null;
    case ye.VARIABLE:
      return s ? s[n.name.value] : void 0;
    default:
      throw new TypeError(e + " cannot represent value: " + gr(n));
  }
}
var bi = new zr({
  name: "JSON",
  description: "The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).",
  specifiedByUrl: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf",
  serialize: vi,
  parseValue: vi,
  parseLiteral: function(n, s) {
    return Xr("JSON", n, s);
  }
}), fc = new zr({
  name: "JSONObject",
  description: "The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).",
  specifiedByUrl: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf",
  serialize: Ti,
  parseValue: Ti,
  parseLiteral: function(n, s) {
    if (n.kind !== ye.OBJECT)
      throw new TypeError("JSONObject cannot represent non-object value: " + gr(n));
    return Ks("JSONObject", n, s);
  }
}), Vr = {}, nn = {}, Xn = {}, gi;
function Ye() {
  if (gi) return Xn;
  gi = 1, Object.defineProperty(Xn, "__esModule", {
    value: !0
  }), Xn.isObjectLike = e;
  function e(n) {
    return typeof n == "object" && n !== null;
  }
  return Xn;
}
var Hn = {}, Wn = {}, Ei;
function Se() {
  if (Ei) return Wn;
  Ei = 1, Object.defineProperty(Wn, "__esModule", {
    value: !0
  }), Wn.invariant = e;
  function e(n, s) {
    if (!!!n)
      throw new Error(
        s ?? "Unexpected invariant triggered."
      );
  }
  return Wn;
}
var Ni;
function Hr() {
  if (Ni) return Hn;
  Ni = 1, Object.defineProperty(Hn, "__esModule", {
    value: !0
  }), Hn.getLocation = s;
  var e = /* @__PURE__ */ Se();
  const n = /\r\n|[\n\r]/g;
  function s(i, t) {
    let r = 0, a = 1;
    for (const c of i.body.matchAll(n)) {
      if (typeof c.index == "number" || (0, e.invariant)(!1), c.index >= t)
        break;
      r = c.index + c[0].length, a += 1;
    }
    return {
      line: a,
      column: t + 1 - r
    };
  }
  return Hn;
}
var Sn = {}, Oi;
function Bs() {
  if (Oi) return Sn;
  Oi = 1, Object.defineProperty(Sn, "__esModule", {
    value: !0
  }), Sn.printLocation = n, Sn.printSourceLocation = s;
  var e = /* @__PURE__ */ Hr();
  function n(t) {
    return s(
      t.source,
      (0, e.getLocation)(t.source, t.start)
    );
  }
  function s(t, r) {
    const a = t.locationOffset.column - 1, c = "".padStart(a) + t.body, u = r.line - 1, f = t.locationOffset.line - 1, y = r.line + f, o = r.line === 1 ? a : 0, p = r.column + o, h = `${t.name}:${y}:${p}
`, l = c.split(/\r\n|[\n\r]/g), d = l[u];
    if (d.length > 120) {
      const m = Math.floor(p / 80), T = p % 80, O = [];
      for (let R = 0; R < d.length; R += 80)
        O.push(d.slice(R, R + 80));
      return h + i([
        [`${y} |`, O[0]],
        ...O.slice(1, m + 1).map((R) => ["|", R]),
        ["|", "^".padStart(T)],
        ["|", O[m + 1]]
      ]);
    }
    return h + i([
      // Lines specified like this: ["prefix", "string"],
      [`${y - 1} |`, l[u - 1]],
      [`${y} |`, d],
      ["|", "^".padStart(p)],
      [`${y + 1} |`, l[u + 1]]
    ]);
  }
  function i(t) {
    const r = t.filter(([c, u]) => u !== void 0), a = Math.max(...r.map(([c]) => c.length));
    return r.map(([c, u]) => c.padStart(a) + (u ? " " + u : "")).join(`
`);
  }
  return Sn;
}
var _i;
function ne() {
  if (_i) return nn;
  _i = 1, Object.defineProperty(nn, "__esModule", {
    value: !0
  }), nn.GraphQLError = void 0, nn.formatError = c, nn.printError = a;
  var e = /* @__PURE__ */ Ye(), n = /* @__PURE__ */ Hr(), s = /* @__PURE__ */ Bs();
  function i(u) {
    const f = u[0];
    return f == null || "kind" in f || "length" in f ? {
      nodes: f,
      source: u[1],
      positions: u[2],
      path: u[3],
      originalError: u[4],
      extensions: u[5]
    } : f;
  }
  let t = class xs extends Error {
    /**
     * An array of `{ line, column }` locations within the source GraphQL document
     * which correspond to this error.
     *
     * Errors during validation often contain multiple locations, for example to
     * point out two things with the same name. Errors during execution include a
     * single location, the field which produced the error.
     *
     * Enumerable, and appears in the result of JSON.stringify().
     */
    /**
     * An array describing the JSON-path into the execution response which
     * corresponds to this error. Only included for errors during execution.
     *
     * Enumerable, and appears in the result of JSON.stringify().
     */
    /**
     * An array of GraphQL AST Nodes corresponding to this error.
     */
    /**
     * The source GraphQL document for the first location of this error.
     *
     * Note that if this Error represents more than one node, the source may not
     * represent nodes after the first node.
     */
    /**
     * An array of character offsets within the source GraphQL document
     * which correspond to this error.
     */
    /**
     * The original error thrown from a field resolver during execution.
     */
    /**
     * Extension fields to add to the formatted error.
     */
    /**
     * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
     */
    constructor(f, ...y) {
      var o, p, h;
      const { nodes: l, source: d, positions: m, path: T, originalError: O, extensions: R } = i(y);
      super(f), this.name = "GraphQLError", this.path = T ?? void 0, this.originalError = O ?? void 0, this.nodes = r(
        Array.isArray(l) ? l : l ? [l] : void 0
      );
      const D = r(
        (o = this.nodes) === null || o === void 0 ? void 0 : o.map((w) => w.loc).filter((w) => w != null)
      );
      this.source = d ?? (D == null || (p = D[0]) === null || p === void 0 ? void 0 : p.source), this.positions = m ?? D?.map((w) => w.start), this.locations = m && d ? m.map((w) => (0, n.getLocation)(d, w)) : D?.map(
        (w) => (0, n.getLocation)(w.source, w.start)
      );
      const _ = (0, e.isObjectLike)(
        O?.extensions
      ) ? O?.extensions : void 0;
      this.extensions = (h = R ?? _) !== null && h !== void 0 ? h : /* @__PURE__ */ Object.create(null), Object.defineProperties(this, {
        message: {
          writable: !0,
          enumerable: !0
        },
        name: {
          enumerable: !1
        },
        nodes: {
          enumerable: !1
        },
        source: {
          enumerable: !1
        },
        positions: {
          enumerable: !1
        },
        originalError: {
          enumerable: !1
        }
      }), O != null && O.stack ? Object.defineProperty(this, "stack", {
        value: O.stack,
        writable: !0,
        configurable: !0
      }) : Error.captureStackTrace ? Error.captureStackTrace(this, xs) : Object.defineProperty(this, "stack", {
        value: Error().stack,
        writable: !0,
        configurable: !0
      });
    }
    get [Symbol.toStringTag]() {
      return "GraphQLError";
    }
    toString() {
      let f = this.message;
      if (this.nodes)
        for (const y of this.nodes)
          y.loc && (f += `

` + (0, s.printLocation)(y.loc));
      else if (this.source && this.locations)
        for (const y of this.locations)
          f += `

` + (0, s.printSourceLocation)(this.source, y);
      return f;
    }
    toJSON() {
      const f = {
        message: this.message
      };
      return this.locations != null && (f.locations = this.locations), this.path != null && (f.path = this.path), this.extensions != null && Object.keys(this.extensions).length > 0 && (f.extensions = this.extensions), f;
    }
  };
  nn.GraphQLError = t;
  function r(u) {
    return u === void 0 || u.length === 0 ? void 0 : u;
  }
  function a(u) {
    return u.toString();
  }
  function c(u) {
    return u.toJSON();
  }
  return nn;
}
var Zn = {}, Ii;
function Wr() {
  if (Ii) return Zn;
  Ii = 1, Object.defineProperty(Zn, "__esModule", {
    value: !0
  }), Zn.syntaxError = n;
  var e = /* @__PURE__ */ ne();
  function n(s, i, t) {
    return new e.GraphQLError(`Syntax Error: ${t}`, {
      source: s,
      positions: [i]
    });
  }
  return Zn;
}
var et = {}, nt = {}, tt = {}, Li;
function de() {
  if (Li) return tt;
  Li = 1, Object.defineProperty(tt, "__esModule", {
    value: !0
  }), tt.inspect = s;
  const e = 10, n = 2;
  function s(f) {
    return i(f, []);
  }
  function i(f, y) {
    switch (typeof f) {
      case "string":
        return JSON.stringify(f);
      case "function":
        return f.name ? `[function ${f.name}]` : "[function]";
      case "object":
        return t(f, y);
      default:
        return String(f);
    }
  }
  function t(f, y) {
    if (f === null)
      return "null";
    if (y.includes(f))
      return "[Circular]";
    const o = [...y, f];
    if (r(f)) {
      const p = f.toJSON();
      if (p !== f)
        return typeof p == "string" ? p : i(p, o);
    } else if (Array.isArray(f))
      return c(f, o);
    return a(f, o);
  }
  function r(f) {
    return typeof f.toJSON == "function";
  }
  function a(f, y) {
    const o = Object.entries(f);
    return o.length === 0 ? "{}" : y.length > n ? "[" + u(f) + "]" : "{ " + o.map(
      ([h, l]) => h + ": " + i(l, y)
    ).join(", ") + " }";
  }
  function c(f, y) {
    if (f.length === 0)
      return "[]";
    if (y.length > n)
      return "[Array]";
    const o = Math.min(e, f.length), p = f.length - o, h = [];
    for (let l = 0; l < o; ++l)
      h.push(i(f[l], y));
    return p === 1 ? h.push("... 1 more item") : p > 1 && h.push(`... ${p} more items`), "[" + h.join(", ") + "]";
  }
  function u(f) {
    const y = Object.prototype.toString.call(f).replace(/^\[object /, "").replace(/]$/, "");
    if (y === "Object" && typeof f.constructor == "function") {
      const o = f.constructor.name;
      if (typeof o == "string" && o !== "")
        return o;
    }
    return y;
  }
  return tt;
}
var Si;
function Nu() {
  if (Si) return nt;
  Si = 1, Object.defineProperty(nt, "__esModule", {
    value: !0
  }), nt.toError = n;
  var e = /* @__PURE__ */ de();
  function n(i) {
    return i instanceof Error ? i : new s(i);
  }
  class s extends Error {
    constructor(t) {
      super("Unexpected error value: " + (0, e.inspect)(t)), this.name = "NonErrorThrown", this.thrownValue = t;
    }
  }
  return nt;
}
var Ri;
function Zr() {
  if (Ri) return et;
  Ri = 1, Object.defineProperty(et, "__esModule", {
    value: !0
  }), et.locatedError = s;
  var e = /* @__PURE__ */ Nu(), n = /* @__PURE__ */ ne();
  function s(t, r, a) {
    var c;
    const u = (0, e.toError)(t);
    return i(u) ? u : new n.GraphQLError(u.message, {
      nodes: (c = u.nodes) !== null && c !== void 0 ? c : r,
      source: u.source,
      positions: u.positions,
      path: a,
      originalError: u
    });
  }
  function i(t) {
    return Array.isArray(t.path);
  }
  return et;
}
var Di;
function Ou() {
  return Di || (Di = 1, function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "GraphQLError", {
      enumerable: !0,
      get: function() {
        return n.GraphQLError;
      }
    }), Object.defineProperty(e, "formatError", {
      enumerable: !0,
      get: function() {
        return n.formatError;
      }
    }), Object.defineProperty(e, "locatedError", {
      enumerable: !0,
      get: function() {
        return i.locatedError;
      }
    }), Object.defineProperty(e, "printError", {
      enumerable: !0,
      get: function() {
        return n.printError;
      }
    }), Object.defineProperty(e, "syntaxError", {
      enumerable: !0,
      get: function() {
        return s.syntaxError;
      }
    });
    var n = /* @__PURE__ */ ne(), s = /* @__PURE__ */ Wr(), i = /* @__PURE__ */ Zr();
  }(Vr)), Vr;
}
var Gr = {}, tn = {}, Ai;
function _u() {
  if (Ai) return tn;
  Ai = 1, Object.defineProperty(tn, "__esModule", {
    value: !0
  }), tn.versionInfo = tn.version = void 0;
  const e = "16.11.0";
  tn.version = e;
  const n = Object.freeze({
    major: 16,
    minor: 11,
    patch: 0,
    preReleaseTag: null
  });
  return tn.versionInfo = n, tn;
}
var Rn = {}, rt = {}, ji;
function Re() {
  if (ji) return rt;
  ji = 1, Object.defineProperty(rt, "__esModule", {
    value: !0
  }), rt.devAssert = e;
  function e(n, s) {
    if (!!!n)
      throw new Error(s);
  }
  return rt;
}
var it = {}, Pi;
function ei() {
  if (Pi) return it;
  Pi = 1, Object.defineProperty(it, "__esModule", {
    value: !0
  }), it.isPromise = e;
  function e(n) {
    return typeof n?.then == "function";
  }
  return it;
}
var Qe = {}, De = {}, Fi;
function Je() {
  if (Fi) return De;
  Fi = 1, Object.defineProperty(De, "__esModule", {
    value: !0
  }), De.Token = De.QueryDocumentKeys = De.OperationTypeNode = De.Location = void 0, De.isNode = t;
  class e {
    /**
     * The character offset at which this Node begins.
     */
    /**
     * The character offset at which this Node ends.
     */
    /**
     * The Token at which this Node begins.
     */
    /**
     * The Token at which this Node ends.
     */
    /**
     * The Source document the AST represents.
     */
    constructor(c, u, f) {
      this.start = c.start, this.end = u.end, this.startToken = c, this.endToken = u, this.source = f;
    }
    get [Symbol.toStringTag]() {
      return "Location";
    }
    toJSON() {
      return {
        start: this.start,
        end: this.end
      };
    }
  }
  De.Location = e;
  class n {
    /**
     * The kind of Token.
     */
    /**
     * The character offset at which this Node begins.
     */
    /**
     * The character offset at which this Node ends.
     */
    /**
     * The 1-indexed line number on which this Token appears.
     */
    /**
     * The 1-indexed column number at which this Token begins.
     */
    /**
     * For non-punctuation tokens, represents the interpreted value of the token.
     *
     * Note: is undefined for punctuation tokens, but typed as string for
     * convenience in the parser.
     */
    /**
     * Tokens exist as nodes in a double-linked-list amongst all tokens
     * including ignored tokens. <SOF> is always the first node and <EOF>
     * the last.
     */
    constructor(c, u, f, y, o, p) {
      this.kind = c, this.start = u, this.end = f, this.line = y, this.column = o, this.value = p, this.prev = null, this.next = null;
    }
    get [Symbol.toStringTag]() {
      return "Token";
    }
    toJSON() {
      return {
        kind: this.kind,
        value: this.value,
        line: this.line,
        column: this.column
      };
    }
  }
  De.Token = n;
  const s = {
    Name: [],
    Document: ["definitions"],
    OperationDefinition: [
      "name",
      "variableDefinitions",
      "directives",
      "selectionSet"
    ],
    VariableDefinition: ["variable", "type", "defaultValue", "directives"],
    Variable: ["name"],
    SelectionSet: ["selections"],
    Field: ["alias", "name", "arguments", "directives", "selectionSet"],
    Argument: ["name", "value"],
    FragmentSpread: ["name", "directives"],
    InlineFragment: ["typeCondition", "directives", "selectionSet"],
    FragmentDefinition: [
      "name",
      // Note: fragment variable definitions are deprecated and will removed in v17.0.0
      "variableDefinitions",
      "typeCondition",
      "directives",
      "selectionSet"
    ],
    IntValue: [],
    FloatValue: [],
    StringValue: [],
    BooleanValue: [],
    NullValue: [],
    EnumValue: [],
    ListValue: ["values"],
    ObjectValue: ["fields"],
    ObjectField: ["name", "value"],
    Directive: ["name", "arguments"],
    NamedType: ["name"],
    ListType: ["type"],
    NonNullType: ["type"],
    SchemaDefinition: ["description", "directives", "operationTypes"],
    OperationTypeDefinition: ["type"],
    ScalarTypeDefinition: ["description", "name", "directives"],
    ObjectTypeDefinition: [
      "description",
      "name",
      "interfaces",
      "directives",
      "fields"
    ],
    FieldDefinition: ["description", "name", "arguments", "type", "directives"],
    InputValueDefinition: [
      "description",
      "name",
      "type",
      "defaultValue",
      "directives"
    ],
    InterfaceTypeDefinition: [
      "description",
      "name",
      "interfaces",
      "directives",
      "fields"
    ],
    UnionTypeDefinition: ["description", "name", "directives", "types"],
    EnumTypeDefinition: ["description", "name", "directives", "values"],
    EnumValueDefinition: ["description", "name", "directives"],
    InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
    DirectiveDefinition: ["description", "name", "arguments", "locations"],
    SchemaExtension: ["directives", "operationTypes"],
    ScalarTypeExtension: ["name", "directives"],
    ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
    InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
    UnionTypeExtension: ["name", "directives", "types"],
    EnumTypeExtension: ["name", "directives", "values"],
    InputObjectTypeExtension: ["name", "directives", "fields"]
  };
  De.QueryDocumentKeys = s;
  const i = new Set(Object.keys(s));
  function t(a) {
    const c = a?.kind;
    return typeof c == "string" && i.has(c);
  }
  var r;
  return De.OperationTypeNode = r, function(a) {
    a.QUERY = "query", a.MUTATION = "mutation", a.SUBSCRIPTION = "subscription";
  }(r || (De.OperationTypeNode = r = {})), De;
}
var pn = {}, wi;
function Bn() {
  if (wi) return pn;
  wi = 1, Object.defineProperty(pn, "__esModule", {
    value: !0
  }), pn.DirectiveLocation = void 0;
  var e;
  return pn.DirectiveLocation = e, function(n) {
    n.QUERY = "QUERY", n.MUTATION = "MUTATION", n.SUBSCRIPTION = "SUBSCRIPTION", n.FIELD = "FIELD", n.FRAGMENT_DEFINITION = "FRAGMENT_DEFINITION", n.FRAGMENT_SPREAD = "FRAGMENT_SPREAD", n.INLINE_FRAGMENT = "INLINE_FRAGMENT", n.VARIABLE_DEFINITION = "VARIABLE_DEFINITION", n.SCHEMA = "SCHEMA", n.SCALAR = "SCALAR", n.OBJECT = "OBJECT", n.FIELD_DEFINITION = "FIELD_DEFINITION", n.ARGUMENT_DEFINITION = "ARGUMENT_DEFINITION", n.INTERFACE = "INTERFACE", n.UNION = "UNION", n.ENUM = "ENUM", n.ENUM_VALUE = "ENUM_VALUE", n.INPUT_OBJECT = "INPUT_OBJECT", n.INPUT_FIELD_DEFINITION = "INPUT_FIELD_DEFINITION";
  }(e || (pn.DirectiveLocation = e = {})), pn;
}
var dn = {}, ki;
function se() {
  if (ki) return dn;
  ki = 1, Object.defineProperty(dn, "__esModule", {
    value: !0
  }), dn.Kind = void 0;
  var e;
  return dn.Kind = e, function(n) {
    n.NAME = "Name", n.DOCUMENT = "Document", n.OPERATION_DEFINITION = "OperationDefinition", n.VARIABLE_DEFINITION = "VariableDefinition", n.SELECTION_SET = "SelectionSet", n.FIELD = "Field", n.ARGUMENT = "Argument", n.FRAGMENT_SPREAD = "FragmentSpread", n.INLINE_FRAGMENT = "InlineFragment", n.FRAGMENT_DEFINITION = "FragmentDefinition", n.VARIABLE = "Variable", n.INT = "IntValue", n.FLOAT = "FloatValue", n.STRING = "StringValue", n.BOOLEAN = "BooleanValue", n.NULL = "NullValue", n.ENUM = "EnumValue", n.LIST = "ListValue", n.OBJECT = "ObjectValue", n.OBJECT_FIELD = "ObjectField", n.DIRECTIVE = "Directive", n.NAMED_TYPE = "NamedType", n.LIST_TYPE = "ListType", n.NON_NULL_TYPE = "NonNullType", n.SCHEMA_DEFINITION = "SchemaDefinition", n.OPERATION_TYPE_DEFINITION = "OperationTypeDefinition", n.SCALAR_TYPE_DEFINITION = "ScalarTypeDefinition", n.OBJECT_TYPE_DEFINITION = "ObjectTypeDefinition", n.FIELD_DEFINITION = "FieldDefinition", n.INPUT_VALUE_DEFINITION = "InputValueDefinition", n.INTERFACE_TYPE_DEFINITION = "InterfaceTypeDefinition", n.UNION_TYPE_DEFINITION = "UnionTypeDefinition", n.ENUM_TYPE_DEFINITION = "EnumTypeDefinition", n.ENUM_VALUE_DEFINITION = "EnumValueDefinition", n.INPUT_OBJECT_TYPE_DEFINITION = "InputObjectTypeDefinition", n.DIRECTIVE_DEFINITION = "DirectiveDefinition", n.SCHEMA_EXTENSION = "SchemaExtension", n.SCALAR_TYPE_EXTENSION = "ScalarTypeExtension", n.OBJECT_TYPE_EXTENSION = "ObjectTypeExtension", n.INTERFACE_TYPE_EXTENSION = "InterfaceTypeExtension", n.UNION_TYPE_EXTENSION = "UnionTypeExtension", n.ENUM_TYPE_EXTENSION = "EnumTypeExtension", n.INPUT_OBJECT_TYPE_EXTENSION = "InputObjectTypeExtension";
  }(e || (dn.Kind = e = {})), dn;
}
var fn = {}, mn = {}, We = {}, Vi;
function ni() {
  if (Vi) return We;
  Vi = 1, Object.defineProperty(We, "__esModule", {
    value: !0
  }), We.isDigit = n, We.isLetter = s, We.isNameContinue = t, We.isNameStart = i, We.isWhiteSpace = e;
  function e(r) {
    return r === 9 || r === 32;
  }
  function n(r) {
    return r >= 48 && r <= 57;
  }
  function s(r) {
    return r >= 97 && r <= 122 || // A-Z
    r >= 65 && r <= 90;
  }
  function i(r) {
    return s(r) || r === 95;
  }
  function t(r) {
    return s(r) || n(r) || r === 95;
  }
  return We;
}
var Gi;
function Or() {
  if (Gi) return mn;
  Gi = 1, Object.defineProperty(mn, "__esModule", {
    value: !0
  }), mn.dedentBlockStringLines = n, mn.isPrintableAsBlockString = i, mn.printBlockString = t;
  var e = /* @__PURE__ */ ni();
  function n(r) {
    var a;
    let c = Number.MAX_SAFE_INTEGER, u = null, f = -1;
    for (let o = 0; o < r.length; ++o) {
      var y;
      const p = r[o], h = s(p);
      h !== p.length && (u = (y = u) !== null && y !== void 0 ? y : o, f = o, o !== 0 && h < c && (c = h));
    }
    return r.map((o, p) => p === 0 ? o : o.slice(c)).slice(
      (a = u) !== null && a !== void 0 ? a : 0,
      f + 1
    );
  }
  function s(r) {
    let a = 0;
    for (; a < r.length && (0, e.isWhiteSpace)(r.charCodeAt(a)); )
      ++a;
    return a;
  }
  function i(r) {
    if (r === "")
      return !0;
    let a = !0, c = !1, u = !0, f = !1;
    for (let y = 0; y < r.length; ++y)
      switch (r.codePointAt(y)) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 11:
        case 12:
        case 14:
        case 15:
          return !1;
        // Has non-printable characters
        case 13:
          return !1;
        // Has \r or \r\n which will be replaced as \n
        case 10:
          if (a && !f)
            return !1;
          f = !0, a = !0, c = !1;
          break;
        case 9:
        //   \t
        case 32:
          c || (c = a);
          break;
        default:
          u && (u = c), a = !1;
      }
    return !(a || u && f);
  }
  function t(r, a) {
    const c = r.replace(/"""/g, '\\"""'), u = c.split(/\r\n|[\n\r]/g), f = u.length === 1, y = u.length > 1 && u.slice(1).every(
      (O) => O.length === 0 || (0, e.isWhiteSpace)(O.charCodeAt(0))
    ), o = c.endsWith('\\"""'), p = r.endsWith('"') && !o, h = r.endsWith("\\"), l = p || h, d = !(a != null && a.minimize) && // add leading and trailing new lines only if it improves readability
    (!f || r.length > 70 || l || y || o);
    let m = "";
    const T = f && (0, e.isWhiteSpace)(r.charCodeAt(0));
    return (d && !T || y) && (m += `
`), m += c, (d || l) && (m += `
`), '"""' + m + '"""';
  }
  return mn;
}
var yn = {}, Mi;
function _r() {
  if (Mi) return yn;
  Mi = 1, Object.defineProperty(yn, "__esModule", {
    value: !0
  }), yn.TokenKind = void 0;
  var e;
  return yn.TokenKind = e, function(n) {
    n.SOF = "<SOF>", n.EOF = "<EOF>", n.BANG = "!", n.DOLLAR = "$", n.AMP = "&", n.PAREN_L = "(", n.PAREN_R = ")", n.SPREAD = "...", n.COLON = ":", n.EQUALS = "=", n.AT = "@", n.BRACKET_L = "[", n.BRACKET_R = "]", n.BRACE_L = "{", n.PIPE = "|", n.BRACE_R = "}", n.NAME = "Name", n.INT = "Int", n.FLOAT = "Float", n.STRING = "String", n.BLOCK_STRING = "BlockString", n.COMMENT = "Comment";
  }(e || (yn.TokenKind = e = {})), yn;
}
var $i;
function ti() {
  if ($i) return fn;
  $i = 1, Object.defineProperty(fn, "__esModule", {
    value: !0
  }), fn.Lexer = void 0, fn.isPunctuatorTokenKind = a;
  var e = /* @__PURE__ */ Wr(), n = /* @__PURE__ */ Je(), s = /* @__PURE__ */ Or(), i = /* @__PURE__ */ ni(), t = /* @__PURE__ */ _r();
  class r {
    /**
     * The previously focused non-ignored token.
     */
    /**
     * The currently focused non-ignored token.
     */
    /**
     * The (1-indexed) line containing the current token.
     */
    /**
     * The character offset at which the current line begins.
     */
    constructor(g) {
      const S = new n.Token(
        t.TokenKind.SOF,
        0,
        0,
        0,
        0
      );
      this.source = g, this.lastToken = S, this.token = S, this.line = 1, this.lineStart = 0;
    }
    get [Symbol.toStringTag]() {
      return "Lexer";
    }
    /**
     * Advances the token stream to the next non-ignored token.
     */
    advance() {
      return this.lastToken = this.token, this.token = this.lookahead();
    }
    /**
     * Looks ahead and returns the next non-ignored token, but does not change
     * the state of Lexer.
     */
    lookahead() {
      let g = this.token;
      if (g.kind !== t.TokenKind.EOF)
        do
          if (g.next)
            g = g.next;
          else {
            const S = h(this, g.end);
            g.next = S, S.prev = g, g = S;
          }
        while (g.kind === t.TokenKind.COMMENT);
      return g;
    }
  }
  fn.Lexer = r;
  function a(N) {
    return N === t.TokenKind.BANG || N === t.TokenKind.DOLLAR || N === t.TokenKind.AMP || N === t.TokenKind.PAREN_L || N === t.TokenKind.PAREN_R || N === t.TokenKind.SPREAD || N === t.TokenKind.COLON || N === t.TokenKind.EQUALS || N === t.TokenKind.AT || N === t.TokenKind.BRACKET_L || N === t.TokenKind.BRACKET_R || N === t.TokenKind.BRACE_L || N === t.TokenKind.PIPE || N === t.TokenKind.BRACE_R;
  }
  function c(N) {
    return N >= 0 && N <= 55295 || N >= 57344 && N <= 1114111;
  }
  function u(N, g) {
    return f(N.charCodeAt(g)) && y(N.charCodeAt(g + 1));
  }
  function f(N) {
    return N >= 55296 && N <= 56319;
  }
  function y(N) {
    return N >= 56320 && N <= 57343;
  }
  function o(N, g) {
    const S = N.source.body.codePointAt(g);
    if (S === void 0)
      return t.TokenKind.EOF;
    if (S >= 32 && S <= 126) {
      const E = String.fromCodePoint(S);
      return E === '"' ? `'"'` : `"${E}"`;
    }
    return "U+" + S.toString(16).toUpperCase().padStart(4, "0");
  }
  function p(N, g, S, E, v) {
    const b = N.line, I = 1 + S - N.lineStart;
    return new n.Token(g, S, E, b, I, v);
  }
  function h(N, g) {
    const S = N.source.body, E = S.length;
    let v = g;
    for (; v < E; ) {
      const b = S.charCodeAt(v);
      switch (b) {
        // Ignored ::
        //   - UnicodeBOM
        //   - WhiteSpace
        //   - LineTerminator
        //   - Comment
        //   - Comma
        //
        // UnicodeBOM :: "Byte Order Mark (U+FEFF)"
        //
        // WhiteSpace ::
        //   - "Horizontal Tab (U+0009)"
        //   - "Space (U+0020)"
        //
        // Comma :: ,
        case 65279:
        // <BOM>
        case 9:
        // \t
        case 32:
        // <space>
        case 44:
          ++v;
          continue;
        // LineTerminator ::
        //   - "New Line (U+000A)"
        //   - "Carriage Return (U+000D)" [lookahead != "New Line (U+000A)"]
        //   - "Carriage Return (U+000D)" "New Line (U+000A)"
        case 10:
          ++v, ++N.line, N.lineStart = v;
          continue;
        case 13:
          S.charCodeAt(v + 1) === 10 ? v += 2 : ++v, ++N.line, N.lineStart = v;
          continue;
        // Comment
        case 35:
          return l(N, v);
        // Token ::
        //   - Punctuator
        //   - Name
        //   - IntValue
        //   - FloatValue
        //   - StringValue
        //
        // Punctuator :: one of ! $ & ( ) ... : = @ [ ] { | }
        case 33:
          return p(
            N,
            t.TokenKind.BANG,
            v,
            v + 1
          );
        case 36:
          return p(
            N,
            t.TokenKind.DOLLAR,
            v,
            v + 1
          );
        case 38:
          return p(
            N,
            t.TokenKind.AMP,
            v,
            v + 1
          );
        case 40:
          return p(
            N,
            t.TokenKind.PAREN_L,
            v,
            v + 1
          );
        case 41:
          return p(
            N,
            t.TokenKind.PAREN_R,
            v,
            v + 1
          );
        case 46:
          if (S.charCodeAt(v + 1) === 46 && S.charCodeAt(v + 2) === 46)
            return p(
              N,
              t.TokenKind.SPREAD,
              v,
              v + 3
            );
          break;
        case 58:
          return p(
            N,
            t.TokenKind.COLON,
            v,
            v + 1
          );
        case 61:
          return p(
            N,
            t.TokenKind.EQUALS,
            v,
            v + 1
          );
        case 64:
          return p(
            N,
            t.TokenKind.AT,
            v,
            v + 1
          );
        case 91:
          return p(
            N,
            t.TokenKind.BRACKET_L,
            v,
            v + 1
          );
        case 93:
          return p(
            N,
            t.TokenKind.BRACKET_R,
            v,
            v + 1
          );
        case 123:
          return p(
            N,
            t.TokenKind.BRACE_L,
            v,
            v + 1
          );
        case 124:
          return p(
            N,
            t.TokenKind.PIPE,
            v,
            v + 1
          );
        case 125:
          return p(
            N,
            t.TokenKind.BRACE_R,
            v,
            v + 1
          );
        // StringValue
        case 34:
          return S.charCodeAt(v + 1) === 34 && S.charCodeAt(v + 2) === 34 ? $(N, v) : T(N, v);
      }
      if ((0, i.isDigit)(b) || b === 45)
        return d(N, v, b);
      if ((0, i.isNameStart)(b))
        return G(N, v);
      throw (0, e.syntaxError)(
        N.source,
        v,
        b === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : c(b) || u(S, v) ? `Unexpected character: ${o(N, v)}.` : `Invalid character: ${o(N, v)}.`
      );
    }
    return p(N, t.TokenKind.EOF, E, E);
  }
  function l(N, g) {
    const S = N.source.body, E = S.length;
    let v = g + 1;
    for (; v < E; ) {
      const b = S.charCodeAt(v);
      if (b === 10 || b === 13)
        break;
      if (c(b))
        ++v;
      else if (u(S, v))
        v += 2;
      else
        break;
    }
    return p(
      N,
      t.TokenKind.COMMENT,
      g,
      v,
      S.slice(g + 1, v)
    );
  }
  function d(N, g, S) {
    const E = N.source.body;
    let v = g, b = S, I = !1;
    if (b === 45 && (b = E.charCodeAt(++v)), b === 48) {
      if (b = E.charCodeAt(++v), (0, i.isDigit)(b))
        throw (0, e.syntaxError)(
          N.source,
          v,
          `Invalid number, unexpected digit after 0: ${o(
            N,
            v
          )}.`
        );
    } else
      v = m(N, v, b), b = E.charCodeAt(v);
    if (b === 46 && (I = !0, b = E.charCodeAt(++v), v = m(N, v, b), b = E.charCodeAt(v)), (b === 69 || b === 101) && (I = !0, b = E.charCodeAt(++v), (b === 43 || b === 45) && (b = E.charCodeAt(++v)), v = m(N, v, b), b = E.charCodeAt(v)), b === 46 || (0, i.isNameStart)(b))
      throw (0, e.syntaxError)(
        N.source,
        v,
        `Invalid number, expected digit but got: ${o(
          N,
          v
        )}.`
      );
    return p(
      N,
      I ? t.TokenKind.FLOAT : t.TokenKind.INT,
      g,
      v,
      E.slice(g, v)
    );
  }
  function m(N, g, S) {
    if (!(0, i.isDigit)(S))
      throw (0, e.syntaxError)(
        N.source,
        g,
        `Invalid number, expected digit but got: ${o(
          N,
          g
        )}.`
      );
    const E = N.source.body;
    let v = g + 1;
    for (; (0, i.isDigit)(E.charCodeAt(v)); )
      ++v;
    return v;
  }
  function T(N, g) {
    const S = N.source.body, E = S.length;
    let v = g + 1, b = v, I = "";
    for (; v < E; ) {
      const L = S.charCodeAt(v);
      if (L === 34)
        return I += S.slice(b, v), p(
          N,
          t.TokenKind.STRING,
          g,
          v + 1,
          I
        );
      if (L === 92) {
        I += S.slice(b, v);
        const j = S.charCodeAt(v + 1) === 117 ? S.charCodeAt(v + 2) === 123 ? O(N, v) : R(N, v) : w(N, v);
        I += j.value, v += j.size, b = v;
        continue;
      }
      if (L === 10 || L === 13)
        break;
      if (c(L))
        ++v;
      else if (u(S, v))
        v += 2;
      else
        throw (0, e.syntaxError)(
          N.source,
          v,
          `Invalid character within String: ${o(
            N,
            v
          )}.`
        );
    }
    throw (0, e.syntaxError)(
      N.source,
      v,
      "Unterminated string."
    );
  }
  function O(N, g) {
    const S = N.source.body;
    let E = 0, v = 3;
    for (; v < 12; ) {
      const b = S.charCodeAt(g + v++);
      if (b === 125) {
        if (v < 5 || !c(E))
          break;
        return {
          value: String.fromCodePoint(E),
          size: v
        };
      }
      if (E = E << 4 | _(b), E < 0)
        break;
    }
    throw (0, e.syntaxError)(
      N.source,
      g,
      `Invalid Unicode escape sequence: "${S.slice(
        g,
        g + v
      )}".`
    );
  }
  function R(N, g) {
    const S = N.source.body, E = D(S, g + 2);
    if (c(E))
      return {
        value: String.fromCodePoint(E),
        size: 6
      };
    if (f(E) && S.charCodeAt(g + 6) === 92 && S.charCodeAt(g + 7) === 117) {
      const v = D(S, g + 8);
      if (y(v))
        return {
          value: String.fromCodePoint(E, v),
          size: 12
        };
    }
    throw (0, e.syntaxError)(
      N.source,
      g,
      `Invalid Unicode escape sequence: "${S.slice(g, g + 6)}".`
    );
  }
  function D(N, g) {
    return _(N.charCodeAt(g)) << 12 | _(N.charCodeAt(g + 1)) << 8 | _(N.charCodeAt(g + 2)) << 4 | _(N.charCodeAt(g + 3));
  }
  function _(N) {
    return N >= 48 && N <= 57 ? N - 48 : N >= 65 && N <= 70 ? N - 55 : N >= 97 && N <= 102 ? N - 87 : -1;
  }
  function w(N, g) {
    const S = N.source.body;
    switch (S.charCodeAt(g + 1)) {
      case 34:
        return {
          value: '"',
          size: 2
        };
      case 92:
        return {
          value: "\\",
          size: 2
        };
      case 47:
        return {
          value: "/",
          size: 2
        };
      case 98:
        return {
          value: "\b",
          size: 2
        };
      case 102:
        return {
          value: "\f",
          size: 2
        };
      case 110:
        return {
          value: `
`,
          size: 2
        };
      case 114:
        return {
          value: "\r",
          size: 2
        };
      case 116:
        return {
          value: "	",
          size: 2
        };
    }
    throw (0, e.syntaxError)(
      N.source,
      g,
      `Invalid character escape sequence: "${S.slice(
        g,
        g + 2
      )}".`
    );
  }
  function $(N, g) {
    const S = N.source.body, E = S.length;
    let v = N.lineStart, b = g + 3, I = b, L = "";
    const j = [];
    for (; b < E; ) {
      const V = S.charCodeAt(b);
      if (V === 34 && S.charCodeAt(b + 1) === 34 && S.charCodeAt(b + 2) === 34) {
        L += S.slice(I, b), j.push(L);
        const U = p(
          N,
          t.TokenKind.BLOCK_STRING,
          g,
          b + 3,
          // Return a string of the lines joined with U+000A.
          (0, s.dedentBlockStringLines)(j).join(`
`)
        );
        return N.line += j.length - 1, N.lineStart = v, U;
      }
      if (V === 92 && S.charCodeAt(b + 1) === 34 && S.charCodeAt(b + 2) === 34 && S.charCodeAt(b + 3) === 34) {
        L += S.slice(I, b), I = b + 1, b += 4;
        continue;
      }
      if (V === 10 || V === 13) {
        L += S.slice(I, b), j.push(L), V === 13 && S.charCodeAt(b + 1) === 10 ? b += 2 : ++b, L = "", I = b, v = b;
        continue;
      }
      if (c(V))
        ++b;
      else if (u(S, b))
        b += 2;
      else
        throw (0, e.syntaxError)(
          N.source,
          b,
          `Invalid character within String: ${o(
            N,
            b
          )}.`
        );
    }
    throw (0, e.syntaxError)(
      N.source,
      b,
      "Unterminated string."
    );
  }
  function G(N, g) {
    const S = N.source.body, E = S.length;
    let v = g + 1;
    for (; v < E; ) {
      const b = S.charCodeAt(v);
      if ((0, i.isNameContinue)(b))
        ++v;
      else
        break;
    }
    return p(
      N,
      t.TokenKind.NAME,
      g,
      v,
      S.slice(g, v)
    );
  }
  return fn;
}
var hn = {}, Dn = {}, Ci;
function Ir() {
  if (Ci) return Dn;
  Ci = 1, Object.defineProperty(Dn, "__esModule", {
    value: !0
  }), Dn.instanceOf = void 0;
  var e = /* @__PURE__ */ de();
  const s = (
    /* c8 ignore next 6 */
    // FIXME: https://github.com/graphql/graphql-js/issues/2317
    globalThis.process && // eslint-disable-next-line no-undef
    process.env.NODE_ENV === "production" ? function(t, r) {
      return t instanceof r;
    } : function(t, r) {
      if (t instanceof r)
        return !0;
      if (typeof t == "object" && t !== null) {
        var a;
        const c = r.prototype[Symbol.toStringTag], u = (
          // We still need to support constructor's name to detect conflicts with older versions of this library.
          Symbol.toStringTag in t ? t[Symbol.toStringTag] : (a = t.constructor) === null || a === void 0 ? void 0 : a.name
        );
        if (c === u) {
          const f = (0, e.inspect)(t);
          throw new Error(`Cannot use ${c} "${f}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
        }
      }
      return !1;
    }
  );
  return Dn.instanceOf = s, Dn;
}
var Ui;
function ri() {
  if (Ui) return hn;
  Ui = 1, Object.defineProperty(hn, "__esModule", {
    value: !0
  }), hn.Source = void 0, hn.isSource = t;
  var e = /* @__PURE__ */ Re(), n = /* @__PURE__ */ de(), s = /* @__PURE__ */ Ir();
  class i {
    constructor(a, c = "GraphQL request", u = {
      line: 1,
      column: 1
    }) {
      typeof a == "string" || (0, e.devAssert)(
        !1,
        `Body must be a string. Received: ${(0, n.inspect)(a)}.`
      ), this.body = a, this.name = c, this.locationOffset = u, this.locationOffset.line > 0 || (0, e.devAssert)(
        !1,
        "line in locationOffset is 1-indexed and must be positive."
      ), this.locationOffset.column > 0 || (0, e.devAssert)(
        !1,
        "column in locationOffset is 1-indexed and must be positive."
      );
    }
    get [Symbol.toStringTag]() {
      return "Source";
    }
  }
  hn.Source = i;
  function t(r) {
    return (0, s.instanceOf)(r, i);
  }
  return hn;
}
var Qi;
function xn() {
  if (Qi) return Qe;
  Qi = 1, Object.defineProperty(Qe, "__esModule", {
    value: !0
  }), Qe.Parser = void 0, Qe.parse = c, Qe.parseConstValue = f, Qe.parseType = y, Qe.parseValue = u;
  var e = /* @__PURE__ */ Wr(), n = /* @__PURE__ */ Je(), s = /* @__PURE__ */ Bn(), i = /* @__PURE__ */ se(), t = /* @__PURE__ */ ti(), r = /* @__PURE__ */ ri(), a = /* @__PURE__ */ _r();
  function c(l, d) {
    const m = new o(l, d), T = m.parseDocument();
    return Object.defineProperty(T, "tokenCount", {
      enumerable: !1,
      value: m.tokenCount
    }), T;
  }
  function u(l, d) {
    const m = new o(l, d);
    m.expectToken(a.TokenKind.SOF);
    const T = m.parseValueLiteral(!1);
    return m.expectToken(a.TokenKind.EOF), T;
  }
  function f(l, d) {
    const m = new o(l, d);
    m.expectToken(a.TokenKind.SOF);
    const T = m.parseConstValueLiteral();
    return m.expectToken(a.TokenKind.EOF), T;
  }
  function y(l, d) {
    const m = new o(l, d);
    m.expectToken(a.TokenKind.SOF);
    const T = m.parseTypeReference();
    return m.expectToken(a.TokenKind.EOF), T;
  }
  class o {
    constructor(d, m = {}) {
      const T = (0, r.isSource)(d) ? d : new r.Source(d);
      this._lexer = new t.Lexer(T), this._options = m, this._tokenCounter = 0;
    }
    get tokenCount() {
      return this._tokenCounter;
    }
    /**
     * Converts a name lex token into a name parse node.
     */
    parseName() {
      const d = this.expectToken(a.TokenKind.NAME);
      return this.node(d, {
        kind: i.Kind.NAME,
        value: d.value
      });
    }
    // Implements the parsing rules in the Document section.
    /**
     * Document : Definition+
     */
    parseDocument() {
      return this.node(this._lexer.token, {
        kind: i.Kind.DOCUMENT,
        definitions: this.many(
          a.TokenKind.SOF,
          this.parseDefinition,
          a.TokenKind.EOF
        )
      });
    }
    /**
     * Definition :
     *   - ExecutableDefinition
     *   - TypeSystemDefinition
     *   - TypeSystemExtension
     *
     * ExecutableDefinition :
     *   - OperationDefinition
     *   - FragmentDefinition
     *
     * TypeSystemDefinition :
     *   - SchemaDefinition
     *   - TypeDefinition
     *   - DirectiveDefinition
     *
     * TypeDefinition :
     *   - ScalarTypeDefinition
     *   - ObjectTypeDefinition
     *   - InterfaceTypeDefinition
     *   - UnionTypeDefinition
     *   - EnumTypeDefinition
     *   - InputObjectTypeDefinition
     */
    parseDefinition() {
      if (this.peek(a.TokenKind.BRACE_L))
        return this.parseOperationDefinition();
      const d = this.peekDescription(), m = d ? this._lexer.lookahead() : this._lexer.token;
      if (m.kind === a.TokenKind.NAME) {
        switch (m.value) {
          case "schema":
            return this.parseSchemaDefinition();
          case "scalar":
            return this.parseScalarTypeDefinition();
          case "type":
            return this.parseObjectTypeDefinition();
          case "interface":
            return this.parseInterfaceTypeDefinition();
          case "union":
            return this.parseUnionTypeDefinition();
          case "enum":
            return this.parseEnumTypeDefinition();
          case "input":
            return this.parseInputObjectTypeDefinition();
          case "directive":
            return this.parseDirectiveDefinition();
        }
        if (d)
          throw (0, e.syntaxError)(
            this._lexer.source,
            this._lexer.token.start,
            "Unexpected description, descriptions are supported only on type definitions."
          );
        switch (m.value) {
          case "query":
          case "mutation":
          case "subscription":
            return this.parseOperationDefinition();
          case "fragment":
            return this.parseFragmentDefinition();
          case "extend":
            return this.parseTypeSystemExtension();
        }
      }
      throw this.unexpected(m);
    }
    // Implements the parsing rules in the Operations section.
    /**
     * OperationDefinition :
     *  - SelectionSet
     *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
     */
    parseOperationDefinition() {
      const d = this._lexer.token;
      if (this.peek(a.TokenKind.BRACE_L))
        return this.node(d, {
          kind: i.Kind.OPERATION_DEFINITION,
          operation: n.OperationTypeNode.QUERY,
          name: void 0,
          variableDefinitions: [],
          directives: [],
          selectionSet: this.parseSelectionSet()
        });
      const m = this.parseOperationType();
      let T;
      return this.peek(a.TokenKind.NAME) && (T = this.parseName()), this.node(d, {
        kind: i.Kind.OPERATION_DEFINITION,
        operation: m,
        name: T,
        variableDefinitions: this.parseVariableDefinitions(),
        directives: this.parseDirectives(!1),
        selectionSet: this.parseSelectionSet()
      });
    }
    /**
     * OperationType : one of query mutation subscription
     */
    parseOperationType() {
      const d = this.expectToken(a.TokenKind.NAME);
      switch (d.value) {
        case "query":
          return n.OperationTypeNode.QUERY;
        case "mutation":
          return n.OperationTypeNode.MUTATION;
        case "subscription":
          return n.OperationTypeNode.SUBSCRIPTION;
      }
      throw this.unexpected(d);
    }
    /**
     * VariableDefinitions : ( VariableDefinition+ )
     */
    parseVariableDefinitions() {
      return this.optionalMany(
        a.TokenKind.PAREN_L,
        this.parseVariableDefinition,
        a.TokenKind.PAREN_R
      );
    }
    /**
     * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
     */
    parseVariableDefinition() {
      return this.node(this._lexer.token, {
        kind: i.Kind.VARIABLE_DEFINITION,
        variable: this.parseVariable(),
        type: (this.expectToken(a.TokenKind.COLON), this.parseTypeReference()),
        defaultValue: this.expectOptionalToken(a.TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
        directives: this.parseConstDirectives()
      });
    }
    /**
     * Variable : $ Name
     */
    parseVariable() {
      const d = this._lexer.token;
      return this.expectToken(a.TokenKind.DOLLAR), this.node(d, {
        kind: i.Kind.VARIABLE,
        name: this.parseName()
      });
    }
    /**
     * ```
     * SelectionSet : { Selection+ }
     * ```
     */
    parseSelectionSet() {
      return this.node(this._lexer.token, {
        kind: i.Kind.SELECTION_SET,
        selections: this.many(
          a.TokenKind.BRACE_L,
          this.parseSelection,
          a.TokenKind.BRACE_R
        )
      });
    }
    /**
     * Selection :
     *   - Field
     *   - FragmentSpread
     *   - InlineFragment
     */
    parseSelection() {
      return this.peek(a.TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
    }
    /**
     * Field : Alias? Name Arguments? Directives? SelectionSet?
     *
     * Alias : Name :
     */
    parseField() {
      const d = this._lexer.token, m = this.parseName();
      let T, O;
      return this.expectOptionalToken(a.TokenKind.COLON) ? (T = m, O = this.parseName()) : O = m, this.node(d, {
        kind: i.Kind.FIELD,
        alias: T,
        name: O,
        arguments: this.parseArguments(!1),
        directives: this.parseDirectives(!1),
        selectionSet: this.peek(a.TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
      });
    }
    /**
     * Arguments[Const] : ( Argument[?Const]+ )
     */
    parseArguments(d) {
      const m = d ? this.parseConstArgument : this.parseArgument;
      return this.optionalMany(
        a.TokenKind.PAREN_L,
        m,
        a.TokenKind.PAREN_R
      );
    }
    /**
     * Argument[Const] : Name : Value[?Const]
     */
    parseArgument(d = !1) {
      const m = this._lexer.token, T = this.parseName();
      return this.expectToken(a.TokenKind.COLON), this.node(m, {
        kind: i.Kind.ARGUMENT,
        name: T,
        value: this.parseValueLiteral(d)
      });
    }
    parseConstArgument() {
      return this.parseArgument(!0);
    }
    // Implements the parsing rules in the Fragments section.
    /**
     * Corresponds to both FragmentSpread and InlineFragment in the spec.
     *
     * FragmentSpread : ... FragmentName Directives?
     *
     * InlineFragment : ... TypeCondition? Directives? SelectionSet
     */
    parseFragment() {
      const d = this._lexer.token;
      this.expectToken(a.TokenKind.SPREAD);
      const m = this.expectOptionalKeyword("on");
      return !m && this.peek(a.TokenKind.NAME) ? this.node(d, {
        kind: i.Kind.FRAGMENT_SPREAD,
        name: this.parseFragmentName(),
        directives: this.parseDirectives(!1)
      }) : this.node(d, {
        kind: i.Kind.INLINE_FRAGMENT,
        typeCondition: m ? this.parseNamedType() : void 0,
        directives: this.parseDirectives(!1),
        selectionSet: this.parseSelectionSet()
      });
    }
    /**
     * FragmentDefinition :
     *   - fragment FragmentName on TypeCondition Directives? SelectionSet
     *
     * TypeCondition : NamedType
     */
    parseFragmentDefinition() {
      const d = this._lexer.token;
      return this.expectKeyword("fragment"), this._options.allowLegacyFragmentVariables === !0 ? this.node(d, {
        kind: i.Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        variableDefinitions: this.parseVariableDefinitions(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(!1),
        selectionSet: this.parseSelectionSet()
      }) : this.node(d, {
        kind: i.Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(!1),
        selectionSet: this.parseSelectionSet()
      });
    }
    /**
     * FragmentName : Name but not `on`
     */
    parseFragmentName() {
      if (this._lexer.token.value === "on")
        throw this.unexpected();
      return this.parseName();
    }
    // Implements the parsing rules in the Values section.
    /**
     * Value[Const] :
     *   - [~Const] Variable
     *   - IntValue
     *   - FloatValue
     *   - StringValue
     *   - BooleanValue
     *   - NullValue
     *   - EnumValue
     *   - ListValue[?Const]
     *   - ObjectValue[?Const]
     *
     * BooleanValue : one of `true` `false`
     *
     * NullValue : `null`
     *
     * EnumValue : Name but not `true`, `false` or `null`
     */
    parseValueLiteral(d) {
      const m = this._lexer.token;
      switch (m.kind) {
        case a.TokenKind.BRACKET_L:
          return this.parseList(d);
        case a.TokenKind.BRACE_L:
          return this.parseObject(d);
        case a.TokenKind.INT:
          return this.advanceLexer(), this.node(m, {
            kind: i.Kind.INT,
            value: m.value
          });
        case a.TokenKind.FLOAT:
          return this.advanceLexer(), this.node(m, {
            kind: i.Kind.FLOAT,
            value: m.value
          });
        case a.TokenKind.STRING:
        case a.TokenKind.BLOCK_STRING:
          return this.parseStringLiteral();
        case a.TokenKind.NAME:
          switch (this.advanceLexer(), m.value) {
            case "true":
              return this.node(m, {
                kind: i.Kind.BOOLEAN,
                value: !0
              });
            case "false":
              return this.node(m, {
                kind: i.Kind.BOOLEAN,
                value: !1
              });
            case "null":
              return this.node(m, {
                kind: i.Kind.NULL
              });
            default:
              return this.node(m, {
                kind: i.Kind.ENUM,
                value: m.value
              });
          }
        case a.TokenKind.DOLLAR:
          if (d)
            if (this.expectToken(a.TokenKind.DOLLAR), this._lexer.token.kind === a.TokenKind.NAME) {
              const T = this._lexer.token.value;
              throw (0, e.syntaxError)(
                this._lexer.source,
                m.start,
                `Unexpected variable "$${T}" in constant value.`
              );
            } else
              throw this.unexpected(m);
          return this.parseVariable();
        default:
          throw this.unexpected();
      }
    }
    parseConstValueLiteral() {
      return this.parseValueLiteral(!0);
    }
    parseStringLiteral() {
      const d = this._lexer.token;
      return this.advanceLexer(), this.node(d, {
        kind: i.Kind.STRING,
        value: d.value,
        block: d.kind === a.TokenKind.BLOCK_STRING
      });
    }
    /**
     * ListValue[Const] :
     *   - [ ]
     *   - [ Value[?Const]+ ]
     */
    parseList(d) {
      const m = () => this.parseValueLiteral(d);
      return this.node(this._lexer.token, {
        kind: i.Kind.LIST,
        values: this.any(
          a.TokenKind.BRACKET_L,
          m,
          a.TokenKind.BRACKET_R
        )
      });
    }
    /**
     * ```
     * ObjectValue[Const] :
     *   - { }
     *   - { ObjectField[?Const]+ }
     * ```
     */
    parseObject(d) {
      const m = () => this.parseObjectField(d);
      return this.node(this._lexer.token, {
        kind: i.Kind.OBJECT,
        fields: this.any(
          a.TokenKind.BRACE_L,
          m,
          a.TokenKind.BRACE_R
        )
      });
    }
    /**
     * ObjectField[Const] : Name : Value[?Const]
     */
    parseObjectField(d) {
      const m = this._lexer.token, T = this.parseName();
      return this.expectToken(a.TokenKind.COLON), this.node(m, {
        kind: i.Kind.OBJECT_FIELD,
        name: T,
        value: this.parseValueLiteral(d)
      });
    }
    // Implements the parsing rules in the Directives section.
    /**
     * Directives[Const] : Directive[?Const]+
     */
    parseDirectives(d) {
      const m = [];
      for (; this.peek(a.TokenKind.AT); )
        m.push(this.parseDirective(d));
      return m;
    }
    parseConstDirectives() {
      return this.parseDirectives(!0);
    }
    /**
     * ```
     * Directive[Const] : @ Name Arguments[?Const]?
     * ```
     */
    parseDirective(d) {
      const m = this._lexer.token;
      return this.expectToken(a.TokenKind.AT), this.node(m, {
        kind: i.Kind.DIRECTIVE,
        name: this.parseName(),
        arguments: this.parseArguments(d)
      });
    }
    // Implements the parsing rules in the Types section.
    /**
     * Type :
     *   - NamedType
     *   - ListType
     *   - NonNullType
     */
    parseTypeReference() {
      const d = this._lexer.token;
      let m;
      if (this.expectOptionalToken(a.TokenKind.BRACKET_L)) {
        const T = this.parseTypeReference();
        this.expectToken(a.TokenKind.BRACKET_R), m = this.node(d, {
          kind: i.Kind.LIST_TYPE,
          type: T
        });
      } else
        m = this.parseNamedType();
      return this.expectOptionalToken(a.TokenKind.BANG) ? this.node(d, {
        kind: i.Kind.NON_NULL_TYPE,
        type: m
      }) : m;
    }
    /**
     * NamedType : Name
     */
    parseNamedType() {
      return this.node(this._lexer.token, {
        kind: i.Kind.NAMED_TYPE,
        name: this.parseName()
      });
    }
    // Implements the parsing rules in the Type Definition section.
    peekDescription() {
      return this.peek(a.TokenKind.STRING) || this.peek(a.TokenKind.BLOCK_STRING);
    }
    /**
     * Description : StringValue
     */
    parseDescription() {
      if (this.peekDescription())
        return this.parseStringLiteral();
    }
    /**
     * ```
     * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
     * ```
     */
    parseSchemaDefinition() {
      const d = this._lexer.token, m = this.parseDescription();
      this.expectKeyword("schema");
      const T = this.parseConstDirectives(), O = this.many(
        a.TokenKind.BRACE_L,
        this.parseOperationTypeDefinition,
        a.TokenKind.BRACE_R
      );
      return this.node(d, {
        kind: i.Kind.SCHEMA_DEFINITION,
        description: m,
        directives: T,
        operationTypes: O
      });
    }
    /**
     * OperationTypeDefinition : OperationType : NamedType
     */
    parseOperationTypeDefinition() {
      const d = this._lexer.token, m = this.parseOperationType();
      this.expectToken(a.TokenKind.COLON);
      const T = this.parseNamedType();
      return this.node(d, {
        kind: i.Kind.OPERATION_TYPE_DEFINITION,
        operation: m,
        type: T
      });
    }
    /**
     * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
     */
    parseScalarTypeDefinition() {
      const d = this._lexer.token, m = this.parseDescription();
      this.expectKeyword("scalar");
      const T = this.parseName(), O = this.parseConstDirectives();
      return this.node(d, {
        kind: i.Kind.SCALAR_TYPE_DEFINITION,
        description: m,
        name: T,
        directives: O
      });
    }
    /**
     * ObjectTypeDefinition :
     *   Description?
     *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
     */
    parseObjectTypeDefinition() {
      const d = this._lexer.token, m = this.parseDescription();
      this.expectKeyword("type");
      const T = this.parseName(), O = this.parseImplementsInterfaces(), R = this.parseConstDirectives(), D = this.parseFieldsDefinition();
      return this.node(d, {
        kind: i.Kind.OBJECT_TYPE_DEFINITION,
        description: m,
        name: T,
        interfaces: O,
        directives: R,
        fields: D
      });
    }
    /**
     * ImplementsInterfaces :
     *   - implements `&`? NamedType
     *   - ImplementsInterfaces & NamedType
     */
    parseImplementsInterfaces() {
      return this.expectOptionalKeyword("implements") ? this.delimitedMany(a.TokenKind.AMP, this.parseNamedType) : [];
    }
    /**
     * ```
     * FieldsDefinition : { FieldDefinition+ }
     * ```
     */
    parseFieldsDefinition() {
      return this.optionalMany(
        a.TokenKind.BRACE_L,
        this.parseFieldDefinition,
        a.TokenKind.BRACE_R
      );
    }
    /**
     * FieldDefinition :
     *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
     */
    parseFieldDefinition() {
      const d = this._lexer.token, m = this.parseDescription(), T = this.parseName(), O = this.parseArgumentDefs();
      this.expectToken(a.TokenKind.COLON);
      const R = this.parseTypeReference(), D = this.parseConstDirectives();
      return this.node(d, {
        kind: i.Kind.FIELD_DEFINITION,
        description: m,
        name: T,
        arguments: O,
        type: R,
        directives: D
      });
    }
    /**
     * ArgumentsDefinition : ( InputValueDefinition+ )
     */
    parseArgumentDefs() {
      return this.optionalMany(
        a.TokenKind.PAREN_L,
        this.parseInputValueDef,
        a.TokenKind.PAREN_R
      );
    }
    /**
     * InputValueDefinition :
     *   - Description? Name : Type DefaultValue? Directives[Const]?
     */
    parseInputValueDef() {
      const d = this._lexer.token, m = this.parseDescription(), T = this.parseName();
      this.expectToken(a.TokenKind.COLON);
      const O = this.parseTypeReference();
      let R;
      this.expectOptionalToken(a.TokenKind.EQUALS) && (R = this.parseConstValueLiteral());
      const D = this.parseConstDirectives();
      return this.node(d, {
        kind: i.Kind.INPUT_VALUE_DEFINITION,
        description: m,
        name: T,
        type: O,
        defaultValue: R,
        directives: D
      });
    }
    /**
     * InterfaceTypeDefinition :
     *   - Description? interface Name Directives[Const]? FieldsDefinition?
     */
    parseInterfaceTypeDefinition() {
      const d = this._lexer.token, m = this.parseDescription();
      this.expectKeyword("interface");
      const T = this.parseName(), O = this.parseImplementsInterfaces(), R = this.parseConstDirectives(), D = this.parseFieldsDefinition();
      return this.node(d, {
        kind: i.Kind.INTERFACE_TYPE_DEFINITION,
        description: m,
        name: T,
        interfaces: O,
        directives: R,
        fields: D
      });
    }
    /**
     * UnionTypeDefinition :
     *   - Description? union Name Directives[Const]? UnionMemberTypes?
     */
    parseUnionTypeDefinition() {
      const d = this._lexer.token, m = this.parseDescription();
      this.expectKeyword("union");
      const T = this.parseName(), O = this.parseConstDirectives(), R = this.parseUnionMemberTypes();
      return this.node(d, {
        kind: i.Kind.UNION_TYPE_DEFINITION,
        description: m,
        name: T,
        directives: O,
        types: R
      });
    }
    /**
     * UnionMemberTypes :
     *   - = `|`? NamedType
     *   - UnionMemberTypes | NamedType
     */
    parseUnionMemberTypes() {
      return this.expectOptionalToken(a.TokenKind.EQUALS) ? this.delimitedMany(a.TokenKind.PIPE, this.parseNamedType) : [];
    }
    /**
     * EnumTypeDefinition :
     *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
     */
    parseEnumTypeDefinition() {
      const d = this._lexer.token, m = this.parseDescription();
      this.expectKeyword("enum");
      const T = this.parseName(), O = this.parseConstDirectives(), R = this.parseEnumValuesDefinition();
      return this.node(d, {
        kind: i.Kind.ENUM_TYPE_DEFINITION,
        description: m,
        name: T,
        directives: O,
        values: R
      });
    }
    /**
     * ```
     * EnumValuesDefinition : { EnumValueDefinition+ }
     * ```
     */
    parseEnumValuesDefinition() {
      return this.optionalMany(
        a.TokenKind.BRACE_L,
        this.parseEnumValueDefinition,
        a.TokenKind.BRACE_R
      );
    }
    /**
     * EnumValueDefinition : Description? EnumValue Directives[Const]?
     */
    parseEnumValueDefinition() {
      const d = this._lexer.token, m = this.parseDescription(), T = this.parseEnumValueName(), O = this.parseConstDirectives();
      return this.node(d, {
        kind: i.Kind.ENUM_VALUE_DEFINITION,
        description: m,
        name: T,
        directives: O
      });
    }
    /**
     * EnumValue : Name but not `true`, `false` or `null`
     */
    parseEnumValueName() {
      if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null")
        throw (0, e.syntaxError)(
          this._lexer.source,
          this._lexer.token.start,
          `${p(
            this._lexer.token
          )} is reserved and cannot be used for an enum value.`
        );
      return this.parseName();
    }
    /**
     * InputObjectTypeDefinition :
     *   - Description? input Name Directives[Const]? InputFieldsDefinition?
     */
    parseInputObjectTypeDefinition() {
      const d = this._lexer.token, m = this.parseDescription();
      this.expectKeyword("input");
      const T = this.parseName(), O = this.parseConstDirectives(), R = this.parseInputFieldsDefinition();
      return this.node(d, {
        kind: i.Kind.INPUT_OBJECT_TYPE_DEFINITION,
        description: m,
        name: T,
        directives: O,
        fields: R
      });
    }
    /**
     * ```
     * InputFieldsDefinition : { InputValueDefinition+ }
     * ```
     */
    parseInputFieldsDefinition() {
      return this.optionalMany(
        a.TokenKind.BRACE_L,
        this.parseInputValueDef,
        a.TokenKind.BRACE_R
      );
    }
    /**
     * TypeSystemExtension :
     *   - SchemaExtension
     *   - TypeExtension
     *
     * TypeExtension :
     *   - ScalarTypeExtension
     *   - ObjectTypeExtension
     *   - InterfaceTypeExtension
     *   - UnionTypeExtension
     *   - EnumTypeExtension
     *   - InputObjectTypeDefinition
     */
    parseTypeSystemExtension() {
      const d = this._lexer.lookahead();
      if (d.kind === a.TokenKind.NAME)
        switch (d.value) {
          case "schema":
            return this.parseSchemaExtension();
          case "scalar":
            return this.parseScalarTypeExtension();
          case "type":
            return this.parseObjectTypeExtension();
          case "interface":
            return this.parseInterfaceTypeExtension();
          case "union":
            return this.parseUnionTypeExtension();
          case "enum":
            return this.parseEnumTypeExtension();
          case "input":
            return this.parseInputObjectTypeExtension();
        }
      throw this.unexpected(d);
    }
    /**
     * ```
     * SchemaExtension :
     *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
     *  - extend schema Directives[Const]
     * ```
     */
    parseSchemaExtension() {
      const d = this._lexer.token;
      this.expectKeyword("extend"), this.expectKeyword("schema");
      const m = this.parseConstDirectives(), T = this.optionalMany(
        a.TokenKind.BRACE_L,
        this.parseOperationTypeDefinition,
        a.TokenKind.BRACE_R
      );
      if (m.length === 0 && T.length === 0)
        throw this.unexpected();
      return this.node(d, {
        kind: i.Kind.SCHEMA_EXTENSION,
        directives: m,
        operationTypes: T
      });
    }
    /**
     * ScalarTypeExtension :
     *   - extend scalar Name Directives[Const]
     */
    parseScalarTypeExtension() {
      const d = this._lexer.token;
      this.expectKeyword("extend"), this.expectKeyword("scalar");
      const m = this.parseName(), T = this.parseConstDirectives();
      if (T.length === 0)
        throw this.unexpected();
      return this.node(d, {
        kind: i.Kind.SCALAR_TYPE_EXTENSION,
        name: m,
        directives: T
      });
    }
    /**
     * ObjectTypeExtension :
     *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
     *  - extend type Name ImplementsInterfaces? Directives[Const]
     *  - extend type Name ImplementsInterfaces
     */
    parseObjectTypeExtension() {
      const d = this._lexer.token;
      this.expectKeyword("extend"), this.expectKeyword("type");
      const m = this.parseName(), T = this.parseImplementsInterfaces(), O = this.parseConstDirectives(), R = this.parseFieldsDefinition();
      if (T.length === 0 && O.length === 0 && R.length === 0)
        throw this.unexpected();
      return this.node(d, {
        kind: i.Kind.OBJECT_TYPE_EXTENSION,
        name: m,
        interfaces: T,
        directives: O,
        fields: R
      });
    }
    /**
     * InterfaceTypeExtension :
     *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
     *  - extend interface Name ImplementsInterfaces? Directives[Const]
     *  - extend interface Name ImplementsInterfaces
     */
    parseInterfaceTypeExtension() {
      const d = this._lexer.token;
      this.expectKeyword("extend"), this.expectKeyword("interface");
      const m = this.parseName(), T = this.parseImplementsInterfaces(), O = this.parseConstDirectives(), R = this.parseFieldsDefinition();
      if (T.length === 0 && O.length === 0 && R.length === 0)
        throw this.unexpected();
      return this.node(d, {
        kind: i.Kind.INTERFACE_TYPE_EXTENSION,
        name: m,
        interfaces: T,
        directives: O,
        fields: R
      });
    }
    /**
     * UnionTypeExtension :
     *   - extend union Name Directives[Const]? UnionMemberTypes
     *   - extend union Name Directives[Const]
     */
    parseUnionTypeExtension() {
      const d = this._lexer.token;
      this.expectKeyword("extend"), this.expectKeyword("union");
      const m = this.parseName(), T = this.parseConstDirectives(), O = this.parseUnionMemberTypes();
      if (T.length === 0 && O.length === 0)
        throw this.unexpected();
      return this.node(d, {
        kind: i.Kind.UNION_TYPE_EXTENSION,
        name: m,
        directives: T,
        types: O
      });
    }
    /**
     * EnumTypeExtension :
     *   - extend enum Name Directives[Const]? EnumValuesDefinition
     *   - extend enum Name Directives[Const]
     */
    parseEnumTypeExtension() {
      const d = this._lexer.token;
      this.expectKeyword("extend"), this.expectKeyword("enum");
      const m = this.parseName(), T = this.parseConstDirectives(), O = this.parseEnumValuesDefinition();
      if (T.length === 0 && O.length === 0)
        throw this.unexpected();
      return this.node(d, {
        kind: i.Kind.ENUM_TYPE_EXTENSION,
        name: m,
        directives: T,
        values: O
      });
    }
    /**
     * InputObjectTypeExtension :
     *   - extend input Name Directives[Const]? InputFieldsDefinition
     *   - extend input Name Directives[Const]
     */
    parseInputObjectTypeExtension() {
      const d = this._lexer.token;
      this.expectKeyword("extend"), this.expectKeyword("input");
      const m = this.parseName(), T = this.parseConstDirectives(), O = this.parseInputFieldsDefinition();
      if (T.length === 0 && O.length === 0)
        throw this.unexpected();
      return this.node(d, {
        kind: i.Kind.INPUT_OBJECT_TYPE_EXTENSION,
        name: m,
        directives: T,
        fields: O
      });
    }
    /**
     * ```
     * DirectiveDefinition :
     *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
     * ```
     */
    parseDirectiveDefinition() {
      const d = this._lexer.token, m = this.parseDescription();
      this.expectKeyword("directive"), this.expectToken(a.TokenKind.AT);
      const T = this.parseName(), O = this.parseArgumentDefs(), R = this.expectOptionalKeyword("repeatable");
      this.expectKeyword("on");
      const D = this.parseDirectiveLocations();
      return this.node(d, {
        kind: i.Kind.DIRECTIVE_DEFINITION,
        description: m,
        name: T,
        arguments: O,
        repeatable: R,
        locations: D
      });
    }
    /**
     * DirectiveLocations :
     *   - `|`? DirectiveLocation
     *   - DirectiveLocations | DirectiveLocation
     */
    parseDirectiveLocations() {
      return this.delimitedMany(
        a.TokenKind.PIPE,
        this.parseDirectiveLocation
      );
    }
    /*
     * DirectiveLocation :
     *   - ExecutableDirectiveLocation
     *   - TypeSystemDirectiveLocation
     *
     * ExecutableDirectiveLocation : one of
     *   `QUERY`
     *   `MUTATION`
     *   `SUBSCRIPTION`
     *   `FIELD`
     *   `FRAGMENT_DEFINITION`
     *   `FRAGMENT_SPREAD`
     *   `INLINE_FRAGMENT`
     *
     * TypeSystemDirectiveLocation : one of
     *   `SCHEMA`
     *   `SCALAR`
     *   `OBJECT`
     *   `FIELD_DEFINITION`
     *   `ARGUMENT_DEFINITION`
     *   `INTERFACE`
     *   `UNION`
     *   `ENUM`
     *   `ENUM_VALUE`
     *   `INPUT_OBJECT`
     *   `INPUT_FIELD_DEFINITION`
     */
    parseDirectiveLocation() {
      const d = this._lexer.token, m = this.parseName();
      if (Object.prototype.hasOwnProperty.call(
        s.DirectiveLocation,
        m.value
      ))
        return m;
      throw this.unexpected(d);
    }
    // Core parsing utility functions
    /**
     * Returns a node that, if configured to do so, sets a "loc" field as a
     * location object, used to identify the place in the source that created a
     * given parsed object.
     */
    node(d, m) {
      return this._options.noLocation !== !0 && (m.loc = new n.Location(
        d,
        this._lexer.lastToken,
        this._lexer.source
      )), m;
    }
    /**
     * Determines if the next token is of a given kind
     */
    peek(d) {
      return this._lexer.token.kind === d;
    }
    /**
     * If the next token is of the given kind, return that token after advancing the lexer.
     * Otherwise, do not change the parser state and throw an error.
     */
    expectToken(d) {
      const m = this._lexer.token;
      if (m.kind === d)
        return this.advanceLexer(), m;
      throw (0, e.syntaxError)(
        this._lexer.source,
        m.start,
        `Expected ${h(d)}, found ${p(m)}.`
      );
    }
    /**
     * If the next token is of the given kind, return "true" after advancing the lexer.
     * Otherwise, do not change the parser state and return "false".
     */
    expectOptionalToken(d) {
      return this._lexer.token.kind === d ? (this.advanceLexer(), !0) : !1;
    }
    /**
     * If the next token is a given keyword, advance the lexer.
     * Otherwise, do not change the parser state and throw an error.
     */
    expectKeyword(d) {
      const m = this._lexer.token;
      if (m.kind === a.TokenKind.NAME && m.value === d)
        this.advanceLexer();
      else
        throw (0, e.syntaxError)(
          this._lexer.source,
          m.start,
          `Expected "${d}", found ${p(m)}.`
        );
    }
    /**
     * If the next token is a given keyword, return "true" after advancing the lexer.
     * Otherwise, do not change the parser state and return "false".
     */
    expectOptionalKeyword(d) {
      const m = this._lexer.token;
      return m.kind === a.TokenKind.NAME && m.value === d ? (this.advanceLexer(), !0) : !1;
    }
    /**
     * Helper function for creating an error when an unexpected lexed token is encountered.
     */
    unexpected(d) {
      const m = d ?? this._lexer.token;
      return (0, e.syntaxError)(
        this._lexer.source,
        m.start,
        `Unexpected ${p(m)}.`
      );
    }
    /**
     * Returns a possibly empty list of parse nodes, determined by the parseFn.
     * This list begins with a lex token of openKind and ends with a lex token of closeKind.
     * Advances the parser to the next lex token after the closing token.
     */
    any(d, m, T) {
      this.expectToken(d);
      const O = [];
      for (; !this.expectOptionalToken(T); )
        O.push(m.call(this));
      return O;
    }
    /**
     * Returns a list of parse nodes, determined by the parseFn.
     * It can be empty only if open token is missing otherwise it will always return non-empty list
     * that begins with a lex token of openKind and ends with a lex token of closeKind.
     * Advances the parser to the next lex token after the closing token.
     */
    optionalMany(d, m, T) {
      if (this.expectOptionalToken(d)) {
        const O = [];
        do
          O.push(m.call(this));
        while (!this.expectOptionalToken(T));
        return O;
      }
      return [];
    }
    /**
     * Returns a non-empty list of parse nodes, determined by the parseFn.
     * This list begins with a lex token of openKind and ends with a lex token of closeKind.
     * Advances the parser to the next lex token after the closing token.
     */
    many(d, m, T) {
      this.expectToken(d);
      const O = [];
      do
        O.push(m.call(this));
      while (!this.expectOptionalToken(T));
      return O;
    }
    /**
     * Returns a non-empty list of parse nodes, determined by the parseFn.
     * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
     * Advances the parser to the next lex token after last item in the list.
     */
    delimitedMany(d, m) {
      this.expectOptionalToken(d);
      const T = [];
      do
        T.push(m.call(this));
      while (this.expectOptionalToken(d));
      return T;
    }
    advanceLexer() {
      const { maxTokens: d } = this._options, m = this._lexer.advance();
      if (m.kind !== a.TokenKind.EOF && (++this._tokenCounter, d !== void 0 && this._tokenCounter > d))
        throw (0, e.syntaxError)(
          this._lexer.source,
          m.start,
          `Document contains more that ${d} tokens. Parsing aborted.`
        );
    }
  }
  Qe.Parser = o;
  function p(l) {
    const d = l.value;
    return h(l.kind) + (d != null ? ` "${d}"` : "");
  }
  function h(l) {
    return (0, t.isPunctuatorTokenKind)(l) ? `"${l}"` : l;
  }
  return Qe;
}
var An = {}, vn = {}, H = {}, at = {}, qi;
function sn() {
  if (qi) return at;
  qi = 1, Object.defineProperty(at, "__esModule", {
    value: !0
  }), at.didYouMean = n;
  const e = 5;
  function n(s, i) {
    const [t, r] = i ? [s, i] : [void 0, s];
    let a = " Did you mean ";
    t && (a += t + " ");
    const c = r.map((y) => `"${y}"`);
    switch (c.length) {
      case 0:
        return "";
      case 1:
        return a + c[0] + "?";
      case 2:
        return a + c[0] + " or " + c[1] + "?";
    }
    const u = c.slice(0, e), f = u.pop();
    return a + u.join(", ") + ", or " + f + "?";
  }
  return at;
}
var st = {}, Ki;
function Iu() {
  if (Ki) return st;
  Ki = 1, Object.defineProperty(st, "__esModule", {
    value: !0
  }), st.identityFunc = e;
  function e(n) {
    return n;
  }
  return st;
}
var ot = {}, Bi;
function on() {
  if (Bi) return ot;
  Bi = 1, Object.defineProperty(ot, "__esModule", {
    value: !0
  }), ot.keyMap = e;
  function e(n, s) {
    const i = /* @__PURE__ */ Object.create(null);
    for (const t of n)
      i[s(t)] = t;
    return i;
  }
  return ot;
}
var ut = {}, xi;
function Lr() {
  if (xi) return ut;
  xi = 1, Object.defineProperty(ut, "__esModule", {
    value: !0
  }), ut.keyValMap = e;
  function e(n, s, i) {
    const t = /* @__PURE__ */ Object.create(null);
    for (const r of n)
      t[s(r)] = i(r);
    return t;
  }
  return ut;
}
var ct = {}, Yi;
function Ys() {
  if (Yi) return ct;
  Yi = 1, Object.defineProperty(ct, "__esModule", {
    value: !0
  }), ct.mapValue = e;
  function e(n, s) {
    const i = /* @__PURE__ */ Object.create(null);
    for (const t of Object.keys(n))
      i[t] = s(n[t], t);
    return i;
  }
  return ct;
}
var lt = {}, pt = {}, Ji;
function Sr() {
  if (Ji) return pt;
  Ji = 1, Object.defineProperty(pt, "__esModule", {
    value: !0
  }), pt.naturalCompare = e;
  function e(t, r) {
    let a = 0, c = 0;
    for (; a < t.length && c < r.length; ) {
      let u = t.charCodeAt(a), f = r.charCodeAt(c);
      if (i(u) && i(f)) {
        let y = 0;
        do
          ++a, y = y * 10 + u - n, u = t.charCodeAt(a);
        while (i(u) && y > 0);
        let o = 0;
        do
          ++c, o = o * 10 + f - n, f = r.charCodeAt(c);
        while (i(f) && o > 0);
        if (y < o)
          return -1;
        if (y > o)
          return 1;
      } else {
        if (u < f)
          return -1;
        if (u > f)
          return 1;
        ++a, ++c;
      }
    }
    return t.length - r.length;
  }
  const n = 48, s = 57;
  function i(t) {
    return !isNaN(t) && n <= t && t <= s;
  }
  return pt;
}
var zi;
function un() {
  if (zi) return lt;
  zi = 1, Object.defineProperty(lt, "__esModule", {
    value: !0
  }), lt.suggestionList = n;
  var e = /* @__PURE__ */ Sr();
  function n(t, r) {
    const a = /* @__PURE__ */ Object.create(null), c = new s(t), u = Math.floor(t.length * 0.4) + 1;
    for (const f of r) {
      const y = c.measure(f, u);
      y !== void 0 && (a[f] = y);
    }
    return Object.keys(a).sort((f, y) => {
      const o = a[f] - a[y];
      return o !== 0 ? o : (0, e.naturalCompare)(f, y);
    });
  }
  class s {
    constructor(r) {
      this._input = r, this._inputLowerCase = r.toLowerCase(), this._inputArray = i(this._inputLowerCase), this._rows = [
        new Array(r.length + 1).fill(0),
        new Array(r.length + 1).fill(0),
        new Array(r.length + 1).fill(0)
      ];
    }
    measure(r, a) {
      if (this._input === r)
        return 0;
      const c = r.toLowerCase();
      if (this._inputLowerCase === c)
        return 1;
      let u = i(c), f = this._inputArray;
      if (u.length < f.length) {
        const l = u;
        u = f, f = l;
      }
      const y = u.length, o = f.length;
      if (y - o > a)
        return;
      const p = this._rows;
      for (let l = 0; l <= o; l++)
        p[0][l] = l;
      for (let l = 1; l <= y; l++) {
        const d = p[(l - 1) % 3], m = p[l % 3];
        let T = m[0] = l;
        for (let O = 1; O <= o; O++) {
          const R = u[l - 1] === f[O - 1] ? 0 : 1;
          let D = Math.min(
            d[O] + 1,
            // delete
            m[O - 1] + 1,
            // insert
            d[O - 1] + R
            // substitute
          );
          if (l > 1 && O > 1 && u[l - 1] === f[O - 2] && u[l - 2] === f[O - 1]) {
            const _ = p[(l - 2) % 3][O - 2];
            D = Math.min(D, _ + 1);
          }
          D < T && (T = D), m[O] = D;
        }
        if (T > a)
          return;
      }
      const h = p[y % 3][o];
      return h <= a ? h : void 0;
    }
  }
  function i(t) {
    const r = t.length, a = new Array(r);
    for (let c = 0; c < r; ++c)
      a[c] = t.charCodeAt(c);
    return a;
  }
  return lt;
}
var dt = {}, Xi;
function ii() {
  if (Xi) return dt;
  Xi = 1, Object.defineProperty(dt, "__esModule", {
    value: !0
  }), dt.toObjMap = e;
  function e(n) {
    if (n == null)
      return /* @__PURE__ */ Object.create(null);
    if (Object.getPrototypeOf(n) === null)
      return n;
    const s = /* @__PURE__ */ Object.create(null);
    for (const [i, t] of Object.entries(n))
      s[i] = t;
    return s;
  }
  return dt;
}
var ft = {}, mt = {}, Hi;
function Lu() {
  if (Hi) return mt;
  Hi = 1, Object.defineProperty(mt, "__esModule", {
    value: !0
  }), mt.printString = e;
  function e(t) {
    return `"${t.replace(n, s)}"`;
  }
  const n = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
  function s(t) {
    return i[t.charCodeAt(0)];
  }
  const i = [
    "\\u0000",
    "\\u0001",
    "\\u0002",
    "\\u0003",
    "\\u0004",
    "\\u0005",
    "\\u0006",
    "\\u0007",
    "\\b",
    "\\t",
    "\\n",
    "\\u000B",
    "\\f",
    "\\r",
    "\\u000E",
    "\\u000F",
    "\\u0010",
    "\\u0011",
    "\\u0012",
    "\\u0013",
    "\\u0014",
    "\\u0015",
    "\\u0016",
    "\\u0017",
    "\\u0018",
    "\\u0019",
    "\\u001A",
    "\\u001B",
    "\\u001C",
    "\\u001D",
    "\\u001E",
    "\\u001F",
    "",
    "",
    '\\"',
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // 2F
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // 3F
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // 4F
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "\\\\",
    "",
    "",
    "",
    // 5F
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // 6F
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "\\u007F",
    "\\u0080",
    "\\u0081",
    "\\u0082",
    "\\u0083",
    "\\u0084",
    "\\u0085",
    "\\u0086",
    "\\u0087",
    "\\u0088",
    "\\u0089",
    "\\u008A",
    "\\u008B",
    "\\u008C",
    "\\u008D",
    "\\u008E",
    "\\u008F",
    "\\u0090",
    "\\u0091",
    "\\u0092",
    "\\u0093",
    "\\u0094",
    "\\u0095",
    "\\u0096",
    "\\u0097",
    "\\u0098",
    "\\u0099",
    "\\u009A",
    "\\u009B",
    "\\u009C",
    "\\u009D",
    "\\u009E",
    "\\u009F"
  ];
  return mt;
}
var qe = {}, Wi;
function On() {
  if (Wi) return qe;
  Wi = 1, Object.defineProperty(qe, "__esModule", {
    value: !0
  }), qe.BREAK = void 0, qe.getEnterLeaveForKind = c, qe.getVisitFn = u, qe.visit = r, qe.visitInParallel = a;
  var e = /* @__PURE__ */ Re(), n = /* @__PURE__ */ de(), s = /* @__PURE__ */ Je(), i = /* @__PURE__ */ se();
  const t = Object.freeze({});
  qe.BREAK = t;
  function r(f, y, o = s.QueryDocumentKeys) {
    const p = /* @__PURE__ */ new Map();
    for (const g of Object.values(i.Kind))
      p.set(g, c(y, g));
    let h, l = Array.isArray(f), d = [f], m = -1, T = [], O = f, R, D;
    const _ = [], w = [];
    do {
      m++;
      const g = m === d.length, S = g && T.length !== 0;
      if (g) {
        if (R = w.length === 0 ? void 0 : _[_.length - 1], O = D, D = w.pop(), S)
          if (l) {
            O = O.slice();
            let v = 0;
            for (const [b, I] of T) {
              const L = b - v;
              I === null ? (O.splice(L, 1), v++) : O[L] = I;
            }
          } else {
            O = { ...O };
            for (const [v, b] of T)
              O[v] = b;
          }
        m = h.index, d = h.keys, T = h.edits, l = h.inArray, h = h.prev;
      } else if (D) {
        if (R = l ? m : d[m], O = D[R], O == null)
          continue;
        _.push(R);
      }
      let E;
      if (!Array.isArray(O)) {
        var $, G;
        (0, s.isNode)(O) || (0, e.devAssert)(
          !1,
          `Invalid AST Node: ${(0, n.inspect)(O)}.`
        );
        const v = g ? ($ = p.get(O.kind)) === null || $ === void 0 ? void 0 : $.leave : (G = p.get(O.kind)) === null || G === void 0 ? void 0 : G.enter;
        if (E = v?.call(y, O, R, D, _, w), E === t)
          break;
        if (E === !1) {
          if (!g) {
            _.pop();
            continue;
          }
        } else if (E !== void 0 && (T.push([R, E]), !g))
          if ((0, s.isNode)(E))
            O = E;
          else {
            _.pop();
            continue;
          }
      }
      if (E === void 0 && S && T.push([R, O]), g)
        _.pop();
      else {
        var N;
        h = {
          inArray: l,
          index: m,
          keys: d,
          edits: T,
          prev: h
        }, l = Array.isArray(O), d = l ? O : (N = o[O.kind]) !== null && N !== void 0 ? N : [], m = -1, T = [], D && w.push(D), D = O;
      }
    } while (h !== void 0);
    return T.length !== 0 ? T[T.length - 1][1] : f;
  }
  function a(f) {
    const y = new Array(f.length).fill(null), o = /* @__PURE__ */ Object.create(null);
    for (const p of Object.values(i.Kind)) {
      let h = !1;
      const l = new Array(f.length).fill(void 0), d = new Array(f.length).fill(void 0);
      for (let T = 0; T < f.length; ++T) {
        const { enter: O, leave: R } = c(f[T], p);
        h || (h = O != null || R != null), l[T] = O, d[T] = R;
      }
      if (!h)
        continue;
      const m = {
        enter(...T) {
          const O = T[0];
          for (let D = 0; D < f.length; D++)
            if (y[D] === null) {
              var R;
              const _ = (R = l[D]) === null || R === void 0 ? void 0 : R.apply(f[D], T);
              if (_ === !1)
                y[D] = O;
              else if (_ === t)
                y[D] = t;
              else if (_ !== void 0)
                return _;
            }
        },
        leave(...T) {
          const O = T[0];
          for (let D = 0; D < f.length; D++)
            if (y[D] === null) {
              var R;
              const _ = (R = d[D]) === null || R === void 0 ? void 0 : R.apply(f[D], T);
              if (_ === t)
                y[D] = t;
              else if (_ !== void 0 && _ !== !1)
                return _;
            } else y[D] === O && (y[D] = null);
        }
      };
      o[p] = m;
    }
    return o;
  }
  function c(f, y) {
    const o = f[y];
    return typeof o == "object" ? o : typeof o == "function" ? {
      enter: o,
      leave: void 0
    } : {
      enter: f.enter,
      leave: f.leave
    };
  }
  function u(f, y, o) {
    const { enter: p, leave: h } = c(f, y);
    return o ? h : p;
  }
  return qe;
}
var Zi;
function we() {
  if (Zi) return ft;
  Zi = 1, Object.defineProperty(ft, "__esModule", {
    value: !0
  }), ft.print = i;
  var e = /* @__PURE__ */ Or(), n = /* @__PURE__ */ Lu(), s = /* @__PURE__ */ On();
  function i(o) {
    return (0, s.visit)(o, r);
  }
  const t = 80, r = {
    Name: {
      leave: (o) => o.value
    },
    Variable: {
      leave: (o) => "$" + o.name
    },
    // Document
    Document: {
      leave: (o) => a(o.definitions, `

`)
    },
    OperationDefinition: {
      leave(o) {
        const p = u("(", a(o.variableDefinitions, ", "), ")"), h = a(
          [
            o.operation,
            a([o.name, p]),
            a(o.directives, " ")
          ],
          " "
        );
        return (h === "query" ? "" : h + " ") + o.selectionSet;
      }
    },
    VariableDefinition: {
      leave: ({ variable: o, type: p, defaultValue: h, directives: l }) => o + ": " + p + u(" = ", h) + u(" ", a(l, " "))
    },
    SelectionSet: {
      leave: ({ selections: o }) => c(o)
    },
    Field: {
      leave({ alias: o, name: p, arguments: h, directives: l, selectionSet: d }) {
        const m = u("", o, ": ") + p;
        let T = m + u("(", a(h, ", "), ")");
        return T.length > t && (T = m + u(`(
`, f(a(h, `
`)), `
)`)), a([T, a(l, " "), d], " ");
      }
    },
    Argument: {
      leave: ({ name: o, value: p }) => o + ": " + p
    },
    // Fragments
    FragmentSpread: {
      leave: ({ name: o, directives: p }) => "..." + o + u(" ", a(p, " "))
    },
    InlineFragment: {
      leave: ({ typeCondition: o, directives: p, selectionSet: h }) => a(
        [
          "...",
          u("on ", o),
          a(p, " "),
          h
        ],
        " "
      )
    },
    FragmentDefinition: {
      leave: ({ name: o, typeCondition: p, variableDefinitions: h, directives: l, selectionSet: d }) => (
        // or removed in the future.
        `fragment ${o}${u("(", a(h, ", "), ")")} on ${p} ${u("", a(l, " "), " ")}` + d
      )
    },
    // Value
    IntValue: {
      leave: ({ value: o }) => o
    },
    FloatValue: {
      leave: ({ value: o }) => o
    },
    StringValue: {
      leave: ({ value: o, block: p }) => p ? (0, e.printBlockString)(o) : (0, n.printString)(o)
    },
    BooleanValue: {
      leave: ({ value: o }) => o ? "true" : "false"
    },
    NullValue: {
      leave: () => "null"
    },
    EnumValue: {
      leave: ({ value: o }) => o
    },
    ListValue: {
      leave: ({ values: o }) => "[" + a(o, ", ") + "]"
    },
    ObjectValue: {
      leave: ({ fields: o }) => "{" + a(o, ", ") + "}"
    },
    ObjectField: {
      leave: ({ name: o, value: p }) => o + ": " + p
    },
    // Directive
    Directive: {
      leave: ({ name: o, arguments: p }) => "@" + o + u("(", a(p, ", "), ")")
    },
    // Type
    NamedType: {
      leave: ({ name: o }) => o
    },
    ListType: {
      leave: ({ type: o }) => "[" + o + "]"
    },
    NonNullType: {
      leave: ({ type: o }) => o + "!"
    },
    // Type System Definitions
    SchemaDefinition: {
      leave: ({ description: o, directives: p, operationTypes: h }) => u("", o, `
`) + a(["schema", a(p, " "), c(h)], " ")
    },
    OperationTypeDefinition: {
      leave: ({ operation: o, type: p }) => o + ": " + p
    },
    ScalarTypeDefinition: {
      leave: ({ description: o, name: p, directives: h }) => u("", o, `
`) + a(["scalar", p, a(h, " ")], " ")
    },
    ObjectTypeDefinition: {
      leave: ({ description: o, name: p, interfaces: h, directives: l, fields: d }) => u("", o, `
`) + a(
        [
          "type",
          p,
          u("implements ", a(h, " & ")),
          a(l, " "),
          c(d)
        ],
        " "
      )
    },
    FieldDefinition: {
      leave: ({ description: o, name: p, arguments: h, type: l, directives: d }) => u("", o, `
`) + p + (y(h) ? u(`(
`, f(a(h, `
`)), `
)`) : u("(", a(h, ", "), ")")) + ": " + l + u(" ", a(d, " "))
    },
    InputValueDefinition: {
      leave: ({ description: o, name: p, type: h, defaultValue: l, directives: d }) => u("", o, `
`) + a(
        [p + ": " + h, u("= ", l), a(d, " ")],
        " "
      )
    },
    InterfaceTypeDefinition: {
      leave: ({ description: o, name: p, interfaces: h, directives: l, fields: d }) => u("", o, `
`) + a(
        [
          "interface",
          p,
          u("implements ", a(h, " & ")),
          a(l, " "),
          c(d)
        ],
        " "
      )
    },
    UnionTypeDefinition: {
      leave: ({ description: o, name: p, directives: h, types: l }) => u("", o, `
`) + a(
        ["union", p, a(h, " "), u("= ", a(l, " | "))],
        " "
      )
    },
    EnumTypeDefinition: {
      leave: ({ description: o, name: p, directives: h, values: l }) => u("", o, `
`) + a(["enum", p, a(h, " "), c(l)], " ")
    },
    EnumValueDefinition: {
      leave: ({ description: o, name: p, directives: h }) => u("", o, `
`) + a([p, a(h, " ")], " ")
    },
    InputObjectTypeDefinition: {
      leave: ({ description: o, name: p, directives: h, fields: l }) => u("", o, `
`) + a(["input", p, a(h, " "), c(l)], " ")
    },
    DirectiveDefinition: {
      leave: ({ description: o, name: p, arguments: h, repeatable: l, locations: d }) => u("", o, `
`) + "directive @" + p + (y(h) ? u(`(
`, f(a(h, `
`)), `
)`) : u("(", a(h, ", "), ")")) + (l ? " repeatable" : "") + " on " + a(d, " | ")
    },
    SchemaExtension: {
      leave: ({ directives: o, operationTypes: p }) => a(
        ["extend schema", a(o, " "), c(p)],
        " "
      )
    },
    ScalarTypeExtension: {
      leave: ({ name: o, directives: p }) => a(["extend scalar", o, a(p, " ")], " ")
    },
    ObjectTypeExtension: {
      leave: ({ name: o, interfaces: p, directives: h, fields: l }) => a(
        [
          "extend type",
          o,
          u("implements ", a(p, " & ")),
          a(h, " "),
          c(l)
        ],
        " "
      )
    },
    InterfaceTypeExtension: {
      leave: ({ name: o, interfaces: p, directives: h, fields: l }) => a(
        [
          "extend interface",
          o,
          u("implements ", a(p, " & ")),
          a(h, " "),
          c(l)
        ],
        " "
      )
    },
    UnionTypeExtension: {
      leave: ({ name: o, directives: p, types: h }) => a(
        [
          "extend union",
          o,
          a(p, " "),
          u("= ", a(h, " | "))
        ],
        " "
      )
    },
    EnumTypeExtension: {
      leave: ({ name: o, directives: p, values: h }) => a(["extend enum", o, a(p, " "), c(h)], " ")
    },
    InputObjectTypeExtension: {
      leave: ({ name: o, directives: p, fields: h }) => a(["extend input", o, a(p, " "), c(h)], " ")
    }
  };
  function a(o, p = "") {
    var h;
    return (h = o?.filter((l) => l).join(p)) !== null && h !== void 0 ? h : "";
  }
  function c(o) {
    return u(`{
`, f(a(o, `
`)), `
}`);
  }
  function u(o, p, h = "") {
    return p != null && p !== "" ? o + p + h : "";
  }
  function f(o) {
    return u("  ", o.replace(/\n/g, `
  `));
  }
  function y(o) {
    var p;
    return (p = o?.some((h) => h.includes(`
`))) !== null && p !== void 0 ? p : !1;
  }
  return ft;
}
var yt = {}, ea;
function Js() {
  if (ea) return yt;
  ea = 1, Object.defineProperty(yt, "__esModule", {
    value: !0
  }), yt.valueFromASTUntyped = s;
  var e = /* @__PURE__ */ Lr(), n = /* @__PURE__ */ se();
  function s(i, t) {
    switch (i.kind) {
      case n.Kind.NULL:
        return null;
      case n.Kind.INT:
        return parseInt(i.value, 10);
      case n.Kind.FLOAT:
        return parseFloat(i.value);
      case n.Kind.STRING:
      case n.Kind.ENUM:
      case n.Kind.BOOLEAN:
        return i.value;
      case n.Kind.LIST:
        return i.values.map(
          (r) => s(r, t)
        );
      case n.Kind.OBJECT:
        return (0, e.keyValMap)(
          i.fields,
          (r) => r.name.value,
          (r) => s(r.value, t)
        );
      case n.Kind.VARIABLE:
        return t?.[i.name.value];
    }
  }
  return yt;
}
var jn = {}, na;
function Rr() {
  if (na) return jn;
  na = 1, Object.defineProperty(jn, "__esModule", {
    value: !0
  }), jn.assertEnumValueName = t, jn.assertName = i;
  var e = /* @__PURE__ */ Re(), n = /* @__PURE__ */ ne(), s = /* @__PURE__ */ ni();
  function i(r) {
    if (r != null || (0, e.devAssert)(!1, "Must provide name."), typeof r == "string" || (0, e.devAssert)(!1, "Expected name to be a string."), r.length === 0)
      throw new n.GraphQLError(
        "Expected name to be a non-empty string."
      );
    for (let a = 1; a < r.length; ++a)
      if (!(0, s.isNameContinue)(r.charCodeAt(a)))
        throw new n.GraphQLError(
          `Names must only contain [_a-zA-Z0-9] but "${r}" does not.`
        );
    if (!(0, s.isNameStart)(r.charCodeAt(0)))
      throw new n.GraphQLError(
        `Names must start with [_a-zA-Z] but "${r}" does not.`
      );
    return r;
  }
  function t(r) {
    if (r === "true" || r === "false" || r === "null")
      throw new n.GraphQLError(
        `Enum values cannot be named: ${r}`
      );
    return i(r);
  }
  return jn;
}
var ta;
function oe() {
  if (ta) return H;
  ta = 1, Object.defineProperty(H, "__esModule", {
    value: !0
  }), H.GraphQLUnionType = H.GraphQLScalarType = H.GraphQLObjectType = H.GraphQLNonNull = H.GraphQLList = H.GraphQLInterfaceType = H.GraphQLInputObjectType = H.GraphQLEnumType = void 0, H.argsToArgsConfig = fe, H.assertAbstractType = B, H.assertCompositeType = M, H.assertEnumType = S, H.assertInputObjectType = v, H.assertInputType = U, H.assertInterfaceType = $, H.assertLeafType = te, H.assertListType = I, H.assertNamedType = Oe, H.assertNonNullType = j, H.assertNullableType = ue, H.assertObjectType = _, H.assertOutputType = P, H.assertScalarType = R, H.assertType = T, H.assertUnionType = N, H.assertWrappingType = ee, H.defineArguments = J, H.getNamedType = Ee, H.getNullableType = ce, H.isAbstractType = C, H.isCompositeType = pe, H.isEnumType = g, H.isInputObjectType = E, H.isInputType = V, H.isInterfaceType = w, H.isLeafType = K, H.isListType = b, H.isNamedType = he, H.isNonNullType = L, H.isNullableType = re, H.isObjectType = D, H.isOutputType = W, H.isRequiredArgument = be, H.isRequiredInputField = $o, H.isScalarType = O, H.isType = m, H.isUnionType = G, H.isWrappingType = Y, H.resolveObjMapThunk = _e, H.resolveReadonlyArrayThunk = ve;
  var e = /* @__PURE__ */ Re(), n = /* @__PURE__ */ sn(), s = /* @__PURE__ */ Iu(), i = /* @__PURE__ */ de(), t = /* @__PURE__ */ Ir(), r = /* @__PURE__ */ Ye(), a = /* @__PURE__ */ on(), c = /* @__PURE__ */ Lr(), u = /* @__PURE__ */ Ys(), f = /* @__PURE__ */ un(), y = /* @__PURE__ */ ii(), o = /* @__PURE__ */ ne(), p = /* @__PURE__ */ se(), h = /* @__PURE__ */ we(), l = /* @__PURE__ */ Js(), d = /* @__PURE__ */ Rr();
  function m(A) {
    return O(A) || D(A) || w(A) || G(A) || g(A) || E(A) || b(A) || L(A);
  }
  function T(A) {
    if (!m(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL type.`
      );
    return A;
  }
  function O(A) {
    return (0, t.instanceOf)(A, Fe);
  }
  function R(A) {
    if (!O(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL Scalar type.`
      );
    return A;
  }
  function D(A) {
    return (0, t.instanceOf)(A, en);
  }
  function _(A) {
    if (!D(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL Object type.`
      );
    return A;
  }
  function w(A) {
    return (0, t.instanceOf)(A, me);
  }
  function $(A) {
    if (!w(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL Interface type.`
      );
    return A;
  }
  function G(A) {
    return (0, t.instanceOf)(A, Ue);
  }
  function N(A) {
    if (!G(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL Union type.`
      );
    return A;
  }
  function g(A) {
    return (0, t.instanceOf)(A, cn);
  }
  function S(A) {
    if (!g(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL Enum type.`
      );
    return A;
  }
  function E(A) {
    return (0, t.instanceOf)(A, li);
  }
  function v(A) {
    if (!E(A))
      throw new Error(
        `Expected ${(0, i.inspect)(
          A
        )} to be a GraphQL Input Object type.`
      );
    return A;
  }
  function b(A) {
    return (0, t.instanceOf)(A, x);
  }
  function I(A) {
    if (!b(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL List type.`
      );
    return A;
  }
  function L(A) {
    return (0, t.instanceOf)(A, Z);
  }
  function j(A) {
    if (!L(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL Non-Null type.`
      );
    return A;
  }
  function V(A) {
    return O(A) || g(A) || E(A) || Y(A) && V(A.ofType);
  }
  function U(A) {
    if (!V(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL input type.`
      );
    return A;
  }
  function W(A) {
    return O(A) || D(A) || w(A) || G(A) || g(A) || Y(A) && W(A.ofType);
  }
  function P(A) {
    if (!W(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL output type.`
      );
    return A;
  }
  function K(A) {
    return O(A) || g(A);
  }
  function te(A) {
    if (!K(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL leaf type.`
      );
    return A;
  }
  function pe(A) {
    return D(A) || w(A) || G(A);
  }
  function M(A) {
    if (!pe(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL composite type.`
      );
    return A;
  }
  function C(A) {
    return w(A) || G(A);
  }
  function B(A) {
    if (!C(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL abstract type.`
      );
    return A;
  }
  class x {
    constructor(F) {
      m(F) || (0, e.devAssert)(
        !1,
        `Expected ${(0, i.inspect)(F)} to be a GraphQL type.`
      ), this.ofType = F;
    }
    get [Symbol.toStringTag]() {
      return "GraphQLList";
    }
    toString() {
      return "[" + String(this.ofType) + "]";
    }
    toJSON() {
      return this.toString();
    }
  }
  H.GraphQLList = x;
  class Z {
    constructor(F) {
      re(F) || (0, e.devAssert)(
        !1,
        `Expected ${(0, i.inspect)(
          F
        )} to be a GraphQL nullable type.`
      ), this.ofType = F;
    }
    get [Symbol.toStringTag]() {
      return "GraphQLNonNull";
    }
    toString() {
      return String(this.ofType) + "!";
    }
    toJSON() {
      return this.toString();
    }
  }
  H.GraphQLNonNull = Z;
  function Y(A) {
    return b(A) || L(A);
  }
  function ee(A) {
    if (!Y(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL wrapping type.`
      );
    return A;
  }
  function re(A) {
    return m(A) && !L(A);
  }
  function ue(A) {
    if (!re(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL nullable type.`
      );
    return A;
  }
  function ce(A) {
    if (A)
      return L(A) ? A.ofType : A;
  }
  function he(A) {
    return O(A) || D(A) || w(A) || G(A) || g(A) || E(A);
  }
  function Oe(A) {
    if (!he(A))
      throw new Error(
        `Expected ${(0, i.inspect)(A)} to be a GraphQL named type.`
      );
    return A;
  }
  function Ee(A) {
    if (A) {
      let F = A;
      for (; Y(F); )
        F = F.ofType;
      return F;
    }
  }
  function ve(A) {
    return typeof A == "function" ? A() : A;
  }
  function _e(A) {
    return typeof A == "function" ? A() : A;
  }
  class Fe {
    constructor(F) {
      var Q, ae, Le, ln;
      const pi = (Q = F.parseValue) !== null && Q !== void 0 ? Q : s.identityFunc;
      this.name = (0, d.assertName)(F.name), this.description = F.description, this.specifiedByURL = F.specifiedByURL, this.serialize = (ae = F.serialize) !== null && ae !== void 0 ? ae : s.identityFunc, this.parseValue = pi, this.parseLiteral = (Le = F.parseLiteral) !== null && Le !== void 0 ? Le : (Co, Uo) => pi(
        (0, l.valueFromASTUntyped)(Co, Uo)
      ), this.extensions = (0, y.toObjMap)(F.extensions), this.astNode = F.astNode, this.extensionASTNodes = (ln = F.extensionASTNodes) !== null && ln !== void 0 ? ln : [], F.specifiedByURL == null || typeof F.specifiedByURL == "string" || (0, e.devAssert)(
        !1,
        `${this.name} must provide "specifiedByURL" as a string, but got: ${(0, i.inspect)(F.specifiedByURL)}.`
      ), F.serialize == null || typeof F.serialize == "function" || (0, e.devAssert)(
        !1,
        `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`
      ), F.parseLiteral && (typeof F.parseValue == "function" && typeof F.parseLiteral == "function" || (0, e.devAssert)(
        !1,
        `${this.name} must provide both "parseValue" and "parseLiteral" functions.`
      ));
    }
    get [Symbol.toStringTag]() {
      return "GraphQLScalarType";
    }
    toConfig() {
      return {
        name: this.name,
        description: this.description,
        specifiedByURL: this.specifiedByURL,
        serialize: this.serialize,
        parseValue: this.parseValue,
        parseLiteral: this.parseLiteral,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes
      };
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return this.toString();
    }
  }
  H.GraphQLScalarType = Fe;
  class en {
    constructor(F) {
      var Q;
      this.name = (0, d.assertName)(F.name), this.description = F.description, this.isTypeOf = F.isTypeOf, this.extensions = (0, y.toObjMap)(F.extensions), this.astNode = F.astNode, this.extensionASTNodes = (Q = F.extensionASTNodes) !== null && Q !== void 0 ? Q : [], this._fields = () => k(F), this._interfaces = () => He(F), F.isTypeOf == null || typeof F.isTypeOf == "function" || (0, e.devAssert)(
        !1,
        `${this.name} must provide "isTypeOf" as a function, but got: ${(0, i.inspect)(F.isTypeOf)}.`
      );
    }
    get [Symbol.toStringTag]() {
      return "GraphQLObjectType";
    }
    getFields() {
      return typeof this._fields == "function" && (this._fields = this._fields()), this._fields;
    }
    getInterfaces() {
      return typeof this._interfaces == "function" && (this._interfaces = this._interfaces()), this._interfaces;
    }
    toConfig() {
      return {
        name: this.name,
        description: this.description,
        interfaces: this.getInterfaces(),
        fields: z(this.getFields()),
        isTypeOf: this.isTypeOf,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes
      };
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return this.toString();
    }
  }
  H.GraphQLObjectType = en;
  function He(A) {
    var F;
    const Q = ve(
      (F = A.interfaces) !== null && F !== void 0 ? F : []
    );
    return Array.isArray(Q) || (0, e.devAssert)(
      !1,
      `${A.name} interfaces must be an Array or a function which returns an Array.`
    ), Q;
  }
  function k(A) {
    const F = _e(A.fields);
    return q(F) || (0, e.devAssert)(
      !1,
      `${A.name} fields must be an object with field names as keys or a function which returns such an object.`
    ), (0, u.mapValue)(F, (Q, ae) => {
      var Le;
      q(Q) || (0, e.devAssert)(
        !1,
        `${A.name}.${ae} field config must be an object.`
      ), Q.resolve == null || typeof Q.resolve == "function" || (0, e.devAssert)(
        !1,
        `${A.name}.${ae} field resolver must be a function if provided, but got: ${(0, i.inspect)(Q.resolve)}.`
      );
      const ln = (Le = Q.args) !== null && Le !== void 0 ? Le : {};
      return q(ln) || (0, e.devAssert)(
        !1,
        `${A.name}.${ae} args must be an object with argument names as keys.`
      ), {
        name: (0, d.assertName)(ae),
        description: Q.description,
        type: Q.type,
        args: J(ln),
        resolve: Q.resolve,
        subscribe: Q.subscribe,
        deprecationReason: Q.deprecationReason,
        extensions: (0, y.toObjMap)(Q.extensions),
        astNode: Q.astNode
      };
    });
  }
  function J(A) {
    return Object.entries(A).map(([F, Q]) => ({
      name: (0, d.assertName)(F),
      description: Q.description,
      type: Q.type,
      defaultValue: Q.defaultValue,
      deprecationReason: Q.deprecationReason,
      extensions: (0, y.toObjMap)(Q.extensions),
      astNode: Q.astNode
    }));
  }
  function q(A) {
    return (0, r.isObjectLike)(A) && !Array.isArray(A);
  }
  function z(A) {
    return (0, u.mapValue)(A, (F) => ({
      description: F.description,
      type: F.type,
      args: fe(F.args),
      resolve: F.resolve,
      subscribe: F.subscribe,
      deprecationReason: F.deprecationReason,
      extensions: F.extensions,
      astNode: F.astNode
    }));
  }
  function fe(A) {
    return (0, c.keyValMap)(
      A,
      (F) => F.name,
      (F) => ({
        description: F.description,
        type: F.type,
        defaultValue: F.defaultValue,
        deprecationReason: F.deprecationReason,
        extensions: F.extensions,
        astNode: F.astNode
      })
    );
  }
  function be(A) {
    return L(A.type) && A.defaultValue === void 0;
  }
  class me {
    constructor(F) {
      var Q;
      this.name = (0, d.assertName)(F.name), this.description = F.description, this.resolveType = F.resolveType, this.extensions = (0, y.toObjMap)(F.extensions), this.astNode = F.astNode, this.extensionASTNodes = (Q = F.extensionASTNodes) !== null && Q !== void 0 ? Q : [], this._fields = k.bind(void 0, F), this._interfaces = He.bind(void 0, F), F.resolveType == null || typeof F.resolveType == "function" || (0, e.devAssert)(
        !1,
        `${this.name} must provide "resolveType" as a function, but got: ${(0, i.inspect)(F.resolveType)}.`
      );
    }
    get [Symbol.toStringTag]() {
      return "GraphQLInterfaceType";
    }
    getFields() {
      return typeof this._fields == "function" && (this._fields = this._fields()), this._fields;
    }
    getInterfaces() {
      return typeof this._interfaces == "function" && (this._interfaces = this._interfaces()), this._interfaces;
    }
    toConfig() {
      return {
        name: this.name,
        description: this.description,
        interfaces: this.getInterfaces(),
        fields: z(this.getFields()),
        resolveType: this.resolveType,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes
      };
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return this.toString();
    }
  }
  H.GraphQLInterfaceType = me;
  class Ue {
    constructor(F) {
      var Q;
      this.name = (0, d.assertName)(F.name), this.description = F.description, this.resolveType = F.resolveType, this.extensions = (0, y.toObjMap)(F.extensions), this.astNode = F.astNode, this.extensionASTNodes = (Q = F.extensionASTNodes) !== null && Q !== void 0 ? Q : [], this._types = Ln.bind(void 0, F), F.resolveType == null || typeof F.resolveType == "function" || (0, e.devAssert)(
        !1,
        `${this.name} must provide "resolveType" as a function, but got: ${(0, i.inspect)(F.resolveType)}.`
      );
    }
    get [Symbol.toStringTag]() {
      return "GraphQLUnionType";
    }
    getTypes() {
      return typeof this._types == "function" && (this._types = this._types()), this._types;
    }
    toConfig() {
      return {
        name: this.name,
        description: this.description,
        types: this.getTypes(),
        resolveType: this.resolveType,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes
      };
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return this.toString();
    }
  }
  H.GraphQLUnionType = Ue;
  function Ln(A) {
    const F = ve(A.types);
    return Array.isArray(F) || (0, e.devAssert)(
      !1,
      `Must provide Array of types or a function which returns such an array for Union ${A.name}.`
    ), F;
  }
  class cn {
    /* <T> */
    constructor(F) {
      var Q;
      this.name = (0, d.assertName)(F.name), this.description = F.description, this.extensions = (0, y.toObjMap)(F.extensions), this.astNode = F.astNode, this.extensionASTNodes = (Q = F.extensionASTNodes) !== null && Q !== void 0 ? Q : [], this._values = typeof F.values == "function" ? F.values : ci(this.name, F.values), this._valueLookup = null, this._nameLookup = null;
    }
    get [Symbol.toStringTag]() {
      return "GraphQLEnumType";
    }
    getValues() {
      return typeof this._values == "function" && (this._values = ci(this.name, this._values())), this._values;
    }
    getValue(F) {
      return this._nameLookup === null && (this._nameLookup = (0, a.keyMap)(
        this.getValues(),
        (Q) => Q.name
      )), this._nameLookup[F];
    }
    serialize(F) {
      this._valueLookup === null && (this._valueLookup = new Map(
        this.getValues().map((ae) => [ae.value, ae])
      ));
      const Q = this._valueLookup.get(F);
      if (Q === void 0)
        throw new o.GraphQLError(
          `Enum "${this.name}" cannot represent value: ${(0, i.inspect)(
            F
          )}`
        );
      return Q.name;
    }
    parseValue(F) {
      if (typeof F != "string") {
        const ae = (0, i.inspect)(F);
        throw new o.GraphQLError(
          `Enum "${this.name}" cannot represent non-string value: ${ae}.` + Ie(this, ae)
        );
      }
      const Q = this.getValue(F);
      if (Q == null)
        throw new o.GraphQLError(
          `Value "${F}" does not exist in "${this.name}" enum.` + Ie(this, F)
        );
      return Q.value;
    }
    parseLiteral(F, Q) {
      if (F.kind !== p.Kind.ENUM) {
        const Le = (0, h.print)(F);
        throw new o.GraphQLError(
          `Enum "${this.name}" cannot represent non-enum value: ${Le}.` + Ie(this, Le),
          {
            nodes: F
          }
        );
      }
      const ae = this.getValue(F.value);
      if (ae == null) {
        const Le = (0, h.print)(F);
        throw new o.GraphQLError(
          `Value "${Le}" does not exist in "${this.name}" enum.` + Ie(this, Le),
          {
            nodes: F
          }
        );
      }
      return ae.value;
    }
    toConfig() {
      const F = (0, c.keyValMap)(
        this.getValues(),
        (Q) => Q.name,
        (Q) => ({
          description: Q.description,
          value: Q.value,
          deprecationReason: Q.deprecationReason,
          extensions: Q.extensions,
          astNode: Q.astNode
        })
      );
      return {
        name: this.name,
        description: this.description,
        values: F,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes
      };
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return this.toString();
    }
  }
  H.GraphQLEnumType = cn;
  function Ie(A, F) {
    const Q = A.getValues().map((Le) => Le.name), ae = (0, f.suggestionList)(
      F,
      Q
    );
    return (0, n.didYouMean)("the enum value", ae);
  }
  function ci(A, F) {
    return q(F) || (0, e.devAssert)(
      !1,
      `${A} values must be an object with value names as keys.`
    ), Object.entries(F).map(([Q, ae]) => (q(ae) || (0, e.devAssert)(
      !1,
      `${A}.${Q} must refer to an object with a "value" key representing an internal value but got: ${(0, i.inspect)(
        ae
      )}.`
    ), {
      name: (0, d.assertEnumValueName)(Q),
      description: ae.description,
      value: ae.value !== void 0 ? ae.value : Q,
      deprecationReason: ae.deprecationReason,
      extensions: (0, y.toObjMap)(ae.extensions),
      astNode: ae.astNode
    }));
  }
  class li {
    constructor(F) {
      var Q, ae;
      this.name = (0, d.assertName)(F.name), this.description = F.description, this.extensions = (0, y.toObjMap)(F.extensions), this.astNode = F.astNode, this.extensionASTNodes = (Q = F.extensionASTNodes) !== null && Q !== void 0 ? Q : [], this.isOneOf = (ae = F.isOneOf) !== null && ae !== void 0 ? ae : !1, this._fields = Mo.bind(void 0, F);
    }
    get [Symbol.toStringTag]() {
      return "GraphQLInputObjectType";
    }
    getFields() {
      return typeof this._fields == "function" && (this._fields = this._fields()), this._fields;
    }
    toConfig() {
      const F = (0, u.mapValue)(this.getFields(), (Q) => ({
        description: Q.description,
        type: Q.type,
        defaultValue: Q.defaultValue,
        deprecationReason: Q.deprecationReason,
        extensions: Q.extensions,
        astNode: Q.astNode
      }));
      return {
        name: this.name,
        description: this.description,
        fields: F,
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes,
        isOneOf: this.isOneOf
      };
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return this.toString();
    }
  }
  H.GraphQLInputObjectType = li;
  function Mo(A) {
    const F = _e(A.fields);
    return q(F) || (0, e.devAssert)(
      !1,
      `${A.name} fields must be an object with field names as keys or a function which returns such an object.`
    ), (0, u.mapValue)(F, (Q, ae) => (!("resolve" in Q) || (0, e.devAssert)(
      !1,
      `${A.name}.${ae} field has a resolve property, but Input Types cannot define resolvers.`
    ), {
      name: (0, d.assertName)(ae),
      description: Q.description,
      type: Q.type,
      defaultValue: Q.defaultValue,
      deprecationReason: Q.deprecationReason,
      extensions: (0, y.toObjMap)(Q.extensions),
      astNode: Q.astNode
    }));
  }
  function $o(A) {
    return L(A.type) && A.defaultValue === void 0;
  }
  return H;
}
var ra;
function Dr() {
  if (ra) return vn;
  ra = 1, Object.defineProperty(vn, "__esModule", {
    value: !0
  }), vn.doTypesOverlap = i, vn.isEqualType = n, vn.isTypeSubTypeOf = s;
  var e = /* @__PURE__ */ oe();
  function n(t, r) {
    return t === r ? !0 : (0, e.isNonNullType)(t) && (0, e.isNonNullType)(r) || (0, e.isListType)(t) && (0, e.isListType)(r) ? n(t.ofType, r.ofType) : !1;
  }
  function s(t, r, a) {
    return r === a ? !0 : (0, e.isNonNullType)(a) ? (0, e.isNonNullType)(r) ? s(t, r.ofType, a.ofType) : !1 : (0, e.isNonNullType)(r) ? s(t, r.ofType, a) : (0, e.isListType)(a) ? (0, e.isListType)(r) ? s(t, r.ofType, a.ofType) : !1 : (0, e.isListType)(r) ? !1 : (0, e.isAbstractType)(a) && ((0, e.isInterfaceType)(r) || (0, e.isObjectType)(r)) && t.isSubType(a, r);
  }
  function i(t, r, a) {
    return r === a ? !0 : (0, e.isAbstractType)(r) ? (0, e.isAbstractType)(a) ? t.getPossibleTypes(r).some((c) => t.isSubType(a, c)) : t.isSubType(r, a) : (0, e.isAbstractType)(a) ? t.isSubType(a, r) : !1;
  }
  return vn;
}
var Te = {}, Ne = {}, ia;
function ze() {
  if (ia) return Ne;
  ia = 1, Object.defineProperty(Ne, "__esModule", {
    value: !0
  }), Ne.GraphQLString = Ne.GraphQLInt = Ne.GraphQLID = Ne.GraphQLFloat = Ne.GraphQLBoolean = Ne.GRAPHQL_MIN_INT = Ne.GRAPHQL_MAX_INT = void 0, Ne.isSpecifiedScalarType = l, Ne.specifiedScalarTypes = void 0;
  var e = /* @__PURE__ */ de(), n = /* @__PURE__ */ Ye(), s = /* @__PURE__ */ ne(), i = /* @__PURE__ */ se(), t = /* @__PURE__ */ we(), r = /* @__PURE__ */ oe();
  const a = 2147483647;
  Ne.GRAPHQL_MAX_INT = a;
  const c = -2147483648;
  Ne.GRAPHQL_MIN_INT = c;
  const u = new r.GraphQLScalarType({
    name: "Int",
    description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
    serialize(m) {
      const T = d(m);
      if (typeof T == "boolean")
        return T ? 1 : 0;
      let O = T;
      if (typeof T == "string" && T !== "" && (O = Number(T)), typeof O != "number" || !Number.isInteger(O))
        throw new s.GraphQLError(
          `Int cannot represent non-integer value: ${(0, e.inspect)(
            T
          )}`
        );
      if (O > a || O < c)
        throw new s.GraphQLError(
          "Int cannot represent non 32-bit signed integer value: " + (0, e.inspect)(T)
        );
      return O;
    },
    parseValue(m) {
      if (typeof m != "number" || !Number.isInteger(m))
        throw new s.GraphQLError(
          `Int cannot represent non-integer value: ${(0, e.inspect)(
            m
          )}`
        );
      if (m > a || m < c)
        throw new s.GraphQLError(
          `Int cannot represent non 32-bit signed integer value: ${m}`
        );
      return m;
    },
    parseLiteral(m) {
      if (m.kind !== i.Kind.INT)
        throw new s.GraphQLError(
          `Int cannot represent non-integer value: ${(0, t.print)(
            m
          )}`,
          {
            nodes: m
          }
        );
      const T = parseInt(m.value, 10);
      if (T > a || T < c)
        throw new s.GraphQLError(
          `Int cannot represent non 32-bit signed integer value: ${m.value}`,
          {
            nodes: m
          }
        );
      return T;
    }
  });
  Ne.GraphQLInt = u;
  const f = new r.GraphQLScalarType({
    name: "Float",
    description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
    serialize(m) {
      const T = d(m);
      if (typeof T == "boolean")
        return T ? 1 : 0;
      let O = T;
      if (typeof T == "string" && T !== "" && (O = Number(T)), typeof O != "number" || !Number.isFinite(O))
        throw new s.GraphQLError(
          `Float cannot represent non numeric value: ${(0, e.inspect)(
            T
          )}`
        );
      return O;
    },
    parseValue(m) {
      if (typeof m != "number" || !Number.isFinite(m))
        throw new s.GraphQLError(
          `Float cannot represent non numeric value: ${(0, e.inspect)(
            m
          )}`
        );
      return m;
    },
    parseLiteral(m) {
      if (m.kind !== i.Kind.FLOAT && m.kind !== i.Kind.INT)
        throw new s.GraphQLError(
          `Float cannot represent non numeric value: ${(0, t.print)(
            m
          )}`,
          m
        );
      return parseFloat(m.value);
    }
  });
  Ne.GraphQLFloat = f;
  const y = new r.GraphQLScalarType({
    name: "String",
    description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
    serialize(m) {
      const T = d(m);
      if (typeof T == "string")
        return T;
      if (typeof T == "boolean")
        return T ? "true" : "false";
      if (typeof T == "number" && Number.isFinite(T))
        return T.toString();
      throw new s.GraphQLError(
        `String cannot represent value: ${(0, e.inspect)(m)}`
      );
    },
    parseValue(m) {
      if (typeof m != "string")
        throw new s.GraphQLError(
          `String cannot represent a non string value: ${(0, e.inspect)(
            m
          )}`
        );
      return m;
    },
    parseLiteral(m) {
      if (m.kind !== i.Kind.STRING)
        throw new s.GraphQLError(
          `String cannot represent a non string value: ${(0, t.print)(
            m
          )}`,
          {
            nodes: m
          }
        );
      return m.value;
    }
  });
  Ne.GraphQLString = y;
  const o = new r.GraphQLScalarType({
    name: "Boolean",
    description: "The `Boolean` scalar type represents `true` or `false`.",
    serialize(m) {
      const T = d(m);
      if (typeof T == "boolean")
        return T;
      if (Number.isFinite(T))
        return T !== 0;
      throw new s.GraphQLError(
        `Boolean cannot represent a non boolean value: ${(0, e.inspect)(
          T
        )}`
      );
    },
    parseValue(m) {
      if (typeof m != "boolean")
        throw new s.GraphQLError(
          `Boolean cannot represent a non boolean value: ${(0, e.inspect)(
            m
          )}`
        );
      return m;
    },
    parseLiteral(m) {
      if (m.kind !== i.Kind.BOOLEAN)
        throw new s.GraphQLError(
          `Boolean cannot represent a non boolean value: ${(0, t.print)(
            m
          )}`,
          {
            nodes: m
          }
        );
      return m.value;
    }
  });
  Ne.GraphQLBoolean = o;
  const p = new r.GraphQLScalarType({
    name: "ID",
    description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
    serialize(m) {
      const T = d(m);
      if (typeof T == "string")
        return T;
      if (Number.isInteger(T))
        return String(T);
      throw new s.GraphQLError(
        `ID cannot represent value: ${(0, e.inspect)(m)}`
      );
    },
    parseValue(m) {
      if (typeof m == "string")
        return m;
      if (typeof m == "number" && Number.isInteger(m))
        return m.toString();
      throw new s.GraphQLError(
        `ID cannot represent value: ${(0, e.inspect)(m)}`
      );
    },
    parseLiteral(m) {
      if (m.kind !== i.Kind.STRING && m.kind !== i.Kind.INT)
        throw new s.GraphQLError(
          "ID cannot represent a non-string and non-integer value: " + (0, t.print)(m),
          {
            nodes: m
          }
        );
      return m.value;
    }
  });
  Ne.GraphQLID = p;
  const h = Object.freeze([
    y,
    u,
    f,
    o,
    p
  ]);
  Ne.specifiedScalarTypes = h;
  function l(m) {
    return h.some(({ name: T }) => m.name === T);
  }
  function d(m) {
    if ((0, n.isObjectLike)(m)) {
      if (typeof m.valueOf == "function") {
        const T = m.valueOf();
        if (!(0, n.isObjectLike)(T))
          return T;
      }
      if (typeof m.toJSON == "function")
        return m.toJSON();
    }
    return m;
  }
  return Ne;
}
var aa;
function Pe() {
  if (aa) return Te;
  aa = 1, Object.defineProperty(Te, "__esModule", {
    value: !0
  }), Te.GraphQLSpecifiedByDirective = Te.GraphQLSkipDirective = Te.GraphQLOneOfDirective = Te.GraphQLIncludeDirective = Te.GraphQLDirective = Te.GraphQLDeprecatedDirective = Te.DEFAULT_DEPRECATION_REASON = void 0, Te.assertDirective = y, Te.isDirective = f, Te.isSpecifiedDirective = R, Te.specifiedDirectives = void 0;
  var e = /* @__PURE__ */ Re(), n = /* @__PURE__ */ de(), s = /* @__PURE__ */ Ir(), i = /* @__PURE__ */ Ye(), t = /* @__PURE__ */ ii(), r = /* @__PURE__ */ Bn(), a = /* @__PURE__ */ Rr(), c = /* @__PURE__ */ oe(), u = /* @__PURE__ */ ze();
  function f(D) {
    return (0, s.instanceOf)(D, o);
  }
  function y(D) {
    if (!f(D))
      throw new Error(
        `Expected ${(0, n.inspect)(D)} to be a GraphQL directive.`
      );
    return D;
  }
  class o {
    constructor(_) {
      var w, $;
      this.name = (0, a.assertName)(_.name), this.description = _.description, this.locations = _.locations, this.isRepeatable = (w = _.isRepeatable) !== null && w !== void 0 ? w : !1, this.extensions = (0, t.toObjMap)(_.extensions), this.astNode = _.astNode, Array.isArray(_.locations) || (0, e.devAssert)(
        !1,
        `@${_.name} locations must be an Array.`
      );
      const G = ($ = _.args) !== null && $ !== void 0 ? $ : {};
      (0, i.isObjectLike)(G) && !Array.isArray(G) || (0, e.devAssert)(
        !1,
        `@${_.name} args must be an object with argument names as keys.`
      ), this.args = (0, c.defineArguments)(G);
    }
    get [Symbol.toStringTag]() {
      return "GraphQLDirective";
    }
    toConfig() {
      return {
        name: this.name,
        description: this.description,
        locations: this.locations,
        args: (0, c.argsToArgsConfig)(this.args),
        isRepeatable: this.isRepeatable,
        extensions: this.extensions,
        astNode: this.astNode
      };
    }
    toString() {
      return "@" + this.name;
    }
    toJSON() {
      return this.toString();
    }
  }
  Te.GraphQLDirective = o;
  const p = new o({
    name: "include",
    description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
    locations: [
      r.DirectiveLocation.FIELD,
      r.DirectiveLocation.FRAGMENT_SPREAD,
      r.DirectiveLocation.INLINE_FRAGMENT
    ],
    args: {
      if: {
        type: new c.GraphQLNonNull(u.GraphQLBoolean),
        description: "Included when true."
      }
    }
  });
  Te.GraphQLIncludeDirective = p;
  const h = new o({
    name: "skip",
    description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
    locations: [
      r.DirectiveLocation.FIELD,
      r.DirectiveLocation.FRAGMENT_SPREAD,
      r.DirectiveLocation.INLINE_FRAGMENT
    ],
    args: {
      if: {
        type: new c.GraphQLNonNull(u.GraphQLBoolean),
        description: "Skipped when true."
      }
    }
  });
  Te.GraphQLSkipDirective = h;
  const l = "No longer supported";
  Te.DEFAULT_DEPRECATION_REASON = l;
  const d = new o({
    name: "deprecated",
    description: "Marks an element of a GraphQL schema as no longer supported.",
    locations: [
      r.DirectiveLocation.FIELD_DEFINITION,
      r.DirectiveLocation.ARGUMENT_DEFINITION,
      r.DirectiveLocation.INPUT_FIELD_DEFINITION,
      r.DirectiveLocation.ENUM_VALUE
    ],
    args: {
      reason: {
        type: u.GraphQLString,
        description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
        defaultValue: l
      }
    }
  });
  Te.GraphQLDeprecatedDirective = d;
  const m = new o({
    name: "specifiedBy",
    description: "Exposes a URL that specifies the behavior of this scalar.",
    locations: [r.DirectiveLocation.SCALAR],
    args: {
      url: {
        type: new c.GraphQLNonNull(u.GraphQLString),
        description: "The URL that specifies the behavior of this scalar."
      }
    }
  });
  Te.GraphQLSpecifiedByDirective = m;
  const T = new o({
    name: "oneOf",
    description: "Indicates exactly one field must be supplied and this field must not be `null`.",
    locations: [r.DirectiveLocation.INPUT_OBJECT],
    args: {}
  });
  Te.GraphQLOneOfDirective = T;
  const O = Object.freeze([
    p,
    h,
    d,
    m,
    T
  ]);
  Te.specifiedDirectives = O;
  function R(D) {
    return O.some(({ name: _ }) => _ === D.name);
  }
  return Te;
}
var le = {}, ht = {}, vt = {}, sa;
function ai() {
  if (sa) return vt;
  sa = 1, Object.defineProperty(vt, "__esModule", {
    value: !0
  }), vt.isIterableObject = e;
  function e(n) {
    return typeof n == "object" && typeof n?.[Symbol.iterator] == "function";
  }
  return vt;
}
var oa;
function Ar() {
  if (oa) return ht;
  oa = 1, Object.defineProperty(ht, "__esModule", {
    value: !0
  }), ht.astFromValue = c;
  var e = /* @__PURE__ */ de(), n = /* @__PURE__ */ Se(), s = /* @__PURE__ */ ai(), i = /* @__PURE__ */ Ye(), t = /* @__PURE__ */ se(), r = /* @__PURE__ */ oe(), a = /* @__PURE__ */ ze();
  function c(f, y) {
    if ((0, r.isNonNullType)(y)) {
      const o = c(f, y.ofType);
      return o?.kind === t.Kind.NULL ? null : o;
    }
    if (f === null)
      return {
        kind: t.Kind.NULL
      };
    if (f === void 0)
      return null;
    if ((0, r.isListType)(y)) {
      const o = y.ofType;
      if ((0, s.isIterableObject)(f)) {
        const p = [];
        for (const h of f) {
          const l = c(h, o);
          l != null && p.push(l);
        }
        return {
          kind: t.Kind.LIST,
          values: p
        };
      }
      return c(f, o);
    }
    if ((0, r.isInputObjectType)(y)) {
      if (!(0, i.isObjectLike)(f))
        return null;
      const o = [];
      for (const p of Object.values(y.getFields())) {
        const h = c(f[p.name], p.type);
        h && o.push({
          kind: t.Kind.OBJECT_FIELD,
          name: {
            kind: t.Kind.NAME,
            value: p.name
          },
          value: h
        });
      }
      return {
        kind: t.Kind.OBJECT,
        fields: o
      };
    }
    if ((0, r.isLeafType)(y)) {
      const o = y.serialize(f);
      if (o == null)
        return null;
      if (typeof o == "boolean")
        return {
          kind: t.Kind.BOOLEAN,
          value: o
        };
      if (typeof o == "number" && Number.isFinite(o)) {
        const p = String(o);
        return u.test(p) ? {
          kind: t.Kind.INT,
          value: p
        } : {
          kind: t.Kind.FLOAT,
          value: p
        };
      }
      if (typeof o == "string")
        return (0, r.isEnumType)(y) ? {
          kind: t.Kind.ENUM,
          value: o
        } : y === a.GraphQLID && u.test(o) ? {
          kind: t.Kind.INT,
          value: o
        } : {
          kind: t.Kind.STRING,
          value: o
        };
      throw new TypeError(
        `Cannot convert value to AST: ${(0, e.inspect)(o)}.`
      );
    }
    (0, n.invariant)(
      !1,
      "Unexpected input type: " + (0, e.inspect)(y)
    );
  }
  const u = /^-?(?:0|[1-9][0-9]*)$/;
  return ht;
}
var ua;
function Me() {
  if (ua) return le;
  ua = 1, Object.defineProperty(le, "__esModule", {
    value: !0
  }), le.introspectionTypes = le.__TypeKind = le.__Type = le.__Schema = le.__InputValue = le.__Field = le.__EnumValue = le.__DirectiveLocation = le.__Directive = le.TypeNameMetaFieldDef = le.TypeMetaFieldDef = le.TypeKind = le.SchemaMetaFieldDef = void 0, le.isIntrospectionType = D;
  var e = /* @__PURE__ */ de(), n = /* @__PURE__ */ Se(), s = /* @__PURE__ */ Bn(), i = /* @__PURE__ */ we(), t = /* @__PURE__ */ Ar(), r = /* @__PURE__ */ oe(), a = /* @__PURE__ */ ze();
  const c = new r.GraphQLObjectType({
    name: "__Schema",
    description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
    fields: () => ({
      description: {
        type: a.GraphQLString,
        resolve: (_) => _.description
      },
      types: {
        description: "A list of all types supported by this server.",
        type: new r.GraphQLNonNull(
          new r.GraphQLList(new r.GraphQLNonNull(y))
        ),
        resolve(_) {
          return Object.values(_.getTypeMap());
        }
      },
      queryType: {
        description: "The type that query operations will be rooted at.",
        type: new r.GraphQLNonNull(y),
        resolve: (_) => _.getQueryType()
      },
      mutationType: {
        description: "If this server supports mutation, the type that mutation operations will be rooted at.",
        type: y,
        resolve: (_) => _.getMutationType()
      },
      subscriptionType: {
        description: "If this server support subscription, the type that subscription operations will be rooted at.",
        type: y,
        resolve: (_) => _.getSubscriptionType()
      },
      directives: {
        description: "A list of all directives supported by this server.",
        type: new r.GraphQLNonNull(
          new r.GraphQLList(
            new r.GraphQLNonNull(u)
          )
        ),
        resolve: (_) => _.getDirectives()
      }
    })
  });
  le.__Schema = c;
  const u = new r.GraphQLObjectType({
    name: "__Directive",
    description: `A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.

In some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.`,
    fields: () => ({
      name: {
        type: new r.GraphQLNonNull(a.GraphQLString),
        resolve: (_) => _.name
      },
      description: {
        type: a.GraphQLString,
        resolve: (_) => _.description
      },
      isRepeatable: {
        type: new r.GraphQLNonNull(a.GraphQLBoolean),
        resolve: (_) => _.isRepeatable
      },
      locations: {
        type: new r.GraphQLNonNull(
          new r.GraphQLList(
            new r.GraphQLNonNull(f)
          )
        ),
        resolve: (_) => _.locations
      },
      args: {
        type: new r.GraphQLNonNull(
          new r.GraphQLList(
            new r.GraphQLNonNull(p)
          )
        ),
        args: {
          includeDeprecated: {
            type: a.GraphQLBoolean,
            defaultValue: !1
          }
        },
        resolve(_, { includeDeprecated: w }) {
          return w ? _.args : _.args.filter(($) => $.deprecationReason == null);
        }
      }
    })
  });
  le.__Directive = u;
  const f = new r.GraphQLEnumType({
    name: "__DirectiveLocation",
    description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
    values: {
      QUERY: {
        value: s.DirectiveLocation.QUERY,
        description: "Location adjacent to a query operation."
      },
      MUTATION: {
        value: s.DirectiveLocation.MUTATION,
        description: "Location adjacent to a mutation operation."
      },
      SUBSCRIPTION: {
        value: s.DirectiveLocation.SUBSCRIPTION,
        description: "Location adjacent to a subscription operation."
      },
      FIELD: {
        value: s.DirectiveLocation.FIELD,
        description: "Location adjacent to a field."
      },
      FRAGMENT_DEFINITION: {
        value: s.DirectiveLocation.FRAGMENT_DEFINITION,
        description: "Location adjacent to a fragment definition."
      },
      FRAGMENT_SPREAD: {
        value: s.DirectiveLocation.FRAGMENT_SPREAD,
        description: "Location adjacent to a fragment spread."
      },
      INLINE_FRAGMENT: {
        value: s.DirectiveLocation.INLINE_FRAGMENT,
        description: "Location adjacent to an inline fragment."
      },
      VARIABLE_DEFINITION: {
        value: s.DirectiveLocation.VARIABLE_DEFINITION,
        description: "Location adjacent to a variable definition."
      },
      SCHEMA: {
        value: s.DirectiveLocation.SCHEMA,
        description: "Location adjacent to a schema definition."
      },
      SCALAR: {
        value: s.DirectiveLocation.SCALAR,
        description: "Location adjacent to a scalar definition."
      },
      OBJECT: {
        value: s.DirectiveLocation.OBJECT,
        description: "Location adjacent to an object type definition."
      },
      FIELD_DEFINITION: {
        value: s.DirectiveLocation.FIELD_DEFINITION,
        description: "Location adjacent to a field definition."
      },
      ARGUMENT_DEFINITION: {
        value: s.DirectiveLocation.ARGUMENT_DEFINITION,
        description: "Location adjacent to an argument definition."
      },
      INTERFACE: {
        value: s.DirectiveLocation.INTERFACE,
        description: "Location adjacent to an interface definition."
      },
      UNION: {
        value: s.DirectiveLocation.UNION,
        description: "Location adjacent to a union definition."
      },
      ENUM: {
        value: s.DirectiveLocation.ENUM,
        description: "Location adjacent to an enum definition."
      },
      ENUM_VALUE: {
        value: s.DirectiveLocation.ENUM_VALUE,
        description: "Location adjacent to an enum value definition."
      },
      INPUT_OBJECT: {
        value: s.DirectiveLocation.INPUT_OBJECT,
        description: "Location adjacent to an input object type definition."
      },
      INPUT_FIELD_DEFINITION: {
        value: s.DirectiveLocation.INPUT_FIELD_DEFINITION,
        description: "Location adjacent to an input object field definition."
      }
    }
  });
  le.__DirectiveLocation = f;
  const y = new r.GraphQLObjectType({
    name: "__Type",
    description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
    fields: () => ({
      kind: {
        type: new r.GraphQLNonNull(d),
        resolve(_) {
          if ((0, r.isScalarType)(_))
            return l.SCALAR;
          if ((0, r.isObjectType)(_))
            return l.OBJECT;
          if ((0, r.isInterfaceType)(_))
            return l.INTERFACE;
          if ((0, r.isUnionType)(_))
            return l.UNION;
          if ((0, r.isEnumType)(_))
            return l.ENUM;
          if ((0, r.isInputObjectType)(_))
            return l.INPUT_OBJECT;
          if ((0, r.isListType)(_))
            return l.LIST;
          if ((0, r.isNonNullType)(_))
            return l.NON_NULL;
          (0, n.invariant)(
            !1,
            `Unexpected type: "${(0, e.inspect)(_)}".`
          );
        }
      },
      name: {
        type: a.GraphQLString,
        resolve: (_) => "name" in _ ? _.name : void 0
      },
      description: {
        type: a.GraphQLString,
        resolve: (_) => (
          /* c8 ignore next */
          "description" in _ ? _.description : void 0
        )
      },
      specifiedByURL: {
        type: a.GraphQLString,
        resolve: (_) => "specifiedByURL" in _ ? _.specifiedByURL : void 0
      },
      fields: {
        type: new r.GraphQLList(
          new r.GraphQLNonNull(o)
        ),
        args: {
          includeDeprecated: {
            type: a.GraphQLBoolean,
            defaultValue: !1
          }
        },
        resolve(_, { includeDeprecated: w }) {
          if ((0, r.isObjectType)(_) || (0, r.isInterfaceType)(_)) {
            const $ = Object.values(_.getFields());
            return w ? $ : $.filter((G) => G.deprecationReason == null);
          }
        }
      },
      interfaces: {
        type: new r.GraphQLList(new r.GraphQLNonNull(y)),
        resolve(_) {
          if ((0, r.isObjectType)(_) || (0, r.isInterfaceType)(_))
            return _.getInterfaces();
        }
      },
      possibleTypes: {
        type: new r.GraphQLList(new r.GraphQLNonNull(y)),
        resolve(_, w, $, { schema: G }) {
          if ((0, r.isAbstractType)(_))
            return G.getPossibleTypes(_);
        }
      },
      enumValues: {
        type: new r.GraphQLList(
          new r.GraphQLNonNull(h)
        ),
        args: {
          includeDeprecated: {
            type: a.GraphQLBoolean,
            defaultValue: !1
          }
        },
        resolve(_, { includeDeprecated: w }) {
          if ((0, r.isEnumType)(_)) {
            const $ = _.getValues();
            return w ? $ : $.filter((G) => G.deprecationReason == null);
          }
        }
      },
      inputFields: {
        type: new r.GraphQLList(
          new r.GraphQLNonNull(p)
        ),
        args: {
          includeDeprecated: {
            type: a.GraphQLBoolean,
            defaultValue: !1
          }
        },
        resolve(_, { includeDeprecated: w }) {
          if ((0, r.isInputObjectType)(_)) {
            const $ = Object.values(_.getFields());
            return w ? $ : $.filter((G) => G.deprecationReason == null);
          }
        }
      },
      ofType: {
        type: y,
        resolve: (_) => "ofType" in _ ? _.ofType : void 0
      },
      isOneOf: {
        type: a.GraphQLBoolean,
        resolve: (_) => {
          if ((0, r.isInputObjectType)(_))
            return _.isOneOf;
        }
      }
    })
  });
  le.__Type = y;
  const o = new r.GraphQLObjectType({
    name: "__Field",
    description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
    fields: () => ({
      name: {
        type: new r.GraphQLNonNull(a.GraphQLString),
        resolve: (_) => _.name
      },
      description: {
        type: a.GraphQLString,
        resolve: (_) => _.description
      },
      args: {
        type: new r.GraphQLNonNull(
          new r.GraphQLList(
            new r.GraphQLNonNull(p)
          )
        ),
        args: {
          includeDeprecated: {
            type: a.GraphQLBoolean,
            defaultValue: !1
          }
        },
        resolve(_, { includeDeprecated: w }) {
          return w ? _.args : _.args.filter(($) => $.deprecationReason == null);
        }
      },
      type: {
        type: new r.GraphQLNonNull(y),
        resolve: (_) => _.type
      },
      isDeprecated: {
        type: new r.GraphQLNonNull(a.GraphQLBoolean),
        resolve: (_) => _.deprecationReason != null
      },
      deprecationReason: {
        type: a.GraphQLString,
        resolve: (_) => _.deprecationReason
      }
    })
  });
  le.__Field = o;
  const p = new r.GraphQLObjectType({
    name: "__InputValue",
    description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
    fields: () => ({
      name: {
        type: new r.GraphQLNonNull(a.GraphQLString),
        resolve: (_) => _.name
      },
      description: {
        type: a.GraphQLString,
        resolve: (_) => _.description
      },
      type: {
        type: new r.GraphQLNonNull(y),
        resolve: (_) => _.type
      },
      defaultValue: {
        type: a.GraphQLString,
        description: "A GraphQL-formatted string representing the default value for this input value.",
        resolve(_) {
          const { type: w, defaultValue: $ } = _, G = (0, t.astFromValue)($, w);
          return G ? (0, i.print)(G) : null;
        }
      },
      isDeprecated: {
        type: new r.GraphQLNonNull(a.GraphQLBoolean),
        resolve: (_) => _.deprecationReason != null
      },
      deprecationReason: {
        type: a.GraphQLString,
        resolve: (_) => _.deprecationReason
      }
    })
  });
  le.__InputValue = p;
  const h = new r.GraphQLObjectType({
    name: "__EnumValue",
    description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
    fields: () => ({
      name: {
        type: new r.GraphQLNonNull(a.GraphQLString),
        resolve: (_) => _.name
      },
      description: {
        type: a.GraphQLString,
        resolve: (_) => _.description
      },
      isDeprecated: {
        type: new r.GraphQLNonNull(a.GraphQLBoolean),
        resolve: (_) => _.deprecationReason != null
      },
      deprecationReason: {
        type: a.GraphQLString,
        resolve: (_) => _.deprecationReason
      }
    })
  });
  le.__EnumValue = h;
  var l;
  le.TypeKind = l, function(_) {
    _.SCALAR = "SCALAR", _.OBJECT = "OBJECT", _.INTERFACE = "INTERFACE", _.UNION = "UNION", _.ENUM = "ENUM", _.INPUT_OBJECT = "INPUT_OBJECT", _.LIST = "LIST", _.NON_NULL = "NON_NULL";
  }(l || (le.TypeKind = l = {}));
  const d = new r.GraphQLEnumType({
    name: "__TypeKind",
    description: "An enum describing what kind of type a given `__Type` is.",
    values: {
      SCALAR: {
        value: l.SCALAR,
        description: "Indicates this type is a scalar."
      },
      OBJECT: {
        value: l.OBJECT,
        description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
      },
      INTERFACE: {
        value: l.INTERFACE,
        description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
      },
      UNION: {
        value: l.UNION,
        description: "Indicates this type is a union. `possibleTypes` is a valid field."
      },
      ENUM: {
        value: l.ENUM,
        description: "Indicates this type is an enum. `enumValues` is a valid field."
      },
      INPUT_OBJECT: {
        value: l.INPUT_OBJECT,
        description: "Indicates this type is an input object. `inputFields` is a valid field."
      },
      LIST: {
        value: l.LIST,
        description: "Indicates this type is a list. `ofType` is a valid field."
      },
      NON_NULL: {
        value: l.NON_NULL,
        description: "Indicates this type is a non-null. `ofType` is a valid field."
      }
    }
  });
  le.__TypeKind = d;
  const m = {
    name: "__schema",
    type: new r.GraphQLNonNull(c),
    description: "Access the current type schema of this server.",
    args: [],
    resolve: (_, w, $, { schema: G }) => G,
    deprecationReason: void 0,
    extensions: /* @__PURE__ */ Object.create(null),
    astNode: void 0
  };
  le.SchemaMetaFieldDef = m;
  const T = {
    name: "__type",
    type: y,
    description: "Request the type information of a single type.",
    args: [
      {
        name: "name",
        description: void 0,
        type: new r.GraphQLNonNull(a.GraphQLString),
        defaultValue: void 0,
        deprecationReason: void 0,
        extensions: /* @__PURE__ */ Object.create(null),
        astNode: void 0
      }
    ],
    resolve: (_, { name: w }, $, { schema: G }) => G.getType(w),
    deprecationReason: void 0,
    extensions: /* @__PURE__ */ Object.create(null),
    astNode: void 0
  };
  le.TypeMetaFieldDef = T;
  const O = {
    name: "__typename",
    type: new r.GraphQLNonNull(a.GraphQLString),
    description: "The name of the current Object type at runtime.",
    args: [],
    resolve: (_, w, $, { parentType: G }) => G.name,
    deprecationReason: void 0,
    extensions: /* @__PURE__ */ Object.create(null),
    astNode: void 0
  };
  le.TypeNameMetaFieldDef = O;
  const R = Object.freeze([
    c,
    u,
    f,
    y,
    o,
    p,
    h,
    d
  ]);
  le.introspectionTypes = R;
  function D(_) {
    return R.some(({ name: w }) => _.name === w);
  }
  return le;
}
var rn = {}, ca;
function _n() {
  if (ca) return rn;
  ca = 1, Object.defineProperty(rn, "__esModule", {
    value: !0
  }), rn.GraphQLSchema = void 0, rn.assertSchema = y, rn.isSchema = f;
  var e = /* @__PURE__ */ Re(), n = /* @__PURE__ */ de(), s = /* @__PURE__ */ Ir(), i = /* @__PURE__ */ Ye(), t = /* @__PURE__ */ ii(), r = /* @__PURE__ */ Je(), a = /* @__PURE__ */ oe(), c = /* @__PURE__ */ Pe(), u = /* @__PURE__ */ Me();
  function f(h) {
    return (0, s.instanceOf)(h, o);
  }
  function y(h) {
    if (!f(h))
      throw new Error(
        `Expected ${(0, n.inspect)(h)} to be a GraphQL schema.`
      );
    return h;
  }
  class o {
    // Used as a cache for validateSchema().
    constructor(l) {
      var d, m;
      this.__validationErrors = l.assumeValid === !0 ? [] : void 0, (0, i.isObjectLike)(l) || (0, e.devAssert)(!1, "Must provide configuration object."), !l.types || Array.isArray(l.types) || (0, e.devAssert)(
        !1,
        `"types" must be Array if provided but got: ${(0, n.inspect)(
          l.types
        )}.`
      ), !l.directives || Array.isArray(l.directives) || (0, e.devAssert)(
        !1,
        `"directives" must be Array if provided but got: ${(0, n.inspect)(l.directives)}.`
      ), this.description = l.description, this.extensions = (0, t.toObjMap)(l.extensions), this.astNode = l.astNode, this.extensionASTNodes = (d = l.extensionASTNodes) !== null && d !== void 0 ? d : [], this._queryType = l.query, this._mutationType = l.mutation, this._subscriptionType = l.subscription, this._directives = (m = l.directives) !== null && m !== void 0 ? m : c.specifiedDirectives;
      const T = new Set(l.types);
      if (l.types != null)
        for (const O of l.types)
          T.delete(O), p(O, T);
      this._queryType != null && p(this._queryType, T), this._mutationType != null && p(this._mutationType, T), this._subscriptionType != null && p(this._subscriptionType, T);
      for (const O of this._directives)
        if ((0, c.isDirective)(O))
          for (const R of O.args)
            p(R.type, T);
      p(u.__Schema, T), this._typeMap = /* @__PURE__ */ Object.create(null), this._subTypeMap = /* @__PURE__ */ Object.create(null), this._implementationsMap = /* @__PURE__ */ Object.create(null);
      for (const O of T) {
        if (O == null)
          continue;
        const R = O.name;
        if (R || (0, e.devAssert)(
          !1,
          "One of the provided types for building the Schema is missing a name."
        ), this._typeMap[R] !== void 0)
          throw new Error(
            `Schema must contain uniquely named types but contains multiple types named "${R}".`
          );
        if (this._typeMap[R] = O, (0, a.isInterfaceType)(O)) {
          for (const D of O.getInterfaces())
            if ((0, a.isInterfaceType)(D)) {
              let _ = this._implementationsMap[D.name];
              _ === void 0 && (_ = this._implementationsMap[D.name] = {
                objects: [],
                interfaces: []
              }), _.interfaces.push(O);
            }
        } else if ((0, a.isObjectType)(O)) {
          for (const D of O.getInterfaces())
            if ((0, a.isInterfaceType)(D)) {
              let _ = this._implementationsMap[D.name];
              _ === void 0 && (_ = this._implementationsMap[D.name] = {
                objects: [],
                interfaces: []
              }), _.objects.push(O);
            }
        }
      }
    }
    get [Symbol.toStringTag]() {
      return "GraphQLSchema";
    }
    getQueryType() {
      return this._queryType;
    }
    getMutationType() {
      return this._mutationType;
    }
    getSubscriptionType() {
      return this._subscriptionType;
    }
    getRootType(l) {
      switch (l) {
        case r.OperationTypeNode.QUERY:
          return this.getQueryType();
        case r.OperationTypeNode.MUTATION:
          return this.getMutationType();
        case r.OperationTypeNode.SUBSCRIPTION:
          return this.getSubscriptionType();
      }
    }
    getTypeMap() {
      return this._typeMap;
    }
    getType(l) {
      return this.getTypeMap()[l];
    }
    getPossibleTypes(l) {
      return (0, a.isUnionType)(l) ? l.getTypes() : this.getImplementations(l).objects;
    }
    getImplementations(l) {
      const d = this._implementationsMap[l.name];
      return d ?? {
        objects: [],
        interfaces: []
      };
    }
    isSubType(l, d) {
      let m = this._subTypeMap[l.name];
      if (m === void 0) {
        if (m = /* @__PURE__ */ Object.create(null), (0, a.isUnionType)(l))
          for (const T of l.getTypes())
            m[T.name] = !0;
        else {
          const T = this.getImplementations(l);
          for (const O of T.objects)
            m[O.name] = !0;
          for (const O of T.interfaces)
            m[O.name] = !0;
        }
        this._subTypeMap[l.name] = m;
      }
      return m[d.name] !== void 0;
    }
    getDirectives() {
      return this._directives;
    }
    getDirective(l) {
      return this.getDirectives().find((d) => d.name === l);
    }
    toConfig() {
      return {
        description: this.description,
        query: this.getQueryType(),
        mutation: this.getMutationType(),
        subscription: this.getSubscriptionType(),
        types: Object.values(this.getTypeMap()),
        directives: this.getDirectives(),
        extensions: this.extensions,
        astNode: this.astNode,
        extensionASTNodes: this.extensionASTNodes,
        assumeValid: this.__validationErrors !== void 0
      };
    }
  }
  rn.GraphQLSchema = o;
  function p(h, l) {
    const d = (0, a.getNamedType)(h);
    if (!l.has(d)) {
      if (l.add(d), (0, a.isUnionType)(d))
        for (const m of d.getTypes())
          p(m, l);
      else if ((0, a.isObjectType)(d) || (0, a.isInterfaceType)(d)) {
        for (const m of d.getInterfaces())
          p(m, l);
        for (const m of Object.values(d.getFields())) {
          p(m.type, l);
          for (const T of m.args)
            p(T.type, l);
        }
      } else if ((0, a.isInputObjectType)(d))
        for (const m of Object.values(d.getFields()))
          p(m.type, l);
    }
    return l;
  }
  return rn;
}
var la;
function jr() {
  if (la) return An;
  la = 1, Object.defineProperty(An, "__esModule", {
    value: !0
  }), An.assertValidSchema = f, An.validateSchema = u;
  var e = /* @__PURE__ */ de(), n = /* @__PURE__ */ ne(), s = /* @__PURE__ */ Je(), i = /* @__PURE__ */ Dr(), t = /* @__PURE__ */ oe(), r = /* @__PURE__ */ Pe(), a = /* @__PURE__ */ Me(), c = /* @__PURE__ */ _n();
  function u(E) {
    if ((0, c.assertSchema)(E), E.__validationErrors)
      return E.__validationErrors;
    const v = new y(E);
    o(v), h(v), d(v);
    const b = v.getErrors();
    return E.__validationErrors = b, b;
  }
  function f(E) {
    const v = u(E);
    if (v.length !== 0)
      throw new Error(v.map((b) => b.message).join(`

`));
  }
  class y {
    constructor(v) {
      this._errors = [], this.schema = v;
    }
    reportError(v, b) {
      const I = Array.isArray(b) ? b.filter(Boolean) : b;
      this._errors.push(
        new n.GraphQLError(v, {
          nodes: I
        })
      );
    }
    getErrors() {
      return this._errors;
    }
  }
  function o(E) {
    const v = E.schema, b = v.getQueryType();
    if (!b)
      E.reportError("Query root type must be provided.", v.astNode);
    else if (!(0, t.isObjectType)(b)) {
      var I;
      E.reportError(
        `Query root type must be Object type, it cannot be ${(0, e.inspect)(b)}.`,
        (I = p(
          v,
          s.OperationTypeNode.QUERY
        )) !== null && I !== void 0 ? I : b.astNode
      );
    }
    const L = v.getMutationType();
    if (L && !(0, t.isObjectType)(L)) {
      var j;
      E.reportError(
        `Mutation root type must be Object type if provided, it cannot be ${(0, e.inspect)(L)}.`,
        (j = p(
          v,
          s.OperationTypeNode.MUTATION
        )) !== null && j !== void 0 ? j : L.astNode
      );
    }
    const V = v.getSubscriptionType();
    if (V && !(0, t.isObjectType)(V)) {
      var U;
      E.reportError(
        `Subscription root type must be Object type if provided, it cannot be ${(0, e.inspect)(V)}.`,
        (U = p(
          v,
          s.OperationTypeNode.SUBSCRIPTION
        )) !== null && U !== void 0 ? U : V.astNode
      );
    }
  }
  function p(E, v) {
    var b;
    return (b = [E.astNode, ...E.extensionASTNodes].flatMap(
      // FIXME: https://github.com/graphql/graphql-js/issues/2203
      (I) => {
        var L;
        return (
          /* c8 ignore next */
          (L = I?.operationTypes) !== null && L !== void 0 ? L : []
        );
      }
    ).find((I) => I.operation === v)) === null || b === void 0 ? void 0 : b.type;
  }
  function h(E) {
    for (const b of E.schema.getDirectives()) {
      if (!(0, r.isDirective)(b)) {
        E.reportError(
          `Expected directive but got: ${(0, e.inspect)(b)}.`,
          b?.astNode
        );
        continue;
      }
      l(E, b), b.locations.length === 0 && E.reportError(
        `Directive @${b.name} must include 1 or more locations.`,
        b.astNode
      );
      for (const I of b.args)
        if (l(E, I), (0, t.isInputType)(I.type) || E.reportError(
          `The type of @${b.name}(${I.name}:) must be Input Type but got: ${(0, e.inspect)(I.type)}.`,
          I.astNode
        ), (0, t.isRequiredArgument)(I) && I.deprecationReason != null) {
          var v;
          E.reportError(
            `Required argument @${b.name}(${I.name}:) cannot be deprecated.`,
            [
              S(I.astNode),
              (v = I.astNode) === null || v === void 0 ? void 0 : v.type
            ]
          );
        }
    }
  }
  function l(E, v) {
    v.name.startsWith("__") && E.reportError(
      `Name "${v.name}" must not begin with "__", which is reserved by GraphQL introspection.`,
      v.astNode
    );
  }
  function d(E) {
    const v = G(E), b = E.schema.getTypeMap();
    for (const I of Object.values(b)) {
      if (!(0, t.isNamedType)(I)) {
        E.reportError(
          `Expected GraphQL named type but got: ${(0, e.inspect)(I)}.`,
          I.astNode
        );
        continue;
      }
      (0, a.isIntrospectionType)(I) || l(E, I), (0, t.isObjectType)(I) || (0, t.isInterfaceType)(I) ? (m(E, I), T(E, I)) : (0, t.isUnionType)(I) ? D(E, I) : (0, t.isEnumType)(I) ? _(E, I) : (0, t.isInputObjectType)(I) && (w(E, I), v(I));
    }
  }
  function m(E, v) {
    const b = Object.values(v.getFields());
    b.length === 0 && E.reportError(`Type ${v.name} must define one or more fields.`, [
      v.astNode,
      ...v.extensionASTNodes
    ]);
    for (const V of b) {
      if (l(E, V), !(0, t.isOutputType)(V.type)) {
        var I;
        E.reportError(
          `The type of ${v.name}.${V.name} must be Output Type but got: ${(0, e.inspect)(V.type)}.`,
          (I = V.astNode) === null || I === void 0 ? void 0 : I.type
        );
      }
      for (const U of V.args) {
        const W = U.name;
        if (l(E, U), !(0, t.isInputType)(U.type)) {
          var L;
          E.reportError(
            `The type of ${v.name}.${V.name}(${W}:) must be Input Type but got: ${(0, e.inspect)(U.type)}.`,
            (L = U.astNode) === null || L === void 0 ? void 0 : L.type
          );
        }
        if ((0, t.isRequiredArgument)(U) && U.deprecationReason != null) {
          var j;
          E.reportError(
            `Required argument ${v.name}.${V.name}(${W}:) cannot be deprecated.`,
            [
              S(U.astNode),
              (j = U.astNode) === null || j === void 0 ? void 0 : j.type
            ]
          );
        }
      }
    }
  }
  function T(E, v) {
    const b = /* @__PURE__ */ Object.create(null);
    for (const I of v.getInterfaces()) {
      if (!(0, t.isInterfaceType)(I)) {
        E.reportError(
          `Type ${(0, e.inspect)(
            v
          )} must only implement Interface types, it cannot implement ${(0, e.inspect)(I)}.`,
          N(v, I)
        );
        continue;
      }
      if (v === I) {
        E.reportError(
          `Type ${v.name} cannot implement itself because it would create a circular reference.`,
          N(v, I)
        );
        continue;
      }
      if (b[I.name]) {
        E.reportError(
          `Type ${v.name} can only implement ${I.name} once.`,
          N(v, I)
        );
        continue;
      }
      b[I.name] = !0, R(E, v, I), O(E, v, I);
    }
  }
  function O(E, v, b) {
    const I = v.getFields();
    for (const W of Object.values(b.getFields())) {
      const P = W.name, K = I[P];
      if (!K) {
        E.reportError(
          `Interface field ${b.name}.${P} expected but ${v.name} does not provide it.`,
          [W.astNode, v.astNode, ...v.extensionASTNodes]
        );
        continue;
      }
      if (!(0, i.isTypeSubTypeOf)(
        E.schema,
        K.type,
        W.type
      )) {
        var L, j;
        E.reportError(
          `Interface field ${b.name}.${P} expects type ${(0, e.inspect)(W.type)} but ${v.name}.${P} is type ${(0, e.inspect)(K.type)}.`,
          [
            (L = W.astNode) === null || L === void 0 ? void 0 : L.type,
            (j = K.astNode) === null || j === void 0 ? void 0 : j.type
          ]
        );
      }
      for (const te of W.args) {
        const pe = te.name, M = K.args.find((C) => C.name === pe);
        if (!M) {
          E.reportError(
            `Interface field argument ${b.name}.${P}(${pe}:) expected but ${v.name}.${P} does not provide it.`,
            [te.astNode, K.astNode]
          );
          continue;
        }
        if (!(0, i.isEqualType)(te.type, M.type)) {
          var V, U;
          E.reportError(
            `Interface field argument ${b.name}.${P}(${pe}:) expects type ${(0, e.inspect)(te.type)} but ${v.name}.${P}(${pe}:) is type ${(0, e.inspect)(M.type)}.`,
            [
              (V = te.astNode) === null || V === void 0 ? void 0 : V.type,
              (U = M.astNode) === null || U === void 0 ? void 0 : U.type
            ]
          );
        }
      }
      for (const te of K.args) {
        const pe = te.name;
        !W.args.find((C) => C.name === pe) && (0, t.isRequiredArgument)(te) && E.reportError(
          `Object field ${v.name}.${P} includes required argument ${pe} that is missing from the Interface field ${b.name}.${P}.`,
          [te.astNode, W.astNode]
        );
      }
    }
  }
  function R(E, v, b) {
    const I = v.getInterfaces();
    for (const L of b.getInterfaces())
      I.includes(L) || E.reportError(
        L === v ? `Type ${v.name} cannot implement ${b.name} because it would create a circular reference.` : `Type ${v.name} must implement ${L.name} because it is implemented by ${b.name}.`,
        [
          ...N(b, L),
          ...N(v, b)
        ]
      );
  }
  function D(E, v) {
    const b = v.getTypes();
    b.length === 0 && E.reportError(
      `Union type ${v.name} must define one or more member types.`,
      [v.astNode, ...v.extensionASTNodes]
    );
    const I = /* @__PURE__ */ Object.create(null);
    for (const L of b) {
      if (I[L.name]) {
        E.reportError(
          `Union type ${v.name} can only include type ${L.name} once.`,
          g(v, L.name)
        );
        continue;
      }
      I[L.name] = !0, (0, t.isObjectType)(L) || E.reportError(
        `Union type ${v.name} can only include Object types, it cannot include ${(0, e.inspect)(L)}.`,
        g(v, String(L))
      );
    }
  }
  function _(E, v) {
    const b = v.getValues();
    b.length === 0 && E.reportError(
      `Enum type ${v.name} must define one or more values.`,
      [v.astNode, ...v.extensionASTNodes]
    );
    for (const I of b)
      l(E, I);
  }
  function w(E, v) {
    const b = Object.values(v.getFields());
    b.length === 0 && E.reportError(
      `Input Object type ${v.name} must define one or more fields.`,
      [v.astNode, ...v.extensionASTNodes]
    );
    for (const j of b) {
      if (l(E, j), !(0, t.isInputType)(j.type)) {
        var I;
        E.reportError(
          `The type of ${v.name}.${j.name} must be Input Type but got: ${(0, e.inspect)(j.type)}.`,
          (I = j.astNode) === null || I === void 0 ? void 0 : I.type
        );
      }
      if ((0, t.isRequiredInputField)(j) && j.deprecationReason != null) {
        var L;
        E.reportError(
          `Required input field ${v.name}.${j.name} cannot be deprecated.`,
          [
            S(j.astNode),
            (L = j.astNode) === null || L === void 0 ? void 0 : L.type
          ]
        );
      }
      v.isOneOf && $(v, j, E);
    }
  }
  function $(E, v, b) {
    if ((0, t.isNonNullType)(v.type)) {
      var I;
      b.reportError(
        `OneOf input field ${E.name}.${v.name} must be nullable.`,
        (I = v.astNode) === null || I === void 0 ? void 0 : I.type
      );
    }
    v.defaultValue !== void 0 && b.reportError(
      `OneOf input field ${E.name}.${v.name} cannot have a default value.`,
      v.astNode
    );
  }
  function G(E) {
    const v = /* @__PURE__ */ Object.create(null), b = [], I = /* @__PURE__ */ Object.create(null);
    return L;
    function L(j) {
      if (v[j.name])
        return;
      v[j.name] = !0, I[j.name] = b.length;
      const V = Object.values(j.getFields());
      for (const U of V)
        if ((0, t.isNonNullType)(U.type) && (0, t.isInputObjectType)(U.type.ofType)) {
          const W = U.type.ofType, P = I[W.name];
          if (b.push(U), P === void 0)
            L(W);
          else {
            const K = b.slice(P), te = K.map((pe) => pe.name).join(".");
            E.reportError(
              `Cannot reference Input Object "${W.name}" within itself through a series of non-null fields: "${te}".`,
              K.map((pe) => pe.astNode)
            );
          }
          b.pop();
        }
      I[j.name] = void 0;
    }
  }
  function N(E, v) {
    const { astNode: b, extensionASTNodes: I } = E;
    return (b != null ? [b, ...I] : I).flatMap((j) => {
      var V;
      return (
        /* c8 ignore next */
        (V = j.interfaces) !== null && V !== void 0 ? V : []
      );
    }).filter((j) => j.name.value === v.name);
  }
  function g(E, v) {
    const { astNode: b, extensionASTNodes: I } = E;
    return (b != null ? [b, ...I] : I).flatMap((j) => {
      var V;
      return (
        /* c8 ignore next */
        (V = j.types) !== null && V !== void 0 ? V : []
      );
    }).filter((j) => j.name.value === v);
  }
  function S(E) {
    var v;
    return E == null || (v = E.directives) === null || v === void 0 ? void 0 : v.find(
      (b) => b.name.value === r.GraphQLDeprecatedDirective.name
    );
  }
  return An;
}
var an = {}, Tn = {}, Tt = {}, pa;
function Xe() {
  if (pa) return Tt;
  pa = 1, Object.defineProperty(Tt, "__esModule", {
    value: !0
  }), Tt.typeFromAST = s;
  var e = /* @__PURE__ */ se(), n = /* @__PURE__ */ oe();
  function s(i, t) {
    switch (t.kind) {
      case e.Kind.LIST_TYPE: {
        const r = s(i, t.type);
        return r && new n.GraphQLList(r);
      }
      case e.Kind.NON_NULL_TYPE: {
        const r = s(i, t.type);
        return r && new n.GraphQLNonNull(r);
      }
      case e.Kind.NAMED_TYPE:
        return i.getType(t.name.value);
    }
  }
  return Tt;
}
var da;
function si() {
  if (da) return Tn;
  da = 1, Object.defineProperty(Tn, "__esModule", {
    value: !0
  }), Tn.TypeInfo = void 0, Tn.visitWithTypeInfo = u;
  var e = /* @__PURE__ */ Je(), n = /* @__PURE__ */ se(), s = /* @__PURE__ */ On(), i = /* @__PURE__ */ oe(), t = /* @__PURE__ */ Me(), r = /* @__PURE__ */ Xe();
  let a = class {
    constructor(y, o, p) {
      this._schema = y, this._typeStack = [], this._parentTypeStack = [], this._inputTypeStack = [], this._fieldDefStack = [], this._defaultValueStack = [], this._directive = null, this._argument = null, this._enumValue = null, this._getFieldDef = p ?? c, o && ((0, i.isInputType)(o) && this._inputTypeStack.push(o), (0, i.isCompositeType)(o) && this._parentTypeStack.push(o), (0, i.isOutputType)(o) && this._typeStack.push(o));
    }
    get [Symbol.toStringTag]() {
      return "TypeInfo";
    }
    getType() {
      if (this._typeStack.length > 0)
        return this._typeStack[this._typeStack.length - 1];
    }
    getParentType() {
      if (this._parentTypeStack.length > 0)
        return this._parentTypeStack[this._parentTypeStack.length - 1];
    }
    getInputType() {
      if (this._inputTypeStack.length > 0)
        return this._inputTypeStack[this._inputTypeStack.length - 1];
    }
    getParentInputType() {
      if (this._inputTypeStack.length > 1)
        return this._inputTypeStack[this._inputTypeStack.length - 2];
    }
    getFieldDef() {
      if (this._fieldDefStack.length > 0)
        return this._fieldDefStack[this._fieldDefStack.length - 1];
    }
    getDefaultValue() {
      if (this._defaultValueStack.length > 0)
        return this._defaultValueStack[this._defaultValueStack.length - 1];
    }
    getDirective() {
      return this._directive;
    }
    getArgument() {
      return this._argument;
    }
    getEnumValue() {
      return this._enumValue;
    }
    enter(y) {
      const o = this._schema;
      switch (y.kind) {
        case n.Kind.SELECTION_SET: {
          const h = (0, i.getNamedType)(this.getType());
          this._parentTypeStack.push(
            (0, i.isCompositeType)(h) ? h : void 0
          );
          break;
        }
        case n.Kind.FIELD: {
          const h = this.getParentType();
          let l, d;
          h && (l = this._getFieldDef(o, h, y), l && (d = l.type)), this._fieldDefStack.push(l), this._typeStack.push(
            (0, i.isOutputType)(d) ? d : void 0
          );
          break;
        }
        case n.Kind.DIRECTIVE:
          this._directive = o.getDirective(y.name.value);
          break;
        case n.Kind.OPERATION_DEFINITION: {
          const h = o.getRootType(y.operation);
          this._typeStack.push(
            (0, i.isObjectType)(h) ? h : void 0
          );
          break;
        }
        case n.Kind.INLINE_FRAGMENT:
        case n.Kind.FRAGMENT_DEFINITION: {
          const h = y.typeCondition, l = h ? (0, r.typeFromAST)(o, h) : (0, i.getNamedType)(this.getType());
          this._typeStack.push(
            (0, i.isOutputType)(l) ? l : void 0
          );
          break;
        }
        case n.Kind.VARIABLE_DEFINITION: {
          const h = (0, r.typeFromAST)(o, y.type);
          this._inputTypeStack.push(
            (0, i.isInputType)(h) ? h : void 0
          );
          break;
        }
        case n.Kind.ARGUMENT: {
          var p;
          let h, l;
          const d = (p = this.getDirective()) !== null && p !== void 0 ? p : this.getFieldDef();
          d && (h = d.args.find(
            (m) => m.name === y.name.value
          ), h && (l = h.type)), this._argument = h, this._defaultValueStack.push(h ? h.defaultValue : void 0), this._inputTypeStack.push(
            (0, i.isInputType)(l) ? l : void 0
          );
          break;
        }
        case n.Kind.LIST: {
          const h = (0, i.getNullableType)(this.getInputType()), l = (0, i.isListType)(h) ? h.ofType : h;
          this._defaultValueStack.push(void 0), this._inputTypeStack.push(
            (0, i.isInputType)(l) ? l : void 0
          );
          break;
        }
        case n.Kind.OBJECT_FIELD: {
          const h = (0, i.getNamedType)(this.getInputType());
          let l, d;
          (0, i.isInputObjectType)(h) && (d = h.getFields()[y.name.value], d && (l = d.type)), this._defaultValueStack.push(
            d ? d.defaultValue : void 0
          ), this._inputTypeStack.push(
            (0, i.isInputType)(l) ? l : void 0
          );
          break;
        }
        case n.Kind.ENUM: {
          const h = (0, i.getNamedType)(this.getInputType());
          let l;
          (0, i.isEnumType)(h) && (l = h.getValue(y.value)), this._enumValue = l;
          break;
        }
      }
    }
    leave(y) {
      switch (y.kind) {
        case n.Kind.SELECTION_SET:
          this._parentTypeStack.pop();
          break;
        case n.Kind.FIELD:
          this._fieldDefStack.pop(), this._typeStack.pop();
          break;
        case n.Kind.DIRECTIVE:
          this._directive = null;
          break;
        case n.Kind.OPERATION_DEFINITION:
        case n.Kind.INLINE_FRAGMENT:
        case n.Kind.FRAGMENT_DEFINITION:
          this._typeStack.pop();
          break;
        case n.Kind.VARIABLE_DEFINITION:
          this._inputTypeStack.pop();
          break;
        case n.Kind.ARGUMENT:
          this._argument = null, this._defaultValueStack.pop(), this._inputTypeStack.pop();
          break;
        case n.Kind.LIST:
        case n.Kind.OBJECT_FIELD:
          this._defaultValueStack.pop(), this._inputTypeStack.pop();
          break;
        case n.Kind.ENUM:
          this._enumValue = null;
          break;
      }
    }
  };
  Tn.TypeInfo = a;
  function c(f, y, o) {
    const p = o.name.value;
    if (p === t.SchemaMetaFieldDef.name && f.getQueryType() === y)
      return t.SchemaMetaFieldDef;
    if (p === t.TypeMetaFieldDef.name && f.getQueryType() === y)
      return t.TypeMetaFieldDef;
    if (p === t.TypeNameMetaFieldDef.name && (0, i.isCompositeType)(y))
      return t.TypeNameMetaFieldDef;
    if ((0, i.isObjectType)(y) || (0, i.isInterfaceType)(y))
      return y.getFields()[p];
  }
  function u(f, y) {
    return {
      enter(...o) {
        const p = o[0];
        f.enter(p);
        const h = (0, s.getEnterLeaveForKind)(y, p.kind).enter;
        if (h) {
          const l = h.apply(y, o);
          return l !== void 0 && (f.leave(p), (0, e.isNode)(l) && f.enter(l)), l;
        }
      },
      leave(...o) {
        const p = o[0], h = (0, s.getEnterLeaveForKind)(y, p.kind).leave;
        let l;
        return h && (l = h.apply(y, o)), f.leave(p), l;
      }
    };
  }
  return Tn;
}
var Ke = {}, bt = {}, Ae = {}, fa;
function In() {
  if (fa) return Ae;
  fa = 1, Object.defineProperty(Ae, "__esModule", {
    value: !0
  }), Ae.isConstValueNode = r, Ae.isDefinitionNode = n, Ae.isExecutableDefinitionNode = s, Ae.isSelectionNode = i, Ae.isTypeDefinitionNode = u, Ae.isTypeExtensionNode = y, Ae.isTypeNode = a, Ae.isTypeSystemDefinitionNode = c, Ae.isTypeSystemExtensionNode = f, Ae.isValueNode = t;
  var e = /* @__PURE__ */ se();
  function n(o) {
    return s(o) || c(o) || f(o);
  }
  function s(o) {
    return o.kind === e.Kind.OPERATION_DEFINITION || o.kind === e.Kind.FRAGMENT_DEFINITION;
  }
  function i(o) {
    return o.kind === e.Kind.FIELD || o.kind === e.Kind.FRAGMENT_SPREAD || o.kind === e.Kind.INLINE_FRAGMENT;
  }
  function t(o) {
    return o.kind === e.Kind.VARIABLE || o.kind === e.Kind.INT || o.kind === e.Kind.FLOAT || o.kind === e.Kind.STRING || o.kind === e.Kind.BOOLEAN || o.kind === e.Kind.NULL || o.kind === e.Kind.ENUM || o.kind === e.Kind.LIST || o.kind === e.Kind.OBJECT;
  }
  function r(o) {
    return t(o) && (o.kind === e.Kind.LIST ? o.values.some(r) : o.kind === e.Kind.OBJECT ? o.fields.some((p) => r(p.value)) : o.kind !== e.Kind.VARIABLE);
  }
  function a(o) {
    return o.kind === e.Kind.NAMED_TYPE || o.kind === e.Kind.LIST_TYPE || o.kind === e.Kind.NON_NULL_TYPE;
  }
  function c(o) {
    return o.kind === e.Kind.SCHEMA_DEFINITION || u(o) || o.kind === e.Kind.DIRECTIVE_DEFINITION;
  }
  function u(o) {
    return o.kind === e.Kind.SCALAR_TYPE_DEFINITION || o.kind === e.Kind.OBJECT_TYPE_DEFINITION || o.kind === e.Kind.INTERFACE_TYPE_DEFINITION || o.kind === e.Kind.UNION_TYPE_DEFINITION || o.kind === e.Kind.ENUM_TYPE_DEFINITION || o.kind === e.Kind.INPUT_OBJECT_TYPE_DEFINITION;
  }
  function f(o) {
    return o.kind === e.Kind.SCHEMA_EXTENSION || y(o);
  }
  function y(o) {
    return o.kind === e.Kind.SCALAR_TYPE_EXTENSION || o.kind === e.Kind.OBJECT_TYPE_EXTENSION || o.kind === e.Kind.INTERFACE_TYPE_EXTENSION || o.kind === e.Kind.UNION_TYPE_EXTENSION || o.kind === e.Kind.ENUM_TYPE_EXTENSION || o.kind === e.Kind.INPUT_OBJECT_TYPE_EXTENSION;
  }
  return Ae;
}
var ma;
function zs() {
  if (ma) return bt;
  ma = 1, Object.defineProperty(bt, "__esModule", {
    value: !0
  }), bt.ExecutableDefinitionsRule = i;
  var e = /* @__PURE__ */ ne(), n = /* @__PURE__ */ se(), s = /* @__PURE__ */ In();
  function i(t) {
    return {
      Document(r) {
        for (const a of r.definitions)
          if (!(0, s.isExecutableDefinitionNode)(a)) {
            const c = a.kind === n.Kind.SCHEMA_DEFINITION || a.kind === n.Kind.SCHEMA_EXTENSION ? "schema" : '"' + a.name.value + '"';
            t.reportError(
              new e.GraphQLError(
                `The ${c} definition is not executable.`,
                {
                  nodes: a
                }
              )
            );
          }
        return !1;
      }
    };
  }
  return bt;
}
var gt = {}, ya;
function Xs() {
  if (ya) return gt;
  ya = 1, Object.defineProperty(gt, "__esModule", {
    value: !0
  }), gt.FieldsOnCorrectTypeRule = r;
  var e = /* @__PURE__ */ sn(), n = /* @__PURE__ */ Sr(), s = /* @__PURE__ */ un(), i = /* @__PURE__ */ ne(), t = /* @__PURE__ */ oe();
  function r(u) {
    return {
      Field(f) {
        const y = u.getParentType();
        if (y && !u.getFieldDef()) {
          const p = u.getSchema(), h = f.name.value;
          let l = (0, e.didYouMean)(
            "to use an inline fragment on",
            a(p, y, h)
          );
          l === "" && (l = (0, e.didYouMean)(
            c(y, h)
          )), u.reportError(
            new i.GraphQLError(
              `Cannot query field "${h}" on type "${y.name}".` + l,
              {
                nodes: f
              }
            )
          );
        }
      }
    };
  }
  function a(u, f, y) {
    if (!(0, t.isAbstractType)(f))
      return [];
    const o = /* @__PURE__ */ new Set(), p = /* @__PURE__ */ Object.create(null);
    for (const l of u.getPossibleTypes(f))
      if (l.getFields()[y]) {
        o.add(l), p[l.name] = 1;
        for (const d of l.getInterfaces()) {
          var h;
          d.getFields()[y] && (o.add(d), p[d.name] = ((h = p[d.name]) !== null && h !== void 0 ? h : 0) + 1);
        }
      }
    return [...o].sort((l, d) => {
      const m = p[d.name] - p[l.name];
      return m !== 0 ? m : (0, t.isInterfaceType)(l) && u.isSubType(l, d) ? -1 : (0, t.isInterfaceType)(d) && u.isSubType(d, l) ? 1 : (0, n.naturalCompare)(l.name, d.name);
    }).map((l) => l.name);
  }
  function c(u, f) {
    if ((0, t.isObjectType)(u) || (0, t.isInterfaceType)(u)) {
      const y = Object.keys(u.getFields());
      return (0, s.suggestionList)(f, y);
    }
    return [];
  }
  return gt;
}
var Et = {}, ha;
function Hs() {
  if (ha) return Et;
  ha = 1, Object.defineProperty(Et, "__esModule", {
    value: !0
  }), Et.FragmentsOnCompositeTypesRule = t;
  var e = /* @__PURE__ */ ne(), n = /* @__PURE__ */ we(), s = /* @__PURE__ */ oe(), i = /* @__PURE__ */ Xe();
  function t(r) {
    return {
      InlineFragment(a) {
        const c = a.typeCondition;
        if (c) {
          const u = (0, i.typeFromAST)(
            r.getSchema(),
            c
          );
          if (u && !(0, s.isCompositeType)(u)) {
            const f = (0, n.print)(c);
            r.reportError(
              new e.GraphQLError(
                `Fragment cannot condition on non composite type "${f}".`,
                {
                  nodes: c
                }
              )
            );
          }
        }
      },
      FragmentDefinition(a) {
        const c = (0, i.typeFromAST)(
          r.getSchema(),
          a.typeCondition
        );
        if (c && !(0, s.isCompositeType)(c)) {
          const u = (0, n.print)(a.typeCondition);
          r.reportError(
            new e.GraphQLError(
              `Fragment "${a.name.value}" cannot condition on non composite type "${u}".`,
              {
                nodes: a.typeCondition
              }
            )
          );
        }
      }
    };
  }
  return Et;
}
var Pn = {}, va;
function Ws() {
  if (va) return Pn;
  va = 1, Object.defineProperty(Pn, "__esModule", {
    value: !0
  }), Pn.KnownArgumentNamesOnDirectivesRule = a, Pn.KnownArgumentNamesRule = r;
  var e = /* @__PURE__ */ sn(), n = /* @__PURE__ */ un(), s = /* @__PURE__ */ ne(), i = /* @__PURE__ */ se(), t = /* @__PURE__ */ Pe();
  function r(c) {
    return {
      // eslint-disable-next-line new-cap
      ...a(c),
      Argument(u) {
        const f = c.getArgument(), y = c.getFieldDef(), o = c.getParentType();
        if (!f && y && o) {
          const p = u.name.value, h = y.args.map((d) => d.name), l = (0, n.suggestionList)(
            p,
            h
          );
          c.reportError(
            new s.GraphQLError(
              `Unknown argument "${p}" on field "${o.name}.${y.name}".` + (0, e.didYouMean)(l),
              {
                nodes: u
              }
            )
          );
        }
      }
    };
  }
  function a(c) {
    const u = /* @__PURE__ */ Object.create(null), f = c.getSchema(), y = f ? f.getDirectives() : t.specifiedDirectives;
    for (const h of y)
      u[h.name] = h.args.map((l) => l.name);
    const o = c.getDocument().definitions;
    for (const h of o)
      if (h.kind === i.Kind.DIRECTIVE_DEFINITION) {
        var p;
        const l = (p = h.arguments) !== null && p !== void 0 ? p : [];
        u[h.name.value] = l.map((d) => d.name.value);
      }
    return {
      Directive(h) {
        const l = h.name.value, d = u[l];
        if (h.arguments && d)
          for (const m of h.arguments) {
            const T = m.name.value;
            if (!d.includes(T)) {
              const O = (0, n.suggestionList)(
                T,
                d
              );
              c.reportError(
                new s.GraphQLError(
                  `Unknown argument "${T}" on directive "@${l}".` + (0, e.didYouMean)(O),
                  {
                    nodes: m
                  }
                )
              );
            }
          }
        return !1;
      }
    };
  }
  return Pn;
}
var Nt = {}, Ta;
function Zs() {
  if (Ta) return Nt;
  Ta = 1, Object.defineProperty(Nt, "__esModule", {
    value: !0
  }), Nt.KnownDirectivesRule = c;
  var e = /* @__PURE__ */ de(), n = /* @__PURE__ */ Se(), s = /* @__PURE__ */ ne(), i = /* @__PURE__ */ Je(), t = /* @__PURE__ */ Bn(), r = /* @__PURE__ */ se(), a = /* @__PURE__ */ Pe();
  function c(y) {
    const o = /* @__PURE__ */ Object.create(null), p = y.getSchema(), h = p ? p.getDirectives() : a.specifiedDirectives;
    for (const d of h)
      o[d.name] = d.locations;
    const l = y.getDocument().definitions;
    for (const d of l)
      d.kind === r.Kind.DIRECTIVE_DEFINITION && (o[d.name.value] = d.locations.map((m) => m.value));
    return {
      Directive(d, m, T, O, R) {
        const D = d.name.value, _ = o[D];
        if (!_) {
          y.reportError(
            new s.GraphQLError(`Unknown directive "@${D}".`, {
              nodes: d
            })
          );
          return;
        }
        const w = u(R);
        w && !_.includes(w) && y.reportError(
          new s.GraphQLError(
            `Directive "@${D}" may not be used on ${w}.`,
            {
              nodes: d
            }
          )
        );
      }
    };
  }
  function u(y) {
    const o = y[y.length - 1];
    switch ("kind" in o || (0, n.invariant)(!1), o.kind) {
      case r.Kind.OPERATION_DEFINITION:
        return f(o.operation);
      case r.Kind.FIELD:
        return t.DirectiveLocation.FIELD;
      case r.Kind.FRAGMENT_SPREAD:
        return t.DirectiveLocation.FRAGMENT_SPREAD;
      case r.Kind.INLINE_FRAGMENT:
        return t.DirectiveLocation.INLINE_FRAGMENT;
      case r.Kind.FRAGMENT_DEFINITION:
        return t.DirectiveLocation.FRAGMENT_DEFINITION;
      case r.Kind.VARIABLE_DEFINITION:
        return t.DirectiveLocation.VARIABLE_DEFINITION;
      case r.Kind.SCHEMA_DEFINITION:
      case r.Kind.SCHEMA_EXTENSION:
        return t.DirectiveLocation.SCHEMA;
      case r.Kind.SCALAR_TYPE_DEFINITION:
      case r.Kind.SCALAR_TYPE_EXTENSION:
        return t.DirectiveLocation.SCALAR;
      case r.Kind.OBJECT_TYPE_DEFINITION:
      case r.Kind.OBJECT_TYPE_EXTENSION:
        return t.DirectiveLocation.OBJECT;
      case r.Kind.FIELD_DEFINITION:
        return t.DirectiveLocation.FIELD_DEFINITION;
      case r.Kind.INTERFACE_TYPE_DEFINITION:
      case r.Kind.INTERFACE_TYPE_EXTENSION:
        return t.DirectiveLocation.INTERFACE;
      case r.Kind.UNION_TYPE_DEFINITION:
      case r.Kind.UNION_TYPE_EXTENSION:
        return t.DirectiveLocation.UNION;
      case r.Kind.ENUM_TYPE_DEFINITION:
      case r.Kind.ENUM_TYPE_EXTENSION:
        return t.DirectiveLocation.ENUM;
      case r.Kind.ENUM_VALUE_DEFINITION:
        return t.DirectiveLocation.ENUM_VALUE;
      case r.Kind.INPUT_OBJECT_TYPE_DEFINITION:
      case r.Kind.INPUT_OBJECT_TYPE_EXTENSION:
        return t.DirectiveLocation.INPUT_OBJECT;
      case r.Kind.INPUT_VALUE_DEFINITION: {
        const p = y[y.length - 3];
        return "kind" in p || (0, n.invariant)(!1), p.kind === r.Kind.INPUT_OBJECT_TYPE_DEFINITION ? t.DirectiveLocation.INPUT_FIELD_DEFINITION : t.DirectiveLocation.ARGUMENT_DEFINITION;
      }
      // Not reachable, all possible types have been considered.
      /* c8 ignore next */
      default:
        (0, n.invariant)(
          !1,
          "Unexpected kind: " + (0, e.inspect)(o.kind)
        );
    }
  }
  function f(y) {
    switch (y) {
      case i.OperationTypeNode.QUERY:
        return t.DirectiveLocation.QUERY;
      case i.OperationTypeNode.MUTATION:
        return t.DirectiveLocation.MUTATION;
      case i.OperationTypeNode.SUBSCRIPTION:
        return t.DirectiveLocation.SUBSCRIPTION;
    }
  }
  return Nt;
}
var Ot = {}, ba;
function eo() {
  if (ba) return Ot;
  ba = 1, Object.defineProperty(Ot, "__esModule", {
    value: !0
  }), Ot.KnownFragmentNamesRule = n;
  var e = /* @__PURE__ */ ne();
  function n(s) {
    return {
      FragmentSpread(i) {
        const t = i.name.value;
        s.getFragment(t) || s.reportError(
          new e.GraphQLError(
            `Unknown fragment "${t}".`,
            {
              nodes: i.name
            }
          )
        );
      }
    };
  }
  return Ot;
}
var _t = {}, ga;
function no() {
  if (ga) return _t;
  ga = 1, Object.defineProperty(_t, "__esModule", {
    value: !0
  }), _t.KnownTypeNamesRule = a;
  var e = /* @__PURE__ */ sn(), n = /* @__PURE__ */ un(), s = /* @__PURE__ */ ne(), i = /* @__PURE__ */ In(), t = /* @__PURE__ */ Me(), r = /* @__PURE__ */ ze();
  function a(f) {
    const y = f.getSchema(), o = y ? y.getTypeMap() : /* @__PURE__ */ Object.create(null), p = /* @__PURE__ */ Object.create(null);
    for (const l of f.getDocument().definitions)
      (0, i.isTypeDefinitionNode)(l) && (p[l.name.value] = !0);
    const h = [
      ...Object.keys(o),
      ...Object.keys(p)
    ];
    return {
      NamedType(l, d, m, T, O) {
        const R = l.name.value;
        if (!o[R] && !p[R]) {
          var D;
          const _ = (D = O[2]) !== null && D !== void 0 ? D : m, w = _ != null && u(_);
          if (w && c.includes(R))
            return;
          const $ = (0, n.suggestionList)(
            R,
            w ? c.concat(h) : h
          );
          f.reportError(
            new s.GraphQLError(
              `Unknown type "${R}".` + (0, e.didYouMean)($),
              {
                nodes: l
              }
            )
          );
        }
      }
    };
  }
  const c = [
    ...r.specifiedScalarTypes,
    ...t.introspectionTypes
  ].map((f) => f.name);
  function u(f) {
    return "kind" in f && ((0, i.isTypeSystemDefinitionNode)(f) || (0, i.isTypeSystemExtensionNode)(f));
  }
  return _t;
}
var It = {}, Ea;
function to() {
  if (Ea) return It;
  Ea = 1, Object.defineProperty(It, "__esModule", {
    value: !0
  }), It.LoneAnonymousOperationRule = s;
  var e = /* @__PURE__ */ ne(), n = /* @__PURE__ */ se();
  function s(i) {
    let t = 0;
    return {
      Document(r) {
        t = r.definitions.filter(
          (a) => a.kind === n.Kind.OPERATION_DEFINITION
        ).length;
      },
      OperationDefinition(r) {
        !r.name && t > 1 && i.reportError(
          new e.GraphQLError(
            "This anonymous operation must be the only defined operation.",
            {
              nodes: r
            }
          )
        );
      }
    };
  }
  return It;
}
var Lt = {}, Na;
function ro() {
  if (Na) return Lt;
  Na = 1, Object.defineProperty(Lt, "__esModule", {
    value: !0
  }), Lt.LoneSchemaDefinitionRule = n;
  var e = /* @__PURE__ */ ne();
  function n(s) {
    var i, t, r;
    const a = s.getSchema(), c = (i = (t = (r = a?.astNode) !== null && r !== void 0 ? r : a?.getQueryType()) !== null && t !== void 0 ? t : a?.getMutationType()) !== null && i !== void 0 ? i : a?.getSubscriptionType();
    let u = 0;
    return {
      SchemaDefinition(f) {
        if (c) {
          s.reportError(
            new e.GraphQLError(
              "Cannot define a new schema within a schema extension.",
              {
                nodes: f
              }
            )
          );
          return;
        }
        u > 0 && s.reportError(
          new e.GraphQLError(
            "Must provide only one schema definition.",
            {
              nodes: f
            }
          )
        ), ++u;
      }
    };
  }
  return Lt;
}
var St = {}, Oa;
function io() {
  if (Oa) return St;
  Oa = 1, Object.defineProperty(St, "__esModule", {
    value: !0
  }), St.MaxIntrospectionDepthRule = i;
  var e = /* @__PURE__ */ ne(), n = /* @__PURE__ */ se();
  const s = 3;
  function i(t) {
    function r(a, c = /* @__PURE__ */ Object.create(null), u = 0) {
      if (a.kind === n.Kind.FRAGMENT_SPREAD) {
        const f = a.name.value;
        if (c[f] === !0)
          return !1;
        const y = t.getFragment(f);
        if (!y)
          return !1;
        try {
          return c[f] = !0, r(y, c, u);
        } finally {
          c[f] = void 0;
        }
      }
      if (a.kind === n.Kind.FIELD && // check all introspection lists
      (a.name.value === "fields" || a.name.value === "interfaces" || a.name.value === "possibleTypes" || a.name.value === "inputFields") && (u++, u >= s))
        return !0;
      if ("selectionSet" in a && a.selectionSet) {
        for (const f of a.selectionSet.selections)
          if (r(f, c, u))
            return !0;
      }
      return !1;
    }
    return {
      Field(a) {
        if ((a.name.value === "__schema" || a.name.value === "__type") && r(a))
          return t.reportError(
            new e.GraphQLError(
              "Maximum introspection depth exceeded",
              {
                nodes: [a]
              }
            )
          ), !1;
      }
    };
  }
  return St;
}
var Rt = {}, _a;
function ao() {
  if (_a) return Rt;
  _a = 1, Object.defineProperty(Rt, "__esModule", {
    value: !0
  }), Rt.NoFragmentCyclesRule = n;
  var e = /* @__PURE__ */ ne();
  function n(s) {
    const i = /* @__PURE__ */ Object.create(null), t = [], r = /* @__PURE__ */ Object.create(null);
    return {
      OperationDefinition: () => !1,
      FragmentDefinition(c) {
        return a(c), !1;
      }
    };
    function a(c) {
      if (i[c.name.value])
        return;
      const u = c.name.value;
      i[u] = !0;
      const f = s.getFragmentSpreads(c.selectionSet);
      if (f.length !== 0) {
        r[u] = t.length;
        for (const y of f) {
          const o = y.name.value, p = r[o];
          if (t.push(y), p === void 0) {
            const h = s.getFragment(o);
            h && a(h);
          } else {
            const h = t.slice(p), l = h.slice(0, -1).map((d) => '"' + d.name.value + '"').join(", ");
            s.reportError(
              new e.GraphQLError(
                `Cannot spread fragment "${o}" within itself` + (l !== "" ? ` via ${l}.` : "."),
                {
                  nodes: h
                }
              )
            );
          }
          t.pop();
        }
        r[u] = void 0;
      }
    }
  }
  return Rt;
}
var Dt = {}, Ia;
function so() {
  if (Ia) return Dt;
  Ia = 1, Object.defineProperty(Dt, "__esModule", {
    value: !0
  }), Dt.NoUndefinedVariablesRule = n;
  var e = /* @__PURE__ */ ne();
  function n(s) {
    let i = /* @__PURE__ */ Object.create(null);
    return {
      OperationDefinition: {
        enter() {
          i = /* @__PURE__ */ Object.create(null);
        },
        leave(t) {
          const r = s.getRecursiveVariableUsages(t);
          for (const { node: a } of r) {
            const c = a.name.value;
            i[c] !== !0 && s.reportError(
              new e.GraphQLError(
                t.name ? `Variable "$${c}" is not defined by operation "${t.name.value}".` : `Variable "$${c}" is not defined.`,
                {
                  nodes: [a, t]
                }
              )
            );
          }
        }
      },
      VariableDefinition(t) {
        i[t.variable.name.value] = !0;
      }
    };
  }
  return Dt;
}
var At = {}, La;
function oo() {
  if (La) return At;
  La = 1, Object.defineProperty(At, "__esModule", {
    value: !0
  }), At.NoUnusedFragmentsRule = n;
  var e = /* @__PURE__ */ ne();
  function n(s) {
    const i = [], t = [];
    return {
      OperationDefinition(r) {
        return i.push(r), !1;
      },
      FragmentDefinition(r) {
        return t.push(r), !1;
      },
      Document: {
        leave() {
          const r = /* @__PURE__ */ Object.create(null);
          for (const a of i)
            for (const c of s.getRecursivelyReferencedFragments(
              a
            ))
              r[c.name.value] = !0;
          for (const a of t) {
            const c = a.name.value;
            r[c] !== !0 && s.reportError(
              new e.GraphQLError(
                `Fragment "${c}" is never used.`,
                {
                  nodes: a
                }
              )
            );
          }
        }
      }
    };
  }
  return At;
}
var jt = {}, Sa;
function uo() {
  if (Sa) return jt;
  Sa = 1, Object.defineProperty(jt, "__esModule", {
    value: !0
  }), jt.NoUnusedVariablesRule = n;
  var e = /* @__PURE__ */ ne();
  function n(s) {
    let i = [];
    return {
      OperationDefinition: {
        enter() {
          i = [];
        },
        leave(t) {
          const r = /* @__PURE__ */ Object.create(null), a = s.getRecursiveVariableUsages(t);
          for (const { node: c } of a)
            r[c.name.value] = !0;
          for (const c of i) {
            const u = c.variable.name.value;
            r[u] !== !0 && s.reportError(
              new e.GraphQLError(
                t.name ? `Variable "$${u}" is never used in operation "${t.name.value}".` : `Variable "$${u}" is never used.`,
                {
                  nodes: c
                }
              )
            );
          }
        }
      },
      VariableDefinition(t) {
        i.push(t);
      }
    };
  }
  return jt;
}
var Pt = {}, Ft = {}, Ra;
function co() {
  if (Ra) return Ft;
  Ra = 1, Object.defineProperty(Ft, "__esModule", {
    value: !0
  }), Ft.sortValueNode = s;
  var e = /* @__PURE__ */ Sr(), n = /* @__PURE__ */ se();
  function s(t) {
    switch (t.kind) {
      case n.Kind.OBJECT:
        return { ...t, fields: i(t.fields) };
      case n.Kind.LIST:
        return { ...t, values: t.values.map(s) };
      case n.Kind.INT:
      case n.Kind.FLOAT:
      case n.Kind.STRING:
      case n.Kind.BOOLEAN:
      case n.Kind.NULL:
      case n.Kind.ENUM:
      case n.Kind.VARIABLE:
        return t;
    }
  }
  function i(t) {
    return t.map((r) => ({
      ...r,
      value: s(r.value)
    })).sort(
      (r, a) => (0, e.naturalCompare)(r.name.value, a.name.value)
    );
  }
  return Ft;
}
var Da;
function lo() {
  if (Da) return Pt;
  Da = 1, Object.defineProperty(Pt, "__esModule", {
    value: !0
  }), Pt.OverlappingFieldsCanBeMergedRule = u;
  var e = /* @__PURE__ */ de(), n = /* @__PURE__ */ ne(), s = /* @__PURE__ */ se(), i = /* @__PURE__ */ we(), t = /* @__PURE__ */ oe(), r = /* @__PURE__ */ co(), a = /* @__PURE__ */ Xe();
  function c(N) {
    return Array.isArray(N) ? N.map(
      ([g, S]) => `subfields "${g}" conflict because ` + c(S)
    ).join(" and ") : N;
  }
  function u(N) {
    const g = new $(), S = new G(), E = /* @__PURE__ */ new Map();
    return {
      SelectionSet(v) {
        const b = f(
          N,
          E,
          g,
          S,
          N.getParentType(),
          v
        );
        for (const [[I, L], j, V] of b) {
          const U = c(L);
          N.reportError(
            new n.GraphQLError(
              `Fields "${I}" conflict because ${U}. Use different aliases on the fields to fetch both if this was intentional.`,
              {
                nodes: j.concat(V)
              }
            )
          );
        }
      }
    };
  }
  function f(N, g, S, E, v, b) {
    const I = [], [L, j] = R(
      N,
      g,
      v,
      b
    );
    if (h(
      N,
      I,
      g,
      S,
      E,
      L
    ), j.length !== 0)
      for (let V = 0; V < j.length; V++) {
        y(
          N,
          I,
          g,
          S,
          E,
          !1,
          L,
          j[V]
        );
        for (let U = V + 1; U < j.length; U++)
          o(
            N,
            I,
            g,
            S,
            E,
            !1,
            j[V],
            j[U]
          );
      }
    return I;
  }
  function y(N, g, S, E, v, b, I, L) {
    if (E.has(
      I,
      L,
      b
    ))
      return;
    E.add(
      I,
      L,
      b
    );
    const j = N.getFragment(L);
    if (!j)
      return;
    const [V, U] = D(
      N,
      S,
      j
    );
    if (I !== V) {
      l(
        N,
        g,
        S,
        E,
        v,
        b,
        I,
        V
      );
      for (const W of U)
        y(
          N,
          g,
          S,
          E,
          v,
          b,
          I,
          W
        );
    }
  }
  function o(N, g, S, E, v, b, I, L) {
    if (I === L || v.has(
      I,
      L,
      b
    ))
      return;
    v.add(I, L, b);
    const j = N.getFragment(I), V = N.getFragment(L);
    if (!j || !V)
      return;
    const [U, W] = D(
      N,
      S,
      j
    ), [P, K] = D(
      N,
      S,
      V
    );
    l(
      N,
      g,
      S,
      E,
      v,
      b,
      U,
      P
    );
    for (const te of K)
      o(
        N,
        g,
        S,
        E,
        v,
        b,
        I,
        te
      );
    for (const te of W)
      o(
        N,
        g,
        S,
        E,
        v,
        b,
        te,
        L
      );
  }
  function p(N, g, S, E, v, b, I, L, j) {
    const V = [], [U, W] = R(
      N,
      g,
      b,
      I
    ), [P, K] = R(
      N,
      g,
      L,
      j
    );
    l(
      N,
      V,
      g,
      S,
      E,
      v,
      U,
      P
    );
    for (const te of K)
      y(
        N,
        V,
        g,
        S,
        E,
        v,
        U,
        te
      );
    for (const te of W)
      y(
        N,
        V,
        g,
        S,
        E,
        v,
        P,
        te
      );
    for (const te of W)
      for (const pe of K)
        o(
          N,
          V,
          g,
          S,
          E,
          v,
          te,
          pe
        );
    return V;
  }
  function h(N, g, S, E, v, b) {
    for (const [I, L] of Object.entries(b))
      if (L.length > 1)
        for (let j = 0; j < L.length; j++)
          for (let V = j + 1; V < L.length; V++) {
            const U = d(
              N,
              S,
              E,
              v,
              !1,
              // within one collection is never mutually exclusive
              I,
              L[j],
              L[V]
            );
            U && g.push(U);
          }
  }
  function l(N, g, S, E, v, b, I, L) {
    for (const [j, V] of Object.entries(I)) {
      const U = L[j];
      if (U)
        for (const W of V)
          for (const P of U) {
            const K = d(
              N,
              S,
              E,
              v,
              b,
              j,
              W,
              P
            );
            K && g.push(K);
          }
    }
  }
  function d(N, g, S, E, v, b, I, L) {
    const [j, V, U] = I, [W, P, K] = L, te = v || j !== W && (0, t.isObjectType)(j) && (0, t.isObjectType)(W);
    if (!te) {
      const x = V.name.value, Z = P.name.value;
      if (x !== Z)
        return [
          [b, `"${x}" and "${Z}" are different fields`],
          [V],
          [P]
        ];
      if (!m(V, P))
        return [
          [b, "they have differing arguments"],
          [V],
          [P]
        ];
    }
    const pe = U?.type, M = K?.type;
    if (pe && M && O(pe, M))
      return [
        [
          b,
          `they return conflicting types "${(0, e.inspect)(
            pe
          )}" and "${(0, e.inspect)(M)}"`
        ],
        [V],
        [P]
      ];
    const C = V.selectionSet, B = P.selectionSet;
    if (C && B) {
      const x = p(
        N,
        g,
        S,
        E,
        te,
        (0, t.getNamedType)(pe),
        C,
        (0, t.getNamedType)(M),
        B
      );
      return w(x, b, V, P);
    }
  }
  function m(N, g) {
    const S = N.arguments, E = g.arguments;
    if (S === void 0 || S.length === 0)
      return E === void 0 || E.length === 0;
    if (E === void 0 || E.length === 0 || S.length !== E.length)
      return !1;
    const v = new Map(E.map(({ name: b, value: I }) => [b.value, I]));
    return S.every((b) => {
      const I = b.value, L = v.get(b.name.value);
      return L === void 0 ? !1 : T(I) === T(L);
    });
  }
  function T(N) {
    return (0, i.print)((0, r.sortValueNode)(N));
  }
  function O(N, g) {
    return (0, t.isListType)(N) ? (0, t.isListType)(g) ? O(N.ofType, g.ofType) : !0 : (0, t.isListType)(g) ? !0 : (0, t.isNonNullType)(N) ? (0, t.isNonNullType)(g) ? O(N.ofType, g.ofType) : !0 : (0, t.isNonNullType)(g) ? !0 : (0, t.isLeafType)(N) || (0, t.isLeafType)(g) ? N !== g : !1;
  }
  function R(N, g, S, E) {
    const v = g.get(E);
    if (v)
      return v;
    const b = /* @__PURE__ */ Object.create(null), I = /* @__PURE__ */ Object.create(null);
    _(
      N,
      S,
      E,
      b,
      I
    );
    const L = [b, Object.keys(I)];
    return g.set(E, L), L;
  }
  function D(N, g, S) {
    const E = g.get(S.selectionSet);
    if (E)
      return E;
    const v = (0, a.typeFromAST)(
      N.getSchema(),
      S.typeCondition
    );
    return R(
      N,
      g,
      v,
      S.selectionSet
    );
  }
  function _(N, g, S, E, v) {
    for (const b of S.selections)
      switch (b.kind) {
        case s.Kind.FIELD: {
          const I = b.name.value;
          let L;
          ((0, t.isObjectType)(g) || (0, t.isInterfaceType)(g)) && (L = g.getFields()[I]);
          const j = b.alias ? b.alias.value : I;
          E[j] || (E[j] = []), E[j].push([g, b, L]);
          break;
        }
        case s.Kind.FRAGMENT_SPREAD:
          v[b.name.value] = !0;
          break;
        case s.Kind.INLINE_FRAGMENT: {
          const I = b.typeCondition, L = I ? (0, a.typeFromAST)(N.getSchema(), I) : g;
          _(
            N,
            L,
            b.selectionSet,
            E,
            v
          );
          break;
        }
      }
  }
  function w(N, g, S, E) {
    if (N.length > 0)
      return [
        [g, N.map(([v]) => v)],
        [S, ...N.map(([, v]) => v).flat()],
        [E, ...N.map(([, , v]) => v).flat()]
      ];
  }
  class $ {
    constructor() {
      this._data = /* @__PURE__ */ new Map();
    }
    has(g, S, E) {
      var v;
      const b = (v = this._data.get(g)) === null || v === void 0 ? void 0 : v.get(S);
      return b === void 0 ? !1 : E ? !0 : E === b;
    }
    add(g, S, E) {
      const v = this._data.get(g);
      v === void 0 ? this._data.set(g, /* @__PURE__ */ new Map([[S, E]])) : v.set(S, E);
    }
  }
  class G {
    constructor() {
      this._orderedPairSet = new $();
    }
    has(g, S, E) {
      return g < S ? this._orderedPairSet.has(g, S, E) : this._orderedPairSet.has(S, g, E);
    }
    add(g, S, E) {
      g < S ? this._orderedPairSet.add(g, S, E) : this._orderedPairSet.add(S, g, E);
    }
  }
  return Pt;
}
var wt = {}, Aa;
function po() {
  if (Aa) return wt;
  Aa = 1, Object.defineProperty(wt, "__esModule", {
    value: !0
  }), wt.PossibleFragmentSpreadsRule = r;
  var e = /* @__PURE__ */ de(), n = /* @__PURE__ */ ne(), s = /* @__PURE__ */ oe(), i = /* @__PURE__ */ Dr(), t = /* @__PURE__ */ Xe();
  function r(c) {
    return {
      InlineFragment(u) {
        const f = c.getType(), y = c.getParentType();
        if ((0, s.isCompositeType)(f) && (0, s.isCompositeType)(y) && !(0, i.doTypesOverlap)(
          c.getSchema(),
          f,
          y
        )) {
          const o = (0, e.inspect)(y), p = (0, e.inspect)(f);
          c.reportError(
            new n.GraphQLError(
              `Fragment cannot be spread here as objects of type "${o}" can never be of type "${p}".`,
              {
                nodes: u
              }
            )
          );
        }
      },
      FragmentSpread(u) {
        const f = u.name.value, y = a(c, f), o = c.getParentType();
        if (y && o && !(0, i.doTypesOverlap)(
          c.getSchema(),
          y,
          o
        )) {
          const p = (0, e.inspect)(o), h = (0, e.inspect)(y);
          c.reportError(
            new n.GraphQLError(
              `Fragment "${f}" cannot be spread here as objects of type "${p}" can never be of type "${h}".`,
              {
                nodes: u
              }
            )
          );
        }
      }
    };
  }
  function a(c, u) {
    const f = c.getFragment(u);
    if (f) {
      const y = (0, t.typeFromAST)(
        c.getSchema(),
        f.typeCondition
      );
      if ((0, s.isCompositeType)(y))
        return y;
    }
  }
  return wt;
}
var kt = {}, ja;
function fo() {
  if (ja) return kt;
  ja = 1, Object.defineProperty(kt, "__esModule", {
    value: !0
  }), kt.PossibleTypeExtensionsRule = u;
  var e = /* @__PURE__ */ sn(), n = /* @__PURE__ */ de(), s = /* @__PURE__ */ Se(), i = /* @__PURE__ */ un(), t = /* @__PURE__ */ ne(), r = /* @__PURE__ */ se(), a = /* @__PURE__ */ In(), c = /* @__PURE__ */ oe();
  function u(p) {
    const h = p.getSchema(), l = /* @__PURE__ */ Object.create(null);
    for (const m of p.getDocument().definitions)
      (0, a.isTypeDefinitionNode)(m) && (l[m.name.value] = m);
    return {
      ScalarTypeExtension: d,
      ObjectTypeExtension: d,
      InterfaceTypeExtension: d,
      UnionTypeExtension: d,
      EnumTypeExtension: d,
      InputObjectTypeExtension: d
    };
    function d(m) {
      const T = m.name.value, O = l[T], R = h?.getType(T);
      let D;
      if (O ? D = f[O.kind] : R && (D = y(R)), D) {
        if (D !== m.kind) {
          const _ = o(m.kind);
          p.reportError(
            new t.GraphQLError(
              `Cannot extend non-${_} type "${T}".`,
              {
                nodes: O ? [O, m] : m
              }
            )
          );
        }
      } else {
        const _ = Object.keys({
          ...l,
          ...h?.getTypeMap()
        }), w = (0, i.suggestionList)(
          T,
          _
        );
        p.reportError(
          new t.GraphQLError(
            `Cannot extend type "${T}" because it is not defined.` + (0, e.didYouMean)(w),
            {
              nodes: m.name
            }
          )
        );
      }
    }
  }
  const f = {
    [r.Kind.SCALAR_TYPE_DEFINITION]: r.Kind.SCALAR_TYPE_EXTENSION,
    [r.Kind.OBJECT_TYPE_DEFINITION]: r.Kind.OBJECT_TYPE_EXTENSION,
    [r.Kind.INTERFACE_TYPE_DEFINITION]: r.Kind.INTERFACE_TYPE_EXTENSION,
    [r.Kind.UNION_TYPE_DEFINITION]: r.Kind.UNION_TYPE_EXTENSION,
    [r.Kind.ENUM_TYPE_DEFINITION]: r.Kind.ENUM_TYPE_EXTENSION,
    [r.Kind.INPUT_OBJECT_TYPE_DEFINITION]: r.Kind.INPUT_OBJECT_TYPE_EXTENSION
  };
  function y(p) {
    if ((0, c.isScalarType)(p))
      return r.Kind.SCALAR_TYPE_EXTENSION;
    if ((0, c.isObjectType)(p))
      return r.Kind.OBJECT_TYPE_EXTENSION;
    if ((0, c.isInterfaceType)(p))
      return r.Kind.INTERFACE_TYPE_EXTENSION;
    if ((0, c.isUnionType)(p))
      return r.Kind.UNION_TYPE_EXTENSION;
    if ((0, c.isEnumType)(p))
      return r.Kind.ENUM_TYPE_EXTENSION;
    if ((0, c.isInputObjectType)(p))
      return r.Kind.INPUT_OBJECT_TYPE_EXTENSION;
    (0, s.invariant)(
      !1,
      "Unexpected type: " + (0, n.inspect)(p)
    );
  }
  function o(p) {
    switch (p) {
      case r.Kind.SCALAR_TYPE_EXTENSION:
        return "scalar";
      case r.Kind.OBJECT_TYPE_EXTENSION:
        return "object";
      case r.Kind.INTERFACE_TYPE_EXTENSION:
        return "interface";
      case r.Kind.UNION_TYPE_EXTENSION:
        return "union";
      case r.Kind.ENUM_TYPE_EXTENSION:
        return "enum";
      case r.Kind.INPUT_OBJECT_TYPE_EXTENSION:
        return "input object";
      // Not reachable. All possible types have been considered
      /* c8 ignore next */
      default:
        (0, s.invariant)(
          !1,
          "Unexpected kind: " + (0, n.inspect)(p)
        );
    }
  }
  return kt;
}
var Fn = {}, Pa;
function mo() {
  if (Pa) return Fn;
  Pa = 1, Object.defineProperty(Fn, "__esModule", {
    value: !0
  }), Fn.ProvidedRequiredArgumentsOnDirectivesRule = u, Fn.ProvidedRequiredArgumentsRule = c;
  var e = /* @__PURE__ */ de(), n = /* @__PURE__ */ on(), s = /* @__PURE__ */ ne(), i = /* @__PURE__ */ se(), t = /* @__PURE__ */ we(), r = /* @__PURE__ */ oe(), a = /* @__PURE__ */ Pe();
  function c(y) {
    return {
      // eslint-disable-next-line new-cap
      ...u(y),
      Field: {
        // Validate on leave to allow for deeper errors to appear first.
        leave(o) {
          var p;
          const h = y.getFieldDef();
          if (!h)
            return !1;
          const l = new Set(
            // FIXME: https://github.com/graphql/graphql-js/issues/2203
            /* c8 ignore next */
            (p = o.arguments) === null || p === void 0 ? void 0 : p.map((d) => d.name.value)
          );
          for (const d of h.args)
            if (!l.has(d.name) && (0, r.isRequiredArgument)(d)) {
              const m = (0, e.inspect)(d.type);
              y.reportError(
                new s.GraphQLError(
                  `Field "${h.name}" argument "${d.name}" of type "${m}" is required, but it was not provided.`,
                  {
                    nodes: o
                  }
                )
              );
            }
        }
      }
    };
  }
  function u(y) {
    var o;
    const p = /* @__PURE__ */ Object.create(null), h = y.getSchema(), l = (o = h?.getDirectives()) !== null && o !== void 0 ? o : a.specifiedDirectives;
    for (const T of l)
      p[T.name] = (0, n.keyMap)(
        T.args.filter(r.isRequiredArgument),
        (O) => O.name
      );
    const d = y.getDocument().definitions;
    for (const T of d)
      if (T.kind === i.Kind.DIRECTIVE_DEFINITION) {
        var m;
        const O = (m = T.arguments) !== null && m !== void 0 ? m : [];
        p[T.name.value] = (0, n.keyMap)(
          O.filter(f),
          (R) => R.name.value
        );
      }
    return {
      Directive: {
        // Validate on leave to allow for deeper errors to appear first.
        leave(T) {
          const O = T.name.value, R = p[O];
          if (R) {
            var D;
            const _ = (D = T.arguments) !== null && D !== void 0 ? D : [], w = new Set(_.map(($) => $.name.value));
            for (const [$, G] of Object.entries(R))
              if (!w.has($)) {
                const N = (0, r.isType)(G.type) ? (0, e.inspect)(G.type) : (0, t.print)(G.type);
                y.reportError(
                  new s.GraphQLError(
                    `Directive "@${O}" argument "${$}" of type "${N}" is required, but it was not provided.`,
                    {
                      nodes: T
                    }
                  )
                );
              }
          }
        }
      }
    };
  }
  function f(y) {
    return y.type.kind === i.Kind.NON_NULL_TYPE && y.defaultValue == null;
  }
  return Fn;
}
var Vt = {}, Fa;
function yo() {
  if (Fa) return Vt;
  Fa = 1, Object.defineProperty(Vt, "__esModule", {
    value: !0
  }), Vt.ScalarLeafsRule = i;
  var e = /* @__PURE__ */ de(), n = /* @__PURE__ */ ne(), s = /* @__PURE__ */ oe();
  function i(t) {
    return {
      Field(r) {
        const a = t.getType(), c = r.selectionSet;
        if (a)
          if ((0, s.isLeafType)((0, s.getNamedType)(a))) {
            if (c) {
              const u = r.name.value, f = (0, e.inspect)(a);
              t.reportError(
                new n.GraphQLError(
                  `Field "${u}" must not have a selection since type "${f}" has no subfields.`,
                  {
                    nodes: c
                  }
                )
              );
            }
          } else if (c) {
            if (c.selections.length === 0) {
              const u = r.name.value, f = (0, e.inspect)(a);
              t.reportError(
                new n.GraphQLError(
                  `Field "${u}" of type "${f}" must have at least one field selected.`,
                  {
                    nodes: r
                  }
                )
              );
            }
          } else {
            const u = r.name.value, f = (0, e.inspect)(a);
            t.reportError(
              new n.GraphQLError(
                `Field "${u}" of type "${f}" must have a selection of subfields. Did you mean "${u} { ... }"?`,
                {
                  nodes: r
                }
              )
            );
          }
      }
    };
  }
  return Vt;
}
var Gt = {}, wn = {}, bn = {}, Mt = {}, wa;
function ho() {
  if (wa) return Mt;
  wa = 1, Object.defineProperty(Mt, "__esModule", {
    value: !0
  }), Mt.printPathArray = e;
  function e(n) {
    return n.map(
      (s) => typeof s == "number" ? "[" + s.toString() + "]" : "." + s
    ).join("");
  }
  return Mt;
}
var $t = {}, kn = {}, ka;
function Pr() {
  if (ka) return kn;
  ka = 1, Object.defineProperty(kn, "__esModule", {
    value: !0
  }), kn.addPath = e, kn.pathToArray = n;
  function e(s, i, t) {
    return {
      prev: s,
      key: i,
      typename: t
    };
  }
  function n(s) {
    const i = [];
    let t = s;
    for (; t; )
      i.push(t.key), t = t.prev;
    return i.reverse();
  }
  return kn;
}
var Va;
function vo() {
  if (Va) return $t;
  Va = 1, Object.defineProperty($t, "__esModule", {
    value: !0
  }), $t.coerceInputValue = y;
  var e = /* @__PURE__ */ sn(), n = /* @__PURE__ */ de(), s = /* @__PURE__ */ Se(), i = /* @__PURE__ */ ai(), t = /* @__PURE__ */ Ye(), r = /* @__PURE__ */ Pr(), a = /* @__PURE__ */ ho(), c = /* @__PURE__ */ un(), u = /* @__PURE__ */ ne(), f = /* @__PURE__ */ oe();
  function y(h, l, d = o) {
    return p(h, l, d, void 0);
  }
  function o(h, l, d) {
    let m = "Invalid value " + (0, n.inspect)(l);
    throw h.length > 0 && (m += ` at "value${(0, a.printPathArray)(h)}"`), d.message = m + ": " + d.message, d;
  }
  function p(h, l, d, m) {
    if ((0, f.isNonNullType)(l)) {
      if (h != null)
        return p(h, l.ofType, d, m);
      d(
        (0, r.pathToArray)(m),
        h,
        new u.GraphQLError(
          `Expected non-nullable type "${(0, n.inspect)(
            l
          )}" not to be null.`
        )
      );
      return;
    }
    if (h == null)
      return null;
    if ((0, f.isListType)(l)) {
      const T = l.ofType;
      return (0, i.isIterableObject)(h) ? Array.from(h, (O, R) => {
        const D = (0, r.addPath)(m, R, void 0);
        return p(O, T, d, D);
      }) : [p(h, T, d, m)];
    }
    if ((0, f.isInputObjectType)(l)) {
      if (!(0, t.isObjectLike)(h) || Array.isArray(h)) {
        d(
          (0, r.pathToArray)(m),
          h,
          new u.GraphQLError(
            `Expected type "${l.name}" to be an object.`
          )
        );
        return;
      }
      const T = {}, O = l.getFields();
      for (const R of Object.values(O)) {
        const D = h[R.name];
        if (D === void 0) {
          if (R.defaultValue !== void 0)
            T[R.name] = R.defaultValue;
          else if ((0, f.isNonNullType)(R.type)) {
            const _ = (0, n.inspect)(R.type);
            d(
              (0, r.pathToArray)(m),
              h,
              new u.GraphQLError(
                `Field "${R.name}" of required type "${_}" was not provided.`
              )
            );
          }
          continue;
        }
        T[R.name] = p(
          D,
          R.type,
          d,
          (0, r.addPath)(m, R.name, l.name)
        );
      }
      for (const R of Object.keys(h))
        if (!O[R]) {
          const D = (0, c.suggestionList)(
            R,
            Object.keys(l.getFields())
          );
          d(
            (0, r.pathToArray)(m),
            h,
            new u.GraphQLError(
              `Field "${R}" is not defined by type "${l.name}".` + (0, e.didYouMean)(D)
            )
          );
        }
      if (l.isOneOf) {
        const R = Object.keys(T);
        R.length !== 1 && d(
          (0, r.pathToArray)(m),
          h,
          new u.GraphQLError(
            `Exactly one key must be specified for OneOf type "${l.name}".`
          )
        );
        const D = R[0], _ = T[D];
        _ === null && d(
          (0, r.pathToArray)(m).concat(D),
          _,
          new u.GraphQLError(`Field "${D}" must be non-null.`)
        );
      }
      return T;
    }
    if ((0, f.isLeafType)(l)) {
      let T;
      try {
        T = l.parseValue(h);
      } catch (O) {
        O instanceof u.GraphQLError ? d((0, r.pathToArray)(m), h, O) : d(
          (0, r.pathToArray)(m),
          h,
          new u.GraphQLError(
            `Expected type "${l.name}". ` + O.message,
            {
              originalError: O
            }
          )
        );
        return;
      }
      return T === void 0 && d(
        (0, r.pathToArray)(m),
        h,
        new u.GraphQLError(`Expected type "${l.name}".`)
      ), T;
    }
    (0, s.invariant)(
      !1,
      "Unexpected input type: " + (0, n.inspect)(l)
    );
  }
  return $t;
}
var Ct = {}, Ga;
function Fr() {
  if (Ga) return Ct;
  Ga = 1, Object.defineProperty(Ct, "__esModule", {
    value: !0
  }), Ct.valueFromAST = r;
  var e = /* @__PURE__ */ de(), n = /* @__PURE__ */ Se(), s = /* @__PURE__ */ on(), i = /* @__PURE__ */ se(), t = /* @__PURE__ */ oe();
  function r(c, u, f) {
    if (c) {
      if (c.kind === i.Kind.VARIABLE) {
        const y = c.name.value;
        if (f == null || f[y] === void 0)
          return;
        const o = f[y];
        return o === null && (0, t.isNonNullType)(u) ? void 0 : o;
      }
      if ((0, t.isNonNullType)(u))
        return c.kind === i.Kind.NULL ? void 0 : r(c, u.ofType, f);
      if (c.kind === i.Kind.NULL)
        return null;
      if ((0, t.isListType)(u)) {
        const y = u.ofType;
        if (c.kind === i.Kind.LIST) {
          const p = [];
          for (const h of c.values)
            if (a(h, f)) {
              if ((0, t.isNonNullType)(y))
                return;
              p.push(null);
            } else {
              const l = r(h, y, f);
              if (l === void 0)
                return;
              p.push(l);
            }
          return p;
        }
        const o = r(c, y, f);
        return o === void 0 ? void 0 : [o];
      }
      if ((0, t.isInputObjectType)(u)) {
        if (c.kind !== i.Kind.OBJECT)
          return;
        const y = /* @__PURE__ */ Object.create(null), o = (0, s.keyMap)(
          c.fields,
          (p) => p.name.value
        );
        for (const p of Object.values(u.getFields())) {
          const h = o[p.name];
          if (!h || a(h.value, f)) {
            if (p.defaultValue !== void 0)
              y[p.name] = p.defaultValue;
            else if ((0, t.isNonNullType)(p.type))
              return;
            continue;
          }
          const l = r(h.value, p.type, f);
          if (l === void 0)
            return;
          y[p.name] = l;
        }
        if (u.isOneOf) {
          const p = Object.keys(y);
          if (p.length !== 1 || y[p[0]] === null)
            return;
        }
        return y;
      }
      if ((0, t.isLeafType)(u)) {
        let y;
        try {
          y = u.parseLiteral(c, f);
        } catch {
          return;
        }
        return y === void 0 ? void 0 : y;
      }
      (0, n.invariant)(
        !1,
        "Unexpected input type: " + (0, e.inspect)(u)
      );
    }
  }
  function a(c, u) {
    return c.kind === i.Kind.VARIABLE && (u == null || u[c.name.value] === void 0);
  }
  return Ct;
}
var Ma;
function Yn() {
  if (Ma) return bn;
  Ma = 1, Object.defineProperty(bn, "__esModule", {
    value: !0
  }), bn.getArgumentValues = p, bn.getDirectiveValues = h, bn.getVariableValues = y;
  var e = /* @__PURE__ */ de(), n = /* @__PURE__ */ on(), s = /* @__PURE__ */ ho(), i = /* @__PURE__ */ ne(), t = /* @__PURE__ */ se(), r = /* @__PURE__ */ we(), a = /* @__PURE__ */ oe(), c = /* @__PURE__ */ vo(), u = /* @__PURE__ */ Xe(), f = /* @__PURE__ */ Fr();
  function y(d, m, T, O) {
    const R = [], D = O?.maxErrors;
    try {
      const _ = o(
        d,
        m,
        T,
        (w) => {
          if (D != null && R.length >= D)
            throw new i.GraphQLError(
              "Too many errors processing variables, error limit reached. Execution aborted."
            );
          R.push(w);
        }
      );
      if (R.length === 0)
        return {
          coerced: _
        };
    } catch (_) {
      R.push(_);
    }
    return {
      errors: R
    };
  }
  function o(d, m, T, O) {
    const R = {};
    for (const D of m) {
      const _ = D.variable.name.value, w = (0, u.typeFromAST)(d, D.type);
      if (!(0, a.isInputType)(w)) {
        const G = (0, r.print)(D.type);
        O(
          new i.GraphQLError(
            `Variable "$${_}" expected value of type "${G}" which cannot be used as an input type.`,
            {
              nodes: D.type
            }
          )
        );
        continue;
      }
      if (!l(T, _)) {
        if (D.defaultValue)
          R[_] = (0, f.valueFromAST)(
            D.defaultValue,
            w
          );
        else if ((0, a.isNonNullType)(w)) {
          const G = (0, e.inspect)(w);
          O(
            new i.GraphQLError(
              `Variable "$${_}" of required type "${G}" was not provided.`,
              {
                nodes: D
              }
            )
          );
        }
        continue;
      }
      const $ = T[_];
      if ($ === null && (0, a.isNonNullType)(w)) {
        const G = (0, e.inspect)(w);
        O(
          new i.GraphQLError(
            `Variable "$${_}" of non-null type "${G}" must not be null.`,
            {
              nodes: D
            }
          )
        );
        continue;
      }
      R[_] = (0, c.coerceInputValue)(
        $,
        w,
        (G, N, g) => {
          let S = `Variable "$${_}" got invalid value ` + (0, e.inspect)(N);
          G.length > 0 && (S += ` at "${_}${(0, s.printPathArray)(
            G
          )}"`), O(
            new i.GraphQLError(S + "; " + g.message, {
              nodes: D,
              originalError: g
            })
          );
        }
      );
    }
    return R;
  }
  function p(d, m, T) {
    var O;
    const R = {}, D = (O = m.arguments) !== null && O !== void 0 ? O : [], _ = (0, n.keyMap)(
      D,
      (w) => w.name.value
    );
    for (const w of d.args) {
      const $ = w.name, G = w.type, N = _[$];
      if (!N) {
        if (w.defaultValue !== void 0)
          R[$] = w.defaultValue;
        else if ((0, a.isNonNullType)(G))
          throw new i.GraphQLError(
            `Argument "${$}" of required type "${(0, e.inspect)(
              G
            )}" was not provided.`,
            {
              nodes: m
            }
          );
        continue;
      }
      const g = N.value;
      let S = g.kind === t.Kind.NULL;
      if (g.kind === t.Kind.VARIABLE) {
        const v = g.name.value;
        if (T == null || !l(T, v)) {
          if (w.defaultValue !== void 0)
            R[$] = w.defaultValue;
          else if ((0, a.isNonNullType)(G))
            throw new i.GraphQLError(
              `Argument "${$}" of required type "${(0, e.inspect)(
                G
              )}" was provided the variable "$${v}" which was not provided a runtime value.`,
              {
                nodes: g
              }
            );
          continue;
        }
        S = T[v] == null;
      }
      if (S && (0, a.isNonNullType)(G))
        throw new i.GraphQLError(
          `Argument "${$}" of non-null type "${(0, e.inspect)(
            G
          )}" must not be null.`,
          {
            nodes: g
          }
        );
      const E = (0, f.valueFromAST)(
        g,
        G,
        T
      );
      if (E === void 0)
        throw new i.GraphQLError(
          `Argument "${$}" has invalid value ${(0, r.print)(
            g
          )}.`,
          {
            nodes: g
          }
        );
      R[$] = E;
    }
    return R;
  }
  function h(d, m, T) {
    var O;
    const R = (O = m.directives) === null || O === void 0 ? void 0 : O.find(
      (D) => D.name.value === d.name
    );
    if (R)
      return p(d, R, T);
  }
  function l(d, m) {
    return Object.prototype.hasOwnProperty.call(d, m);
  }
  return bn;
}
var $a;
function oi() {
  if ($a) return wn;
  $a = 1, Object.defineProperty(wn, "__esModule", {
    value: !0
  }), wn.collectFields = r, wn.collectSubfields = a;
  var e = /* @__PURE__ */ se(), n = /* @__PURE__ */ oe(), s = /* @__PURE__ */ Pe(), i = /* @__PURE__ */ Xe(), t = /* @__PURE__ */ Yn();
  function r(o, p, h, l, d) {
    const m = /* @__PURE__ */ new Map();
    return c(
      o,
      p,
      h,
      l,
      d,
      m,
      /* @__PURE__ */ new Set()
    ), m;
  }
  function a(o, p, h, l, d) {
    const m = /* @__PURE__ */ new Map(), T = /* @__PURE__ */ new Set();
    for (const O of d)
      O.selectionSet && c(
        o,
        p,
        h,
        l,
        O.selectionSet,
        m,
        T
      );
    return m;
  }
  function c(o, p, h, l, d, m, T) {
    for (const O of d.selections)
      switch (O.kind) {
        case e.Kind.FIELD: {
          if (!u(h, O))
            continue;
          const R = y(O), D = m.get(R);
          D !== void 0 ? D.push(O) : m.set(R, [O]);
          break;
        }
        case e.Kind.INLINE_FRAGMENT: {
          if (!u(h, O) || !f(o, O, l))
            continue;
          c(
            o,
            p,
            h,
            l,
            O.selectionSet,
            m,
            T
          );
          break;
        }
        case e.Kind.FRAGMENT_SPREAD: {
          const R = O.name.value;
          if (T.has(R) || !u(h, O))
            continue;
          T.add(R);
          const D = p[R];
          if (!D || !f(o, D, l))
            continue;
          c(
            o,
            p,
            h,
            l,
            D.selectionSet,
            m,
            T
          );
          break;
        }
      }
  }
  function u(o, p) {
    const h = (0, t.getDirectiveValues)(
      s.GraphQLSkipDirective,
      p,
      o
    );
    if (h?.if === !0)
      return !1;
    const l = (0, t.getDirectiveValues)(
      s.GraphQLIncludeDirective,
      p,
      o
    );
    return l?.if !== !1;
  }
  function f(o, p, h) {
    const l = p.typeCondition;
    if (!l)
      return !0;
    const d = (0, i.typeFromAST)(
      o,
      l
    );
    return d === h ? !0 : (0, n.isAbstractType)(d) ? o.isSubType(d, h) : !1;
  }
  function y(o) {
    return o.alias ? o.alias.value : o.name.value;
  }
  return wn;
}
var Ca;
function To() {
  if (Ca) return Gt;
  Ca = 1, Object.defineProperty(Gt, "__esModule", {
    value: !0
  }), Gt.SingleFieldSubscriptionsRule = i;
  var e = /* @__PURE__ */ ne(), n = /* @__PURE__ */ se(), s = /* @__PURE__ */ oi();
  function i(t) {
    return {
      OperationDefinition(r) {
        if (r.operation === "subscription") {
          const a = t.getSchema(), c = a.getSubscriptionType();
          if (c) {
            const u = r.name ? r.name.value : null, f = /* @__PURE__ */ Object.create(null), y = t.getDocument(), o = /* @__PURE__ */ Object.create(null);
            for (const h of y.definitions)
              h.kind === n.Kind.FRAGMENT_DEFINITION && (o[h.name.value] = h);
            const p = (0, s.collectFields)(
              a,
              o,
              f,
              c,
              r.selectionSet
            );
            if (p.size > 1) {
              const d = [...p.values()].slice(1).flat();
              t.reportError(
                new e.GraphQLError(
                  u != null ? `Subscription "${u}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.",
                  {
                    nodes: d
                  }
                )
              );
            }
            for (const h of p.values())
              h[0].name.value.startsWith("__") && t.reportError(
                new e.GraphQLError(
                  u != null ? `Subscription "${u}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.",
                  {
                    nodes: h
                  }
                )
              );
          }
        }
      }
    };
  }
  return Gt;
}
var Ut = {}, Qt = {}, Ua;
function ui() {
  if (Ua) return Qt;
  Ua = 1, Object.defineProperty(Qt, "__esModule", {
    value: !0
  }), Qt.groupBy = e;
  function e(n, s) {
    const i = /* @__PURE__ */ new Map();
    for (const t of n) {
      const r = s(t), a = i.get(r);
      a === void 0 ? i.set(r, [t]) : a.push(t);
    }
    return i;
  }
  return Qt;
}
var Qa;
function bo() {
  if (Qa) return Ut;
  Qa = 1, Object.defineProperty(Ut, "__esModule", {
    value: !0
  }), Ut.UniqueArgumentDefinitionNamesRule = s;
  var e = /* @__PURE__ */ ui(), n = /* @__PURE__ */ ne();
  function s(i) {
    return {
      DirectiveDefinition(a) {
        var c;
        const u = (c = a.arguments) !== null && c !== void 0 ? c : [];
        return r(`@${a.name.value}`, u);
      },
      InterfaceTypeDefinition: t,
      InterfaceTypeExtension: t,
      ObjectTypeDefinition: t,
      ObjectTypeExtension: t
    };
    function t(a) {
      var c;
      const u = a.name.value, f = (c = a.fields) !== null && c !== void 0 ? c : [];
      for (const o of f) {
        var y;
        const p = o.name.value, h = (y = o.arguments) !== null && y !== void 0 ? y : [];
        r(`${u}.${p}`, h);
      }
      return !1;
    }
    function r(a, c) {
      const u = (0, e.groupBy)(
        c,
        (f) => f.name.value
      );
      for (const [f, y] of u)
        y.length > 1 && i.reportError(
          new n.GraphQLError(
            `Argument "${a}(${f}:)" can only be defined once.`,
            {
              nodes: y.map((o) => o.name)
            }
          )
        );
      return !1;
    }
  }
  return Ut;
}
var qt = {}, qa;
function go() {
  if (qa) return qt;
  qa = 1, Object.defineProperty(qt, "__esModule", {
    value: !0
  }), qt.UniqueArgumentNamesRule = s;
  var e = /* @__PURE__ */ ui(), n = /* @__PURE__ */ ne();
  function s(i) {
    return {
      Field: t,
      Directive: t
    };
    function t(r) {
      var a;
      const c = (a = r.arguments) !== null && a !== void 0 ? a : [], u = (0, e.groupBy)(
        c,
        (f) => f.name.value
      );
      for (const [f, y] of u)
        y.length > 1 && i.reportError(
          new n.GraphQLError(
            `There can be only one argument named "${f}".`,
            {
              nodes: y.map((o) => o.name)
            }
          )
        );
    }
  }
  return qt;
}
var Kt = {}, Ka;
function Eo() {
  if (Ka) return Kt;
  Ka = 1, Object.defineProperty(Kt, "__esModule", {
    value: !0
  }), Kt.UniqueDirectiveNamesRule = n;
  var e = /* @__PURE__ */ ne();
  function n(s) {
    const i = /* @__PURE__ */ Object.create(null), t = s.getSchema();
    return {
      DirectiveDefinition(r) {
        const a = r.name.value;
        if (t != null && t.getDirective(a)) {
          s.reportError(
            new e.GraphQLError(
              `Directive "@${a}" already exists in the schema. It cannot be redefined.`,
              {
                nodes: r.name
              }
            )
          );
          return;
        }
        return i[a] ? s.reportError(
          new e.GraphQLError(
            `There can be only one directive named "@${a}".`,
            {
              nodes: [i[a], r.name]
            }
          )
        ) : i[a] = r.name, !1;
      }
    };
  }
  return Kt;
}
var Bt = {}, Ba;
function No() {
  if (Ba) return Bt;
  Ba = 1, Object.defineProperty(Bt, "__esModule", {
    value: !0
  }), Bt.UniqueDirectivesPerLocationRule = t;
  var e = /* @__PURE__ */ ne(), n = /* @__PURE__ */ se(), s = /* @__PURE__ */ In(), i = /* @__PURE__ */ Pe();
  function t(r) {
    const a = /* @__PURE__ */ Object.create(null), c = r.getSchema(), u = c ? c.getDirectives() : i.specifiedDirectives;
    for (const p of u)
      a[p.name] = !p.isRepeatable;
    const f = r.getDocument().definitions;
    for (const p of f)
      p.kind === n.Kind.DIRECTIVE_DEFINITION && (a[p.name.value] = !p.repeatable);
    const y = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ Object.create(null);
    return {
      // Many different AST nodes may contain directives. Rather than listing
      // them all, just listen for entering any node, and check to see if it
      // defines any directives.
      enter(p) {
        if (!("directives" in p) || !p.directives)
          return;
        let h;
        if (p.kind === n.Kind.SCHEMA_DEFINITION || p.kind === n.Kind.SCHEMA_EXTENSION)
          h = y;
        else if ((0, s.isTypeDefinitionNode)(p) || (0, s.isTypeExtensionNode)(p)) {
          const l = p.name.value;
          h = o[l], h === void 0 && (o[l] = h = /* @__PURE__ */ Object.create(null));
        } else
          h = /* @__PURE__ */ Object.create(null);
        for (const l of p.directives) {
          const d = l.name.value;
          a[d] && (h[d] ? r.reportError(
            new e.GraphQLError(
              `The directive "@${d}" can only be used once at this location.`,
              {
                nodes: [h[d], l]
              }
            )
          ) : h[d] = l);
        }
      }
    };
  }
  return Bt;
}
var xt = {}, xa;
function Oo() {
  if (xa) return xt;
  xa = 1, Object.defineProperty(xt, "__esModule", {
    value: !0
  }), xt.UniqueEnumValueNamesRule = s;
  var e = /* @__PURE__ */ ne(), n = /* @__PURE__ */ oe();
  function s(i) {
    const t = i.getSchema(), r = t ? t.getTypeMap() : /* @__PURE__ */ Object.create(null), a = /* @__PURE__ */ Object.create(null);
    return {
      EnumTypeDefinition: c,
      EnumTypeExtension: c
    };
    function c(u) {
      var f;
      const y = u.name.value;
      a[y] || (a[y] = /* @__PURE__ */ Object.create(null));
      const o = (f = u.values) !== null && f !== void 0 ? f : [], p = a[y];
      for (const h of o) {
        const l = h.name.value, d = r[y];
        (0, n.isEnumType)(d) && d.getValue(l) ? i.reportError(
          new e.GraphQLError(
            `Enum value "${y}.${l}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: h.name
            }
          )
        ) : p[l] ? i.reportError(
          new e.GraphQLError(
            `Enum value "${y}.${l}" can only be defined once.`,
            {
              nodes: [p[l], h.name]
            }
          )
        ) : p[l] = h.name;
      }
      return !1;
    }
  }
  return xt;
}
var Yt = {}, Ya;
function _o() {
  if (Ya) return Yt;
  Ya = 1, Object.defineProperty(Yt, "__esModule", {
    value: !0
  }), Yt.UniqueFieldDefinitionNamesRule = s;
  var e = /* @__PURE__ */ ne(), n = /* @__PURE__ */ oe();
  function s(t) {
    const r = t.getSchema(), a = r ? r.getTypeMap() : /* @__PURE__ */ Object.create(null), c = /* @__PURE__ */ Object.create(null);
    return {
      InputObjectTypeDefinition: u,
      InputObjectTypeExtension: u,
      InterfaceTypeDefinition: u,
      InterfaceTypeExtension: u,
      ObjectTypeDefinition: u,
      ObjectTypeExtension: u
    };
    function u(f) {
      var y;
      const o = f.name.value;
      c[o] || (c[o] = /* @__PURE__ */ Object.create(null));
      const p = (y = f.fields) !== null && y !== void 0 ? y : [], h = c[o];
      for (const l of p) {
        const d = l.name.value;
        i(a[o], d) ? t.reportError(
          new e.GraphQLError(
            `Field "${o}.${d}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: l.name
            }
          )
        ) : h[d] ? t.reportError(
          new e.GraphQLError(
            `Field "${o}.${d}" can only be defined once.`,
            {
              nodes: [h[d], l.name]
            }
          )
        ) : h[d] = l.name;
      }
      return !1;
    }
  }
  function i(t, r) {
    return (0, n.isObjectType)(t) || (0, n.isInterfaceType)(t) || (0, n.isInputObjectType)(t) ? t.getFields()[r] != null : !1;
  }
  return Yt;
}
var Jt = {}, Ja;
function Io() {
  if (Ja) return Jt;
  Ja = 1, Object.defineProperty(Jt, "__esModule", {
    value: !0
  }), Jt.UniqueFragmentNamesRule = n;
  var e = /* @__PURE__ */ ne();
  function n(s) {
    const i = /* @__PURE__ */ Object.create(null);
    return {
      OperationDefinition: () => !1,
      FragmentDefinition(t) {
        const r = t.name.value;
        return i[r] ? s.reportError(
          new e.GraphQLError(
            `There can be only one fragment named "${r}".`,
            {
              nodes: [i[r], t.name]
            }
          )
        ) : i[r] = t.name, !1;
      }
    };
  }
  return Jt;
}
var zt = {}, za;
function Lo() {
  if (za) return zt;
  za = 1, Object.defineProperty(zt, "__esModule", {
    value: !0
  }), zt.UniqueInputFieldNamesRule = s;
  var e = /* @__PURE__ */ Se(), n = /* @__PURE__ */ ne();
  function s(i) {
    const t = [];
    let r = /* @__PURE__ */ Object.create(null);
    return {
      ObjectValue: {
        enter() {
          t.push(r), r = /* @__PURE__ */ Object.create(null);
        },
        leave() {
          const a = t.pop();
          a || (0, e.invariant)(!1), r = a;
        }
      },
      ObjectField(a) {
        const c = a.name.value;
        r[c] ? i.reportError(
          new n.GraphQLError(
            `There can be only one input field named "${c}".`,
            {
              nodes: [r[c], a.name]
            }
          )
        ) : r[c] = a.name;
      }
    };
  }
  return zt;
}
var Xt = {}, Xa;
function So() {
  if (Xa) return Xt;
  Xa = 1, Object.defineProperty(Xt, "__esModule", {
    value: !0
  }), Xt.UniqueOperationNamesRule = n;
  var e = /* @__PURE__ */ ne();
  function n(s) {
    const i = /* @__PURE__ */ Object.create(null);
    return {
      OperationDefinition(t) {
        const r = t.name;
        return r && (i[r.value] ? s.reportError(
          new e.GraphQLError(
            `There can be only one operation named "${r.value}".`,
            {
              nodes: [
                i[r.value],
                r
              ]
            }
          )
        ) : i[r.value] = r), !1;
      },
      FragmentDefinition: () => !1
    };
  }
  return Xt;
}
var Ht = {}, Ha;
function Ro() {
  if (Ha) return Ht;
  Ha = 1, Object.defineProperty(Ht, "__esModule", {
    value: !0
  }), Ht.UniqueOperationTypesRule = n;
  var e = /* @__PURE__ */ ne();
  function n(s) {
    const i = s.getSchema(), t = /* @__PURE__ */ Object.create(null), r = i ? {
      query: i.getQueryType(),
      mutation: i.getMutationType(),
      subscription: i.getSubscriptionType()
    } : {};
    return {
      SchemaDefinition: a,
      SchemaExtension: a
    };
    function a(c) {
      var u;
      const f = (u = c.operationTypes) !== null && u !== void 0 ? u : [];
      for (const y of f) {
        const o = y.operation, p = t[o];
        r[o] ? s.reportError(
          new e.GraphQLError(
            `Type for ${o} already defined in the schema. It cannot be redefined.`,
            {
              nodes: y
            }
          )
        ) : p ? s.reportError(
          new e.GraphQLError(
            `There can be only one ${o} type in schema.`,
            {
              nodes: [p, y]
            }
          )
        ) : t[o] = y;
      }
      return !1;
    }
  }
  return Ht;
}
var Wt = {}, Wa;
function Do() {
  if (Wa) return Wt;
  Wa = 1, Object.defineProperty(Wt, "__esModule", {
    value: !0
  }), Wt.UniqueTypeNamesRule = n;
  var e = /* @__PURE__ */ ne();
  function n(s) {
    const i = /* @__PURE__ */ Object.create(null), t = s.getSchema();
    return {
      ScalarTypeDefinition: r,
      ObjectTypeDefinition: r,
      InterfaceTypeDefinition: r,
      UnionTypeDefinition: r,
      EnumTypeDefinition: r,
      InputObjectTypeDefinition: r
    };
    function r(a) {
      const c = a.name.value;
      if (t != null && t.getType(c)) {
        s.reportError(
          new e.GraphQLError(
            `Type "${c}" already exists in the schema. It cannot also be defined in this type definition.`,
            {
              nodes: a.name
            }
          )
        );
        return;
      }
      return i[c] ? s.reportError(
        new e.GraphQLError(
          `There can be only one type named "${c}".`,
          {
            nodes: [i[c], a.name]
          }
        )
      ) : i[c] = a.name, !1;
    }
  }
  return Wt;
}
var Zt = {}, Za;
function Ao() {
  if (Za) return Zt;
  Za = 1, Object.defineProperty(Zt, "__esModule", {
    value: !0
  }), Zt.UniqueVariableNamesRule = s;
  var e = /* @__PURE__ */ ui(), n = /* @__PURE__ */ ne();
  function s(i) {
    return {
      OperationDefinition(t) {
        var r;
        const a = (r = t.variableDefinitions) !== null && r !== void 0 ? r : [], c = (0, e.groupBy)(
          a,
          (u) => u.variable.name.value
        );
        for (const [u, f] of c)
          f.length > 1 && i.reportError(
            new n.GraphQLError(
              `There can be only one variable named "$${u}".`,
              {
                nodes: f.map((y) => y.variable.name)
              }
            )
          );
      }
    };
  }
  return Zt;
}
var er = {}, es;
function jo() {
  if (es) return er;
  es = 1, Object.defineProperty(er, "__esModule", {
    value: !0
  }), er.ValuesOfCorrectTypeRule = u;
  var e = /* @__PURE__ */ sn(), n = /* @__PURE__ */ de(), s = /* @__PURE__ */ on(), i = /* @__PURE__ */ un(), t = /* @__PURE__ */ ne(), r = /* @__PURE__ */ se(), a = /* @__PURE__ */ we(), c = /* @__PURE__ */ oe();
  function u(o) {
    let p = {};
    return {
      OperationDefinition: {
        enter() {
          p = {};
        }
      },
      VariableDefinition(h) {
        p[h.variable.name.value] = h;
      },
      ListValue(h) {
        const l = (0, c.getNullableType)(
          o.getParentInputType()
        );
        if (!(0, c.isListType)(l))
          return f(o, h), !1;
      },
      ObjectValue(h) {
        const l = (0, c.getNamedType)(o.getInputType());
        if (!(0, c.isInputObjectType)(l))
          return f(o, h), !1;
        const d = (0, s.keyMap)(
          h.fields,
          (m) => m.name.value
        );
        for (const m of Object.values(l.getFields()))
          if (!d[m.name] && (0, c.isRequiredInputField)(m)) {
            const O = (0, n.inspect)(m.type);
            o.reportError(
              new t.GraphQLError(
                `Field "${l.name}.${m.name}" of required type "${O}" was not provided.`,
                {
                  nodes: h
                }
              )
            );
          }
        l.isOneOf && y(
          o,
          h,
          l,
          d,
          p
        );
      },
      ObjectField(h) {
        const l = (0, c.getNamedType)(
          o.getParentInputType()
        );
        if (!o.getInputType() && (0, c.isInputObjectType)(l)) {
          const m = (0, i.suggestionList)(
            h.name.value,
            Object.keys(l.getFields())
          );
          o.reportError(
            new t.GraphQLError(
              `Field "${h.name.value}" is not defined by type "${l.name}".` + (0, e.didYouMean)(m),
              {
                nodes: h
              }
            )
          );
        }
      },
      NullValue(h) {
        const l = o.getInputType();
        (0, c.isNonNullType)(l) && o.reportError(
          new t.GraphQLError(
            `Expected value of type "${(0, n.inspect)(
              l
            )}", found ${(0, a.print)(h)}.`,
            {
              nodes: h
            }
          )
        );
      },
      EnumValue: (h) => f(o, h),
      IntValue: (h) => f(o, h),
      FloatValue: (h) => f(o, h),
      StringValue: (h) => f(o, h),
      BooleanValue: (h) => f(o, h)
    };
  }
  function f(o, p) {
    const h = o.getInputType();
    if (!h)
      return;
    const l = (0, c.getNamedType)(h);
    if (!(0, c.isLeafType)(l)) {
      const d = (0, n.inspect)(h);
      o.reportError(
        new t.GraphQLError(
          `Expected value of type "${d}", found ${(0, a.print)(
            p
          )}.`,
          {
            nodes: p
          }
        )
      );
      return;
    }
    try {
      if (l.parseLiteral(
        p,
        void 0
        /* variables */
      ) === void 0) {
        const m = (0, n.inspect)(h);
        o.reportError(
          new t.GraphQLError(
            `Expected value of type "${m}", found ${(0, a.print)(
              p
            )}.`,
            {
              nodes: p
            }
          )
        );
      }
    } catch (d) {
      const m = (0, n.inspect)(h);
      d instanceof t.GraphQLError ? o.reportError(d) : o.reportError(
        new t.GraphQLError(
          `Expected value of type "${m}", found ${(0, a.print)(
            p
          )}; ` + d.message,
          {
            nodes: p,
            originalError: d
          }
        )
      );
    }
  }
  function y(o, p, h, l, d) {
    var m;
    const T = Object.keys(l);
    if (T.length !== 1) {
      o.reportError(
        new t.GraphQLError(
          `OneOf Input Object "${h.name}" must specify exactly one key.`,
          {
            nodes: [p]
          }
        )
      );
      return;
    }
    const R = (m = l[T[0]]) === null || m === void 0 ? void 0 : m.value, D = !R || R.kind === r.Kind.NULL, _ = R?.kind === r.Kind.VARIABLE;
    if (D) {
      o.reportError(
        new t.GraphQLError(
          `Field "${h.name}.${T[0]}" must be non-null.`,
          {
            nodes: [p]
          }
        )
      );
      return;
    }
    if (_) {
      const w = R.name.value;
      d[w].type.kind !== r.Kind.NON_NULL_TYPE && o.reportError(
        new t.GraphQLError(
          `Variable "${w}" must be non-nullable to be used for OneOf Input Object "${h.name}".`,
          {
            nodes: [p]
          }
        )
      );
    }
  }
  return er;
}
var nr = {}, ns;
function Po() {
  if (ns) return nr;
  ns = 1, Object.defineProperty(nr, "__esModule", {
    value: !0
  }), nr.VariablesAreInputTypesRule = t;
  var e = /* @__PURE__ */ ne(), n = /* @__PURE__ */ we(), s = /* @__PURE__ */ oe(), i = /* @__PURE__ */ Xe();
  function t(r) {
    return {
      VariableDefinition(a) {
        const c = (0, i.typeFromAST)(
          r.getSchema(),
          a.type
        );
        if (c !== void 0 && !(0, s.isInputType)(c)) {
          const u = a.variable.name.value, f = (0, n.print)(a.type);
          r.reportError(
            new e.GraphQLError(
              `Variable "$${u}" cannot be non-input type "${f}".`,
              {
                nodes: a.type
              }
            )
          );
        }
      }
    };
  }
  return nr;
}
var tr = {}, ts;
function Fo() {
  if (ts) return tr;
  ts = 1, Object.defineProperty(tr, "__esModule", {
    value: !0
  }), tr.VariablesInAllowedPositionRule = a;
  var e = /* @__PURE__ */ de(), n = /* @__PURE__ */ ne(), s = /* @__PURE__ */ se(), i = /* @__PURE__ */ oe(), t = /* @__PURE__ */ Dr(), r = /* @__PURE__ */ Xe();
  function a(u) {
    let f = /* @__PURE__ */ Object.create(null);
    return {
      OperationDefinition: {
        enter() {
          f = /* @__PURE__ */ Object.create(null);
        },
        leave(y) {
          const o = u.getRecursiveVariableUsages(y);
          for (const { node: p, type: h, defaultValue: l, parentType: d } of o) {
            const m = p.name.value, T = f[m];
            if (T && h) {
              const O = u.getSchema(), R = (0, r.typeFromAST)(O, T.type);
              if (R && !c(
                O,
                R,
                T.defaultValue,
                h,
                l
              )) {
                const D = (0, e.inspect)(R), _ = (0, e.inspect)(h);
                u.reportError(
                  new n.GraphQLError(
                    `Variable "$${m}" of type "${D}" used in position expecting type "${_}".`,
                    {
                      nodes: [T, p]
                    }
                  )
                );
              }
              (0, i.isInputObjectType)(d) && d.isOneOf && (0, i.isNullableType)(R) && u.reportError(
                new n.GraphQLError(
                  `Variable "$${m}" is of type "${R}" but must be non-nullable to be used for OneOf Input Object "${d}".`,
                  {
                    nodes: [T, p]
                  }
                )
              );
            }
          }
        }
      },
      VariableDefinition(y) {
        f[y.variable.name.value] = y;
      }
    };
  }
  function c(u, f, y, o, p) {
    if ((0, i.isNonNullType)(o) && !(0, i.isNonNullType)(f)) {
      if (!(y != null && y.kind !== s.Kind.NULL) && !(p !== void 0))
        return !1;
      const d = o.ofType;
      return (0, t.isTypeSubTypeOf)(
        u,
        f,
        d
      );
    }
    return (0, t.isTypeSubTypeOf)(u, f, o);
  }
  return tr;
}
var rs;
function wo() {
  if (rs) return Ke;
  rs = 1, Object.defineProperty(Ke, "__esModule", {
    value: !0
  }), Ke.specifiedSDLRules = Ke.specifiedRules = Ke.recommendedRules = void 0;
  var e = /* @__PURE__ */ zs(), n = /* @__PURE__ */ Xs(), s = /* @__PURE__ */ Hs(), i = /* @__PURE__ */ Ws(), t = /* @__PURE__ */ Zs(), r = /* @__PURE__ */ eo(), a = /* @__PURE__ */ no(), c = /* @__PURE__ */ to(), u = /* @__PURE__ */ ro(), f = /* @__PURE__ */ io(), y = /* @__PURE__ */ ao(), o = /* @__PURE__ */ so(), p = /* @__PURE__ */ oo(), h = /* @__PURE__ */ uo(), l = /* @__PURE__ */ lo(), d = /* @__PURE__ */ po(), m = /* @__PURE__ */ fo(), T = /* @__PURE__ */ mo(), O = /* @__PURE__ */ yo(), R = /* @__PURE__ */ To(), D = /* @__PURE__ */ bo(), _ = /* @__PURE__ */ go(), w = /* @__PURE__ */ Eo(), $ = /* @__PURE__ */ No(), G = /* @__PURE__ */ Oo(), N = /* @__PURE__ */ _o(), g = /* @__PURE__ */ Io(), S = /* @__PURE__ */ Lo(), E = /* @__PURE__ */ So(), v = /* @__PURE__ */ Ro(), b = /* @__PURE__ */ Do(), I = /* @__PURE__ */ Ao(), L = /* @__PURE__ */ jo(), j = /* @__PURE__ */ Po(), V = /* @__PURE__ */ Fo();
  const U = Object.freeze([
    f.MaxIntrospectionDepthRule
  ]);
  Ke.recommendedRules = U;
  const W = Object.freeze([
    e.ExecutableDefinitionsRule,
    E.UniqueOperationNamesRule,
    c.LoneAnonymousOperationRule,
    R.SingleFieldSubscriptionsRule,
    a.KnownTypeNamesRule,
    s.FragmentsOnCompositeTypesRule,
    j.VariablesAreInputTypesRule,
    O.ScalarLeafsRule,
    n.FieldsOnCorrectTypeRule,
    g.UniqueFragmentNamesRule,
    r.KnownFragmentNamesRule,
    p.NoUnusedFragmentsRule,
    d.PossibleFragmentSpreadsRule,
    y.NoFragmentCyclesRule,
    I.UniqueVariableNamesRule,
    o.NoUndefinedVariablesRule,
    h.NoUnusedVariablesRule,
    t.KnownDirectivesRule,
    $.UniqueDirectivesPerLocationRule,
    i.KnownArgumentNamesRule,
    _.UniqueArgumentNamesRule,
    L.ValuesOfCorrectTypeRule,
    T.ProvidedRequiredArgumentsRule,
    V.VariablesInAllowedPositionRule,
    l.OverlappingFieldsCanBeMergedRule,
    S.UniqueInputFieldNamesRule,
    ...U
  ]);
  Ke.specifiedRules = W;
  const P = Object.freeze([
    u.LoneSchemaDefinitionRule,
    v.UniqueOperationTypesRule,
    b.UniqueTypeNamesRule,
    G.UniqueEnumValueNamesRule,
    N.UniqueFieldDefinitionNamesRule,
    D.UniqueArgumentDefinitionNamesRule,
    w.UniqueDirectiveNamesRule,
    a.KnownTypeNamesRule,
    t.KnownDirectivesRule,
    $.UniqueDirectivesPerLocationRule,
    m.PossibleTypeExtensionsRule,
    i.KnownArgumentNamesOnDirectivesRule,
    _.UniqueArgumentNamesRule,
    S.UniqueInputFieldNamesRule,
    T.ProvidedRequiredArgumentsOnDirectivesRule
  ]);
  return Ke.specifiedSDLRules = P, Ke;
}
var Be = {}, is;
function ko() {
  if (is) return Be;
  is = 1, Object.defineProperty(Be, "__esModule", {
    value: !0
  }), Be.ValidationContext = Be.SDLValidationContext = Be.ASTValidationContext = void 0;
  var e = /* @__PURE__ */ se(), n = /* @__PURE__ */ On(), s = /* @__PURE__ */ si();
  class i {
    constructor(c, u) {
      this._ast = c, this._fragments = void 0, this._fragmentSpreads = /* @__PURE__ */ new Map(), this._recursivelyReferencedFragments = /* @__PURE__ */ new Map(), this._onError = u;
    }
    get [Symbol.toStringTag]() {
      return "ASTValidationContext";
    }
    reportError(c) {
      this._onError(c);
    }
    getDocument() {
      return this._ast;
    }
    getFragment(c) {
      let u;
      if (this._fragments)
        u = this._fragments;
      else {
        u = /* @__PURE__ */ Object.create(null);
        for (const f of this.getDocument().definitions)
          f.kind === e.Kind.FRAGMENT_DEFINITION && (u[f.name.value] = f);
        this._fragments = u;
      }
      return u[c];
    }
    getFragmentSpreads(c) {
      let u = this._fragmentSpreads.get(c);
      if (!u) {
        u = [];
        const f = [c];
        let y;
        for (; y = f.pop(); )
          for (const o of y.selections)
            o.kind === e.Kind.FRAGMENT_SPREAD ? u.push(o) : o.selectionSet && f.push(o.selectionSet);
        this._fragmentSpreads.set(c, u);
      }
      return u;
    }
    getRecursivelyReferencedFragments(c) {
      let u = this._recursivelyReferencedFragments.get(c);
      if (!u) {
        u = [];
        const f = /* @__PURE__ */ Object.create(null), y = [c.selectionSet];
        let o;
        for (; o = y.pop(); )
          for (const p of this.getFragmentSpreads(o)) {
            const h = p.name.value;
            if (f[h] !== !0) {
              f[h] = !0;
              const l = this.getFragment(h);
              l && (u.push(l), y.push(l.selectionSet));
            }
          }
        this._recursivelyReferencedFragments.set(c, u);
      }
      return u;
    }
  }
  Be.ASTValidationContext = i;
  class t extends i {
    constructor(c, u, f) {
      super(c, f), this._schema = u;
    }
    get [Symbol.toStringTag]() {
      return "SDLValidationContext";
    }
    getSchema() {
      return this._schema;
    }
  }
  Be.SDLValidationContext = t;
  let r = class extends i {
    constructor(c, u, f, y) {
      super(u, y), this._schema = c, this._typeInfo = f, this._variableUsages = /* @__PURE__ */ new Map(), this._recursiveVariableUsages = /* @__PURE__ */ new Map();
    }
    get [Symbol.toStringTag]() {
      return "ValidationContext";
    }
    getSchema() {
      return this._schema;
    }
    getVariableUsages(c) {
      let u = this._variableUsages.get(c);
      if (!u) {
        const f = [], y = new s.TypeInfo(this._schema);
        (0, n.visit)(
          c,
          (0, s.visitWithTypeInfo)(y, {
            VariableDefinition: () => !1,
            Variable(o) {
              f.push({
                node: o,
                type: y.getInputType(),
                defaultValue: y.getDefaultValue(),
                parentType: y.getParentInputType()
              });
            }
          })
        ), u = f, this._variableUsages.set(c, u);
      }
      return u;
    }
    getRecursiveVariableUsages(c) {
      let u = this._recursiveVariableUsages.get(c);
      if (!u) {
        u = this.getVariableUsages(c);
        for (const f of this.getRecursivelyReferencedFragments(c))
          u = u.concat(this.getVariableUsages(f));
        this._recursiveVariableUsages.set(c, u);
      }
      return u;
    }
    getType() {
      return this._typeInfo.getType();
    }
    getParentType() {
      return this._typeInfo.getParentType();
    }
    getInputType() {
      return this._typeInfo.getInputType();
    }
    getParentInputType() {
      return this._typeInfo.getParentInputType();
    }
    getFieldDef() {
      return this._typeInfo.getFieldDef();
    }
    getDirective() {
      return this._typeInfo.getDirective();
    }
    getArgument() {
      return this._typeInfo.getArgument();
    }
    getEnumValue() {
      return this._typeInfo.getEnumValue();
    }
  };
  return Be.ValidationContext = r, Be;
}
var as;
function wr() {
  if (as) return an;
  as = 1, Object.defineProperty(an, "__esModule", {
    value: !0
  }), an.assertValidSDL = f, an.assertValidSDLExtension = y, an.validate = c, an.validateSDL = u;
  var e = /* @__PURE__ */ Re(), n = /* @__PURE__ */ ne(), s = /* @__PURE__ */ On(), i = /* @__PURE__ */ jr(), t = /* @__PURE__ */ si(), r = /* @__PURE__ */ wo(), a = /* @__PURE__ */ ko();
  function c(o, p, h = r.specifiedRules, l, d = new t.TypeInfo(o)) {
    var m;
    const T = (m = l?.maxErrors) !== null && m !== void 0 ? m : 100;
    p || (0, e.devAssert)(!1, "Must provide document."), (0, i.assertValidSchema)(o);
    const O = Object.freeze({}), R = [], D = new a.ValidationContext(
      o,
      p,
      d,
      (w) => {
        if (R.length >= T)
          throw R.push(
            new n.GraphQLError(
              "Too many validation errors, error limit reached. Validation aborted."
            )
          ), O;
        R.push(w);
      }
    ), _ = (0, s.visitInParallel)(
      h.map((w) => w(D))
    );
    try {
      (0, s.visit)(
        p,
        (0, t.visitWithTypeInfo)(d, _)
      );
    } catch (w) {
      if (w !== O)
        throw w;
    }
    return R;
  }
  function u(o, p, h = r.specifiedSDLRules) {
    const l = [], d = new a.SDLValidationContext(
      o,
      p,
      (T) => {
        l.push(T);
      }
    ), m = h.map((T) => T(d));
    return (0, s.visit)(o, (0, s.visitInParallel)(m)), l;
  }
  function f(o) {
    const p = u(o);
    if (p.length !== 0)
      throw new Error(p.map((h) => h.message).join(`

`));
  }
  function y(o, p) {
    const h = u(o, p);
    if (h.length !== 0)
      throw new Error(h.map((l) => l.message).join(`

`));
  }
  return an;
}
var je = {}, rr = {}, ss;
function Su() {
  if (ss) return rr;
  ss = 1, Object.defineProperty(rr, "__esModule", {
    value: !0
  }), rr.memoize3 = e;
  function e(n) {
    let s;
    return function(t, r, a) {
      s === void 0 && (s = /* @__PURE__ */ new WeakMap());
      let c = s.get(t);
      c === void 0 && (c = /* @__PURE__ */ new WeakMap(), s.set(t, c));
      let u = c.get(r);
      u === void 0 && (u = /* @__PURE__ */ new WeakMap(), c.set(r, u));
      let f = u.get(a);
      return f === void 0 && (f = n(t, r, a), u.set(a, f)), f;
    };
  }
  return rr;
}
var ir = {}, os;
function Ru() {
  if (os) return ir;
  os = 1, Object.defineProperty(ir, "__esModule", {
    value: !0
  }), ir.promiseForObject = e;
  function e(n) {
    return Promise.all(Object.values(n)).then((s) => {
      const i = /* @__PURE__ */ Object.create(null);
      for (const [t, r] of Object.keys(n).entries())
        i[r] = s[t];
      return i;
    });
  }
  return ir;
}
var ar = {}, us;
function Du() {
  if (us) return ar;
  us = 1, Object.defineProperty(ar, "__esModule", {
    value: !0
  }), ar.promiseReduce = n;
  var e = /* @__PURE__ */ ei();
  function n(s, i, t) {
    let r = t;
    for (const a of s)
      r = (0, e.isPromise)(r) ? r.then((c) => i(c, a)) : i(r, a);
    return r;
  }
  return ar;
}
var cs;
function kr() {
  if (cs) return je;
  cs = 1, Object.defineProperty(je, "__esModule", {
    value: !0
  }), je.assertValidExecutionArguments = $, je.buildExecutionContext = G, je.buildResolveInfo = v, je.defaultTypeResolver = je.defaultFieldResolver = void 0, je.execute = D, je.executeSync = _, je.getFieldDef = pe;
  var e = /* @__PURE__ */ Re(), n = /* @__PURE__ */ de(), s = /* @__PURE__ */ Se(), i = /* @__PURE__ */ ai(), t = /* @__PURE__ */ Ye(), r = /* @__PURE__ */ ei(), a = /* @__PURE__ */ Su(), c = /* @__PURE__ */ Pr(), u = /* @__PURE__ */ Ru(), f = /* @__PURE__ */ Du(), y = /* @__PURE__ */ ne(), o = /* @__PURE__ */ Zr(), p = /* @__PURE__ */ Je(), h = /* @__PURE__ */ se(), l = /* @__PURE__ */ oe(), d = /* @__PURE__ */ Me(), m = /* @__PURE__ */ jr(), T = /* @__PURE__ */ oi(), O = /* @__PURE__ */ Yn();
  const R = (0, a.memoize3)(
    (M, C, B) => (0, T.collectSubfields)(
      M.schema,
      M.fragments,
      M.variableValues,
      C,
      B
    )
  );
  function D(M) {
    arguments.length < 2 || (0, e.devAssert)(
      !1,
      "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
    );
    const { schema: C, document: B, variableValues: x, rootValue: Z } = M;
    $(C, B, x);
    const Y = G(M);
    if (!("schema" in Y))
      return {
        errors: Y
      };
    try {
      const { operation: ee } = Y, re = N(Y, ee, Z);
      return (0, r.isPromise)(re) ? re.then(
        (ue) => w(ue, Y.errors),
        (ue) => (Y.errors.push(ue), w(null, Y.errors))
      ) : w(re, Y.errors);
    } catch (ee) {
      return Y.errors.push(ee), w(null, Y.errors);
    }
  }
  function _(M) {
    const C = D(M);
    if ((0, r.isPromise)(C))
      throw new Error("GraphQL execution failed to complete synchronously.");
    return C;
  }
  function w(M, C) {
    return C.length === 0 ? {
      data: M
    } : {
      errors: C,
      data: M
    };
  }
  function $(M, C, B) {
    C || (0, e.devAssert)(!1, "Must provide document."), (0, m.assertValidSchema)(M), B == null || (0, t.isObjectLike)(B) || (0, e.devAssert)(
      !1,
      "Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided."
    );
  }
  function G(M) {
    var C, B, x;
    const {
      schema: Z,
      document: Y,
      rootValue: ee,
      contextValue: re,
      variableValues: ue,
      operationName: ce,
      fieldResolver: he,
      typeResolver: Oe,
      subscribeFieldResolver: Ee,
      options: ve
    } = M;
    let _e;
    const Fe = /* @__PURE__ */ Object.create(null);
    for (const k of Y.definitions)
      switch (k.kind) {
        case h.Kind.OPERATION_DEFINITION:
          if (ce == null) {
            if (_e !== void 0)
              return [
                new y.GraphQLError(
                  "Must provide operation name if query contains multiple operations."
                )
              ];
            _e = k;
          } else ((C = k.name) === null || C === void 0 ? void 0 : C.value) === ce && (_e = k);
          break;
        case h.Kind.FRAGMENT_DEFINITION:
          Fe[k.name.value] = k;
          break;
      }
    if (!_e)
      return ce != null ? [
        new y.GraphQLError(
          `Unknown operation named "${ce}".`
        )
      ] : [new y.GraphQLError("Must provide an operation.")];
    const en = (B = _e.variableDefinitions) !== null && B !== void 0 ? B : [], He = (0, O.getVariableValues)(
      Z,
      en,
      ue ?? {},
      {
        maxErrors: (x = ve?.maxCoercionErrors) !== null && x !== void 0 ? x : 50
      }
    );
    return He.errors ? He.errors : {
      schema: Z,
      fragments: Fe,
      rootValue: ee,
      contextValue: re,
      operation: _e,
      variableValues: He.coerced,
      fieldResolver: he ?? te,
      typeResolver: Oe ?? K,
      subscribeFieldResolver: Ee ?? te,
      errors: []
    };
  }
  function N(M, C, B) {
    const x = M.schema.getRootType(C.operation);
    if (x == null)
      throw new y.GraphQLError(
        `Schema is not configured to execute ${C.operation} operation.`,
        {
          nodes: C
        }
      );
    const Z = (0, T.collectFields)(
      M.schema,
      M.fragments,
      M.variableValues,
      x,
      C.selectionSet
    ), Y = void 0;
    switch (C.operation) {
      case p.OperationTypeNode.QUERY:
        return S(M, x, B, Y, Z);
      case p.OperationTypeNode.MUTATION:
        return g(
          M,
          x,
          B,
          Y,
          Z
        );
      case p.OperationTypeNode.SUBSCRIPTION:
        return S(M, x, B, Y, Z);
    }
  }
  function g(M, C, B, x, Z) {
    return (0, f.promiseReduce)(
      Z.entries(),
      (Y, [ee, re]) => {
        const ue = (0, c.addPath)(x, ee, C.name), ce = E(
          M,
          C,
          B,
          re,
          ue
        );
        return ce === void 0 ? Y : (0, r.isPromise)(ce) ? ce.then((he) => (Y[ee] = he, Y)) : (Y[ee] = ce, Y);
      },
      /* @__PURE__ */ Object.create(null)
    );
  }
  function S(M, C, B, x, Z) {
    const Y = /* @__PURE__ */ Object.create(null);
    let ee = !1;
    try {
      for (const [re, ue] of Z.entries()) {
        const ce = (0, c.addPath)(x, re, C.name), he = E(
          M,
          C,
          B,
          ue,
          ce
        );
        he !== void 0 && (Y[re] = he, (0, r.isPromise)(he) && (ee = !0));
      }
    } catch (re) {
      if (ee)
        return (0, u.promiseForObject)(Y).finally(() => {
          throw re;
        });
      throw re;
    }
    return ee ? (0, u.promiseForObject)(Y) : Y;
  }
  function E(M, C, B, x, Z) {
    var Y;
    const ee = pe(M.schema, C, x[0]);
    if (!ee)
      return;
    const re = ee.type, ue = (Y = ee.resolve) !== null && Y !== void 0 ? Y : M.fieldResolver, ce = v(
      M,
      ee,
      x,
      C,
      Z
    );
    try {
      const he = (0, O.getArgumentValues)(
        ee,
        x[0],
        M.variableValues
      ), Oe = M.contextValue, Ee = ue(B, he, Oe, ce);
      let ve;
      return (0, r.isPromise)(Ee) ? ve = Ee.then(
        (_e) => I(M, re, x, ce, Z, _e)
      ) : ve = I(
        M,
        re,
        x,
        ce,
        Z,
        Ee
      ), (0, r.isPromise)(ve) ? ve.then(void 0, (_e) => {
        const Fe = (0, o.locatedError)(
          _e,
          x,
          (0, c.pathToArray)(Z)
        );
        return b(Fe, re, M);
      }) : ve;
    } catch (he) {
      const Oe = (0, o.locatedError)(
        he,
        x,
        (0, c.pathToArray)(Z)
      );
      return b(Oe, re, M);
    }
  }
  function v(M, C, B, x, Z) {
    return {
      fieldName: C.name,
      fieldNodes: B,
      returnType: C.type,
      parentType: x,
      path: Z,
      schema: M.schema,
      fragments: M.fragments,
      rootValue: M.rootValue,
      operation: M.operation,
      variableValues: M.variableValues
    };
  }
  function b(M, C, B) {
    if ((0, l.isNonNullType)(C))
      throw M;
    return B.errors.push(M), null;
  }
  function I(M, C, B, x, Z, Y) {
    if (Y instanceof Error)
      throw Y;
    if ((0, l.isNonNullType)(C)) {
      const ee = I(
        M,
        C.ofType,
        B,
        x,
        Z,
        Y
      );
      if (ee === null)
        throw new Error(
          `Cannot return null for non-nullable field ${x.parentType.name}.${x.fieldName}.`
        );
      return ee;
    }
    if (Y == null)
      return null;
    if ((0, l.isListType)(C))
      return L(
        M,
        C,
        B,
        x,
        Z,
        Y
      );
    if ((0, l.isLeafType)(C))
      return j(C, Y);
    if ((0, l.isAbstractType)(C))
      return V(
        M,
        C,
        B,
        x,
        Z,
        Y
      );
    if ((0, l.isObjectType)(C))
      return W(
        M,
        C,
        B,
        x,
        Z,
        Y
      );
    (0, s.invariant)(
      !1,
      "Cannot complete value of unexpected output type: " + (0, n.inspect)(C)
    );
  }
  function L(M, C, B, x, Z, Y) {
    if (!(0, i.isIterableObject)(Y))
      throw new y.GraphQLError(
        `Expected Iterable, but did not find one for field "${x.parentType.name}.${x.fieldName}".`
      );
    const ee = C.ofType;
    let re = !1;
    const ue = Array.from(Y, (ce, he) => {
      const Oe = (0, c.addPath)(Z, he, void 0);
      try {
        let Ee;
        return (0, r.isPromise)(ce) ? Ee = ce.then(
          (ve) => I(
            M,
            ee,
            B,
            x,
            Oe,
            ve
          )
        ) : Ee = I(
          M,
          ee,
          B,
          x,
          Oe,
          ce
        ), (0, r.isPromise)(Ee) ? (re = !0, Ee.then(void 0, (ve) => {
          const _e = (0, o.locatedError)(
            ve,
            B,
            (0, c.pathToArray)(Oe)
          );
          return b(_e, ee, M);
        })) : Ee;
      } catch (Ee) {
        const ve = (0, o.locatedError)(
          Ee,
          B,
          (0, c.pathToArray)(Oe)
        );
        return b(ve, ee, M);
      }
    });
    return re ? Promise.all(ue) : ue;
  }
  function j(M, C) {
    const B = M.serialize(C);
    if (B == null)
      throw new Error(
        `Expected \`${(0, n.inspect)(M)}.serialize(${(0, n.inspect)(C)})\` to return non-nullable value, returned: ${(0, n.inspect)(
          B
        )}`
      );
    return B;
  }
  function V(M, C, B, x, Z, Y) {
    var ee;
    const re = (ee = C.resolveType) !== null && ee !== void 0 ? ee : M.typeResolver, ue = M.contextValue, ce = re(Y, ue, x, C);
    return (0, r.isPromise)(ce) ? ce.then(
      (he) => W(
        M,
        U(
          he,
          M,
          C,
          B,
          x,
          Y
        ),
        B,
        x,
        Z,
        Y
      )
    ) : W(
      M,
      U(
        ce,
        M,
        C,
        B,
        x,
        Y
      ),
      B,
      x,
      Z,
      Y
    );
  }
  function U(M, C, B, x, Z, Y) {
    if (M == null)
      throw new y.GraphQLError(
        `Abstract type "${B.name}" must resolve to an Object type at runtime for field "${Z.parentType.name}.${Z.fieldName}". Either the "${B.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`,
        x
      );
    if ((0, l.isObjectType)(M))
      throw new y.GraphQLError(
        "Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead."
      );
    if (typeof M != "string")
      throw new y.GraphQLError(
        `Abstract type "${B.name}" must resolve to an Object type at runtime for field "${Z.parentType.name}.${Z.fieldName}" with value ${(0, n.inspect)(Y)}, received "${(0, n.inspect)(M)}".`
      );
    const ee = C.schema.getType(M);
    if (ee == null)
      throw new y.GraphQLError(
        `Abstract type "${B.name}" was resolved to a type "${M}" that does not exist inside the schema.`,
        {
          nodes: x
        }
      );
    if (!(0, l.isObjectType)(ee))
      throw new y.GraphQLError(
        `Abstract type "${B.name}" was resolved to a non-object type "${M}".`,
        {
          nodes: x
        }
      );
    if (!C.schema.isSubType(B, ee))
      throw new y.GraphQLError(
        `Runtime Object type "${ee.name}" is not a possible type for "${B.name}".`,
        {
          nodes: x
        }
      );
    return ee;
  }
  function W(M, C, B, x, Z, Y) {
    const ee = R(M, C, B);
    if (C.isTypeOf) {
      const re = C.isTypeOf(Y, M.contextValue, x);
      if ((0, r.isPromise)(re))
        return re.then((ue) => {
          if (!ue)
            throw P(C, Y, B);
          return S(
            M,
            C,
            Y,
            Z,
            ee
          );
        });
      if (!re)
        throw P(C, Y, B);
    }
    return S(M, C, Y, Z, ee);
  }
  function P(M, C, B) {
    return new y.GraphQLError(
      `Expected value of type "${M.name}" but got: ${(0, n.inspect)(C)}.`,
      {
        nodes: B
      }
    );
  }
  const K = function(M, C, B, x) {
    if ((0, t.isObjectLike)(M) && typeof M.__typename == "string")
      return M.__typename;
    const Z = B.schema.getPossibleTypes(x), Y = [];
    for (let ee = 0; ee < Z.length; ee++) {
      const re = Z[ee];
      if (re.isTypeOf) {
        const ue = re.isTypeOf(M, C, B);
        if ((0, r.isPromise)(ue))
          Y[ee] = ue;
        else if (ue)
          return re.name;
      }
    }
    if (Y.length)
      return Promise.all(Y).then((ee) => {
        for (let re = 0; re < ee.length; re++)
          if (ee[re])
            return Z[re].name;
      });
  };
  je.defaultTypeResolver = K;
  const te = function(M, C, B, x) {
    if ((0, t.isObjectLike)(M) || typeof M == "function") {
      const Z = M[x.fieldName];
      return typeof Z == "function" ? M[x.fieldName](C, B, x) : Z;
    }
  };
  je.defaultFieldResolver = te;
  function pe(M, C, B) {
    const x = B.name.value;
    return x === d.SchemaMetaFieldDef.name && M.getQueryType() === C ? d.SchemaMetaFieldDef : x === d.TypeMetaFieldDef.name && M.getQueryType() === C ? d.TypeMetaFieldDef : x === d.TypeNameMetaFieldDef.name ? d.TypeNameMetaFieldDef : C.getFields()[x];
  }
  return je;
}
var ls;
function Au() {
  if (ls) return Rn;
  ls = 1, Object.defineProperty(Rn, "__esModule", {
    value: !0
  }), Rn.graphql = a, Rn.graphqlSync = c;
  var e = /* @__PURE__ */ Re(), n = /* @__PURE__ */ ei(), s = /* @__PURE__ */ xn(), i = /* @__PURE__ */ jr(), t = /* @__PURE__ */ wr(), r = /* @__PURE__ */ kr();
  function a(f) {
    return new Promise((y) => y(u(f)));
  }
  function c(f) {
    const y = u(f);
    if ((0, n.isPromise)(y))
      throw new Error("GraphQL execution failed to complete synchronously.");
    return y;
  }
  function u(f) {
    arguments.length < 2 || (0, e.devAssert)(
      !1,
      "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
    );
    const {
      schema: y,
      source: o,
      rootValue: p,
      contextValue: h,
      variableValues: l,
      operationName: d,
      fieldResolver: m,
      typeResolver: T
    } = f, O = (0, i.validateSchema)(y);
    if (O.length > 0)
      return {
        errors: O
      };
    let R;
    try {
      R = (0, s.parse)(o);
    } catch (_) {
      return {
        errors: [_]
      };
    }
    const D = (0, t.validate)(y, R);
    return D.length > 0 ? {
      errors: D
    } : (0, r.execute)({
      schema: y,
      document: R,
      rootValue: p,
      contextValue: h,
      variableValues: l,
      operationName: d,
      fieldResolver: m,
      typeResolver: T
    });
  }
  return Rn;
}
var Mr = {}, ps;
function ju() {
  return ps || (ps = 1, function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "DEFAULT_DEPRECATION_REASON", {
      enumerable: !0,
      get: function() {
        return i.DEFAULT_DEPRECATION_REASON;
      }
    }), Object.defineProperty(e, "GRAPHQL_MAX_INT", {
      enumerable: !0,
      get: function() {
        return t.GRAPHQL_MAX_INT;
      }
    }), Object.defineProperty(e, "GRAPHQL_MIN_INT", {
      enumerable: !0,
      get: function() {
        return t.GRAPHQL_MIN_INT;
      }
    }), Object.defineProperty(e, "GraphQLBoolean", {
      enumerable: !0,
      get: function() {
        return t.GraphQLBoolean;
      }
    }), Object.defineProperty(e, "GraphQLDeprecatedDirective", {
      enumerable: !0,
      get: function() {
        return i.GraphQLDeprecatedDirective;
      }
    }), Object.defineProperty(e, "GraphQLDirective", {
      enumerable: !0,
      get: function() {
        return i.GraphQLDirective;
      }
    }), Object.defineProperty(e, "GraphQLEnumType", {
      enumerable: !0,
      get: function() {
        return s.GraphQLEnumType;
      }
    }), Object.defineProperty(e, "GraphQLFloat", {
      enumerable: !0,
      get: function() {
        return t.GraphQLFloat;
      }
    }), Object.defineProperty(e, "GraphQLID", {
      enumerable: !0,
      get: function() {
        return t.GraphQLID;
      }
    }), Object.defineProperty(e, "GraphQLIncludeDirective", {
      enumerable: !0,
      get: function() {
        return i.GraphQLIncludeDirective;
      }
    }), Object.defineProperty(e, "GraphQLInputObjectType", {
      enumerable: !0,
      get: function() {
        return s.GraphQLInputObjectType;
      }
    }), Object.defineProperty(e, "GraphQLInt", {
      enumerable: !0,
      get: function() {
        return t.GraphQLInt;
      }
    }), Object.defineProperty(e, "GraphQLInterfaceType", {
      enumerable: !0,
      get: function() {
        return s.GraphQLInterfaceType;
      }
    }), Object.defineProperty(e, "GraphQLList", {
      enumerable: !0,
      get: function() {
        return s.GraphQLList;
      }
    }), Object.defineProperty(e, "GraphQLNonNull", {
      enumerable: !0,
      get: function() {
        return s.GraphQLNonNull;
      }
    }), Object.defineProperty(e, "GraphQLObjectType", {
      enumerable: !0,
      get: function() {
        return s.GraphQLObjectType;
      }
    }), Object.defineProperty(e, "GraphQLOneOfDirective", {
      enumerable: !0,
      get: function() {
        return i.GraphQLOneOfDirective;
      }
    }), Object.defineProperty(e, "GraphQLScalarType", {
      enumerable: !0,
      get: function() {
        return s.GraphQLScalarType;
      }
    }), Object.defineProperty(e, "GraphQLSchema", {
      enumerable: !0,
      get: function() {
        return n.GraphQLSchema;
      }
    }), Object.defineProperty(e, "GraphQLSkipDirective", {
      enumerable: !0,
      get: function() {
        return i.GraphQLSkipDirective;
      }
    }), Object.defineProperty(e, "GraphQLSpecifiedByDirective", {
      enumerable: !0,
      get: function() {
        return i.GraphQLSpecifiedByDirective;
      }
    }), Object.defineProperty(e, "GraphQLString", {
      enumerable: !0,
      get: function() {
        return t.GraphQLString;
      }
    }), Object.defineProperty(e, "GraphQLUnionType", {
      enumerable: !0,
      get: function() {
        return s.GraphQLUnionType;
      }
    }), Object.defineProperty(e, "SchemaMetaFieldDef", {
      enumerable: !0,
      get: function() {
        return r.SchemaMetaFieldDef;
      }
    }), Object.defineProperty(e, "TypeKind", {
      enumerable: !0,
      get: function() {
        return r.TypeKind;
      }
    }), Object.defineProperty(e, "TypeMetaFieldDef", {
      enumerable: !0,
      get: function() {
        return r.TypeMetaFieldDef;
      }
    }), Object.defineProperty(e, "TypeNameMetaFieldDef", {
      enumerable: !0,
      get: function() {
        return r.TypeNameMetaFieldDef;
      }
    }), Object.defineProperty(e, "__Directive", {
      enumerable: !0,
      get: function() {
        return r.__Directive;
      }
    }), Object.defineProperty(e, "__DirectiveLocation", {
      enumerable: !0,
      get: function() {
        return r.__DirectiveLocation;
      }
    }), Object.defineProperty(e, "__EnumValue", {
      enumerable: !0,
      get: function() {
        return r.__EnumValue;
      }
    }), Object.defineProperty(e, "__Field", {
      enumerable: !0,
      get: function() {
        return r.__Field;
      }
    }), Object.defineProperty(e, "__InputValue", {
      enumerable: !0,
      get: function() {
        return r.__InputValue;
      }
    }), Object.defineProperty(e, "__Schema", {
      enumerable: !0,
      get: function() {
        return r.__Schema;
      }
    }), Object.defineProperty(e, "__Type", {
      enumerable: !0,
      get: function() {
        return r.__Type;
      }
    }), Object.defineProperty(e, "__TypeKind", {
      enumerable: !0,
      get: function() {
        return r.__TypeKind;
      }
    }), Object.defineProperty(e, "assertAbstractType", {
      enumerable: !0,
      get: function() {
        return s.assertAbstractType;
      }
    }), Object.defineProperty(e, "assertCompositeType", {
      enumerable: !0,
      get: function() {
        return s.assertCompositeType;
      }
    }), Object.defineProperty(e, "assertDirective", {
      enumerable: !0,
      get: function() {
        return i.assertDirective;
      }
    }), Object.defineProperty(e, "assertEnumType", {
      enumerable: !0,
      get: function() {
        return s.assertEnumType;
      }
    }), Object.defineProperty(e, "assertEnumValueName", {
      enumerable: !0,
      get: function() {
        return c.assertEnumValueName;
      }
    }), Object.defineProperty(e, "assertInputObjectType", {
      enumerable: !0,
      get: function() {
        return s.assertInputObjectType;
      }
    }), Object.defineProperty(e, "assertInputType", {
      enumerable: !0,
      get: function() {
        return s.assertInputType;
      }
    }), Object.defineProperty(e, "assertInterfaceType", {
      enumerable: !0,
      get: function() {
        return s.assertInterfaceType;
      }
    }), Object.defineProperty(e, "assertLeafType", {
      enumerable: !0,
      get: function() {
        return s.assertLeafType;
      }
    }), Object.defineProperty(e, "assertListType", {
      enumerable: !0,
      get: function() {
        return s.assertListType;
      }
    }), Object.defineProperty(e, "assertName", {
      enumerable: !0,
      get: function() {
        return c.assertName;
      }
    }), Object.defineProperty(e, "assertNamedType", {
      enumerable: !0,
      get: function() {
        return s.assertNamedType;
      }
    }), Object.defineProperty(e, "assertNonNullType", {
      enumerable: !0,
      get: function() {
        return s.assertNonNullType;
      }
    }), Object.defineProperty(e, "assertNullableType", {
      enumerable: !0,
      get: function() {
        return s.assertNullableType;
      }
    }), Object.defineProperty(e, "assertObjectType", {
      enumerable: !0,
      get: function() {
        return s.assertObjectType;
      }
    }), Object.defineProperty(e, "assertOutputType", {
      enumerable: !0,
      get: function() {
        return s.assertOutputType;
      }
    }), Object.defineProperty(e, "assertScalarType", {
      enumerable: !0,
      get: function() {
        return s.assertScalarType;
      }
    }), Object.defineProperty(e, "assertSchema", {
      enumerable: !0,
      get: function() {
        return n.assertSchema;
      }
    }), Object.defineProperty(e, "assertType", {
      enumerable: !0,
      get: function() {
        return s.assertType;
      }
    }), Object.defineProperty(e, "assertUnionType", {
      enumerable: !0,
      get: function() {
        return s.assertUnionType;
      }
    }), Object.defineProperty(e, "assertValidSchema", {
      enumerable: !0,
      get: function() {
        return a.assertValidSchema;
      }
    }), Object.defineProperty(e, "assertWrappingType", {
      enumerable: !0,
      get: function() {
        return s.assertWrappingType;
      }
    }), Object.defineProperty(e, "getNamedType", {
      enumerable: !0,
      get: function() {
        return s.getNamedType;
      }
    }), Object.defineProperty(e, "getNullableType", {
      enumerable: !0,
      get: function() {
        return s.getNullableType;
      }
    }), Object.defineProperty(e, "introspectionTypes", {
      enumerable: !0,
      get: function() {
        return r.introspectionTypes;
      }
    }), Object.defineProperty(e, "isAbstractType", {
      enumerable: !0,
      get: function() {
        return s.isAbstractType;
      }
    }), Object.defineProperty(e, "isCompositeType", {
      enumerable: !0,
      get: function() {
        return s.isCompositeType;
      }
    }), Object.defineProperty(e, "isDirective", {
      enumerable: !0,
      get: function() {
        return i.isDirective;
      }
    }), Object.defineProperty(e, "isEnumType", {
      enumerable: !0,
      get: function() {
        return s.isEnumType;
      }
    }), Object.defineProperty(e, "isInputObjectType", {
      enumerable: !0,
      get: function() {
        return s.isInputObjectType;
      }
    }), Object.defineProperty(e, "isInputType", {
      enumerable: !0,
      get: function() {
        return s.isInputType;
      }
    }), Object.defineProperty(e, "isInterfaceType", {
      enumerable: !0,
      get: function() {
        return s.isInterfaceType;
      }
    }), Object.defineProperty(e, "isIntrospectionType", {
      enumerable: !0,
      get: function() {
        return r.isIntrospectionType;
      }
    }), Object.defineProperty(e, "isLeafType", {
      enumerable: !0,
      get: function() {
        return s.isLeafType;
      }
    }), Object.defineProperty(e, "isListType", {
      enumerable: !0,
      get: function() {
        return s.isListType;
      }
    }), Object.defineProperty(e, "isNamedType", {
      enumerable: !0,
      get: function() {
        return s.isNamedType;
      }
    }), Object.defineProperty(e, "isNonNullType", {
      enumerable: !0,
      get: function() {
        return s.isNonNullType;
      }
    }), Object.defineProperty(e, "isNullableType", {
      enumerable: !0,
      get: function() {
        return s.isNullableType;
      }
    }), Object.defineProperty(e, "isObjectType", {
      enumerable: !0,
      get: function() {
        return s.isObjectType;
      }
    }), Object.defineProperty(e, "isOutputType", {
      enumerable: !0,
      get: function() {
        return s.isOutputType;
      }
    }), Object.defineProperty(e, "isRequiredArgument", {
      enumerable: !0,
      get: function() {
        return s.isRequiredArgument;
      }
    }), Object.defineProperty(e, "isRequiredInputField", {
      enumerable: !0,
      get: function() {
        return s.isRequiredInputField;
      }
    }), Object.defineProperty(e, "isScalarType", {
      enumerable: !0,
      get: function() {
        return s.isScalarType;
      }
    }), Object.defineProperty(e, "isSchema", {
      enumerable: !0,
      get: function() {
        return n.isSchema;
      }
    }), Object.defineProperty(e, "isSpecifiedDirective", {
      enumerable: !0,
      get: function() {
        return i.isSpecifiedDirective;
      }
    }), Object.defineProperty(e, "isSpecifiedScalarType", {
      enumerable: !0,
      get: function() {
        return t.isSpecifiedScalarType;
      }
    }), Object.defineProperty(e, "isType", {
      enumerable: !0,
      get: function() {
        return s.isType;
      }
    }), Object.defineProperty(e, "isUnionType", {
      enumerable: !0,
      get: function() {
        return s.isUnionType;
      }
    }), Object.defineProperty(e, "isWrappingType", {
      enumerable: !0,
      get: function() {
        return s.isWrappingType;
      }
    }), Object.defineProperty(e, "resolveObjMapThunk", {
      enumerable: !0,
      get: function() {
        return s.resolveObjMapThunk;
      }
    }), Object.defineProperty(e, "resolveReadonlyArrayThunk", {
      enumerable: !0,
      get: function() {
        return s.resolveReadonlyArrayThunk;
      }
    }), Object.defineProperty(e, "specifiedDirectives", {
      enumerable: !0,
      get: function() {
        return i.specifiedDirectives;
      }
    }), Object.defineProperty(e, "specifiedScalarTypes", {
      enumerable: !0,
      get: function() {
        return t.specifiedScalarTypes;
      }
    }), Object.defineProperty(e, "validateSchema", {
      enumerable: !0,
      get: function() {
        return a.validateSchema;
      }
    });
    var n = /* @__PURE__ */ _n(), s = /* @__PURE__ */ oe(), i = /* @__PURE__ */ Pe(), t = /* @__PURE__ */ ze(), r = /* @__PURE__ */ Me(), a = /* @__PURE__ */ jr(), c = /* @__PURE__ */ Rr();
  }(Mr)), Mr;
}
var $r = {}, ds;
function Pu() {
  return ds || (ds = 1, function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "BREAK", {
      enumerable: !0,
      get: function() {
        return f.BREAK;
      }
    }), Object.defineProperty(e, "DirectiveLocation", {
      enumerable: !0,
      get: function() {
        return p.DirectiveLocation;
      }
    }), Object.defineProperty(e, "Kind", {
      enumerable: !0,
      get: function() {
        return t.Kind;
      }
    }), Object.defineProperty(e, "Lexer", {
      enumerable: !0,
      get: function() {
        return a.Lexer;
      }
    }), Object.defineProperty(e, "Location", {
      enumerable: !0,
      get: function() {
        return y.Location;
      }
    }), Object.defineProperty(e, "OperationTypeNode", {
      enumerable: !0,
      get: function() {
        return y.OperationTypeNode;
      }
    }), Object.defineProperty(e, "Source", {
      enumerable: !0,
      get: function() {
        return n.Source;
      }
    }), Object.defineProperty(e, "Token", {
      enumerable: !0,
      get: function() {
        return y.Token;
      }
    }), Object.defineProperty(e, "TokenKind", {
      enumerable: !0,
      get: function() {
        return r.TokenKind;
      }
    }), Object.defineProperty(e, "getEnterLeaveForKind", {
      enumerable: !0,
      get: function() {
        return f.getEnterLeaveForKind;
      }
    }), Object.defineProperty(e, "getLocation", {
      enumerable: !0,
      get: function() {
        return s.getLocation;
      }
    }), Object.defineProperty(e, "getVisitFn", {
      enumerable: !0,
      get: function() {
        return f.getVisitFn;
      }
    }), Object.defineProperty(e, "isConstValueNode", {
      enumerable: !0,
      get: function() {
        return o.isConstValueNode;
      }
    }), Object.defineProperty(e, "isDefinitionNode", {
      enumerable: !0,
      get: function() {
        return o.isDefinitionNode;
      }
    }), Object.defineProperty(e, "isExecutableDefinitionNode", {
      enumerable: !0,
      get: function() {
        return o.isExecutableDefinitionNode;
      }
    }), Object.defineProperty(e, "isSelectionNode", {
      enumerable: !0,
      get: function() {
        return o.isSelectionNode;
      }
    }), Object.defineProperty(e, "isTypeDefinitionNode", {
      enumerable: !0,
      get: function() {
        return o.isTypeDefinitionNode;
      }
    }), Object.defineProperty(e, "isTypeExtensionNode", {
      enumerable: !0,
      get: function() {
        return o.isTypeExtensionNode;
      }
    }), Object.defineProperty(e, "isTypeNode", {
      enumerable: !0,
      get: function() {
        return o.isTypeNode;
      }
    }), Object.defineProperty(e, "isTypeSystemDefinitionNode", {
      enumerable: !0,
      get: function() {
        return o.isTypeSystemDefinitionNode;
      }
    }), Object.defineProperty(e, "isTypeSystemExtensionNode", {
      enumerable: !0,
      get: function() {
        return o.isTypeSystemExtensionNode;
      }
    }), Object.defineProperty(e, "isValueNode", {
      enumerable: !0,
      get: function() {
        return o.isValueNode;
      }
    }), Object.defineProperty(e, "parse", {
      enumerable: !0,
      get: function() {
        return c.parse;
      }
    }), Object.defineProperty(e, "parseConstValue", {
      enumerable: !0,
      get: function() {
        return c.parseConstValue;
      }
    }), Object.defineProperty(e, "parseType", {
      enumerable: !0,
      get: function() {
        return c.parseType;
      }
    }), Object.defineProperty(e, "parseValue", {
      enumerable: !0,
      get: function() {
        return c.parseValue;
      }
    }), Object.defineProperty(e, "print", {
      enumerable: !0,
      get: function() {
        return u.print;
      }
    }), Object.defineProperty(e, "printLocation", {
      enumerable: !0,
      get: function() {
        return i.printLocation;
      }
    }), Object.defineProperty(e, "printSourceLocation", {
      enumerable: !0,
      get: function() {
        return i.printSourceLocation;
      }
    }), Object.defineProperty(e, "visit", {
      enumerable: !0,
      get: function() {
        return f.visit;
      }
    }), Object.defineProperty(e, "visitInParallel", {
      enumerable: !0,
      get: function() {
        return f.visitInParallel;
      }
    });
    var n = /* @__PURE__ */ ri(), s = /* @__PURE__ */ Hr(), i = /* @__PURE__ */ Bs(), t = /* @__PURE__ */ se(), r = /* @__PURE__ */ _r(), a = /* @__PURE__ */ ti(), c = /* @__PURE__ */ xn(), u = /* @__PURE__ */ we(), f = /* @__PURE__ */ On(), y = /* @__PURE__ */ Je(), o = /* @__PURE__ */ In(), p = /* @__PURE__ */ Bn();
  }($r)), $r;
}
var Cr = {}, Vn = {}, sr = {}, fs;
function Fu() {
  if (fs) return sr;
  fs = 1, Object.defineProperty(sr, "__esModule", {
    value: !0
  }), sr.isAsyncIterable = e;
  function e(n) {
    return typeof n?.[Symbol.asyncIterator] == "function";
  }
  return sr;
}
var or = {}, ms;
function wu() {
  if (ms) return or;
  ms = 1, Object.defineProperty(or, "__esModule", {
    value: !0
  }), or.mapAsyncIterator = e;
  function e(n, s) {
    const i = n[Symbol.asyncIterator]();
    async function t(r) {
      if (r.done)
        return r;
      try {
        return {
          value: await s(r.value),
          done: !1
        };
      } catch (a) {
        if (typeof i.return == "function")
          try {
            await i.return();
          } catch {
          }
        throw a;
      }
    }
    return {
      async next() {
        return t(await i.next());
      },
      async return() {
        return typeof i.return == "function" ? t(await i.return()) : {
          value: void 0,
          done: !0
        };
      },
      async throw(r) {
        if (typeof i.throw == "function")
          return t(await i.throw(r));
        throw r;
      },
      [Symbol.asyncIterator]() {
        return this;
      }
    };
  }
  return or;
}
var ys;
function ku() {
  if (ys) return Vn;
  ys = 1, Object.defineProperty(Vn, "__esModule", {
    value: !0
  }), Vn.createSourceEventStream = p, Vn.subscribe = y;
  var e = /* @__PURE__ */ Re(), n = /* @__PURE__ */ de(), s = /* @__PURE__ */ Fu(), i = /* @__PURE__ */ Pr(), t = /* @__PURE__ */ ne(), r = /* @__PURE__ */ Zr(), a = /* @__PURE__ */ oi(), c = /* @__PURE__ */ kr(), u = /* @__PURE__ */ wu(), f = /* @__PURE__ */ Yn();
  async function y(l) {
    arguments.length < 2 || (0, e.devAssert)(
      !1,
      "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead."
    );
    const d = await p(l);
    if (!(0, s.isAsyncIterable)(d))
      return d;
    const m = (T) => (0, c.execute)({ ...l, rootValue: T });
    return (0, u.mapAsyncIterator)(
      d,
      m
    );
  }
  function o(l) {
    const d = l[0];
    return d && "document" in d ? d : {
      schema: d,
      // FIXME: when underlying TS bug fixed, see https://github.com/microsoft/TypeScript/issues/31613
      document: l[1],
      rootValue: l[2],
      contextValue: l[3],
      variableValues: l[4],
      operationName: l[5],
      subscribeFieldResolver: l[6]
    };
  }
  async function p(...l) {
    const d = o(l), { schema: m, document: T, variableValues: O } = d;
    (0, c.assertValidExecutionArguments)(m, T, O);
    const R = (0, c.buildExecutionContext)(d);
    if (!("schema" in R))
      return {
        errors: R
      };
    try {
      const D = await h(R);
      if (!(0, s.isAsyncIterable)(D))
        throw new Error(
          `Subscription field must return Async Iterable. Received: ${(0, n.inspect)(D)}.`
        );
      return D;
    } catch (D) {
      if (D instanceof t.GraphQLError)
        return {
          errors: [D]
        };
      throw D;
    }
  }
  async function h(l) {
    const { schema: d, fragments: m, operation: T, variableValues: O, rootValue: R } = l, D = d.getSubscriptionType();
    if (D == null)
      throw new t.GraphQLError(
        "Schema is not configured to execute subscription operation.",
        {
          nodes: T
        }
      );
    const _ = (0, a.collectFields)(
      d,
      m,
      O,
      D,
      T.selectionSet
    ), [w, $] = [..._.entries()][0], G = (0, c.getFieldDef)(d, D, $[0]);
    if (!G) {
      const E = $[0].name.value;
      throw new t.GraphQLError(
        `The subscription field "${E}" is not defined.`,
        {
          nodes: $
        }
      );
    }
    const N = (0, i.addPath)(void 0, w, D.name), g = (0, c.buildResolveInfo)(
      l,
      G,
      $,
      D,
      N
    );
    try {
      var S;
      const E = (0, f.getArgumentValues)(
        G,
        $[0],
        O
      ), v = l.contextValue, I = await ((S = G.subscribe) !== null && S !== void 0 ? S : l.subscribeFieldResolver)(R, E, v, g);
      if (I instanceof Error)
        throw I;
      return I;
    } catch (E) {
      throw (0, r.locatedError)(
        E,
        $,
        (0, i.pathToArray)(N)
      );
    }
  }
  return Vn;
}
var hs;
function Vu() {
  return hs || (hs = 1, function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "createSourceEventStream", {
      enumerable: !0,
      get: function() {
        return i.createSourceEventStream;
      }
    }), Object.defineProperty(e, "defaultFieldResolver", {
      enumerable: !0,
      get: function() {
        return s.defaultFieldResolver;
      }
    }), Object.defineProperty(e, "defaultTypeResolver", {
      enumerable: !0,
      get: function() {
        return s.defaultTypeResolver;
      }
    }), Object.defineProperty(e, "execute", {
      enumerable: !0,
      get: function() {
        return s.execute;
      }
    }), Object.defineProperty(e, "executeSync", {
      enumerable: !0,
      get: function() {
        return s.executeSync;
      }
    }), Object.defineProperty(e, "getArgumentValues", {
      enumerable: !0,
      get: function() {
        return t.getArgumentValues;
      }
    }), Object.defineProperty(e, "getDirectiveValues", {
      enumerable: !0,
      get: function() {
        return t.getDirectiveValues;
      }
    }), Object.defineProperty(e, "getVariableValues", {
      enumerable: !0,
      get: function() {
        return t.getVariableValues;
      }
    }), Object.defineProperty(e, "responsePathAsArray", {
      enumerable: !0,
      get: function() {
        return n.pathToArray;
      }
    }), Object.defineProperty(e, "subscribe", {
      enumerable: !0,
      get: function() {
        return i.subscribe;
      }
    });
    var n = /* @__PURE__ */ Pr(), s = /* @__PURE__ */ kr(), i = /* @__PURE__ */ ku(), t = /* @__PURE__ */ Yn();
  }(Cr)), Cr;
}
var Ur = {}, ur = {}, vs;
function Gu() {
  if (vs) return ur;
  vs = 1, Object.defineProperty(ur, "__esModule", {
    value: !0
  }), ur.NoDeprecatedCustomRule = i;
  var e = /* @__PURE__ */ Se(), n = /* @__PURE__ */ ne(), s = /* @__PURE__ */ oe();
  function i(t) {
    return {
      Field(r) {
        const a = t.getFieldDef(), c = a?.deprecationReason;
        if (a && c != null) {
          const u = t.getParentType();
          u != null || (0, e.invariant)(!1), t.reportError(
            new n.GraphQLError(
              `The field ${u.name}.${a.name} is deprecated. ${c}`,
              {
                nodes: r
              }
            )
          );
        }
      },
      Argument(r) {
        const a = t.getArgument(), c = a?.deprecationReason;
        if (a && c != null) {
          const u = t.getDirective();
          if (u != null)
            t.reportError(
              new n.GraphQLError(
                `Directive "@${u.name}" argument "${a.name}" is deprecated. ${c}`,
                {
                  nodes: r
                }
              )
            );
          else {
            const f = t.getParentType(), y = t.getFieldDef();
            f != null && y != null || (0, e.invariant)(!1), t.reportError(
              new n.GraphQLError(
                `Field "${f.name}.${y.name}" argument "${a.name}" is deprecated. ${c}`,
                {
                  nodes: r
                }
              )
            );
          }
        }
      },
      ObjectField(r) {
        const a = (0, s.getNamedType)(
          t.getParentInputType()
        );
        if ((0, s.isInputObjectType)(a)) {
          const c = a.getFields()[r.name.value], u = c?.deprecationReason;
          u != null && t.reportError(
            new n.GraphQLError(
              `The input field ${a.name}.${c.name} is deprecated. ${u}`,
              {
                nodes: r
              }
            )
          );
        }
      },
      EnumValue(r) {
        const a = t.getEnumValue(), c = a?.deprecationReason;
        if (a && c != null) {
          const u = (0, s.getNamedType)(
            t.getInputType()
          );
          u != null || (0, e.invariant)(!1), t.reportError(
            new n.GraphQLError(
              `The enum value "${u.name}.${a.name}" is deprecated. ${c}`,
              {
                nodes: r
              }
            )
          );
        }
      }
    };
  }
  return ur;
}
var cr = {}, Ts;
function Mu() {
  if (Ts) return cr;
  Ts = 1, Object.defineProperty(cr, "__esModule", {
    value: !0
  }), cr.NoSchemaIntrospectionCustomRule = i;
  var e = /* @__PURE__ */ ne(), n = /* @__PURE__ */ oe(), s = /* @__PURE__ */ Me();
  function i(t) {
    return {
      Field(r) {
        const a = (0, n.getNamedType)(t.getType());
        a && (0, s.isIntrospectionType)(a) && t.reportError(
          new e.GraphQLError(
            `GraphQL introspection has been disabled, but the requested query contained the field "${r.name.value}".`,
            {
              nodes: r
            }
          )
        );
      }
    };
  }
  return cr;
}
var bs;
function $u() {
  return bs || (bs = 1, function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "ExecutableDefinitionsRule", {
      enumerable: !0,
      get: function() {
        return t.ExecutableDefinitionsRule;
      }
    }), Object.defineProperty(e, "FieldsOnCorrectTypeRule", {
      enumerable: !0,
      get: function() {
        return r.FieldsOnCorrectTypeRule;
      }
    }), Object.defineProperty(e, "FragmentsOnCompositeTypesRule", {
      enumerable: !0,
      get: function() {
        return a.FragmentsOnCompositeTypesRule;
      }
    }), Object.defineProperty(e, "KnownArgumentNamesRule", {
      enumerable: !0,
      get: function() {
        return c.KnownArgumentNamesRule;
      }
    }), Object.defineProperty(e, "KnownDirectivesRule", {
      enumerable: !0,
      get: function() {
        return u.KnownDirectivesRule;
      }
    }), Object.defineProperty(e, "KnownFragmentNamesRule", {
      enumerable: !0,
      get: function() {
        return f.KnownFragmentNamesRule;
      }
    }), Object.defineProperty(e, "KnownTypeNamesRule", {
      enumerable: !0,
      get: function() {
        return y.KnownTypeNamesRule;
      }
    }), Object.defineProperty(e, "LoneAnonymousOperationRule", {
      enumerable: !0,
      get: function() {
        return o.LoneAnonymousOperationRule;
      }
    }), Object.defineProperty(e, "LoneSchemaDefinitionRule", {
      enumerable: !0,
      get: function() {
        return I.LoneSchemaDefinitionRule;
      }
    }), Object.defineProperty(e, "MaxIntrospectionDepthRule", {
      enumerable: !0,
      get: function() {
        return b.MaxIntrospectionDepthRule;
      }
    }), Object.defineProperty(e, "NoDeprecatedCustomRule", {
      enumerable: !0,
      get: function() {
        return te.NoDeprecatedCustomRule;
      }
    }), Object.defineProperty(e, "NoFragmentCyclesRule", {
      enumerable: !0,
      get: function() {
        return p.NoFragmentCyclesRule;
      }
    }), Object.defineProperty(e, "NoSchemaIntrospectionCustomRule", {
      enumerable: !0,
      get: function() {
        return pe.NoSchemaIntrospectionCustomRule;
      }
    }), Object.defineProperty(e, "NoUndefinedVariablesRule", {
      enumerable: !0,
      get: function() {
        return h.NoUndefinedVariablesRule;
      }
    }), Object.defineProperty(e, "NoUnusedFragmentsRule", {
      enumerable: !0,
      get: function() {
        return l.NoUnusedFragmentsRule;
      }
    }), Object.defineProperty(e, "NoUnusedVariablesRule", {
      enumerable: !0,
      get: function() {
        return d.NoUnusedVariablesRule;
      }
    }), Object.defineProperty(e, "OverlappingFieldsCanBeMergedRule", {
      enumerable: !0,
      get: function() {
        return m.OverlappingFieldsCanBeMergedRule;
      }
    }), Object.defineProperty(e, "PossibleFragmentSpreadsRule", {
      enumerable: !0,
      get: function() {
        return T.PossibleFragmentSpreadsRule;
      }
    }), Object.defineProperty(e, "PossibleTypeExtensionsRule", {
      enumerable: !0,
      get: function() {
        return K.PossibleTypeExtensionsRule;
      }
    }), Object.defineProperty(e, "ProvidedRequiredArgumentsRule", {
      enumerable: !0,
      get: function() {
        return O.ProvidedRequiredArgumentsRule;
      }
    }), Object.defineProperty(e, "ScalarLeafsRule", {
      enumerable: !0,
      get: function() {
        return R.ScalarLeafsRule;
      }
    }), Object.defineProperty(e, "SingleFieldSubscriptionsRule", {
      enumerable: !0,
      get: function() {
        return D.SingleFieldSubscriptionsRule;
      }
    }), Object.defineProperty(e, "UniqueArgumentDefinitionNamesRule", {
      enumerable: !0,
      get: function() {
        return W.UniqueArgumentDefinitionNamesRule;
      }
    }), Object.defineProperty(e, "UniqueArgumentNamesRule", {
      enumerable: !0,
      get: function() {
        return _.UniqueArgumentNamesRule;
      }
    }), Object.defineProperty(e, "UniqueDirectiveNamesRule", {
      enumerable: !0,
      get: function() {
        return P.UniqueDirectiveNamesRule;
      }
    }), Object.defineProperty(e, "UniqueDirectivesPerLocationRule", {
      enumerable: !0,
      get: function() {
        return w.UniqueDirectivesPerLocationRule;
      }
    }), Object.defineProperty(e, "UniqueEnumValueNamesRule", {
      enumerable: !0,
      get: function() {
        return V.UniqueEnumValueNamesRule;
      }
    }), Object.defineProperty(e, "UniqueFieldDefinitionNamesRule", {
      enumerable: !0,
      get: function() {
        return U.UniqueFieldDefinitionNamesRule;
      }
    }), Object.defineProperty(e, "UniqueFragmentNamesRule", {
      enumerable: !0,
      get: function() {
        return $.UniqueFragmentNamesRule;
      }
    }), Object.defineProperty(e, "UniqueInputFieldNamesRule", {
      enumerable: !0,
      get: function() {
        return G.UniqueInputFieldNamesRule;
      }
    }), Object.defineProperty(e, "UniqueOperationNamesRule", {
      enumerable: !0,
      get: function() {
        return N.UniqueOperationNamesRule;
      }
    }), Object.defineProperty(e, "UniqueOperationTypesRule", {
      enumerable: !0,
      get: function() {
        return L.UniqueOperationTypesRule;
      }
    }), Object.defineProperty(e, "UniqueTypeNamesRule", {
      enumerable: !0,
      get: function() {
        return j.UniqueTypeNamesRule;
      }
    }), Object.defineProperty(e, "UniqueVariableNamesRule", {
      enumerable: !0,
      get: function() {
        return g.UniqueVariableNamesRule;
      }
    }), Object.defineProperty(e, "ValidationContext", {
      enumerable: !0,
      get: function() {
        return s.ValidationContext;
      }
    }), Object.defineProperty(e, "ValuesOfCorrectTypeRule", {
      enumerable: !0,
      get: function() {
        return S.ValuesOfCorrectTypeRule;
      }
    }), Object.defineProperty(e, "VariablesAreInputTypesRule", {
      enumerable: !0,
      get: function() {
        return E.VariablesAreInputTypesRule;
      }
    }), Object.defineProperty(e, "VariablesInAllowedPositionRule", {
      enumerable: !0,
      get: function() {
        return v.VariablesInAllowedPositionRule;
      }
    }), Object.defineProperty(e, "recommendedRules", {
      enumerable: !0,
      get: function() {
        return i.recommendedRules;
      }
    }), Object.defineProperty(e, "specifiedRules", {
      enumerable: !0,
      get: function() {
        return i.specifiedRules;
      }
    }), Object.defineProperty(e, "validate", {
      enumerable: !0,
      get: function() {
        return n.validate;
      }
    });
    var n = /* @__PURE__ */ wr(), s = /* @__PURE__ */ ko(), i = /* @__PURE__ */ wo(), t = /* @__PURE__ */ zs(), r = /* @__PURE__ */ Xs(), a = /* @__PURE__ */ Hs(), c = /* @__PURE__ */ Ws(), u = /* @__PURE__ */ Zs(), f = /* @__PURE__ */ eo(), y = /* @__PURE__ */ no(), o = /* @__PURE__ */ to(), p = /* @__PURE__ */ ao(), h = /* @__PURE__ */ so(), l = /* @__PURE__ */ oo(), d = /* @__PURE__ */ uo(), m = /* @__PURE__ */ lo(), T = /* @__PURE__ */ po(), O = /* @__PURE__ */ mo(), R = /* @__PURE__ */ yo(), D = /* @__PURE__ */ To(), _ = /* @__PURE__ */ go(), w = /* @__PURE__ */ No(), $ = /* @__PURE__ */ Io(), G = /* @__PURE__ */ Lo(), N = /* @__PURE__ */ So(), g = /* @__PURE__ */ Ao(), S = /* @__PURE__ */ jo(), E = /* @__PURE__ */ Po(), v = /* @__PURE__ */ Fo(), b = /* @__PURE__ */ io(), I = /* @__PURE__ */ ro(), L = /* @__PURE__ */ Ro(), j = /* @__PURE__ */ Do(), V = /* @__PURE__ */ Oo(), U = /* @__PURE__ */ _o(), W = /* @__PURE__ */ bo(), P = /* @__PURE__ */ Eo(), K = /* @__PURE__ */ fo(), te = /* @__PURE__ */ Gu(), pe = /* @__PURE__ */ Mu();
  }(Ur)), Ur;
}
var Qr = {}, lr = {}, gs;
function Vo() {
  if (gs) return lr;
  gs = 1, Object.defineProperty(lr, "__esModule", {
    value: !0
  }), lr.getIntrospectionQuery = e;
  function e(n) {
    const s = {
      descriptions: !0,
      specifiedByUrl: !1,
      directiveIsRepeatable: !1,
      schemaDescription: !1,
      inputValueDeprecation: !1,
      oneOf: !1,
      ...n
    }, i = s.descriptions ? "description" : "", t = s.specifiedByUrl ? "specifiedByURL" : "", r = s.directiveIsRepeatable ? "isRepeatable" : "", a = s.schemaDescription ? i : "";
    function c(f) {
      return s.inputValueDeprecation ? f : "";
    }
    const u = s.oneOf ? "isOneOf" : "";
    return `
    query IntrospectionQuery {
      __schema {
        ${a}
        queryType { name kind }
        mutationType { name kind }
        subscriptionType { name kind }
        types {
          ...FullType
        }
        directives {
          name
          ${i}
          ${r}
          locations
          args${c("(includeDeprecated: true)")} {
            ...InputValue
          }
        }
      }
    }

    fragment FullType on __Type {
      kind
      name
      ${i}
      ${t}
      ${u}
      fields(includeDeprecated: true) {
        name
        ${i}
        args${c("(includeDeprecated: true)")} {
          ...InputValue
        }
        type {
          ...TypeRef
        }
        isDeprecated
        deprecationReason
      }
      inputFields${c("(includeDeprecated: true)")} {
        ...InputValue
      }
      interfaces {
        ...TypeRef
      }
      enumValues(includeDeprecated: true) {
        name
        ${i}
        isDeprecated
        deprecationReason
      }
      possibleTypes {
        ...TypeRef
      }
    }

    fragment InputValue on __InputValue {
      name
      ${i}
      type { ...TypeRef }
      defaultValue
      ${c("isDeprecated")}
      ${c("deprecationReason")}
    }

    fragment TypeRef on __Type {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
                ofType {
                  kind
                  name
                  ofType {
                    kind
                    name
                    ofType {
                      kind
                      name
                      ofType {
                        kind
                        name
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  `;
  }
  return lr;
}
var pr = {}, Es;
function Cu() {
  if (Es) return pr;
  Es = 1, Object.defineProperty(pr, "__esModule", {
    value: !0
  }), pr.getOperationAST = n;
  var e = /* @__PURE__ */ se();
  function n(s, i) {
    let t = null;
    for (const a of s.definitions)
      if (a.kind === e.Kind.OPERATION_DEFINITION) {
        var r;
        if (i == null) {
          if (t)
            return null;
          t = a;
        } else if (((r = a.name) === null || r === void 0 ? void 0 : r.value) === i)
          return a;
      }
    return t;
  }
  return pr;
}
var dr = {}, Ns;
function Uu() {
  if (Ns) return dr;
  Ns = 1, Object.defineProperty(dr, "__esModule", {
    value: !0
  }), dr.getOperationRootType = n;
  var e = /* @__PURE__ */ ne();
  function n(s, i) {
    if (i.operation === "query") {
      const t = s.getQueryType();
      if (!t)
        throw new e.GraphQLError(
          "Schema does not define the required query root type.",
          {
            nodes: i
          }
        );
      return t;
    }
    if (i.operation === "mutation") {
      const t = s.getMutationType();
      if (!t)
        throw new e.GraphQLError(
          "Schema is not configured for mutations.",
          {
            nodes: i
          }
        );
      return t;
    }
    if (i.operation === "subscription") {
      const t = s.getSubscriptionType();
      if (!t)
        throw new e.GraphQLError(
          "Schema is not configured for subscriptions.",
          {
            nodes: i
          }
        );
      return t;
    }
    throw new e.GraphQLError(
      "Can only have query, mutation and subscription operations.",
      {
        nodes: i
      }
    );
  }
  return dr;
}
var fr = {}, Os;
function Qu() {
  if (Os) return fr;
  Os = 1, Object.defineProperty(fr, "__esModule", {
    value: !0
  }), fr.introspectionFromSchema = t;
  var e = /* @__PURE__ */ Se(), n = /* @__PURE__ */ xn(), s = /* @__PURE__ */ kr(), i = /* @__PURE__ */ Vo();
  function t(r, a) {
    const c = {
      specifiedByUrl: !0,
      directiveIsRepeatable: !0,
      schemaDescription: !0,
      inputValueDeprecation: !0,
      oneOf: !0,
      ...a
    }, u = (0, n.parse)(
      (0, i.getIntrospectionQuery)(c)
    ), f = (0, s.executeSync)({
      schema: r,
      document: u
    });
    return !f.errors && f.data || (0, e.invariant)(!1), f.data;
  }
  return fr;
}
var mr = {}, _s;
function qu() {
  if (_s) return mr;
  _s = 1, Object.defineProperty(mr, "__esModule", {
    value: !0
  }), mr.buildClientSchema = o;
  var e = /* @__PURE__ */ Re(), n = /* @__PURE__ */ de(), s = /* @__PURE__ */ Ye(), i = /* @__PURE__ */ Lr(), t = /* @__PURE__ */ xn(), r = /* @__PURE__ */ oe(), a = /* @__PURE__ */ Pe(), c = /* @__PURE__ */ Me(), u = /* @__PURE__ */ ze(), f = /* @__PURE__ */ _n(), y = /* @__PURE__ */ Fr();
  function o(p, h) {
    (0, s.isObjectLike)(p) && (0, s.isObjectLike)(p.__schema) || (0, e.devAssert)(
      !1,
      `Invalid or incomplete introspection result. Ensure that you are passing "data" property of introspection response and no "errors" was returned alongside: ${(0, n.inspect)(p)}.`
    );
    const l = p.__schema, d = (0, i.keyValMap)(
      l.types,
      (P) => P.name,
      (P) => G(P)
    );
    for (const P of [
      ...u.specifiedScalarTypes,
      ...c.introspectionTypes
    ])
      d[P.name] && (d[P.name] = P);
    const m = l.queryType ? w(l.queryType) : null, T = l.mutationType ? w(l.mutationType) : null, O = l.subscriptionType ? w(l.subscriptionType) : null, R = l.directives ? l.directives.map(W) : [];
    return new f.GraphQLSchema({
      description: l.description,
      query: m,
      mutation: T,
      subscription: O,
      types: Object.values(d),
      directives: R,
      assumeValid: h?.assumeValid
    });
    function D(P) {
      if (P.kind === c.TypeKind.LIST) {
        const K = P.ofType;
        if (!K)
          throw new Error("Decorated type deeper than introspection query.");
        return new r.GraphQLList(D(K));
      }
      if (P.kind === c.TypeKind.NON_NULL) {
        const K = P.ofType;
        if (!K)
          throw new Error("Decorated type deeper than introspection query.");
        const te = D(K);
        return new r.GraphQLNonNull(
          (0, r.assertNullableType)(te)
        );
      }
      return _(P);
    }
    function _(P) {
      const K = P.name;
      if (!K)
        throw new Error(
          `Unknown type reference: ${(0, n.inspect)(P)}.`
        );
      const te = d[K];
      if (!te)
        throw new Error(
          `Invalid or incomplete schema, unknown type: ${K}. Ensure that a full introspection query is used in order to build a client schema.`
        );
      return te;
    }
    function w(P) {
      return (0, r.assertObjectType)(_(P));
    }
    function $(P) {
      return (0, r.assertInterfaceType)(_(P));
    }
    function G(P) {
      if (P != null && P.name != null && P.kind != null)
        switch (P.kind) {
          case c.TypeKind.SCALAR:
            return N(P);
          case c.TypeKind.OBJECT:
            return S(P);
          case c.TypeKind.INTERFACE:
            return E(P);
          case c.TypeKind.UNION:
            return v(P);
          case c.TypeKind.ENUM:
            return b(P);
          case c.TypeKind.INPUT_OBJECT:
            return I(P);
        }
      const K = (0, n.inspect)(P);
      throw new Error(
        `Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${K}.`
      );
    }
    function N(P) {
      return new r.GraphQLScalarType({
        name: P.name,
        description: P.description,
        specifiedByURL: P.specifiedByURL
      });
    }
    function g(P) {
      if (P.interfaces === null && P.kind === c.TypeKind.INTERFACE)
        return [];
      if (!P.interfaces) {
        const K = (0, n.inspect)(
          P
        );
        throw new Error(
          `Introspection result missing interfaces: ${K}.`
        );
      }
      return P.interfaces.map($);
    }
    function S(P) {
      return new r.GraphQLObjectType({
        name: P.name,
        description: P.description,
        interfaces: () => g(P),
        fields: () => L(P)
      });
    }
    function E(P) {
      return new r.GraphQLInterfaceType({
        name: P.name,
        description: P.description,
        interfaces: () => g(P),
        fields: () => L(P)
      });
    }
    function v(P) {
      if (!P.possibleTypes) {
        const K = (0, n.inspect)(P);
        throw new Error(
          `Introspection result missing possibleTypes: ${K}.`
        );
      }
      return new r.GraphQLUnionType({
        name: P.name,
        description: P.description,
        types: () => P.possibleTypes.map(w)
      });
    }
    function b(P) {
      if (!P.enumValues) {
        const K = (0, n.inspect)(P);
        throw new Error(
          `Introspection result missing enumValues: ${K}.`
        );
      }
      return new r.GraphQLEnumType({
        name: P.name,
        description: P.description,
        values: (0, i.keyValMap)(
          P.enumValues,
          (K) => K.name,
          (K) => ({
            description: K.description,
            deprecationReason: K.deprecationReason
          })
        )
      });
    }
    function I(P) {
      if (!P.inputFields) {
        const K = (0, n.inspect)(
          P
        );
        throw new Error(
          `Introspection result missing inputFields: ${K}.`
        );
      }
      return new r.GraphQLInputObjectType({
        name: P.name,
        description: P.description,
        fields: () => V(P.inputFields),
        isOneOf: P.isOneOf
      });
    }
    function L(P) {
      if (!P.fields)
        throw new Error(
          `Introspection result missing fields: ${(0, n.inspect)(
            P
          )}.`
        );
      return (0, i.keyValMap)(
        P.fields,
        (K) => K.name,
        j
      );
    }
    function j(P) {
      const K = D(P.type);
      if (!(0, r.isOutputType)(K)) {
        const te = (0, n.inspect)(K);
        throw new Error(
          `Introspection must provide output type for fields, but received: ${te}.`
        );
      }
      if (!P.args) {
        const te = (0, n.inspect)(P);
        throw new Error(
          `Introspection result missing field args: ${te}.`
        );
      }
      return {
        description: P.description,
        deprecationReason: P.deprecationReason,
        type: K,
        args: V(P.args)
      };
    }
    function V(P) {
      return (0, i.keyValMap)(
        P,
        (K) => K.name,
        U
      );
    }
    function U(P) {
      const K = D(P.type);
      if (!(0, r.isInputType)(K)) {
        const pe = (0, n.inspect)(K);
        throw new Error(
          `Introspection must provide input type for arguments, but received: ${pe}.`
        );
      }
      const te = P.defaultValue != null ? (0, y.valueFromAST)(
        (0, t.parseValue)(P.defaultValue),
        K
      ) : void 0;
      return {
        description: P.description,
        type: K,
        defaultValue: te,
        deprecationReason: P.deprecationReason
      };
    }
    function W(P) {
      if (!P.args) {
        const K = (0, n.inspect)(
          P
        );
        throw new Error(
          `Introspection result missing directive args: ${K}.`
        );
      }
      if (!P.locations) {
        const K = (0, n.inspect)(
          P
        );
        throw new Error(
          `Introspection result missing directive locations: ${K}.`
        );
      }
      return new a.GraphQLDirective({
        name: P.name,
        description: P.description,
        isRepeatable: P.isRepeatable,
        locations: P.locations.slice(),
        args: V(P.args)
      });
    }
  }
  return mr;
}
var Gn = {}, Mn = {}, Is;
function Go() {
  if (Is) return Mn;
  Is = 1, Object.defineProperty(Mn, "__esModule", {
    value: !0
  }), Mn.extendSchema = d, Mn.extendSchemaImpl = m;
  var e = /* @__PURE__ */ Re(), n = /* @__PURE__ */ de(), s = /* @__PURE__ */ Se(), i = /* @__PURE__ */ on(), t = /* @__PURE__ */ Ys(), r = /* @__PURE__ */ se(), a = /* @__PURE__ */ In(), c = /* @__PURE__ */ oe(), u = /* @__PURE__ */ Pe(), f = /* @__PURE__ */ Me(), y = /* @__PURE__ */ ze(), o = /* @__PURE__ */ _n(), p = /* @__PURE__ */ wr(), h = /* @__PURE__ */ Yn(), l = /* @__PURE__ */ Fr();
  function d(_, w, $) {
    (0, o.assertSchema)(_), w != null && w.kind === r.Kind.DOCUMENT || (0, e.devAssert)(!1, "Must provide valid Document AST."), $?.assumeValid !== !0 && $?.assumeValidSDL !== !0 && (0, p.assertValidSDLExtension)(w, _);
    const G = _.toConfig(), N = m(G, w, $);
    return G === N ? _ : new o.GraphQLSchema(N);
  }
  function m(_, w, $) {
    var G, N, g, S;
    const E = [], v = /* @__PURE__ */ Object.create(null), b = [];
    let I;
    const L = [];
    for (const k of w.definitions)
      if (k.kind === r.Kind.SCHEMA_DEFINITION)
        I = k;
      else if (k.kind === r.Kind.SCHEMA_EXTENSION)
        L.push(k);
      else if ((0, a.isTypeDefinitionNode)(k))
        E.push(k);
      else if ((0, a.isTypeExtensionNode)(k)) {
        const J = k.name.value, q = v[J];
        v[J] = q ? q.concat([k]) : [k];
      } else k.kind === r.Kind.DIRECTIVE_DEFINITION && b.push(k);
    if (Object.keys(v).length === 0 && E.length === 0 && b.length === 0 && L.length === 0 && I == null)
      return _;
    const j = /* @__PURE__ */ Object.create(null);
    for (const k of _.types)
      j[k.name] = te(k);
    for (const k of E) {
      var V;
      const J = k.name.value;
      j[J] = (V = T[J]) !== null && V !== void 0 ? V : He(k);
    }
    const U = {
      // Get the extended root operation types.
      query: _.query && P(_.query),
      mutation: _.mutation && P(_.mutation),
      subscription: _.subscription && P(_.subscription),
      // Then, incorporate schema definition and all schema extensions.
      ...I && re([I]),
      ...re(L)
    };
    return {
      description: (G = I) === null || G === void 0 || (N = G.description) === null || N === void 0 ? void 0 : N.value,
      ...U,
      types: Object.values(j),
      directives: [
        ..._.directives.map(K),
        ...b.map(he)
      ],
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: (g = I) !== null && g !== void 0 ? g : _.astNode,
      extensionASTNodes: _.extensionASTNodes.concat(L),
      assumeValid: (S = $?.assumeValid) !== null && S !== void 0 ? S : !1
    };
    function W(k) {
      return (0, c.isListType)(k) ? new c.GraphQLList(W(k.ofType)) : (0, c.isNonNullType)(k) ? new c.GraphQLNonNull(W(k.ofType)) : P(k);
    }
    function P(k) {
      return j[k.name];
    }
    function K(k) {
      const J = k.toConfig();
      return new u.GraphQLDirective({
        ...J,
        args: (0, t.mapValue)(J.args, ee)
      });
    }
    function te(k) {
      if ((0, f.isIntrospectionType)(k) || (0, y.isSpecifiedScalarType)(k))
        return k;
      if ((0, c.isScalarType)(k))
        return C(k);
      if ((0, c.isObjectType)(k))
        return B(k);
      if ((0, c.isInterfaceType)(k))
        return x(k);
      if ((0, c.isUnionType)(k))
        return Z(k);
      if ((0, c.isEnumType)(k))
        return M(k);
      if ((0, c.isInputObjectType)(k))
        return pe(k);
      (0, s.invariant)(
        !1,
        "Unexpected type: " + (0, n.inspect)(k)
      );
    }
    function pe(k) {
      var J;
      const q = k.toConfig(), z = (J = v[q.name]) !== null && J !== void 0 ? J : [];
      return new c.GraphQLInputObjectType({
        ...q,
        fields: () => ({
          ...(0, t.mapValue)(q.fields, (fe) => ({
            ...fe,
            type: W(fe.type)
          })),
          ...ve(z)
        }),
        extensionASTNodes: q.extensionASTNodes.concat(z)
      });
    }
    function M(k) {
      var J;
      const q = k.toConfig(), z = (J = v[k.name]) !== null && J !== void 0 ? J : [];
      return new c.GraphQLEnumType({
        ...q,
        values: { ...q.values, ..._e(z) },
        extensionASTNodes: q.extensionASTNodes.concat(z)
      });
    }
    function C(k) {
      var J;
      const q = k.toConfig(), z = (J = v[q.name]) !== null && J !== void 0 ? J : [];
      let fe = q.specifiedByURL;
      for (const me of z) {
        var be;
        fe = (be = R(me)) !== null && be !== void 0 ? be : fe;
      }
      return new c.GraphQLScalarType({
        ...q,
        specifiedByURL: fe,
        extensionASTNodes: q.extensionASTNodes.concat(z)
      });
    }
    function B(k) {
      var J;
      const q = k.toConfig(), z = (J = v[q.name]) !== null && J !== void 0 ? J : [];
      return new c.GraphQLObjectType({
        ...q,
        interfaces: () => [
          ...k.getInterfaces().map(P),
          ...Fe(z)
        ],
        fields: () => ({
          ...(0, t.mapValue)(q.fields, Y),
          ...Oe(z)
        }),
        extensionASTNodes: q.extensionASTNodes.concat(z)
      });
    }
    function x(k) {
      var J;
      const q = k.toConfig(), z = (J = v[q.name]) !== null && J !== void 0 ? J : [];
      return new c.GraphQLInterfaceType({
        ...q,
        interfaces: () => [
          ...k.getInterfaces().map(P),
          ...Fe(z)
        ],
        fields: () => ({
          ...(0, t.mapValue)(q.fields, Y),
          ...Oe(z)
        }),
        extensionASTNodes: q.extensionASTNodes.concat(z)
      });
    }
    function Z(k) {
      var J;
      const q = k.toConfig(), z = (J = v[q.name]) !== null && J !== void 0 ? J : [];
      return new c.GraphQLUnionType({
        ...q,
        types: () => [
          ...k.getTypes().map(P),
          ...en(z)
        ],
        extensionASTNodes: q.extensionASTNodes.concat(z)
      });
    }
    function Y(k) {
      return {
        ...k,
        type: W(k.type),
        args: k.args && (0, t.mapValue)(k.args, ee)
      };
    }
    function ee(k) {
      return { ...k, type: W(k.type) };
    }
    function re(k) {
      const J = {};
      for (const z of k) {
        var q;
        const fe = (
          /* c8 ignore next */
          (q = z.operationTypes) !== null && q !== void 0 ? q : []
        );
        for (const be of fe)
          J[be.operation] = ue(be.type);
      }
      return J;
    }
    function ue(k) {
      var J;
      const q = k.name.value, z = (J = T[q]) !== null && J !== void 0 ? J : j[q];
      if (z === void 0)
        throw new Error(`Unknown type: "${q}".`);
      return z;
    }
    function ce(k) {
      return k.kind === r.Kind.LIST_TYPE ? new c.GraphQLList(ce(k.type)) : k.kind === r.Kind.NON_NULL_TYPE ? new c.GraphQLNonNull(ce(k.type)) : ue(k);
    }
    function he(k) {
      var J;
      return new u.GraphQLDirective({
        name: k.name.value,
        description: (J = k.description) === null || J === void 0 ? void 0 : J.value,
        // @ts-expect-error
        locations: k.locations.map(({ value: q }) => q),
        isRepeatable: k.repeatable,
        args: Ee(k.arguments),
        astNode: k
      });
    }
    function Oe(k) {
      const J = /* @__PURE__ */ Object.create(null);
      for (const fe of k) {
        var q;
        const be = (
          /* c8 ignore next */
          (q = fe.fields) !== null && q !== void 0 ? q : []
        );
        for (const me of be) {
          var z;
          J[me.name.value] = {
            // Note: While this could make assertions to get the correctly typed
            // value, that would throw immediately while type system validation
            // with validateSchema() will produce more actionable results.
            type: ce(me.type),
            description: (z = me.description) === null || z === void 0 ? void 0 : z.value,
            args: Ee(me.arguments),
            deprecationReason: O(me),
            astNode: me
          };
        }
      }
      return J;
    }
    function Ee(k) {
      const J = (
        /* c8 ignore next */
        k ?? []
      ), q = /* @__PURE__ */ Object.create(null);
      for (const fe of J) {
        var z;
        const be = ce(fe.type);
        q[fe.name.value] = {
          type: be,
          description: (z = fe.description) === null || z === void 0 ? void 0 : z.value,
          defaultValue: (0, l.valueFromAST)(fe.defaultValue, be),
          deprecationReason: O(fe),
          astNode: fe
        };
      }
      return q;
    }
    function ve(k) {
      const J = /* @__PURE__ */ Object.create(null);
      for (const fe of k) {
        var q;
        const be = (
          /* c8 ignore next */
          (q = fe.fields) !== null && q !== void 0 ? q : []
        );
        for (const me of be) {
          var z;
          const Ue = ce(me.type);
          J[me.name.value] = {
            type: Ue,
            description: (z = me.description) === null || z === void 0 ? void 0 : z.value,
            defaultValue: (0, l.valueFromAST)(
              me.defaultValue,
              Ue
            ),
            deprecationReason: O(me),
            astNode: me
          };
        }
      }
      return J;
    }
    function _e(k) {
      const J = /* @__PURE__ */ Object.create(null);
      for (const fe of k) {
        var q;
        const be = (
          /* c8 ignore next */
          (q = fe.values) !== null && q !== void 0 ? q : []
        );
        for (const me of be) {
          var z;
          J[me.name.value] = {
            description: (z = me.description) === null || z === void 0 ? void 0 : z.value,
            deprecationReason: O(me),
            astNode: me
          };
        }
      }
      return J;
    }
    function Fe(k) {
      return k.flatMap(
        // FIXME: https://github.com/graphql/graphql-js/issues/2203
        (J) => {
          var q, z;
          return (
            /* c8 ignore next */
            (q = (z = J.interfaces) === null || z === void 0 ? void 0 : z.map(ue)) !== null && q !== void 0 ? q : []
          );
        }
      );
    }
    function en(k) {
      return k.flatMap(
        // FIXME: https://github.com/graphql/graphql-js/issues/2203
        (J) => {
          var q, z;
          return (
            /* c8 ignore next */
            (q = (z = J.types) === null || z === void 0 ? void 0 : z.map(ue)) !== null && q !== void 0 ? q : []
          );
        }
      );
    }
    function He(k) {
      var J;
      const q = k.name.value, z = (J = v[q]) !== null && J !== void 0 ? J : [];
      switch (k.kind) {
        case r.Kind.OBJECT_TYPE_DEFINITION: {
          var fe;
          const Ie = [k, ...z];
          return new c.GraphQLObjectType({
            name: q,
            description: (fe = k.description) === null || fe === void 0 ? void 0 : fe.value,
            interfaces: () => Fe(Ie),
            fields: () => Oe(Ie),
            astNode: k,
            extensionASTNodes: z
          });
        }
        case r.Kind.INTERFACE_TYPE_DEFINITION: {
          var be;
          const Ie = [k, ...z];
          return new c.GraphQLInterfaceType({
            name: q,
            description: (be = k.description) === null || be === void 0 ? void 0 : be.value,
            interfaces: () => Fe(Ie),
            fields: () => Oe(Ie),
            astNode: k,
            extensionASTNodes: z
          });
        }
        case r.Kind.ENUM_TYPE_DEFINITION: {
          var me;
          const Ie = [k, ...z];
          return new c.GraphQLEnumType({
            name: q,
            description: (me = k.description) === null || me === void 0 ? void 0 : me.value,
            values: _e(Ie),
            astNode: k,
            extensionASTNodes: z
          });
        }
        case r.Kind.UNION_TYPE_DEFINITION: {
          var Ue;
          const Ie = [k, ...z];
          return new c.GraphQLUnionType({
            name: q,
            description: (Ue = k.description) === null || Ue === void 0 ? void 0 : Ue.value,
            types: () => en(Ie),
            astNode: k,
            extensionASTNodes: z
          });
        }
        case r.Kind.SCALAR_TYPE_DEFINITION: {
          var Ln;
          return new c.GraphQLScalarType({
            name: q,
            description: (Ln = k.description) === null || Ln === void 0 ? void 0 : Ln.value,
            specifiedByURL: R(k),
            astNode: k,
            extensionASTNodes: z
          });
        }
        case r.Kind.INPUT_OBJECT_TYPE_DEFINITION: {
          var cn;
          const Ie = [k, ...z];
          return new c.GraphQLInputObjectType({
            name: q,
            description: (cn = k.description) === null || cn === void 0 ? void 0 : cn.value,
            fields: () => ve(Ie),
            astNode: k,
            extensionASTNodes: z,
            isOneOf: D(k)
          });
        }
      }
    }
  }
  const T = (0, i.keyMap)(
    [...y.specifiedScalarTypes, ...f.introspectionTypes],
    (_) => _.name
  );
  function O(_) {
    const w = (0, h.getDirectiveValues)(
      u.GraphQLDeprecatedDirective,
      _
    );
    return w?.reason;
  }
  function R(_) {
    const w = (0, h.getDirectiveValues)(
      u.GraphQLSpecifiedByDirective,
      _
    );
    return w?.url;
  }
  function D(_) {
    return !!(0, h.getDirectiveValues)(u.GraphQLOneOfDirective, _);
  }
  return Mn;
}
var Ls;
function Ku() {
  if (Ls) return Gn;
  Ls = 1, Object.defineProperty(Gn, "__esModule", {
    value: !0
  }), Gn.buildASTSchema = c, Gn.buildSchema = u;
  var e = /* @__PURE__ */ Re(), n = /* @__PURE__ */ se(), s = /* @__PURE__ */ xn(), i = /* @__PURE__ */ Pe(), t = /* @__PURE__ */ _n(), r = /* @__PURE__ */ wr(), a = /* @__PURE__ */ Go();
  function c(f, y) {
    f != null && f.kind === n.Kind.DOCUMENT || (0, e.devAssert)(!1, "Must provide valid Document AST."), y?.assumeValid !== !0 && y?.assumeValidSDL !== !0 && (0, r.assertValidSDL)(f);
    const o = {
      description: void 0,
      types: [],
      directives: [],
      extensions: /* @__PURE__ */ Object.create(null),
      extensionASTNodes: [],
      assumeValid: !1
    }, p = (0, a.extendSchemaImpl)(
      o,
      f,
      y
    );
    if (p.astNode == null)
      for (const l of p.types)
        switch (l.name) {
          // Note: While this could make early assertions to get the correctly
          // typed values below, that would throw immediately while type system
          // validation with validateSchema() will produce more actionable results.
          case "Query":
            p.query = l;
            break;
          case "Mutation":
            p.mutation = l;
            break;
          case "Subscription":
            p.subscription = l;
            break;
        }
    const h = [
      ...p.directives,
      // If specified directives were not explicitly declared, add them.
      ...i.specifiedDirectives.filter(
        (l) => p.directives.every(
          (d) => d.name !== l.name
        )
      )
    ];
    return new t.GraphQLSchema({ ...p, directives: h });
  }
  function u(f, y) {
    const o = (0, s.parse)(f, {
      noLocation: y?.noLocation,
      allowLegacyFragmentVariables: y?.allowLegacyFragmentVariables
    });
    return c(o, {
      assumeValidSDL: y?.assumeValidSDL,
      assumeValid: y?.assumeValid
    });
  }
  return Gn;
}
var yr = {}, Ss;
function Bu() {
  if (Ss) return yr;
  Ss = 1, Object.defineProperty(yr, "__esModule", {
    value: !0
  }), yr.lexicographicSortSchema = u;
  var e = /* @__PURE__ */ de(), n = /* @__PURE__ */ Se(), s = /* @__PURE__ */ Lr(), i = /* @__PURE__ */ Sr(), t = /* @__PURE__ */ oe(), r = /* @__PURE__ */ Pe(), a = /* @__PURE__ */ Me(), c = /* @__PURE__ */ _n();
  function u(p) {
    const h = p.toConfig(), l = (0, s.keyValMap)(
      y(h.types),
      (G) => G.name,
      $
    );
    return new c.GraphQLSchema({
      ...h,
      types: Object.values(l),
      directives: y(h.directives).map(O),
      query: T(h.query),
      mutation: T(h.mutation),
      subscription: T(h.subscription)
    });
    function d(G) {
      return (0, t.isListType)(G) ? new t.GraphQLList(d(G.ofType)) : (0, t.isNonNullType)(G) ? new t.GraphQLNonNull(d(G.ofType)) : m(G);
    }
    function m(G) {
      return l[G.name];
    }
    function T(G) {
      return G && m(G);
    }
    function O(G) {
      const N = G.toConfig();
      return new r.GraphQLDirective({
        ...N,
        locations: o(N.locations, (g) => g),
        args: R(N.args)
      });
    }
    function R(G) {
      return f(G, (N) => ({ ...N, type: d(N.type) }));
    }
    function D(G) {
      return f(G, (N) => ({
        ...N,
        type: d(N.type),
        args: N.args && R(N.args)
      }));
    }
    function _(G) {
      return f(G, (N) => ({
        ...N,
        type: d(N.type)
      }));
    }
    function w(G) {
      return y(G).map(m);
    }
    function $(G) {
      if ((0, t.isScalarType)(G) || (0, a.isIntrospectionType)(G))
        return G;
      if ((0, t.isObjectType)(G)) {
        const N = G.toConfig();
        return new t.GraphQLObjectType({
          ...N,
          interfaces: () => w(N.interfaces),
          fields: () => D(N.fields)
        });
      }
      if ((0, t.isInterfaceType)(G)) {
        const N = G.toConfig();
        return new t.GraphQLInterfaceType({
          ...N,
          interfaces: () => w(N.interfaces),
          fields: () => D(N.fields)
        });
      }
      if ((0, t.isUnionType)(G)) {
        const N = G.toConfig();
        return new t.GraphQLUnionType({
          ...N,
          types: () => w(N.types)
        });
      }
      if ((0, t.isEnumType)(G)) {
        const N = G.toConfig();
        return new t.GraphQLEnumType({
          ...N,
          values: f(N.values, (g) => g)
        });
      }
      if ((0, t.isInputObjectType)(G)) {
        const N = G.toConfig();
        return new t.GraphQLInputObjectType({
          ...N,
          fields: () => _(N.fields)
        });
      }
      (0, n.invariant)(
        !1,
        "Unexpected type: " + (0, e.inspect)(G)
      );
    }
  }
  function f(p, h) {
    const l = /* @__PURE__ */ Object.create(null);
    for (const d of Object.keys(p).sort(i.naturalCompare))
      l[d] = h(p[d]);
    return l;
  }
  function y(p) {
    return o(p, (h) => h.name);
  }
  function o(p, h) {
    return p.slice().sort((l, d) => {
      const m = h(l), T = h(d);
      return (0, i.naturalCompare)(m, T);
    });
  }
  return yr;
}
var gn = {}, Rs;
function xu() {
  if (Rs) return gn;
  Rs = 1, Object.defineProperty(gn, "__esModule", {
    value: !0
  }), gn.printIntrospectionSchema = o, gn.printSchema = y, gn.printType = m;
  var e = /* @__PURE__ */ de(), n = /* @__PURE__ */ Se(), s = /* @__PURE__ */ Or(), i = /* @__PURE__ */ se(), t = /* @__PURE__ */ we(), r = /* @__PURE__ */ oe(), a = /* @__PURE__ */ Pe(), c = /* @__PURE__ */ Me(), u = /* @__PURE__ */ ze(), f = /* @__PURE__ */ Ar();
  function y(L) {
    return h(
      L,
      (j) => !(0, a.isSpecifiedDirective)(j),
      p
    );
  }
  function o(L) {
    return h(
      L,
      a.isSpecifiedDirective,
      c.isIntrospectionType
    );
  }
  function p(L) {
    return !(0, u.isSpecifiedScalarType)(L) && !(0, c.isIntrospectionType)(L);
  }
  function h(L, j, V) {
    const U = L.getDirectives().filter(j), W = Object.values(L.getTypeMap()).filter(V);
    return [
      l(L),
      ...U.map((P) => E(P)),
      ...W.map((P) => m(P))
    ].filter(Boolean).join(`

`);
  }
  function l(L) {
    if (L.description == null && d(L))
      return;
    const j = [], V = L.getQueryType();
    V && j.push(`  query: ${V.name}`);
    const U = L.getMutationType();
    U && j.push(`  mutation: ${U.name}`);
    const W = L.getSubscriptionType();
    return W && j.push(`  subscription: ${W.name}`), I(L) + `schema {
${j.join(`
`)}
}`;
  }
  function d(L) {
    const j = L.getQueryType();
    if (j && j.name !== "Query")
      return !1;
    const V = L.getMutationType();
    if (V && V.name !== "Mutation")
      return !1;
    const U = L.getSubscriptionType();
    return !(U && U.name !== "Subscription");
  }
  function m(L) {
    if ((0, r.isScalarType)(L))
      return T(L);
    if ((0, r.isObjectType)(L))
      return R(L);
    if ((0, r.isInterfaceType)(L))
      return D(L);
    if ((0, r.isUnionType)(L))
      return _(L);
    if ((0, r.isEnumType)(L))
      return w(L);
    if ((0, r.isInputObjectType)(L))
      return $(L);
    (0, n.invariant)(
      !1,
      "Unexpected type: " + (0, e.inspect)(L)
    );
  }
  function T(L) {
    return I(L) + `scalar ${L.name}` + b(L);
  }
  function O(L) {
    const j = L.getInterfaces();
    return j.length ? " implements " + j.map((V) => V.name).join(" & ") : "";
  }
  function R(L) {
    return I(L) + `type ${L.name}` + O(L) + G(L);
  }
  function D(L) {
    return I(L) + `interface ${L.name}` + O(L) + G(L);
  }
  function _(L) {
    const j = L.getTypes(), V = j.length ? " = " + j.join(" | ") : "";
    return I(L) + "union " + L.name + V;
  }
  function w(L) {
    const j = L.getValues().map(
      (V, U) => I(V, "  ", !U) + "  " + V.name + v(V.deprecationReason)
    );
    return I(L) + `enum ${L.name}` + N(j);
  }
  function $(L) {
    const j = Object.values(L.getFields()).map(
      (V, U) => I(V, "  ", !U) + "  " + S(V)
    );
    return I(L) + `input ${L.name}` + (L.isOneOf ? " @oneOf" : "") + N(j);
  }
  function G(L) {
    const j = Object.values(L.getFields()).map(
      (V, U) => I(V, "  ", !U) + "  " + V.name + g(V.args, "  ") + ": " + String(V.type) + v(V.deprecationReason)
    );
    return N(j);
  }
  function N(L) {
    return L.length !== 0 ? ` {
` + L.join(`
`) + `
}` : "";
  }
  function g(L, j = "") {
    return L.length === 0 ? "" : L.every((V) => !V.description) ? "(" + L.map(S).join(", ") + ")" : `(
` + L.map(
      (V, U) => I(V, "  " + j, !U) + "  " + j + S(V)
    ).join(`
`) + `
` + j + ")";
  }
  function S(L) {
    const j = (0, f.astFromValue)(
      L.defaultValue,
      L.type
    );
    let V = L.name + ": " + String(L.type);
    return j && (V += ` = ${(0, t.print)(j)}`), V + v(L.deprecationReason);
  }
  function E(L) {
    return I(L) + "directive @" + L.name + g(L.args) + (L.isRepeatable ? " repeatable" : "") + " on " + L.locations.join(" | ");
  }
  function v(L) {
    return L == null ? "" : L !== a.DEFAULT_DEPRECATION_REASON ? ` @deprecated(reason: ${(0, t.print)({
      kind: i.Kind.STRING,
      value: L
    })})` : " @deprecated";
  }
  function b(L) {
    return L.specifiedByURL == null ? "" : ` @specifiedBy(url: ${(0, t.print)({
      kind: i.Kind.STRING,
      value: L.specifiedByURL
    })})`;
  }
  function I(L, j = "", V = !0) {
    const { description: U } = L;
    if (U == null)
      return "";
    const W = (0, t.print)({
      kind: i.Kind.STRING,
      value: U,
      block: (0, s.isPrintableAsBlockString)(U)
    });
    return (j && !V ? `
` + j : j) + W.replace(/\n/g, `
` + j) + `
`;
  }
  return gn;
}
var hr = {}, Ds;
function Yu() {
  if (Ds) return hr;
  Ds = 1, Object.defineProperty(hr, "__esModule", {
    value: !0
  }), hr.concatAST = n;
  var e = /* @__PURE__ */ se();
  function n(s) {
    const i = [];
    for (const t of s)
      i.push(...t.definitions);
    return {
      kind: e.Kind.DOCUMENT,
      definitions: i
    };
  }
  return hr;
}
var vr = {}, As;
function Ju() {
  if (As) return vr;
  As = 1, Object.defineProperty(vr, "__esModule", {
    value: !0
  }), vr.separateOperations = s;
  var e = /* @__PURE__ */ se(), n = /* @__PURE__ */ On();
  function s(r) {
    const a = [], c = /* @__PURE__ */ Object.create(null);
    for (const f of r.definitions)
      switch (f.kind) {
        case e.Kind.OPERATION_DEFINITION:
          a.push(f);
          break;
        case e.Kind.FRAGMENT_DEFINITION:
          c[f.name.value] = t(
            f.selectionSet
          );
          break;
      }
    const u = /* @__PURE__ */ Object.create(null);
    for (const f of a) {
      const y = /* @__PURE__ */ new Set();
      for (const p of t(f.selectionSet))
        i(y, c, p);
      const o = f.name ? f.name.value : "";
      u[o] = {
        kind: e.Kind.DOCUMENT,
        definitions: r.definitions.filter(
          (p) => p === f || p.kind === e.Kind.FRAGMENT_DEFINITION && y.has(p.name.value)
        )
      };
    }
    return u;
  }
  function i(r, a, c) {
    if (!r.has(c)) {
      r.add(c);
      const u = a[c];
      if (u !== void 0)
        for (const f of u)
          i(r, a, f);
    }
  }
  function t(r) {
    const a = [];
    return (0, n.visit)(r, {
      FragmentSpread(c) {
        a.push(c.name.value);
      }
    }), a;
  }
  return vr;
}
var Tr = {}, js;
function zu() {
  if (js) return Tr;
  js = 1, Object.defineProperty(Tr, "__esModule", {
    value: !0
  }), Tr.stripIgnoredCharacters = t;
  var e = /* @__PURE__ */ Or(), n = /* @__PURE__ */ ti(), s = /* @__PURE__ */ ri(), i = /* @__PURE__ */ _r();
  function t(r) {
    const a = (0, s.isSource)(r) ? r : new s.Source(r), c = a.body, u = new n.Lexer(a);
    let f = "", y = !1;
    for (; u.advance().kind !== i.TokenKind.EOF; ) {
      const o = u.token, p = o.kind, h = !(0, n.isPunctuatorTokenKind)(
        o.kind
      );
      y && (h || o.kind === i.TokenKind.SPREAD) && (f += " ");
      const l = c.slice(o.start, o.end);
      p === i.TokenKind.BLOCK_STRING ? f += (0, e.printBlockString)(o.value, {
        minimize: !0
      }) : f += l, y = h;
    }
    return f;
  }
  return Tr;
}
var $n = {}, Ps;
function Xu() {
  if (Ps) return $n;
  Ps = 1, Object.defineProperty($n, "__esModule", {
    value: !0
  }), $n.assertValidName = i, $n.isValidNameError = t;
  var e = /* @__PURE__ */ Re(), n = /* @__PURE__ */ ne(), s = /* @__PURE__ */ Rr();
  function i(r) {
    const a = t(r);
    if (a)
      throw a;
    return r;
  }
  function t(r) {
    if (typeof r == "string" || (0, e.devAssert)(!1, "Expected name to be a string."), r.startsWith("__"))
      return new n.GraphQLError(
        `Name "${r}" must not begin with "__", which is reserved by GraphQL introspection.`
      );
    try {
      (0, s.assertName)(r);
    } catch (a) {
      return a;
    }
  }
  return $n;
}
var Ve = {}, Fs;
function Hu() {
  if (Fs) return Ve;
  Fs = 1, Object.defineProperty(Ve, "__esModule", {
    value: !0
  }), Ve.DangerousChangeType = Ve.BreakingChangeType = void 0, Ve.findBreakingChanges = y, Ve.findDangerousChanges = o;
  var e = /* @__PURE__ */ de(), n = /* @__PURE__ */ Se(), s = /* @__PURE__ */ on(), i = /* @__PURE__ */ we(), t = /* @__PURE__ */ oe(), r = /* @__PURE__ */ ze(), a = /* @__PURE__ */ Ar(), c = /* @__PURE__ */ co(), u;
  Ve.BreakingChangeType = u, function(g) {
    g.TYPE_REMOVED = "TYPE_REMOVED", g.TYPE_CHANGED_KIND = "TYPE_CHANGED_KIND", g.TYPE_REMOVED_FROM_UNION = "TYPE_REMOVED_FROM_UNION", g.VALUE_REMOVED_FROM_ENUM = "VALUE_REMOVED_FROM_ENUM", g.REQUIRED_INPUT_FIELD_ADDED = "REQUIRED_INPUT_FIELD_ADDED", g.IMPLEMENTED_INTERFACE_REMOVED = "IMPLEMENTED_INTERFACE_REMOVED", g.FIELD_REMOVED = "FIELD_REMOVED", g.FIELD_CHANGED_KIND = "FIELD_CHANGED_KIND", g.REQUIRED_ARG_ADDED = "REQUIRED_ARG_ADDED", g.ARG_REMOVED = "ARG_REMOVED", g.ARG_CHANGED_KIND = "ARG_CHANGED_KIND", g.DIRECTIVE_REMOVED = "DIRECTIVE_REMOVED", g.DIRECTIVE_ARG_REMOVED = "DIRECTIVE_ARG_REMOVED", g.REQUIRED_DIRECTIVE_ARG_ADDED = "REQUIRED_DIRECTIVE_ARG_ADDED", g.DIRECTIVE_REPEATABLE_REMOVED = "DIRECTIVE_REPEATABLE_REMOVED", g.DIRECTIVE_LOCATION_REMOVED = "DIRECTIVE_LOCATION_REMOVED";
  }(
    u || (Ve.BreakingChangeType = u = {})
  );
  var f;
  Ve.DangerousChangeType = f, function(g) {
    g.VALUE_ADDED_TO_ENUM = "VALUE_ADDED_TO_ENUM", g.TYPE_ADDED_TO_UNION = "TYPE_ADDED_TO_UNION", g.OPTIONAL_INPUT_FIELD_ADDED = "OPTIONAL_INPUT_FIELD_ADDED", g.OPTIONAL_ARG_ADDED = "OPTIONAL_ARG_ADDED", g.IMPLEMENTED_INTERFACE_ADDED = "IMPLEMENTED_INTERFACE_ADDED", g.ARG_DEFAULT_VALUE_CHANGE = "ARG_DEFAULT_VALUE_CHANGE";
  }(
    f || (Ve.DangerousChangeType = f = {})
  );
  function y(g, S) {
    return p(g, S).filter(
      (E) => E.type in u
    );
  }
  function o(g, S) {
    return p(g, S).filter(
      (E) => E.type in f
    );
  }
  function p(g, S) {
    return [
      ...l(g, S),
      ...h(g, S)
    ];
  }
  function h(g, S) {
    const E = [], v = N(
      g.getDirectives(),
      S.getDirectives()
    );
    for (const b of v.removed)
      E.push({
        type: u.DIRECTIVE_REMOVED,
        description: `${b.name} was removed.`
      });
    for (const [b, I] of v.persisted) {
      const L = N(b.args, I.args);
      for (const j of L.added)
        (0, t.isRequiredArgument)(j) && E.push({
          type: u.REQUIRED_DIRECTIVE_ARG_ADDED,
          description: `A required arg ${j.name} on directive ${b.name} was added.`
        });
      for (const j of L.removed)
        E.push({
          type: u.DIRECTIVE_ARG_REMOVED,
          description: `${j.name} was removed from ${b.name}.`
        });
      b.isRepeatable && !I.isRepeatable && E.push({
        type: u.DIRECTIVE_REPEATABLE_REMOVED,
        description: `Repeatable flag was removed from ${b.name}.`
      });
      for (const j of b.locations)
        I.locations.includes(j) || E.push({
          type: u.DIRECTIVE_LOCATION_REMOVED,
          description: `${j} was removed from ${b.name}.`
        });
    }
    return E;
  }
  function l(g, S) {
    const E = [], v = N(
      Object.values(g.getTypeMap()),
      Object.values(S.getTypeMap())
    );
    for (const b of v.removed)
      E.push({
        type: u.TYPE_REMOVED,
        description: (0, r.isSpecifiedScalarType)(b) ? `Standard scalar ${b.name} was removed because it is not referenced anymore.` : `${b.name} was removed.`
      });
    for (const [b, I] of v.persisted)
      (0, t.isEnumType)(b) && (0, t.isEnumType)(I) ? E.push(...T(b, I)) : (0, t.isUnionType)(b) && (0, t.isUnionType)(I) ? E.push(...m(b, I)) : (0, t.isInputObjectType)(b) && (0, t.isInputObjectType)(I) ? E.push(...d(b, I)) : (0, t.isObjectType)(b) && (0, t.isObjectType)(I) ? E.push(
        ...R(b, I),
        ...O(b, I)
      ) : (0, t.isInterfaceType)(b) && (0, t.isInterfaceType)(I) ? E.push(
        ...R(b, I),
        ...O(b, I)
      ) : b.constructor !== I.constructor && E.push({
        type: u.TYPE_CHANGED_KIND,
        description: `${b.name} changed from ${$(b)} to ${$(I)}.`
      });
    return E;
  }
  function d(g, S) {
    const E = [], v = N(
      Object.values(g.getFields()),
      Object.values(S.getFields())
    );
    for (const b of v.added)
      (0, t.isRequiredInputField)(b) ? E.push({
        type: u.REQUIRED_INPUT_FIELD_ADDED,
        description: `A required field ${b.name} on input type ${g.name} was added.`
      }) : E.push({
        type: f.OPTIONAL_INPUT_FIELD_ADDED,
        description: `An optional field ${b.name} on input type ${g.name} was added.`
      });
    for (const b of v.removed)
      E.push({
        type: u.FIELD_REMOVED,
        description: `${g.name}.${b.name} was removed.`
      });
    for (const [b, I] of v.persisted)
      w(
        b.type,
        I.type
      ) || E.push({
        type: u.FIELD_CHANGED_KIND,
        description: `${g.name}.${b.name} changed type from ${String(b.type)} to ${String(I.type)}.`
      });
    return E;
  }
  function m(g, S) {
    const E = [], v = N(g.getTypes(), S.getTypes());
    for (const b of v.added)
      E.push({
        type: f.TYPE_ADDED_TO_UNION,
        description: `${b.name} was added to union type ${g.name}.`
      });
    for (const b of v.removed)
      E.push({
        type: u.TYPE_REMOVED_FROM_UNION,
        description: `${b.name} was removed from union type ${g.name}.`
      });
    return E;
  }
  function T(g, S) {
    const E = [], v = N(g.getValues(), S.getValues());
    for (const b of v.added)
      E.push({
        type: f.VALUE_ADDED_TO_ENUM,
        description: `${b.name} was added to enum type ${g.name}.`
      });
    for (const b of v.removed)
      E.push({
        type: u.VALUE_REMOVED_FROM_ENUM,
        description: `${b.name} was removed from enum type ${g.name}.`
      });
    return E;
  }
  function O(g, S) {
    const E = [], v = N(g.getInterfaces(), S.getInterfaces());
    for (const b of v.added)
      E.push({
        type: f.IMPLEMENTED_INTERFACE_ADDED,
        description: `${b.name} added to interfaces implemented by ${g.name}.`
      });
    for (const b of v.removed)
      E.push({
        type: u.IMPLEMENTED_INTERFACE_REMOVED,
        description: `${g.name} no longer implements interface ${b.name}.`
      });
    return E;
  }
  function R(g, S) {
    const E = [], v = N(
      Object.values(g.getFields()),
      Object.values(S.getFields())
    );
    for (const b of v.removed)
      E.push({
        type: u.FIELD_REMOVED,
        description: `${g.name}.${b.name} was removed.`
      });
    for (const [b, I] of v.persisted)
      E.push(...D(g, b, I)), _(
        b.type,
        I.type
      ) || E.push({
        type: u.FIELD_CHANGED_KIND,
        description: `${g.name}.${b.name} changed type from ${String(b.type)} to ${String(I.type)}.`
      });
    return E;
  }
  function D(g, S, E) {
    const v = [], b = N(S.args, E.args);
    for (const I of b.removed)
      v.push({
        type: u.ARG_REMOVED,
        description: `${g.name}.${S.name} arg ${I.name} was removed.`
      });
    for (const [I, L] of b.persisted)
      if (!w(
        I.type,
        L.type
      ))
        v.push({
          type: u.ARG_CHANGED_KIND,
          description: `${g.name}.${S.name} arg ${I.name} has changed type from ${String(I.type)} to ${String(L.type)}.`
        });
      else if (I.defaultValue !== void 0)
        if (L.defaultValue === void 0)
          v.push({
            type: f.ARG_DEFAULT_VALUE_CHANGE,
            description: `${g.name}.${S.name} arg ${I.name} defaultValue was removed.`
          });
        else {
          const V = G(I.defaultValue, I.type), U = G(L.defaultValue, L.type);
          V !== U && v.push({
            type: f.ARG_DEFAULT_VALUE_CHANGE,
            description: `${g.name}.${S.name} arg ${I.name} has changed defaultValue from ${V} to ${U}.`
          });
        }
    for (const I of b.added)
      (0, t.isRequiredArgument)(I) ? v.push({
        type: u.REQUIRED_ARG_ADDED,
        description: `A required arg ${I.name} on ${g.name}.${S.name} was added.`
      }) : v.push({
        type: f.OPTIONAL_ARG_ADDED,
        description: `An optional arg ${I.name} on ${g.name}.${S.name} was added.`
      });
    return v;
  }
  function _(g, S) {
    return (0, t.isListType)(g) ? (
      // if they're both lists, make sure the underlying types are compatible
      (0, t.isListType)(S) && _(
        g.ofType,
        S.ofType
      ) || // moving from nullable to non-null of the same underlying type is safe
      (0, t.isNonNullType)(S) && _(g, S.ofType)
    ) : (0, t.isNonNullType)(g) ? (0, t.isNonNullType)(S) && _(g.ofType, S.ofType) : (
      // if they're both named types, see if their names are equivalent
      (0, t.isNamedType)(S) && g.name === S.name || // moving from nullable to non-null of the same underlying type is safe
      (0, t.isNonNullType)(S) && _(g, S.ofType)
    );
  }
  function w(g, S) {
    return (0, t.isListType)(g) ? (0, t.isListType)(S) && w(g.ofType, S.ofType) : (0, t.isNonNullType)(g) ? (
      // if they're both non-null, make sure the underlying types are
      // compatible
      (0, t.isNonNullType)(S) && w(
        g.ofType,
        S.ofType
      ) || // moving from non-null to nullable of the same underlying type is safe
      !(0, t.isNonNullType)(S) && w(g.ofType, S)
    ) : (0, t.isNamedType)(S) && g.name === S.name;
  }
  function $(g) {
    if ((0, t.isScalarType)(g))
      return "a Scalar type";
    if ((0, t.isObjectType)(g))
      return "an Object type";
    if ((0, t.isInterfaceType)(g))
      return "an Interface type";
    if ((0, t.isUnionType)(g))
      return "a Union type";
    if ((0, t.isEnumType)(g))
      return "an Enum type";
    if ((0, t.isInputObjectType)(g))
      return "an Input type";
    (0, n.invariant)(
      !1,
      "Unexpected type: " + (0, e.inspect)(g)
    );
  }
  function G(g, S) {
    const E = (0, a.astFromValue)(g, S);
    return E != null || (0, n.invariant)(!1), (0, i.print)((0, c.sortValueNode)(E));
  }
  function N(g, S) {
    const E = [], v = [], b = [], I = (0, s.keyMap)(g, ({ name: j }) => j), L = (0, s.keyMap)(S, ({ name: j }) => j);
    for (const j of g) {
      const V = L[j.name];
      V === void 0 ? v.push(j) : b.push([j, V]);
    }
    for (const j of S)
      I[j.name] === void 0 && E.push(j);
    return {
      added: E,
      persisted: b,
      removed: v
    };
  }
  return Ve;
}
var ws;
function Wu() {
  return ws || (ws = 1, function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "BreakingChangeType", {
      enumerable: !0,
      get: function() {
        return _.BreakingChangeType;
      }
    }), Object.defineProperty(e, "DangerousChangeType", {
      enumerable: !0,
      get: function() {
        return _.DangerousChangeType;
      }
    }), Object.defineProperty(e, "TypeInfo", {
      enumerable: !0,
      get: function() {
        return l.TypeInfo;
      }
    }), Object.defineProperty(e, "assertValidName", {
      enumerable: !0,
      get: function() {
        return D.assertValidName;
      }
    }), Object.defineProperty(e, "astFromValue", {
      enumerable: !0,
      get: function() {
        return h.astFromValue;
      }
    }), Object.defineProperty(e, "buildASTSchema", {
      enumerable: !0,
      get: function() {
        return a.buildASTSchema;
      }
    }), Object.defineProperty(e, "buildClientSchema", {
      enumerable: !0,
      get: function() {
        return r.buildClientSchema;
      }
    }), Object.defineProperty(e, "buildSchema", {
      enumerable: !0,
      get: function() {
        return a.buildSchema;
      }
    }), Object.defineProperty(e, "coerceInputValue", {
      enumerable: !0,
      get: function() {
        return d.coerceInputValue;
      }
    }), Object.defineProperty(e, "concatAST", {
      enumerable: !0,
      get: function() {
        return m.concatAST;
      }
    }), Object.defineProperty(e, "doTypesOverlap", {
      enumerable: !0,
      get: function() {
        return R.doTypesOverlap;
      }
    }), Object.defineProperty(e, "extendSchema", {
      enumerable: !0,
      get: function() {
        return c.extendSchema;
      }
    }), Object.defineProperty(e, "findBreakingChanges", {
      enumerable: !0,
      get: function() {
        return _.findBreakingChanges;
      }
    }), Object.defineProperty(e, "findDangerousChanges", {
      enumerable: !0,
      get: function() {
        return _.findDangerousChanges;
      }
    }), Object.defineProperty(e, "getIntrospectionQuery", {
      enumerable: !0,
      get: function() {
        return n.getIntrospectionQuery;
      }
    }), Object.defineProperty(e, "getOperationAST", {
      enumerable: !0,
      get: function() {
        return s.getOperationAST;
      }
    }), Object.defineProperty(e, "getOperationRootType", {
      enumerable: !0,
      get: function() {
        return i.getOperationRootType;
      }
    }), Object.defineProperty(e, "introspectionFromSchema", {
      enumerable: !0,
      get: function() {
        return t.introspectionFromSchema;
      }
    }), Object.defineProperty(e, "isEqualType", {
      enumerable: !0,
      get: function() {
        return R.isEqualType;
      }
    }), Object.defineProperty(e, "isTypeSubTypeOf", {
      enumerable: !0,
      get: function() {
        return R.isTypeSubTypeOf;
      }
    }), Object.defineProperty(e, "isValidNameError", {
      enumerable: !0,
      get: function() {
        return D.isValidNameError;
      }
    }), Object.defineProperty(e, "lexicographicSortSchema", {
      enumerable: !0,
      get: function() {
        return u.lexicographicSortSchema;
      }
    }), Object.defineProperty(e, "printIntrospectionSchema", {
      enumerable: !0,
      get: function() {
        return f.printIntrospectionSchema;
      }
    }), Object.defineProperty(e, "printSchema", {
      enumerable: !0,
      get: function() {
        return f.printSchema;
      }
    }), Object.defineProperty(e, "printType", {
      enumerable: !0,
      get: function() {
        return f.printType;
      }
    }), Object.defineProperty(e, "separateOperations", {
      enumerable: !0,
      get: function() {
        return T.separateOperations;
      }
    }), Object.defineProperty(e, "stripIgnoredCharacters", {
      enumerable: !0,
      get: function() {
        return O.stripIgnoredCharacters;
      }
    }), Object.defineProperty(e, "typeFromAST", {
      enumerable: !0,
      get: function() {
        return y.typeFromAST;
      }
    }), Object.defineProperty(e, "valueFromAST", {
      enumerable: !0,
      get: function() {
        return o.valueFromAST;
      }
    }), Object.defineProperty(e, "valueFromASTUntyped", {
      enumerable: !0,
      get: function() {
        return p.valueFromASTUntyped;
      }
    }), Object.defineProperty(e, "visitWithTypeInfo", {
      enumerable: !0,
      get: function() {
        return l.visitWithTypeInfo;
      }
    });
    var n = /* @__PURE__ */ Vo(), s = /* @__PURE__ */ Cu(), i = /* @__PURE__ */ Uu(), t = /* @__PURE__ */ Qu(), r = /* @__PURE__ */ qu(), a = /* @__PURE__ */ Ku(), c = /* @__PURE__ */ Go(), u = /* @__PURE__ */ Bu(), f = /* @__PURE__ */ xu(), y = /* @__PURE__ */ Xe(), o = /* @__PURE__ */ Fr(), p = /* @__PURE__ */ Js(), h = /* @__PURE__ */ Ar(), l = /* @__PURE__ */ si(), d = /* @__PURE__ */ vo(), m = /* @__PURE__ */ Yu(), T = /* @__PURE__ */ Ju(), O = /* @__PURE__ */ zu(), R = /* @__PURE__ */ Dr(), D = /* @__PURE__ */ Xu(), _ = /* @__PURE__ */ Hu();
  }(Qr)), Qr;
}
var ks;
function Zu() {
  return ks || (ks = 1, function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "BREAK", {
      enumerable: !0,
      get: function() {
        return t.BREAK;
      }
    }), Object.defineProperty(e, "BreakingChangeType", {
      enumerable: !0,
      get: function() {
        return u.BreakingChangeType;
      }
    }), Object.defineProperty(e, "DEFAULT_DEPRECATION_REASON", {
      enumerable: !0,
      get: function() {
        return i.DEFAULT_DEPRECATION_REASON;
      }
    }), Object.defineProperty(e, "DangerousChangeType", {
      enumerable: !0,
      get: function() {
        return u.DangerousChangeType;
      }
    }), Object.defineProperty(e, "DirectiveLocation", {
      enumerable: !0,
      get: function() {
        return t.DirectiveLocation;
      }
    }), Object.defineProperty(e, "ExecutableDefinitionsRule", {
      enumerable: !0,
      get: function() {
        return a.ExecutableDefinitionsRule;
      }
    }), Object.defineProperty(e, "FieldsOnCorrectTypeRule", {
      enumerable: !0,
      get: function() {
        return a.FieldsOnCorrectTypeRule;
      }
    }), Object.defineProperty(e, "FragmentsOnCompositeTypesRule", {
      enumerable: !0,
      get: function() {
        return a.FragmentsOnCompositeTypesRule;
      }
    }), Object.defineProperty(e, "GRAPHQL_MAX_INT", {
      enumerable: !0,
      get: function() {
        return i.GRAPHQL_MAX_INT;
      }
    }), Object.defineProperty(e, "GRAPHQL_MIN_INT", {
      enumerable: !0,
      get: function() {
        return i.GRAPHQL_MIN_INT;
      }
    }), Object.defineProperty(e, "GraphQLBoolean", {
      enumerable: !0,
      get: function() {
        return i.GraphQLBoolean;
      }
    }), Object.defineProperty(e, "GraphQLDeprecatedDirective", {
      enumerable: !0,
      get: function() {
        return i.GraphQLDeprecatedDirective;
      }
    }), Object.defineProperty(e, "GraphQLDirective", {
      enumerable: !0,
      get: function() {
        return i.GraphQLDirective;
      }
    }), Object.defineProperty(e, "GraphQLEnumType", {
      enumerable: !0,
      get: function() {
        return i.GraphQLEnumType;
      }
    }), Object.defineProperty(e, "GraphQLError", {
      enumerable: !0,
      get: function() {
        return c.GraphQLError;
      }
    }), Object.defineProperty(e, "GraphQLFloat", {
      enumerable: !0,
      get: function() {
        return i.GraphQLFloat;
      }
    }), Object.defineProperty(e, "GraphQLID", {
      enumerable: !0,
      get: function() {
        return i.GraphQLID;
      }
    }), Object.defineProperty(e, "GraphQLIncludeDirective", {
      enumerable: !0,
      get: function() {
        return i.GraphQLIncludeDirective;
      }
    }), Object.defineProperty(e, "GraphQLInputObjectType", {
      enumerable: !0,
      get: function() {
        return i.GraphQLInputObjectType;
      }
    }), Object.defineProperty(e, "GraphQLInt", {
      enumerable: !0,
      get: function() {
        return i.GraphQLInt;
      }
    }), Object.defineProperty(e, "GraphQLInterfaceType", {
      enumerable: !0,
      get: function() {
        return i.GraphQLInterfaceType;
      }
    }), Object.defineProperty(e, "GraphQLList", {
      enumerable: !0,
      get: function() {
        return i.GraphQLList;
      }
    }), Object.defineProperty(e, "GraphQLNonNull", {
      enumerable: !0,
      get: function() {
        return i.GraphQLNonNull;
      }
    }), Object.defineProperty(e, "GraphQLObjectType", {
      enumerable: !0,
      get: function() {
        return i.GraphQLObjectType;
      }
    }), Object.defineProperty(e, "GraphQLOneOfDirective", {
      enumerable: !0,
      get: function() {
        return i.GraphQLOneOfDirective;
      }
    }), Object.defineProperty(e, "GraphQLScalarType", {
      enumerable: !0,
      get: function() {
        return i.GraphQLScalarType;
      }
    }), Object.defineProperty(e, "GraphQLSchema", {
      enumerable: !0,
      get: function() {
        return i.GraphQLSchema;
      }
    }), Object.defineProperty(e, "GraphQLSkipDirective", {
      enumerable: !0,
      get: function() {
        return i.GraphQLSkipDirective;
      }
    }), Object.defineProperty(e, "GraphQLSpecifiedByDirective", {
      enumerable: !0,
      get: function() {
        return i.GraphQLSpecifiedByDirective;
      }
    }), Object.defineProperty(e, "GraphQLString", {
      enumerable: !0,
      get: function() {
        return i.GraphQLString;
      }
    }), Object.defineProperty(e, "GraphQLUnionType", {
      enumerable: !0,
      get: function() {
        return i.GraphQLUnionType;
      }
    }), Object.defineProperty(e, "Kind", {
      enumerable: !0,
      get: function() {
        return t.Kind;
      }
    }), Object.defineProperty(e, "KnownArgumentNamesRule", {
      enumerable: !0,
      get: function() {
        return a.KnownArgumentNamesRule;
      }
    }), Object.defineProperty(e, "KnownDirectivesRule", {
      enumerable: !0,
      get: function() {
        return a.KnownDirectivesRule;
      }
    }), Object.defineProperty(e, "KnownFragmentNamesRule", {
      enumerable: !0,
      get: function() {
        return a.KnownFragmentNamesRule;
      }
    }), Object.defineProperty(e, "KnownTypeNamesRule", {
      enumerable: !0,
      get: function() {
        return a.KnownTypeNamesRule;
      }
    }), Object.defineProperty(e, "Lexer", {
      enumerable: !0,
      get: function() {
        return t.Lexer;
      }
    }), Object.defineProperty(e, "Location", {
      enumerable: !0,
      get: function() {
        return t.Location;
      }
    }), Object.defineProperty(e, "LoneAnonymousOperationRule", {
      enumerable: !0,
      get: function() {
        return a.LoneAnonymousOperationRule;
      }
    }), Object.defineProperty(e, "LoneSchemaDefinitionRule", {
      enumerable: !0,
      get: function() {
        return a.LoneSchemaDefinitionRule;
      }
    }), Object.defineProperty(e, "MaxIntrospectionDepthRule", {
      enumerable: !0,
      get: function() {
        return a.MaxIntrospectionDepthRule;
      }
    }), Object.defineProperty(e, "NoDeprecatedCustomRule", {
      enumerable: !0,
      get: function() {
        return a.NoDeprecatedCustomRule;
      }
    }), Object.defineProperty(e, "NoFragmentCyclesRule", {
      enumerable: !0,
      get: function() {
        return a.NoFragmentCyclesRule;
      }
    }), Object.defineProperty(e, "NoSchemaIntrospectionCustomRule", {
      enumerable: !0,
      get: function() {
        return a.NoSchemaIntrospectionCustomRule;
      }
    }), Object.defineProperty(e, "NoUndefinedVariablesRule", {
      enumerable: !0,
      get: function() {
        return a.NoUndefinedVariablesRule;
      }
    }), Object.defineProperty(e, "NoUnusedFragmentsRule", {
      enumerable: !0,
      get: function() {
        return a.NoUnusedFragmentsRule;
      }
    }), Object.defineProperty(e, "NoUnusedVariablesRule", {
      enumerable: !0,
      get: function() {
        return a.NoUnusedVariablesRule;
      }
    }), Object.defineProperty(e, "OperationTypeNode", {
      enumerable: !0,
      get: function() {
        return t.OperationTypeNode;
      }
    }), Object.defineProperty(e, "OverlappingFieldsCanBeMergedRule", {
      enumerable: !0,
      get: function() {
        return a.OverlappingFieldsCanBeMergedRule;
      }
    }), Object.defineProperty(e, "PossibleFragmentSpreadsRule", {
      enumerable: !0,
      get: function() {
        return a.PossibleFragmentSpreadsRule;
      }
    }), Object.defineProperty(e, "PossibleTypeExtensionsRule", {
      enumerable: !0,
      get: function() {
        return a.PossibleTypeExtensionsRule;
      }
    }), Object.defineProperty(e, "ProvidedRequiredArgumentsRule", {
      enumerable: !0,
      get: function() {
        return a.ProvidedRequiredArgumentsRule;
      }
    }), Object.defineProperty(e, "ScalarLeafsRule", {
      enumerable: !0,
      get: function() {
        return a.ScalarLeafsRule;
      }
    }), Object.defineProperty(e, "SchemaMetaFieldDef", {
      enumerable: !0,
      get: function() {
        return i.SchemaMetaFieldDef;
      }
    }), Object.defineProperty(e, "SingleFieldSubscriptionsRule", {
      enumerable: !0,
      get: function() {
        return a.SingleFieldSubscriptionsRule;
      }
    }), Object.defineProperty(e, "Source", {
      enumerable: !0,
      get: function() {
        return t.Source;
      }
    }), Object.defineProperty(e, "Token", {
      enumerable: !0,
      get: function() {
        return t.Token;
      }
    }), Object.defineProperty(e, "TokenKind", {
      enumerable: !0,
      get: function() {
        return t.TokenKind;
      }
    }), Object.defineProperty(e, "TypeInfo", {
      enumerable: !0,
      get: function() {
        return u.TypeInfo;
      }
    }), Object.defineProperty(e, "TypeKind", {
      enumerable: !0,
      get: function() {
        return i.TypeKind;
      }
    }), Object.defineProperty(e, "TypeMetaFieldDef", {
      enumerable: !0,
      get: function() {
        return i.TypeMetaFieldDef;
      }
    }), Object.defineProperty(e, "TypeNameMetaFieldDef", {
      enumerable: !0,
      get: function() {
        return i.TypeNameMetaFieldDef;
      }
    }), Object.defineProperty(e, "UniqueArgumentDefinitionNamesRule", {
      enumerable: !0,
      get: function() {
        return a.UniqueArgumentDefinitionNamesRule;
      }
    }), Object.defineProperty(e, "UniqueArgumentNamesRule", {
      enumerable: !0,
      get: function() {
        return a.UniqueArgumentNamesRule;
      }
    }), Object.defineProperty(e, "UniqueDirectiveNamesRule", {
      enumerable: !0,
      get: function() {
        return a.UniqueDirectiveNamesRule;
      }
    }), Object.defineProperty(e, "UniqueDirectivesPerLocationRule", {
      enumerable: !0,
      get: function() {
        return a.UniqueDirectivesPerLocationRule;
      }
    }), Object.defineProperty(e, "UniqueEnumValueNamesRule", {
      enumerable: !0,
      get: function() {
        return a.UniqueEnumValueNamesRule;
      }
    }), Object.defineProperty(e, "UniqueFieldDefinitionNamesRule", {
      enumerable: !0,
      get: function() {
        return a.UniqueFieldDefinitionNamesRule;
      }
    }), Object.defineProperty(e, "UniqueFragmentNamesRule", {
      enumerable: !0,
      get: function() {
        return a.UniqueFragmentNamesRule;
      }
    }), Object.defineProperty(e, "UniqueInputFieldNamesRule", {
      enumerable: !0,
      get: function() {
        return a.UniqueInputFieldNamesRule;
      }
    }), Object.defineProperty(e, "UniqueOperationNamesRule", {
      enumerable: !0,
      get: function() {
        return a.UniqueOperationNamesRule;
      }
    }), Object.defineProperty(e, "UniqueOperationTypesRule", {
      enumerable: !0,
      get: function() {
        return a.UniqueOperationTypesRule;
      }
    }), Object.defineProperty(e, "UniqueTypeNamesRule", {
      enumerable: !0,
      get: function() {
        return a.UniqueTypeNamesRule;
      }
    }), Object.defineProperty(e, "UniqueVariableNamesRule", {
      enumerable: !0,
      get: function() {
        return a.UniqueVariableNamesRule;
      }
    }), Object.defineProperty(e, "ValidationContext", {
      enumerable: !0,
      get: function() {
        return a.ValidationContext;
      }
    }), Object.defineProperty(e, "ValuesOfCorrectTypeRule", {
      enumerable: !0,
      get: function() {
        return a.ValuesOfCorrectTypeRule;
      }
    }), Object.defineProperty(e, "VariablesAreInputTypesRule", {
      enumerable: !0,
      get: function() {
        return a.VariablesAreInputTypesRule;
      }
    }), Object.defineProperty(e, "VariablesInAllowedPositionRule", {
      enumerable: !0,
      get: function() {
        return a.VariablesInAllowedPositionRule;
      }
    }), Object.defineProperty(e, "__Directive", {
      enumerable: !0,
      get: function() {
        return i.__Directive;
      }
    }), Object.defineProperty(e, "__DirectiveLocation", {
      enumerable: !0,
      get: function() {
        return i.__DirectiveLocation;
      }
    }), Object.defineProperty(e, "__EnumValue", {
      enumerable: !0,
      get: function() {
        return i.__EnumValue;
      }
    }), Object.defineProperty(e, "__Field", {
      enumerable: !0,
      get: function() {
        return i.__Field;
      }
    }), Object.defineProperty(e, "__InputValue", {
      enumerable: !0,
      get: function() {
        return i.__InputValue;
      }
    }), Object.defineProperty(e, "__Schema", {
      enumerable: !0,
      get: function() {
        return i.__Schema;
      }
    }), Object.defineProperty(e, "__Type", {
      enumerable: !0,
      get: function() {
        return i.__Type;
      }
    }), Object.defineProperty(e, "__TypeKind", {
      enumerable: !0,
      get: function() {
        return i.__TypeKind;
      }
    }), Object.defineProperty(e, "assertAbstractType", {
      enumerable: !0,
      get: function() {
        return i.assertAbstractType;
      }
    }), Object.defineProperty(e, "assertCompositeType", {
      enumerable: !0,
      get: function() {
        return i.assertCompositeType;
      }
    }), Object.defineProperty(e, "assertDirective", {
      enumerable: !0,
      get: function() {
        return i.assertDirective;
      }
    }), Object.defineProperty(e, "assertEnumType", {
      enumerable: !0,
      get: function() {
        return i.assertEnumType;
      }
    }), Object.defineProperty(e, "assertEnumValueName", {
      enumerable: !0,
      get: function() {
        return i.assertEnumValueName;
      }
    }), Object.defineProperty(e, "assertInputObjectType", {
      enumerable: !0,
      get: function() {
        return i.assertInputObjectType;
      }
    }), Object.defineProperty(e, "assertInputType", {
      enumerable: !0,
      get: function() {
        return i.assertInputType;
      }
    }), Object.defineProperty(e, "assertInterfaceType", {
      enumerable: !0,
      get: function() {
        return i.assertInterfaceType;
      }
    }), Object.defineProperty(e, "assertLeafType", {
      enumerable: !0,
      get: function() {
        return i.assertLeafType;
      }
    }), Object.defineProperty(e, "assertListType", {
      enumerable: !0,
      get: function() {
        return i.assertListType;
      }
    }), Object.defineProperty(e, "assertName", {
      enumerable: !0,
      get: function() {
        return i.assertName;
      }
    }), Object.defineProperty(e, "assertNamedType", {
      enumerable: !0,
      get: function() {
        return i.assertNamedType;
      }
    }), Object.defineProperty(e, "assertNonNullType", {
      enumerable: !0,
      get: function() {
        return i.assertNonNullType;
      }
    }), Object.defineProperty(e, "assertNullableType", {
      enumerable: !0,
      get: function() {
        return i.assertNullableType;
      }
    }), Object.defineProperty(e, "assertObjectType", {
      enumerable: !0,
      get: function() {
        return i.assertObjectType;
      }
    }), Object.defineProperty(e, "assertOutputType", {
      enumerable: !0,
      get: function() {
        return i.assertOutputType;
      }
    }), Object.defineProperty(e, "assertScalarType", {
      enumerable: !0,
      get: function() {
        return i.assertScalarType;
      }
    }), Object.defineProperty(e, "assertSchema", {
      enumerable: !0,
      get: function() {
        return i.assertSchema;
      }
    }), Object.defineProperty(e, "assertType", {
      enumerable: !0,
      get: function() {
        return i.assertType;
      }
    }), Object.defineProperty(e, "assertUnionType", {
      enumerable: !0,
      get: function() {
        return i.assertUnionType;
      }
    }), Object.defineProperty(e, "assertValidName", {
      enumerable: !0,
      get: function() {
        return u.assertValidName;
      }
    }), Object.defineProperty(e, "assertValidSchema", {
      enumerable: !0,
      get: function() {
        return i.assertValidSchema;
      }
    }), Object.defineProperty(e, "assertWrappingType", {
      enumerable: !0,
      get: function() {
        return i.assertWrappingType;
      }
    }), Object.defineProperty(e, "astFromValue", {
      enumerable: !0,
      get: function() {
        return u.astFromValue;
      }
    }), Object.defineProperty(e, "buildASTSchema", {
      enumerable: !0,
      get: function() {
        return u.buildASTSchema;
      }
    }), Object.defineProperty(e, "buildClientSchema", {
      enumerable: !0,
      get: function() {
        return u.buildClientSchema;
      }
    }), Object.defineProperty(e, "buildSchema", {
      enumerable: !0,
      get: function() {
        return u.buildSchema;
      }
    }), Object.defineProperty(e, "coerceInputValue", {
      enumerable: !0,
      get: function() {
        return u.coerceInputValue;
      }
    }), Object.defineProperty(e, "concatAST", {
      enumerable: !0,
      get: function() {
        return u.concatAST;
      }
    }), Object.defineProperty(e, "createSourceEventStream", {
      enumerable: !0,
      get: function() {
        return r.createSourceEventStream;
      }
    }), Object.defineProperty(e, "defaultFieldResolver", {
      enumerable: !0,
      get: function() {
        return r.defaultFieldResolver;
      }
    }), Object.defineProperty(e, "defaultTypeResolver", {
      enumerable: !0,
      get: function() {
        return r.defaultTypeResolver;
      }
    }), Object.defineProperty(e, "doTypesOverlap", {
      enumerable: !0,
      get: function() {
        return u.doTypesOverlap;
      }
    }), Object.defineProperty(e, "execute", {
      enumerable: !0,
      get: function() {
        return r.execute;
      }
    }), Object.defineProperty(e, "executeSync", {
      enumerable: !0,
      get: function() {
        return r.executeSync;
      }
    }), Object.defineProperty(e, "extendSchema", {
      enumerable: !0,
      get: function() {
        return u.extendSchema;
      }
    }), Object.defineProperty(e, "findBreakingChanges", {
      enumerable: !0,
      get: function() {
        return u.findBreakingChanges;
      }
    }), Object.defineProperty(e, "findDangerousChanges", {
      enumerable: !0,
      get: function() {
        return u.findDangerousChanges;
      }
    }), Object.defineProperty(e, "formatError", {
      enumerable: !0,
      get: function() {
        return c.formatError;
      }
    }), Object.defineProperty(e, "getArgumentValues", {
      enumerable: !0,
      get: function() {
        return r.getArgumentValues;
      }
    }), Object.defineProperty(e, "getDirectiveValues", {
      enumerable: !0,
      get: function() {
        return r.getDirectiveValues;
      }
    }), Object.defineProperty(e, "getEnterLeaveForKind", {
      enumerable: !0,
      get: function() {
        return t.getEnterLeaveForKind;
      }
    }), Object.defineProperty(e, "getIntrospectionQuery", {
      enumerable: !0,
      get: function() {
        return u.getIntrospectionQuery;
      }
    }), Object.defineProperty(e, "getLocation", {
      enumerable: !0,
      get: function() {
        return t.getLocation;
      }
    }), Object.defineProperty(e, "getNamedType", {
      enumerable: !0,
      get: function() {
        return i.getNamedType;
      }
    }), Object.defineProperty(e, "getNullableType", {
      enumerable: !0,
      get: function() {
        return i.getNullableType;
      }
    }), Object.defineProperty(e, "getOperationAST", {
      enumerable: !0,
      get: function() {
        return u.getOperationAST;
      }
    }), Object.defineProperty(e, "getOperationRootType", {
      enumerable: !0,
      get: function() {
        return u.getOperationRootType;
      }
    }), Object.defineProperty(e, "getVariableValues", {
      enumerable: !0,
      get: function() {
        return r.getVariableValues;
      }
    }), Object.defineProperty(e, "getVisitFn", {
      enumerable: !0,
      get: function() {
        return t.getVisitFn;
      }
    }), Object.defineProperty(e, "graphql", {
      enumerable: !0,
      get: function() {
        return s.graphql;
      }
    }), Object.defineProperty(e, "graphqlSync", {
      enumerable: !0,
      get: function() {
        return s.graphqlSync;
      }
    }), Object.defineProperty(e, "introspectionFromSchema", {
      enumerable: !0,
      get: function() {
        return u.introspectionFromSchema;
      }
    }), Object.defineProperty(e, "introspectionTypes", {
      enumerable: !0,
      get: function() {
        return i.introspectionTypes;
      }
    }), Object.defineProperty(e, "isAbstractType", {
      enumerable: !0,
      get: function() {
        return i.isAbstractType;
      }
    }), Object.defineProperty(e, "isCompositeType", {
      enumerable: !0,
      get: function() {
        return i.isCompositeType;
      }
    }), Object.defineProperty(e, "isConstValueNode", {
      enumerable: !0,
      get: function() {
        return t.isConstValueNode;
      }
    }), Object.defineProperty(e, "isDefinitionNode", {
      enumerable: !0,
      get: function() {
        return t.isDefinitionNode;
      }
    }), Object.defineProperty(e, "isDirective", {
      enumerable: !0,
      get: function() {
        return i.isDirective;
      }
    }), Object.defineProperty(e, "isEnumType", {
      enumerable: !0,
      get: function() {
        return i.isEnumType;
      }
    }), Object.defineProperty(e, "isEqualType", {
      enumerable: !0,
      get: function() {
        return u.isEqualType;
      }
    }), Object.defineProperty(e, "isExecutableDefinitionNode", {
      enumerable: !0,
      get: function() {
        return t.isExecutableDefinitionNode;
      }
    }), Object.defineProperty(e, "isInputObjectType", {
      enumerable: !0,
      get: function() {
        return i.isInputObjectType;
      }
    }), Object.defineProperty(e, "isInputType", {
      enumerable: !0,
      get: function() {
        return i.isInputType;
      }
    }), Object.defineProperty(e, "isInterfaceType", {
      enumerable: !0,
      get: function() {
        return i.isInterfaceType;
      }
    }), Object.defineProperty(e, "isIntrospectionType", {
      enumerable: !0,
      get: function() {
        return i.isIntrospectionType;
      }
    }), Object.defineProperty(e, "isLeafType", {
      enumerable: !0,
      get: function() {
        return i.isLeafType;
      }
    }), Object.defineProperty(e, "isListType", {
      enumerable: !0,
      get: function() {
        return i.isListType;
      }
    }), Object.defineProperty(e, "isNamedType", {
      enumerable: !0,
      get: function() {
        return i.isNamedType;
      }
    }), Object.defineProperty(e, "isNonNullType", {
      enumerable: !0,
      get: function() {
        return i.isNonNullType;
      }
    }), Object.defineProperty(e, "isNullableType", {
      enumerable: !0,
      get: function() {
        return i.isNullableType;
      }
    }), Object.defineProperty(e, "isObjectType", {
      enumerable: !0,
      get: function() {
        return i.isObjectType;
      }
    }), Object.defineProperty(e, "isOutputType", {
      enumerable: !0,
      get: function() {
        return i.isOutputType;
      }
    }), Object.defineProperty(e, "isRequiredArgument", {
      enumerable: !0,
      get: function() {
        return i.isRequiredArgument;
      }
    }), Object.defineProperty(e, "isRequiredInputField", {
      enumerable: !0,
      get: function() {
        return i.isRequiredInputField;
      }
    }), Object.defineProperty(e, "isScalarType", {
      enumerable: !0,
      get: function() {
        return i.isScalarType;
      }
    }), Object.defineProperty(e, "isSchema", {
      enumerable: !0,
      get: function() {
        return i.isSchema;
      }
    }), Object.defineProperty(e, "isSelectionNode", {
      enumerable: !0,
      get: function() {
        return t.isSelectionNode;
      }
    }), Object.defineProperty(e, "isSpecifiedDirective", {
      enumerable: !0,
      get: function() {
        return i.isSpecifiedDirective;
      }
    }), Object.defineProperty(e, "isSpecifiedScalarType", {
      enumerable: !0,
      get: function() {
        return i.isSpecifiedScalarType;
      }
    }), Object.defineProperty(e, "isType", {
      enumerable: !0,
      get: function() {
        return i.isType;
      }
    }), Object.defineProperty(e, "isTypeDefinitionNode", {
      enumerable: !0,
      get: function() {
        return t.isTypeDefinitionNode;
      }
    }), Object.defineProperty(e, "isTypeExtensionNode", {
      enumerable: !0,
      get: function() {
        return t.isTypeExtensionNode;
      }
    }), Object.defineProperty(e, "isTypeNode", {
      enumerable: !0,
      get: function() {
        return t.isTypeNode;
      }
    }), Object.defineProperty(e, "isTypeSubTypeOf", {
      enumerable: !0,
      get: function() {
        return u.isTypeSubTypeOf;
      }
    }), Object.defineProperty(e, "isTypeSystemDefinitionNode", {
      enumerable: !0,
      get: function() {
        return t.isTypeSystemDefinitionNode;
      }
    }), Object.defineProperty(e, "isTypeSystemExtensionNode", {
      enumerable: !0,
      get: function() {
        return t.isTypeSystemExtensionNode;
      }
    }), Object.defineProperty(e, "isUnionType", {
      enumerable: !0,
      get: function() {
        return i.isUnionType;
      }
    }), Object.defineProperty(e, "isValidNameError", {
      enumerable: !0,
      get: function() {
        return u.isValidNameError;
      }
    }), Object.defineProperty(e, "isValueNode", {
      enumerable: !0,
      get: function() {
        return t.isValueNode;
      }
    }), Object.defineProperty(e, "isWrappingType", {
      enumerable: !0,
      get: function() {
        return i.isWrappingType;
      }
    }), Object.defineProperty(e, "lexicographicSortSchema", {
      enumerable: !0,
      get: function() {
        return u.lexicographicSortSchema;
      }
    }), Object.defineProperty(e, "locatedError", {
      enumerable: !0,
      get: function() {
        return c.locatedError;
      }
    }), Object.defineProperty(e, "parse", {
      enumerable: !0,
      get: function() {
        return t.parse;
      }
    }), Object.defineProperty(e, "parseConstValue", {
      enumerable: !0,
      get: function() {
        return t.parseConstValue;
      }
    }), Object.defineProperty(e, "parseType", {
      enumerable: !0,
      get: function() {
        return t.parseType;
      }
    }), Object.defineProperty(e, "parseValue", {
      enumerable: !0,
      get: function() {
        return t.parseValue;
      }
    }), Object.defineProperty(e, "print", {
      enumerable: !0,
      get: function() {
        return t.print;
      }
    }), Object.defineProperty(e, "printError", {
      enumerable: !0,
      get: function() {
        return c.printError;
      }
    }), Object.defineProperty(e, "printIntrospectionSchema", {
      enumerable: !0,
      get: function() {
        return u.printIntrospectionSchema;
      }
    }), Object.defineProperty(e, "printLocation", {
      enumerable: !0,
      get: function() {
        return t.printLocation;
      }
    }), Object.defineProperty(e, "printSchema", {
      enumerable: !0,
      get: function() {
        return u.printSchema;
      }
    }), Object.defineProperty(e, "printSourceLocation", {
      enumerable: !0,
      get: function() {
        return t.printSourceLocation;
      }
    }), Object.defineProperty(e, "printType", {
      enumerable: !0,
      get: function() {
        return u.printType;
      }
    }), Object.defineProperty(e, "recommendedRules", {
      enumerable: !0,
      get: function() {
        return a.recommendedRules;
      }
    }), Object.defineProperty(e, "resolveObjMapThunk", {
      enumerable: !0,
      get: function() {
        return i.resolveObjMapThunk;
      }
    }), Object.defineProperty(e, "resolveReadonlyArrayThunk", {
      enumerable: !0,
      get: function() {
        return i.resolveReadonlyArrayThunk;
      }
    }), Object.defineProperty(e, "responsePathAsArray", {
      enumerable: !0,
      get: function() {
        return r.responsePathAsArray;
      }
    }), Object.defineProperty(e, "separateOperations", {
      enumerable: !0,
      get: function() {
        return u.separateOperations;
      }
    }), Object.defineProperty(e, "specifiedDirectives", {
      enumerable: !0,
      get: function() {
        return i.specifiedDirectives;
      }
    }), Object.defineProperty(e, "specifiedRules", {
      enumerable: !0,
      get: function() {
        return a.specifiedRules;
      }
    }), Object.defineProperty(e, "specifiedScalarTypes", {
      enumerable: !0,
      get: function() {
        return i.specifiedScalarTypes;
      }
    }), Object.defineProperty(e, "stripIgnoredCharacters", {
      enumerable: !0,
      get: function() {
        return u.stripIgnoredCharacters;
      }
    }), Object.defineProperty(e, "subscribe", {
      enumerable: !0,
      get: function() {
        return r.subscribe;
      }
    }), Object.defineProperty(e, "syntaxError", {
      enumerable: !0,
      get: function() {
        return c.syntaxError;
      }
    }), Object.defineProperty(e, "typeFromAST", {
      enumerable: !0,
      get: function() {
        return u.typeFromAST;
      }
    }), Object.defineProperty(e, "validate", {
      enumerable: !0,
      get: function() {
        return a.validate;
      }
    }), Object.defineProperty(e, "validateSchema", {
      enumerable: !0,
      get: function() {
        return i.validateSchema;
      }
    }), Object.defineProperty(e, "valueFromAST", {
      enumerable: !0,
      get: function() {
        return u.valueFromAST;
      }
    }), Object.defineProperty(e, "valueFromASTUntyped", {
      enumerable: !0,
      get: function() {
        return u.valueFromASTUntyped;
      }
    }), Object.defineProperty(e, "version", {
      enumerable: !0,
      get: function() {
        return n.version;
      }
    }), Object.defineProperty(e, "versionInfo", {
      enumerable: !0,
      get: function() {
        return n.versionInfo;
      }
    }), Object.defineProperty(e, "visit", {
      enumerable: !0,
      get: function() {
        return t.visit;
      }
    }), Object.defineProperty(e, "visitInParallel", {
      enumerable: !0,
      get: function() {
        return t.visitInParallel;
      }
    }), Object.defineProperty(e, "visitWithTypeInfo", {
      enumerable: !0,
      get: function() {
        return u.visitWithTypeInfo;
      }
    });
    var n = /* @__PURE__ */ _u(), s = /* @__PURE__ */ Au(), i = /* @__PURE__ */ ju(), t = /* @__PURE__ */ Pu(), r = /* @__PURE__ */ Vu(), a = /* @__PURE__ */ $u(), c = /* @__PURE__ */ Ou(), u = /* @__PURE__ */ Wu();
  }(Gr)), Gr;
}
var ec = /* @__PURE__ */ Zu();
const nc = "$[Circular Reference]", tc = /* @__PURE__ */ new Set([
  "properties",
  "items",
  "additionalProperties",
  "allOf",
  "anyOf",
  "oneOf"
]), Br = (e, n = /* @__PURE__ */ new WeakSet(), s = /* @__PURE__ */ new WeakMap(), i = []) => {
  if (e === null || typeof e != "object") return e;
  if (n.has(e)) {
    const r = s.get(e);
    if (r) return r;
    const a = i.find((c) => !tc.has(c)) || i[0];
    return [nc, a].filter(Boolean).join(":");
  }
  if (n.add(e), Array.isArray(e)) {
    const r = e.map(
      (a, c) => Br(a, n, s, [...i, c.toString()])
    );
    return s.set(e, r), r;
  }
  const t = {};
  for (const [r, a] of Object.entries(e))
    t[r] = Br(a, n, s, [...i, r]);
  return s.set(e, t), t;
}, hc = new ec.GraphQLScalarType({
  ...bi,
  name: "JSONSchema",
  description: "OpenAPI schema scalar type that handles circular references",
  serialize: (e) => bi.serialize(Br(e))
});
export {
  uc as A,
  Vs as B,
  nc as C,
  Jo as D,
  Xo as E,
  Wo as F,
  zr as G,
  zo as H,
  Gs as I,
  du as J,
  ye as K,
  iu as L,
  ic as M,
  xr as N,
  hu as O,
  vu as P,
  gu as Q,
  Ou as R,
  bi as S,
  fc as T,
  hc as U,
  Nn as a,
  Ms as b,
  Qn as c,
  Nr as d,
  pu as e,
  Ce as f,
  mu as g,
  yu as h,
  oc as i,
  Yr as j,
  ac as k,
  Kn as l,
  fu as m,
  lu as n,
  bu as o,
  gr as p,
  Un as q,
  qn as r,
  lc as s,
  $e as t,
  uu as u,
  pc as v,
  cc as w,
  cu as x,
  dc as y,
  sc as z
};
//# sourceMappingURL=circular-06Yrxzsw.js.map
