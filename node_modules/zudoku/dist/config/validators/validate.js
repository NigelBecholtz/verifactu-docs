import colors from "picocolors";
import { isValidElement } from "react";
import { z } from "zod";
import { GOOGLE_FONTS } from "../../vite/plugin-theme.js";
import { InputNavigationSchema } from "./InputNavigationSchema.js";
import { ProtectedRoutesSchema } from "./ProtectedRoutesSchema.js";
const ThemeSchema = z
    .object({
    background: z.string(),
    foreground: z.string(),
    card: z.string(),
    cardForeground: z.string(),
    popover: z.string(),
    popoverForeground: z.string(),
    primary: z.string(),
    primaryForeground: z.string(),
    secondary: z.string(),
    secondaryForeground: z.string(),
    muted: z.string(),
    mutedForeground: z.string(),
    accent: z.string(),
    accentForeground: z.string(),
    destructive: z.string(),
    destructiveForeground: z.string(),
    border: z.string(),
    input: z.string(),
    ring: z.string(),
    radius: z.string(),
})
    .partial();
const ApiCatalogCategorySchema = z.object({
    label: z.string(),
    tags: z.array(z.string()),
});
const ApiOptionsSchema = z
    .object({
    examplesLanguage: z.string(),
    disablePlayground: z.boolean(),
    disableSidecar: z.boolean(),
    showVersionSelect: z.enum(["always", "if-available", "hide"]),
    expandAllTags: z.boolean(),
    expandApiInformation: z.boolean(),
    transformExamples: z.custom((val) => typeof val === "function"),
})
    .partial();
const ApiConfigSchema = z
    .object({
    server: z.string(),
    path: z.string(),
    categories: z.array(ApiCatalogCategorySchema),
    options: ApiOptionsSchema,
})
    .partial();
const ApiSchema = z.discriminatedUnion("type", [
    z.object({
        type: z.literal("url"),
        input: z.string(),
        ...ApiConfigSchema.shape,
    }),
    z.object({
        type: z.literal("file"),
        input: z.union([z.string(), z.array(z.string())]),
        ...ApiConfigSchema.shape,
    }),
    z.object({
        type: z.literal("raw"),
        input: z.string(),
        ...ApiConfigSchema.shape,
    }),
]);
const ApiKeysSchema = z.object({
    enabled: z.boolean(),
    getKeys: z
        .custom((val) => typeof val === "function")
        .optional(),
    rollKey: z
        .custom((val) => typeof val === "function")
        .optional(),
    deleteKey: z
        .custom((val) => typeof val === "function")
        .optional(),
    updateKeyDescription: z
        .custom((val) => typeof val === "function")
        .optional(),
    createKey: z
        .custom((val) => typeof val === "function")
        .optional(),
});
const LogoSchema = z.object({
    src: z.object({ light: z.string(), dark: z.string() }),
    alt: z.string().optional(),
    width: z.string().or(z.number()).optional(),
    href: z.string().optional(),
});
export const FooterSocialIcons = [
    "reddit",
    "discord",
    "github",
    "x",
    "linkedin",
    "facebook",
    "instagram",
    "youtube",
    "tiktok",
    "twitch",
    "pinterest",
    "snapchat",
    "whatsapp",
    "telegram",
];
export const FooterSocialSchema = z.object({
    label: z.string().optional(),
    href: z.string(),
    icon: z
        .union([
        z.enum(FooterSocialIcons),
        z.custom((val) => isValidElement(val)),
    ])
        .optional(),
});
export const FooterSchema = z
    .object({
    columns: z
        .array(z.object({
        position: z.enum(["start", "center", "end"]).optional(),
        title: z.string(),
        links: z.array(z.object({ label: z.string(), href: z.string() })),
    }))
        .optional(),
    social: z.array(FooterSocialSchema).optional(),
    copyright: z.string().optional(),
    logo: LogoSchema.optional(),
    position: z.enum(["start", "center", "end"]).optional(),
})
    .optional();
const SiteMapSchema = z
    .object({
    /**
     * Base url of your website
     */
    siteUrl: z.string(),
    /**
     * Change frequency.
     * @default 'daily'
     */
    changefreq: z.optional(z.enum([
        "always",
        "hourly",
        "daily",
        "weekly",
        "monthly",
        "yearly",
        "never",
    ])),
    /**
     * Priority
     * @default 0.7
     */
    priority: z.optional(z.number()),
    outDir: z.string().optional(),
    /**
     * Add <lastmod/> property.
     * @default true
     */
    autoLastmod: z.boolean().optional(),
    /**
     * Array of relative paths to exclude from listing on sitemap.xml or sitemap-*.xml.
     * @example ['/page-0', '/page/example']
     */
    exclude: z
        .union([
        z.custom((val) => typeof val === "function"),
        z.array(z.string()),
    ])
        .optional(),
})
    .optional();
const DEFAULT_DOCS_FILES = "/pages/**/*.{md,mdx}";
export const DocsConfigSchema = z.object({
    files: z
        .union([z.string(), z.array(z.string())])
        .transform((val) => (typeof val === "string" ? [val] : val))
        .default([DEFAULT_DOCS_FILES]),
    defaultOptions: z
        .object({
        toc: z.boolean(),
        disablePager: z.boolean(),
        showLastModified: z.boolean(),
        suggestEdit: z
            .object({
            url: z.string(),
            text: z.string().optional(),
        })
            .optional(),
    })
        .partial()
        .optional(),
});
const Redirect = z.object({
    from: z.string(),
    to: z.string(),
});
const SearchSchema = z
    .discriminatedUnion("type", [
    // looseObject to allow additional properties so the
    // user can set other inkeep settings
    z.looseObject({
        type: z.literal("inkeep"),
        apiKey: z.string(),
        integrationId: z.string(),
        organizationId: z.string(),
        primaryBrandColor: z.string(),
        organizationDisplayName: z.string(),
    }),
    z.object({
        type: z.literal("pagefind"),
        ranking: z
            .object({
            termFrequency: z.number(),
            pageLength: z.number(),
            termSimilarity: z.number(),
            termSaturation: z.number(),
        })
            .optional(),
        maxResults: z.number().optional(),
        maxSubResults: z.number().optional(),
        transformResults: z
            .custom((val) => typeof val === "function")
            .optional(),
    }),
])
    .optional();
const AuthenticationSchema = z.discriminatedUnion("type", [
    z.object({
        type: z.literal("clerk"),
        clerkPubKey: z
            .custom()
            .refine((val) => /^pk_(test|live)_\w+$/.test(val), {
            message: "Clerk public key invalid, must start with pk_test or pk_live",
        }),
        jwtTemplateName: z.string().optional().default("dev-portal"),
        redirectToAfterSignUp: z.string().optional(),
        redirectToAfterSignIn: z.string().optional(),
        redirectToAfterSignOut: z.string().optional(),
    }),
    z.object({
        type: z.literal("openid"),
        clientId: z.string(),
        issuer: z.string(),
        audience: z.string().optional(),
        scopes: z.array(z.string()).optional(),
        redirectToAfterSignUp: z.string().optional(),
        redirectToAfterSignIn: z.string().optional(),
        redirectToAfterSignOut: z.string().optional(),
    }),
    z.object({
        type: z.literal("azureb2c"),
        clientId: z.string(),
        tenantName: z.string(),
        policyName: z.string(),
        scopes: z.array(z.string()).optional(),
        issuer: z.string(),
        redirectToAfterSignUp: z.string().optional(),
        redirectToAfterSignIn: z.string().optional(),
        redirectToAfterSignOut: z.string().optional(),
    }),
    z.object({
        type: z.literal("auth0"),
        clientId: z.string(),
        domain: z.string().refine((val) => {
            if (val.startsWith("http://") || val.startsWith("https://")) {
                return false;
            }
            if (val.includes("/")) {
                return false;
            }
            return val.includes(".") && val.length > 0;
        }, {
            message: "Domain must be a host only (e.g., 'example.com') without protocol or slashes",
        }),
        audience: z.string().optional(),
        scopes: z.array(z.string()).optional(),
        redirectToAfterSignUp: z.string().optional(),
        redirectToAfterSignIn: z.string().optional(),
        redirectToAfterSignOut: z.string().optional(),
    }),
    z.object({
        type: z.literal("supabase"),
        supabaseUrl: z.string(),
        supabaseKey: z.string(),
        provider: z.enum([
            "google",
            "github",
            "gitlab",
            "bitbucket",
            "facebook",
            "twitter",
        ]),
        redirectToAfterSignUp: z.string().optional(),
        redirectToAfterSignIn: z.string().optional(),
        redirectToAfterSignOut: z.string().optional(),
    }),
]);
const MetadataSchema = z
    .object({
    title: z.string(),
    defaultTitle: z.string().optional(),
    description: z.string(),
    logo: z.string(),
    favicon: z.string(),
    generator: z.string(),
    applicationName: z.string(),
    referrer: z.string(),
    keywords: z.array(z.string()),
    authors: z.array(z.string()),
    creator: z.string(),
    publisher: z.string(),
})
    .partial();
const FontConfigSchema = z.union([
    z.enum(GOOGLE_FONTS),
    z.object({
        url: z.string(),
        fontFamily: z.string().optional(),
    }),
]);
const FontsConfigSchema = z.object({
    sans: FontConfigSchema.optional(),
    serif: FontConfigSchema.optional(),
    mono: FontConfigSchema.optional(),
});
const CssObject = z.record(z.string(), z.lazy(() => z.union([
    z.string(),
    z.record(z.string(), z.union([z.string(), z.record(z.string(), z.string())])),
])));
const ThemeConfigSchema = z.object({
    registryUrl: z.string().url().optional(),
    customCss: z.union([z.string(), CssObject]).optional(),
    light: ThemeSchema.optional(),
    dark: ThemeSchema.optional(),
    fonts: FontsConfigSchema.optional(),
    noDefaultTheme: z.boolean().optional(),
});
const SiteSchema = z
    .object({
    title: z.string(),
    logoUrl: z.string(),
    dir: z.enum(["ltr", "rtl"]).optional(),
    logo: LogoSchema,
    showPoweredBy: z.boolean().optional(),
    banner: z.object({
        message: z.custom(),
        color: z
            .custom((val) => typeof val === "string")
            .optional(),
        dismissible: z.boolean().optional(),
    }),
    footer: FooterSchema,
})
    .partial();
const ApiCatalogSchema = z.object({
    path: z.string(),
    label: z.string(),
    items: z.array(z.string()).optional(),
    filterItems: z
        .custom((val) => typeof val === "function")
        .optional(),
});
export const CdnUrlSchema = z
    .union([
    z.string(),
    z.object({
        base: z.string().optional(),
        media: z.string().optional(),
    }),
])
    .transform((val) => {
    if (typeof val === "string") {
        return { base: val, media: val };
    }
    return { base: val.base, media: val.media };
})
    .optional();
const BaseConfigSchema = z.object({
    slots: z.record(z.string(), z.custom()),
    /**
     * @deprecated Use `slots` instead
     */
    UNSAFE_slotlets: z.record(z.string(), z.custom()),
    mdx: z
        .object({
        components: z.custom(),
    })
        .partial(),
    customPages: z.array(z.object({
        path: z.string(),
        element: z.custom().optional(),
        render: z.custom().optional(),
        prose: z.boolean().optional(),
    })),
    plugins: z.array(z.custom()),
    build: z.custom(),
    protectedRoutes: ProtectedRoutesSchema,
    basePath: z.string().optional(),
    canonicalUrlOrigin: z.string().optional(),
    cdnUrl: CdnUrlSchema.optional(),
    port: z.number().optional(),
    https: z
        .object({
        key: z.string(),
        cert: z.string(),
        ca: z.string().optional(),
    })
        .optional(),
    site: SiteSchema,
    navigation: InputNavigationSchema,
    theme: ThemeConfigSchema,
    syntaxHighlighting: z
        .object({
        languages: z.array(z.custom()),
        themes: z.object({
            light: z.custom(),
            dark: z.custom(),
        }),
    })
        .partial()
        .optional(),
    metadata: MetadataSchema,
    authentication: AuthenticationSchema,
    search: SearchSchema,
    docs: DocsConfigSchema.optional(),
    apis: z.union([ApiSchema, z.array(ApiSchema)]),
    catalogs: z.union([ApiCatalogSchema, z.array(ApiCatalogSchema)]),
    apiKeys: ApiKeysSchema,
    redirects: z.array(Redirect),
    sitemap: SiteMapSchema,
    enableStatusPages: z.boolean().optional(),
    defaults: z.object({
        apis: ApiOptionsSchema,
        /**
         * @deprecated Use `apis.examplesLanguage` or `defaults.apis.examplesLanguage` instead
         */
        examplesLanguage: z.string().optional(),
    }),
});
export const ZudokuConfig = BaseConfigSchema.partial();
export function validateConfig(config, configPath) {
    const validationResult = ZudokuConfig.safeParse(config);
    if (!validationResult.success) {
        // In production (build mode), throw an error to fail the build
        if (process.env.NODE_ENV === "production") {
            throw new Error(`Whoops, looks like there's an issue with your ${configPath ?? "config"}:\n${z.prettifyError(validationResult.error)}`);
        }
        // In development mode, log warnings but don't fail
        // biome-ignore lint/suspicious/noConsole: Logging allowed here
        console.log(colors.yellow("Validation errors:"));
        // biome-ignore lint/suspicious/noConsole: Logging allowed here
        console.log(colors.yellow(z.prettifyError(validationResult.error)));
    }
}
//# sourceMappingURL=validate.js.map