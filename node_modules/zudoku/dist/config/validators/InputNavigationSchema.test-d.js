// biome-ignore-all lint/suspicious/noExplicitAny: Allow any type
// biome-ignore-all lint/style/noNonNullAssertion: Allow it
import { assertType, describe, expectTypeOf, it } from "vitest";
describe("InputNavigationSchema types", () => {
    it("infers correct types for navigation items", () => {
        // Test that TypeScript correctly infers the types using satisfies
        const docString = "path/to/doc.md";
        const docObject = {
            type: "doc",
            file: "path/to/doc.md",
            label: "My Doc",
            icon: "book",
            badge: { label: "New", color: "green" },
            display: "always",
        };
        const linkObject = {
            type: "link",
            label: "External Link",
            to: "https://example.com",
            icon: "external-link",
            badge: { label: "External", color: "blue" },
            display: "auth",
        };
        const customPage = {
            type: "custom-page",
            path: "/custom",
            label: "Custom Page",
            element: null,
            icon: "star",
            badge: { label: "Custom", color: "purple" },
            display: "anon",
        };
        // Test that these are assignable to InputNavigationItem
        assertType(docString);
        assertType(docObject);
        assertType(linkObject);
        assertType(customPage);
    });
    it("prevents items array from being unknown[]", () => {
        // Core test: ensure items are properly typed
        const category = {
            type: "category",
            label: "Test Category",
            items: [
                "doc.md",
                { type: "doc", file: "test.md" },
                { type: "link", label: "Link", to: "https://example.com" },
                { type: "category", label: "Nested", items: ["nested.md"] },
            ],
        };
        // Key assertions - items must be InputNavigationItem[], not unknown[]
        assertType(category.items);
        expectTypeOf(category.items).not.toEqualTypeOf();
        expectTypeOf(category.items).not.toEqualTypeOf();
    });
    it("validates nested structure maintains type safety", () => {
        const navigation = [
            {
                type: "category",
                label: "Parent",
                items: [
                    {
                        type: "category",
                        label: "Child",
                        items: ["nested.md", { type: "doc", file: "nested.md" }],
                    },
                ],
            },
        ];
        const parent = navigation[0];
        assertType(parent.items);
        const child = parent.items[0];
        assertType(child.items);
        expectTypeOf(child.items).not.toEqualTypeOf();
    });
    it("validates union types work correctly", () => {
        // Test that all valid types are assignable
        assertType("doc.md");
        assertType({ type: "doc", file: "test.md" });
        assertType({ type: "link", label: "Link", to: "/" });
        assertType({
            type: "category",
            label: "C",
            items: [],
        });
        // Test type constraints
        expectTypeOf().toEqualTypeOf();
        expectTypeOf().not.toEqualTypeOf();
        expectTypeOf().not.toEqualTypeOf();
    });
    it("validates individual type exports", () => {
        const doc = {
            type: "doc",
            file: "test.md",
            label: "Test Doc",
        };
        assertType(doc);
        const link = {
            type: "link",
            label: "Test Link",
            to: "https://example.com",
        };
        assertType(link);
        const customPage = {
            type: "custom-page",
            path: "/test",
            label: "Test Page",
            element: null,
        };
        assertType(customPage);
        const category = {
            type: "category",
            label: "Test Category",
            items: ["test.md"],
        };
        assertType(category);
        assertType(category.items);
    });
    it("validates constrained properties", () => {
        const validDisplayValues = ["auth", "anon", "always", "hide"];
        for (const display of validDisplayValues) {
            const item = {
                type: "doc",
                file: "test.md",
                display,
            };
            assertType(item);
        }
    });
    it("rejects invalid types", () => {
        // Test that invalid values fail at compile time
        // @ts-expect-error - number not assignable to InputNavigationItem
        assertType(0);
        // @ts-expect-error - missing required 'file' property
        assertType({ type: "doc" });
        // @ts-expect-error - missing required 'href' property
        assertType({ type: "link", label: "Invalid Link" });
        assertType({
            type: "category",
            label: "Test",
            // @ts-expect-error - items should not accept unknown[]
            items: [],
        });
    });
});
//# sourceMappingURL=InputNavigationSchema.test-d.js.map