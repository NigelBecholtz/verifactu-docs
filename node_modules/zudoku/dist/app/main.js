import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { configuredApiKeysPlugin } from "virtual:zudoku-api-keys-plugin";
import { configuredApiCatalogPlugins, configuredApiPlugins, } from "virtual:zudoku-api-plugins";
import { configuredAuthProvider } from "virtual:zudoku-auth";
import { configuredCustomPagesPlugin } from "virtual:zudoku-custom-pages-plugin";
import { configuredDocsPlugin } from "virtual:zudoku-docs-plugin";
import { configuredNavigation } from "virtual:zudoku-navigation";
import { configuredRedirectPlugin } from "virtual:zudoku-redirect-plugin";
import { configuredSearchPlugin } from "virtual:zudoku-search-plugin";
import { registerShiki } from "virtual:zudoku-shiki-register";
import "virtual:zudoku-theme.css";
import { BuildCheck, Layout, Meta, RouteGuard, RouterError, StatusPage, } from "zudoku/__internal";
import { Zudoku } from "zudoku/components";
import { Outlet } from "zudoku/router";
import { isNavigationPlugin } from "../lib/core/plugins.js";
import { highlighter } from "../lib/shiki.js";
import { ZuploEnv } from "./env.js";
import "./main.css";
await registerShiki(highlighter);
export const convertZudokuConfigToOptions = (config) => {
    return {
        basePath: config.basePath,
        canonicalUrlOrigin: config.canonicalUrlOrigin,
        protectedRoutes: config.protectedRoutes,
        site: {
            ...config.site,
            showPoweredBy: ZuploEnv.buildConfig?.entitlements.devPortalZuploBranding ??
                config.site?.showPoweredBy,
            logo: config.site?.logo,
        },
        slots: config.slots,
        metadata: {
            favicon: "https://cdn.zudoku.dev/logos/favicon.svg",
            title: "%s - Zudoku",
            ...config.metadata,
        },
        navigation: configuredNavigation,
        mdx: config.mdx,
        plugins: [
            ...(configuredAuthProvider ? [configuredAuthProvider] : []),
            ...(configuredDocsPlugin ? [configuredDocsPlugin] : []),
            ...configuredApiPlugins,
            ...(configuredSearchPlugin ? [configuredSearchPlugin] : []),
            ...(configuredRedirectPlugin ? [configuredRedirectPlugin] : []),
            ...(configuredApiKeysPlugin ? [configuredApiKeysPlugin] : []),
            ...(configuredCustomPagesPlugin ? [configuredCustomPagesPlugin] : []),
            ...configuredApiCatalogPlugins,
            ...(config.plugins ?? []),
        ],
        syntaxHighlighting: {
            highlighter,
            themes: config.syntaxHighlighting?.themes,
        },
    };
};
export const getRoutesByOptions = (options, enableStatusPages = true) => {
    const allPlugins = [
        ...(options.plugins ?? []),
        ...(options.authentication ? [options.authentication] : []),
    ];
    const routes = allPlugins
        .flatMap((plugin) => (isNavigationPlugin(plugin) ? plugin.getRoutes() : []))
        .concat(enableStatusPages
        ? [400, 404, 500].map((statusCode) => ({
            path: `/${statusCode}`,
            element: _jsx(StatusPage, { statusCode: statusCode }),
        }))
        : [])
        .concat([{ path: "*", element: _jsx(StatusPage, { statusCode: 404 }) }]);
    // @TODO Detect conflicts in routes and log warning
    return routes;
};
export const getRoutesByConfig = (config) => {
    const options = convertZudokuConfigToOptions(config);
    const routes = getRoutesByOptions(options, import.meta.env.IS_ZUPLO || config.enableStatusPages);
    return [
        {
            element: (_jsxs(Zudoku, { ...options, children: [_jsx(BuildCheck, { buildId: import.meta.env.ZUPLO_BUILD_ID, environmentType: import.meta.env.ZUPLO_ENVIRONMENT_TYPE }), _jsx(Outlet, {})] })),
            hydrateFallbackElement: _jsx("div", { children: "Loading..." }),
            children: [
                {
                    element: (_jsx(Meta, { children: _jsx(RouteGuard, {}) })),
                    errorElement: _jsx(RouterError, {}),
                    children: routes.map((r) => r.handle?.layout === "none" ? r : wrapWithLayout(r)),
                },
            ],
        },
    ];
};
const wrapWithLayout = (route) => {
    return {
        element: _jsx(Layout, {}),
        children: [route],
    };
};
//# sourceMappingURL=main.js.map