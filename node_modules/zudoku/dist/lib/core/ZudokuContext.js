import { createNanoEvents } from "nanoevents";
import { useAuthState } from "../authentication/state.js";
import { joinUrl } from "../util/joinUrl.js";
import { objectEntries } from "../util/objectEntries.js";
import { isApiIdentityPlugin, isAuthenticationPlugin, isEventConsumerPlugin, isNavigationPlugin, isProfileMenuPlugin, needsInitialization, } from "./plugins.js";
export const transformProtectedRoutes = (val) => {
    if (!val)
        return undefined;
    if (Array.isArray(val)) {
        return Object.fromEntries(val.map((route) => [
            route,
            (c) => c.auth.isAuthenticated,
        ]));
    }
    return val;
};
export class ZudokuContext {
    plugins;
    navigation;
    meta;
    site;
    authentication;
    queryClient;
    options;
    navigationPlugins;
    emitter = createNanoEvents();
    constructor(options, queryClient) {
        const pluginProtectedRoutes = Object.fromEntries((options.plugins ?? []).flatMap((plugin) => {
            if (!isNavigationPlugin(plugin))
                return [];
            const routes = plugin.getProtectedRoutes?.();
            if (!routes)
                return [];
            return Object.entries(transformProtectedRoutes(routes) ?? {});
        }));
        const protectedRoutes = {
            ...pluginProtectedRoutes,
            ...transformProtectedRoutes(options.protectedRoutes),
        };
        this.queryClient = queryClient;
        this.options = { ...options, protectedRoutes };
        this.plugins = options.plugins ?? [];
        this.navigation = options.navigation ?? [];
        this.navigationPlugins = this.plugins.filter(isNavigationPlugin);
        this.authentication = this.plugins.find(isAuthenticationPlugin);
        this.meta = options.metadata;
        this.site = options.site;
        this.plugins.forEach((plugin) => {
            if (!isEventConsumerPlugin(plugin))
                return;
            objectEntries(plugin.events).forEach(([event, handler]) => {
                // biome-ignore lint/style/noNonNullAssertion: handler is guaranteed to be defined
                this.emitter.on(event, handler);
            });
        });
        useAuthState.subscribe((state, prevState) => {
            this.emitEvent("auth", {
                prev: prevState,
                next: state,
            });
        });
    }
    initialize = async () => {
        await Promise.all(this.plugins
            .filter(needsInitialization)
            .map((plugin) => plugin.initialize?.(this)));
    };
    getApiIdentities = async () => {
        const keys = await Promise.all(this.plugins
            .filter(isApiIdentityPlugin)
            .map((plugin) => plugin.getIdentities(this)));
        return keys.flat();
    };
    addEventListener(event, callback) {
        return this.emitter.on(event, callback);
    }
    emitEvent = (event, ...data) => {
        return this.emitter.emit(event, ...data);
    };
    getPluginNavigation = async (path) => {
        const navigations = await Promise.all(this.navigationPlugins.map((plugin) => plugin.getNavigation?.(joinUrl(path), this)));
        return navigations.flatMap((nav) => nav ?? []);
    };
    getProfileMenuItems = () => {
        const accountItems = this.plugins
            .filter((p) => isProfileMenuPlugin(p))
            .flatMap((p) => p.getProfileMenuItems(this))
            .sort(sortByCategory(["top", "middle", "bottom"]))
            .sort((i) => i.weight ?? 0);
        return accountItems;
    };
    signRequest = async (request) => {
        if (!this.authentication) {
            throw new Error("No authentication provider configured");
        }
        return await this.authentication.signRequest(request);
    };
}
const sortByCategory = (categories) => (a, b) => {
    const aIndex = categories.indexOf(a.category ?? "middle");
    const bIndex = categories.indexOf(b.category ?? "middle");
    return aIndex - bIndex;
};
//# sourceMappingURL=ZudokuContext.js.map