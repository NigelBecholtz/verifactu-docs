export const traverse = (specification, transform, path = []) => {
    const transformed = transform(specification, path);
    if (typeof transformed !== "object" || transformed === null) {
        return transformed;
    }
    const result = Array.isArray(transformed) ? [] : {};
    for (const [key, value] of Object.entries(transformed)) {
        const currentPath = [...path, key];
        if (Array.isArray(value)) {
            result[key] = value.map((item, index) => typeof item === "object" && item != null
                ? traverse(item, transform, [...currentPath, index.toString()])
                : item);
        }
        else if (typeof value === "object" && value != null) {
            result[key] = traverse(value, transform, currentPath);
        }
        else {
            result[key] = value;
        }
    }
    return result;
};
export const traverseAsync = async (specification, transform, path = []) => {
    const transformed = await transform(specification, path);
    if (typeof transformed !== "object" || transformed === null) {
        return transformed;
    }
    const result = Array.isArray(transformed) ? [] : {};
    for (const [key, value] of Object.entries(transformed)) {
        const currentPath = [...path, key];
        if (Array.isArray(value)) {
            result[key] = await Promise.all(value.map(async (item, index) => typeof item === "object" && item != null
                ? await traverseAsync(item, transform, [
                    ...currentPath,
                    index.toString(),
                ])
                : item));
        }
        else if (typeof value === "object" && value != null) {
            result[key] = await traverseAsync(value, transform, currentPath);
        }
        else {
            result[key] = value;
        }
    }
    return result;
};
//# sourceMappingURL=traverse.js.map