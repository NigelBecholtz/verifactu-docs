import { jsx as _jsx } from "react/jsx-runtime";
import { createContext, Fragment, use, useMemo, useRef, } from "react";
import { createStore, useStore } from "zustand";
import { useExposedProps, } from "../../util/useExposedProps.js";
const createSlotStore = ({ slots = {}, } = {}) => {
    const initialItems = new Map(Object.entries(slots).map(([id, content]) => [
        id,
        [{ id, content, type: "replace", sequence: 0 }],
    ]));
    const EMPTY_ITEMS = [];
    return createStore()((set, get) => ({
        items: initialItems,
        sequences: new Map(),
        getItems: (name) => get().items.get(name) ?? EMPTY_ITEMS,
        setSlot: (id, name, content, type) => set((state) => {
            if (content == null)
                return state;
            const items = new Map(state.items);
            const sequences = new Map(state.sequences);
            const existing = items.get(name) ?? [];
            const filtered = existing.filter((item) => item.id !== id);
            const currentSequence = sequences.get(name) ?? 0;
            const newSequence = currentSequence + 1;
            sequences.set(name, newSequence);
            const newItem = {
                id,
                content,
                type,
                // Use negative sequence values for "prepend" to ensure they are sorted before positive values for "append".
                sequence: type === "prepend" ? -newSequence : newSequence,
            };
            if (type === "replace") {
                const nonReplaceItems = filtered.filter((item) => item.type !== "replace");
                items.set(name, [...nonReplaceItems, newItem]);
            }
            else {
                items.set(name, [...filtered, newItem]);
            }
            return { items, sequences };
        }),
        clearSlot: (id, name) => set((state) => {
            const items = new Map(state.items);
            const sequences = new Map(state.sequences);
            const existing = items.get(name) ?? [];
            const filtered = existing.filter((item) => item.id !== id);
            if (filtered.length === 0) {
                items.delete(name);
                sequences.delete(name);
            }
            else {
                items.set(name, filtered);
            }
            return { items, sequences };
        }),
    }));
};
const SlotContext = createContext(createSlotStore());
export const SlotProvider = ({ children, slots, }) => {
    const store = useRef(createSlotStore({ slots })).current;
    return _jsx(SlotContext, { value: store, children: children });
};
export function useSlotContext(selector) {
    const store = use(SlotContext);
    return useStore(store, selector);
}
const ORDER = ["prepend", "replace", "append"];
export const useRenderSlot = (name) => {
    const exposedProps = useExposedProps();
    const items = useSlotContext((s) => s.getItems(name));
    return useMemo(() => {
        if (items.length === 0)
            return [];
        return items
            .toSorted((a, b) => {
            const typeOrder = ORDER.indexOf(a.type) - ORDER.indexOf(b.type);
            if (typeOrder !== 0)
                return typeOrder;
            return a.sequence - b.sequence;
        })
            .map((item) => typeof item.content === "function" ? (_jsx(item.content, { ...exposedProps }, item.id)) : (_jsx(Fragment, { children: item.content }, item.id)));
    }, [items, exposedProps]);
};
//# sourceMappingURL=SlotProvider.js.map