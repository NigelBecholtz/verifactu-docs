import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useCallback, useLayoutEffect, useRef } from "react";
import { humanFileSize } from "../../../../util/humanFileSize.js";
const ResponseCodeCircle = ({ status }) => {
    if (!status)
        return _jsx("div", { className: "w-2 h-2 rounded-full bg-gray-500" });
    switch (Number(status.toString().slice(0, 1))) {
        case 2:
            return _jsx("div", { className: "w-2 h-2 rounded-full bg-green-500" });
        case 4:
            return _jsx("div", { className: "w-2 h-2 rounded-full bg-yellow-400" });
        case 5:
            return _jsx("div", { className: "w-2 h-2 rounded-full bg-red-500" });
        default:
            return _jsx("div", { className: "w-2 h-2 rounded-full bg-gray-500" });
    }
};
const RealTimeCounter = () => {
    const spanRef = useRef(null);
    const textRef = useRef(null);
    const startTimeRef = useRef(Date.now());
    const animationFrameRef = useRef(null);
    const updateTime = useCallback(() => {
        if (textRef.current) {
            const elapsed = Date.now() - startTimeRef.current;
            textRef.current.nodeValue = elapsed.toFixed();
        }
        animationFrameRef.current = requestAnimationFrame(updateTime);
    }, []);
    useLayoutEffect(() => {
        const currentSpanRef = spanRef.current;
        if (!currentSpanRef)
            return;
        // Create a text node and attach it to the span
        const textNode = document.createTextNode("0");
        currentSpanRef.appendChild(textNode);
        textRef.current = textNode;
        // Start the real-time counter
        startTimeRef.current = Date.now();
        animationFrameRef.current = requestAnimationFrame(updateTime);
        return () => {
            if (animationFrameRef.current) {
                cancelAnimationFrame(animationFrameRef.current);
            }
            if (textRef.current && currentSpanRef.contains(textNode)) {
                currentSpanRef.removeChild(textNode);
            }
        };
    }, [updateTime]);
    return _jsx("span", { className: "inline-block text-end w-[3ch]", ref: spanRef });
};
export const ResponseStatusBar = ({ status, time, size, isFinished, progress, }) => {
    const statusCodeMap = {
        200: "OK",
        201: "Created",
        202: "Accepted",
        204: "No Content",
        400: "Bad Request",
        401: "Unauthorized",
        403: "Forbidden",
        404: "Not Found",
        405: "Method Not Allowed",
        500: "Internal Server Error",
    };
    return (_jsxs("div", { className: "relative flex h-10 text-xs gap-4 px-4 items-center justify-between font-mono border-b", children: [_jsxs("div", { className: "flex items-center gap-2", children: [_jsx(ResponseCodeCircle, { status: status }), " ", status ?? "Sending Request...", status ? ` ${statusCodeMap[status]}` : ""] }), _jsxs("div", { className: "flex gap-2", children: [_jsxs("div", { children: [_jsx("span", { className: "text-muted-foreground", children: "Size" }), " ", _jsx("span", { className: "inline-block text-end min-w-[5ch]", children: size ? humanFileSize(size) : "- B" })] }), _jsxs("div", { children: [_jsx("span", { className: "text-muted-foreground", children: "Time" }), " ", time !== undefined ? `${time.toFixed(0)}` : _jsx(RealTimeCounter, {}), "ms"] })] }), _jsx("div", { className: "h-full bg-neutral-500/10 absolute left-0 -bottom-0 z-10 transition-all duration-200 ease-in-out", style: {
                    opacity: isFinished ? 0 : 1,
                    width: isFinished ? 0 : `${progress * 100}%`,
                } })] }));
};
export default ResponseStatusBar;
//# sourceMappingURL=ResponseStatusBar.js.map