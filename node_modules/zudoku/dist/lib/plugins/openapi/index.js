import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { CirclePlayIcon, LogInIcon } from "lucide-react";
import { matchPath } from "react-router";
import { useAuth } from "../../authentication/hook.js";
import { Button } from "../../ui/Button.js";
import { joinUrl } from "../../util/joinUrl.js";
import { GraphQLClient } from "./client/GraphQLClient.js";
import { createQuery } from "./client/useCreateQuery.js";
import { graphql } from "./graphql/index.js";
import { PlaygroundDialog } from "./playground/PlaygroundDialog.js";
import { createNavigationCategory } from "./util/createNavigationCategory.js";
import { getRoutes, getVersions } from "./util/getRoutes.js";
export const GetNavigationOperationsQuery = graphql(`
  query GetNavigationOperations($input: JSON!, $type: SchemaType!) {
    schema(input: $input, type: $type) {
      extensions
      tags {
        slug
        name
        extensions
        operations {
          summary
          slug
          method
          operationId
          path
        }
      }
      components {
        schemas {
          __typename
        }
      }
    }
  }
`);
export const UNTAGGED_PATH = "~endpoints";
export const openApiPlugin = (config) => {
    const basePath = joinUrl(config.path);
    const client = new GraphQLClient(config);
    return {
        getHead: () => {
            if (config.type === "url" && !config.skipPreload) {
                return (_jsx("link", { rel: "preload", href: config.input, as: "fetch", crossOrigin: "anonymous" }));
            }
            if (config.server) {
                return _jsx("link", { rel: "preconnect", href: config.server });
            }
        },
        getMdxComponents: () => ({
            OpenPlaygroundButton: ({ requireAuth, server, method, url, children, ...props }) => {
                const auth = useAuth();
                if (!server) {
                    throw new Error("Server is required");
                }
                if (requireAuth && !auth.isAuthenticated) {
                    return (_jsxs(Button, { className: "gap-2 items-center", variant: "outline", onClick: auth.login, children: ["Login to open in Playground ", _jsx(LogInIcon, { size: 16 })] }));
                }
                return (_jsx(PlaygroundDialog, { url: url ?? "/", method: method ?? "get", server: server, ...props, children: _jsx(Button, { className: "gap-2 items-center", variant: "outline", children: children ?? (_jsxs(_Fragment, { children: ["Open in Playground ", _jsx(CirclePlayIcon, { size: 16 })] })) }) }));
            },
        }),
        getNavigation: async (path, context) => {
            if (!matchPath({ path: basePath, end: false }, path)) {
                return [];
            }
            const match = matchPath({ path: `${basePath}/:version?/:tag`, end: true }, path);
            try {
                const versionParam = match?.params.version;
                const version = versionParam ?? getVersions(config).at(0);
                const { type } = config;
                // biome-ignore lint/style/noNonNullAssertion: version is guaranteed to be defined
                const input = type === "file" ? config.input[version] : config.input;
                const query = createQuery(client, GetNavigationOperationsQuery, {
                    type,
                    input,
                });
                const data = await context.queryClient.ensureQueryData(query);
                const tagCategories = new Map(data.schema.tags
                    .filter((tag) => tag.name && tag.operations.length > 0)
                    .map((tag) => {
                    if (!tag.name) {
                        throw new Error(`Tag ${tag.slug} has no name`);
                    }
                    const categoryPath = joinUrl(basePath, versionParam, tag.slug);
                    const isCollapsed = tag.extensions?.["x-zudoku-collapsed"] ??
                        !config.options?.expandAllTags;
                    const isCollapsible = tag.extensions?.["x-zudoku-collapsible"] ?? true;
                    return [
                        tag.name,
                        createNavigationCategory({
                            label: tag.extensions?.["x-displayName"] ?? tag.name,
                            path: categoryPath,
                            operations: tag.operations,
                            collapsed: isCollapsed,
                            collapsible: isCollapsible,
                        }),
                    ];
                }));
                const tagGroups = data.schema.extensions?.["x-tagGroups"] ?? [];
                const groupedTags = new Set(tagGroups.flatMap((group) => group.tags.filter((name) => tagCategories.has(name))));
                const groupedCategories = tagGroups.flatMap((group) => {
                    const items = group.tags
                        .map((name) => tagCategories.get(name))
                        .filter(Boolean);
                    if (items.length === 0) {
                        return [];
                    }
                    return [
                        {
                            type: "category",
                            label: group.name,
                            items,
                            collapsible: true,
                            collapsed: !config.options?.expandAllTags,
                        },
                    ];
                });
                const categories = [
                    ...groupedCategories,
                    ...Array.from(tagCategories.entries())
                        .filter(([name]) => !groupedTags.has(name))
                        .map(([, cat]) => cat),
                ];
                const untaggedOperations = data.schema.tags.find((tag) => !tag.name)?.operations;
                if (untaggedOperations) {
                    categories.push(createNavigationCategory({
                        label: categories.length === 0 ? "Endpoints" : "Other endpoints",
                        path: joinUrl(basePath, versionParam, UNTAGGED_PATH),
                        operations: untaggedOperations,
                        collapsed: !config.options?.expandAllTags,
                    }));
                }
                if (data.schema.components?.schemas?.length) {
                    categories.push({
                        type: "link",
                        label: "Schemas",
                        to: joinUrl(basePath, versionParam, "~schemas"),
                    });
                }
                return categories;
            }
            catch {
                return [];
            }
        },
        getRoutes: () => getRoutes({ basePath, config, client }),
    };
};
//# sourceMappingURL=index.js.map