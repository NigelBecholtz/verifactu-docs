import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useMutation, useQueryClient, useSuspenseQuery, } from "@tanstack/react-query";
import { CheckIcon, CircleSlashIcon, PencilLineIcon, RefreshCwIcon, TrashIcon, XIcon, } from "lucide-react";
import { AnimatePresence } from "motion/react";
import React, { useState } from "react";
import { Alert, AlertTitle } from "zudoku/ui/Alert.js";
import { Card, CardHeader } from "zudoku/ui/Card.js";
import { Dialog, DialogClose, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle, DialogTrigger, } from "zudoku/ui/Dialog.js";
import { Secret } from "zudoku/ui/Secret.js";
import { useZudoku } from "../../components/context/ZudokuContext.js";
import { Slot } from "../../components/Slot.js";
import { Button } from "../../ui/Button.js";
import { Input } from "../../ui/Input.js";
import { cn } from "../../util/cn.js";
import { CreateApiKeyDialog } from "./CreateApiKeyDialog.js";
export const SettingsApiKeys = ({ service }) => {
    const context = useZudoku();
    const queryClient = useQueryClient();
    const [editingConsumerId, setEditingConsumerId] = useState(null);
    const [editingLabel, setEditingLabel] = useState("");
    const { data, isFetching } = useSuspenseQuery({
        queryFn: () => service.getConsumers(context),
        queryKey: ["api-keys"],
        retry: false,
    });
    const [isCreateApiKeyOpen, setIsCreateApiKeyOpen] = useState(false);
    const deleteKeyMutation = useMutation({
        mutationFn: ({ consumerId, keyId, }) => {
            if (!service.deleteKey) {
                throw new Error("deleteKey not implemented");
            }
            return service.deleteKey(consumerId, keyId, context);
        },
        onMutate: async ({ consumerId, keyId }) => {
            await queryClient.cancelQueries({ queryKey: ["api-keys"] });
            const previousData = queryClient.getQueryData([
                "api-keys",
            ]);
            queryClient.setQueryData(["api-keys"], (old) => {
                if (!old) {
                    return old;
                }
                return old.map((consumer) => {
                    if (consumer.id === consumerId) {
                        return {
                            ...consumer,
                            apiKeys: consumer.apiKeys.filter((key) => key.id !== keyId),
                        };
                    }
                    return consumer;
                });
            });
            return { previousData };
        },
        onError: (_err, _variables, context) => {
            if (context?.previousData) {
                queryClient.setQueryData(["api-keys"], context.previousData);
            }
        },
        onSuccess: () => {
            void queryClient.invalidateQueries({ queryKey: ["api-keys"] });
        },
    });
    const updateConsumerMutation = useMutation({
        mutationFn: ({ consumerId, label, }) => {
            if (!service.updateConsumer) {
                throw new Error("updateConsumer not implemented");
            }
            return service.updateConsumer({ id: consumerId, label }, context);
        },
        onMutate: async ({ consumerId, label }) => {
            await queryClient.cancelQueries({ queryKey: ["api-keys"] });
            const previousData = queryClient.getQueryData(["api-keys"]);
            queryClient.setQueryData(["api-keys"], (old) => {
                if (!old) {
                    return old;
                }
                return old.map((consumer) => {
                    if (consumer.id === consumerId) {
                        return {
                            ...consumer,
                            label,
                        };
                    }
                    return consumer;
                });
            });
            return { previousData };
        },
        onError: (_err, _variables, context) => {
            if (context?.previousData) {
                queryClient.setQueryData(["api-keys"], context.previousData);
            }
        },
        onSuccess: () => {
            void queryClient.invalidateQueries({ queryKey: ["api-keys"] });
        },
    });
    const rollKeyMutation = useMutation({
        mutationFn: (id) => {
            if (!service.rollKey) {
                throw new Error("rollKey not implemented");
            }
            return service.rollKey(id, context);
        },
        onSuccess: () => queryClient.invalidateQueries({ queryKey: ["api-keys"] }),
    });
    const handleStartEdit = (consumerId, currentLabel) => {
        setEditingConsumerId(consumerId);
        setEditingLabel(currentLabel);
    };
    const handleSaveEdit = (consumerId) => {
        if (editingLabel.trim()) {
            updateConsumerMutation.mutate({
                consumerId,
                label: editingLabel.trim(),
            });
        }
        setEditingConsumerId(null);
        setEditingLabel("");
    };
    const handleCancelEdit = () => {
        setEditingConsumerId(null);
        setEditingLabel("");
    };
    return (_jsxs("div", { className: "max-w-screen-md h-full pt-(--padding-content-top) pb-(--padding-content-bottom)", children: [_jsx(Slot.Target, { name: "api-keys-list-page" }), _jsxs("div", { className: "flex justify-between pb-3", children: [_jsx("h1", { className: "font-medium text-2xl", children: "API Keys" }), service.createKey && (_jsx(CreateApiKeyDialog, { service: service, isOpen: isCreateApiKeyOpen, onOpenChange: setIsCreateApiKeyOpen }))] }), _jsx("p", { children: "Create, manage, and monitor your API keys" }), _jsx(Slot.Target, { name: "api-keys-list-page-before-keys" }), _jsx("div", { className: "h-8" }), rollKeyMutation.isError && (_jsxs(Alert, { variant: "destructive", className: "mb-4", children: [_jsx(CircleSlashIcon, { size: 16 }), _jsx(AlertTitle, { children: rollKeyMutation.error.message })] })), updateConsumerMutation.isError && (_jsxs(Alert, { variant: "destructive", className: "mb-4", children: [_jsx(CircleSlashIcon, { size: 16 }), _jsx(AlertTitle, { children: updateConsumerMutation.error.message })] })), deleteKeyMutation.isError && (_jsxs(Alert, { variant: "destructive", className: "mb-4", children: [_jsx(CircleSlashIcon, { size: 16 }), _jsx(AlertTitle, { children: deleteKeyMutation.error.message })] })), _jsx("div", { className: "", children: data.length === 0 ? (_jsxs("div", { className: "flex col-span-full flex-col justify-center gap-4 items-center p-8 border rounded-sm bg-muted/30 text-muted-foreground", children: [_jsxs("p", { className: "text-center", children: ["You have no API keys yet.", _jsx("br", {}), service.createKey && "Get started and create your first key."] }), service.createKey && (_jsx(CreateApiKeyDialog, { service: service, isOpen: isCreateApiKeyOpen, onOpenChange: setIsCreateApiKeyOpen }))] })) : (_jsx("ul", { className: cn("grid grid-cols-[1fr_min-content] divide-y divide-border col-span-6"), children: data.map((consumers) => (_jsxs(Card, { className: "grid grid-cols-subgrid col-span-full items-center mb-4 group", children: [_jsxs(CardHeader, { className: "border-b col-span-full grid-cols-subgrid grid", children: [_jsxs("div", { className: "h-10 flex flex-col text-sm justify-center", children: [_jsxs("div", { className: "font-medium text-lg flex items-center gap-2", children: [editingConsumerId === consumers.id ? (_jsxs("div", { className: "flex items-center gap-2 w-full", children: [_jsx(Input, { maxLength: 32, value: editingLabel, onChange: (e) => setEditingLabel(e.target.value), onKeyDown: (e) => {
                                                                    if (e.key === "Enter") {
                                                                        handleSaveEdit(consumers.id);
                                                                    }
                                                                    else if (e.key === "Escape") {
                                                                        handleCancelEdit();
                                                                    }
                                                                }, className: "text-lg font-medium", autoFocus: true }), _jsxs("div", { className: "flex items-center", children: [_jsx(Button, { size: "icon", variant: "ghost", onClick: () => handleSaveEdit(consumers.id), disabled: !editingLabel.trim(), children: _jsx(CheckIcon, { size: 16 }) }), _jsx(Button, { size: "icon", variant: "ghost", onClick: handleCancelEdit, children: _jsx(XIcon, { size: 16 }) })] })] })) : (consumers.label), _jsx("div", { className: "text-muted-foreground text-xs", children: consumers.createdOn })] }), _jsxs("div", { className: "text-muted-foreground text-xs", children: [consumers.createdOn && (_jsxs("div", { children: ["Created on", " ", new Date(consumers.createdOn).toLocaleDateString()] })), consumers.expiresOn && (_jsxs("div", { children: ["Expires on", " ", new Date(consumers.expiresOn).toLocaleDateString()] }))] })] }), _jsxs("div", { className: "flex justify-end", children: [service.updateConsumer && (_jsxs(Button, { variant: "ghost", onClick: () => handleStartEdit(consumers.id, consumers.label), className: cn("flex gap-2", editingConsumerId === consumers.id &&
                                                    "opacity-0! pointer-events-none"), disabled: editingConsumerId === consumers.id, children: [_jsx(PencilLineIcon, { size: 16 }), _jsx("span", { className: "hidden md:block", children: "Edit label" })] })), service.rollKey && (_jsxs(Dialog, { children: [_jsx(DialogTrigger, { asChild: true, children: _jsxs(Button, { title: "Roll this key", variant: "ghost", disabled: rollKeyMutation.isPending, className: "flex items-center gap-2", children: [_jsx(RefreshCwIcon, { size: 16, className: rollKeyMutation.isPending
                                                                        ? "animate-spin"
                                                                        : undefined }), _jsx("span", { className: "hidden md:block", children: "Roll key" })] }) }), _jsxs(DialogContent, { children: [_jsxs(DialogHeader, { children: [_jsx(DialogTitle, { children: "Roll API Key" }), _jsx(DialogDescription, { children: "Are you sure you want to roll this API key?" })] }), _jsxs(DialogFooter, { children: [_jsx(DialogClose, { asChild: true, children: _jsx(Button, { variant: "outline", children: "Cancel" }) }), _jsx(DialogClose, { asChild: true, children: _jsx(Button, { onClick: () => {
                                                                                rollKeyMutation.mutate(consumers.id);
                                                                            }, children: "Roll Key" }) })] })] })] }))] })] }), _jsx("div", { className: "col-span-full grid-cols-subgrid grid", children: _jsx(AnimatePresence, { children: consumers.apiKeys.map((apiKey) => (_jsxs(React.Fragment, { children: [_jsx(RevealApiKey, { apiKey: apiKey, onDeleteKey: () => {
                                                    deleteKeyMutation.mutate({
                                                        consumerId: consumers.id,
                                                        keyId: apiKey.id,
                                                    });
                                                }, className: deleteKeyMutation.variables?.keyId === apiKey.id &&
                                                    (deleteKeyMutation.isPending || isFetching)
                                                    ? "opacity-10!"
                                                    : undefined }), _jsx("div", { className: "col-span-full h-px bg-border" })] }, apiKey.id))) }) })] }, consumers.id))) })) })] }));
};
const getTimeAgo = (date) => {
    const now = new Date();
    const created = new Date(date);
    const diffInSeconds = Math.floor((now.getTime() - created.getTime()) / 1000);
    const rtf = new Intl.RelativeTimeFormat("en", { numeric: "auto" });
    if (diffInSeconds < 60)
        return rtf.format(-diffInSeconds, "second");
    if (diffInSeconds < 3600)
        return rtf.format(-Math.floor(diffInSeconds / 60), "minute");
    if (diffInSeconds < 86400)
        return rtf.format(-Math.floor(diffInSeconds / 3600), "hour");
    if (diffInSeconds < 2592000)
        return rtf.format(-Math.floor(diffInSeconds / 86400), "day");
    if (diffInSeconds < 31536000)
        return rtf.format(-Math.floor(diffInSeconds / 2592000), "month");
    return rtf.format(-Math.floor(diffInSeconds / 31536000), "year");
};
const RevealApiKey = ({ apiKey, onDeleteKey, className, }) => {
    const [revealed, setRevealed] = useState(false);
    const { key, createdOn, expiresOn } = apiKey;
    const isExpired = expiresOn && new Date(expiresOn) < new Date();
    const daysUntilExpiry = expiresOn
        ? Math.ceil((new Date(expiresOn).getTime() - Date.now()) / (1000 * 60 * 60 * 24))
        : Infinity;
    const expiresSoon = daysUntilExpiry <= 7 && !isExpired;
    return (_jsxs("div", { className: cn("grid col-span-full grid-cols-subgrid p-6", className), children: [_jsxs("div", { className: "flex flex-col gap-1", children: [_jsx(Secret, { className: "max-w-fit w-full", secret: key, status: isExpired ? "expired" : expiresSoon ? "expiring" : "active", revealed: revealed, onReveal: setRevealed }), _jsxs("div", { className: "flex gap-1 mt-0.5 text-nowrap", children: [createdOn && (_jsxs("span", { className: "text-xs text-muted-foreground", children: ["Created ", getTimeAgo(createdOn), "."] })), " ", expiresOn && expiresSoon && (_jsxs("span", { className: "text-xs text-primary", children: ["Expires in ", daysUntilExpiry, " ", daysUntilExpiry === 1 ? "day" : "days", "."] })), expiresOn && isExpired && (_jsxs("span", { className: "text-xs text-primary", children: ["Expired", " ", daysUntilExpiry === 0
                                        ? "today."
                                        : `${daysUntilExpiry * -1} days ago.`] }))] })] }), _jsx("div", { className: "flex justify-end", children: expiresOn && onDeleteKey && (_jsxs(Dialog, { children: [_jsx(DialogTrigger, { asChild: true, children: _jsx(Button, { variant: "ghost", size: "icon", children: _jsx(TrashIcon, { size: 16 }) }) }), _jsxs(DialogContent, { children: [_jsxs(DialogHeader, { children: [_jsx(DialogTitle, { children: "Delete API Key" }), _jsx(DialogDescription, { children: "Are you sure you want to delete this API key?" })] }), _jsxs(DialogFooter, { children: [_jsx(DialogClose, { asChild: true, children: _jsx(Button, { variant: "outline", children: "Cancel" }) }), _jsx(DialogClose, { asChild: true, children: _jsx(Button, { onClick: () => {
                                                    onDeleteKey();
                                                }, children: "Delete" }) })] })] })] })) })] }));
};
//# sourceMappingURL=SettingsApiKeys.js.map